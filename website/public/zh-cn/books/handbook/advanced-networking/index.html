<!DOCTYPE html>
<html class="theme-light" lang="zh-cn">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=""/>
  <meta name="keywords" content=""/>
  <meta name="copyright" content="1995-2023 The FreeBSD Foundation" />
  <link rel="canonical" href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/" />

  <title>第 32 章 高级网络 |  FreeBSD Documentation Portal</title>

  <meta name="theme-color" content="#790000">
  <meta name="color-scheme" content="system light dark high-contrast">

    <link rel="shortcut icon" href="/favicon.ico">
    <link rel="stylesheet" href="/styles/main.min.css">
    <link rel="stylesheet" href="/css/font-awesome-min.css">
    <script defer src="/js/theme-chooser.min.js"></script>
    <script defer src="/js/copy-clipboard.min.js"></script>
    <script defer src="/js/search.min.js"></script>

  
  
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:domain" content="docs.FreeBSD.org"/>
    <meta name="twitter:site" content="@freebsd"/>
    <meta name="twitter:url" content="https://twitter.com/freebsd"/>
    <meta property="og:title" content="第 32 章 高级网络" />
    <meta property="og:description" content="" />
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="http://127.0.0.1:5500favicon.ico"/>
    <meta property="og:image:alt" content="FreeBSD Logo">
    <meta property="og:locale" content="zh-cn" />
    <meta property="og:url" content="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/" />
    <meta property="og:site_name" content="FreeBSD Documentation Portal" />
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Article",
        "url": "http:\/\/127.0.0.1:5500\/zh-cn\/books\/handbook\/advanced-networking\/",
        "name": "FreeBSD Documentation Portal",
        "headline": "FreeBSD Documentation Portal",
        "description": "FreeBSD Documentation Portal"
      }
    </script>
    

  
</head>


  <body>
    <header>
  <div class="header-container">
    <div class="logo-menu-bars-container">
      <a href="http://127.0.0.1:5500" class="logo">
        <img src="/images/FreeBSD-monochromatic.svg" width="160" height="50" alt="FreeBSD logo" />
      </a>
      <label class="menu-bars" for="menu-bars">
        <i class="fa fa-bars" aria-hidden="true"></i>
      </label>
    </div>
    <input id="menu-bars" type="checkbox" />
    
    <div class="search-donate-container">
      
      
    </div>
  </div>
</header>

    
<input type="checkbox" class="hidden toggle" id="menu-control">
<main class="main-wrapper-book">
  <a id="top"></a>
  
  <aside class="book-menu">
    <div class="book-menu-content">
      <input id="search-book" type="text" placeholder="Search" aria-label="Search" maxlength="128" />
      <nav id="MenuContents">
        
  <ul>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-8ada319c45e780947f82b569049480cc" class="toggle"  />
          <label  class="icon cursor"  for="chapter-8ada319c45e780947f82b569049480cc"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/">
              前言
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/#preface-audience">预期的读者</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/#preface-changes-from3">相对于第三版的改动</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/#preface-changes-from2">相对于第二版的改动 (2004)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/#preface-changes">相对于第一版的改变 (2001)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/#preface-overview">本手册的组织</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/#preface-conv">本书中使用的一些约定</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/preface/#preface-acknowledgements">致谢</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-32a83d18a326852a8d9ae2582360bbc8" class="toggle"  />
          <label  for="chapter-32a83d18a326852a8d9ae2582360bbc8"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/parti/">
              部分 I. 起步
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-a4909db05d872d16d5be86a57cbc2dc7" class="toggle"  />
          <label  class="icon cursor"  for="chapter-a4909db05d872d16d5be86a57cbc2dc7"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/introduction/">
              第 1 章 介绍
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/introduction/#introduction-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/introduction/#nutshell">2. 欢迎来到 FreeBSD 的世界!</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/introduction/#history">3. 关于 FreeBSD 项目</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-6655173739803bf0920b92a7fe8a363d" class="toggle"  />
          <label  class="icon cursor"  for="chapter-6655173739803bf0920b92a7fe8a363d"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/">
              第 2 章 安装 FreeBSD
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-hardware">2. 硬件需求</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-pre">3. 安装前的准备工作</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-start">4. 开始安装</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#using-sysinstall">5. 介绍 Sysinstall</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-steps">6. 分配磁盘空间</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-choosing">7. 选择要安装的软件包</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-media">8. 选择您要使用的安装介质</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-final-warning">9. 安装确认</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-post">10. 安装后的配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-trouble">11. 常见问题</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-advanced">12. 高级安装指南</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/install/#install-diff-media">13. 准备您自己的安装介质</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-3c2455cadf89eadd3f6e77461085d5e9" class="toggle"  />
          <label  class="icon cursor"  for="chapter-3c2455cadf89eadd3f6e77461085d5e9"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/">
              第 3 章 安装 FreeBSD（适用于 9.x 及以后版本）
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-hardware">2. 硬件需求</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-pre">3. 安装前的准备工作</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-start">4. 开始安装</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#using-bsdinstall">5. 介绍 bsdinstall</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-netinstall">6. 通过网络安装</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-partitioning">7. 分配磁盘空间</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-final-warning">8. 安装确认</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-post">9. 安装后的配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bsdinstall/#bsdinstall-install-trouble">10. 故障排除</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-709481b75d22ad36960f7ac166b3306c" class="toggle"  />
          <label  class="icon cursor"  for="chapter-709481b75d22ad36960f7ac166b3306c"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/">
              第 4 章 UNIX 基础
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#basics-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#consoles">2. 虚拟控制台和终端</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#permissions">3. 权限</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#dirstructure">4. 目录架构</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#disk-organization">5. 磁盘组织</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#mount-unmount">6. 文件系统的挂接和卸下</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#basics-processes">7. 进程</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#basics-daemons">8. 守护进程，信号和杀死进程</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#shells">9. Shells</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#editors">10. 文本编辑器</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#basics-devices">11. 设备和设备节点</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#binary-formats">12. 二进制文件格式</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/basics/#basics-more-information">13. 取得更多的资讯</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-58c050d31a1fbecd859248dacefeb567" class="toggle"  />
          <label  class="icon cursor"  for="chapter-58c050d31a1fbecd859248dacefeb567"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/">
              第 5 章 安装应用程序: Packages 和 Ports
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/#ports-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/#ports-overview">2. 软件安装预览</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/#ports-finding-applications">3. 寻找您要的应用程序</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/#packages-using">4. 使用 Package 系统</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/#ports-using">5. 使用Ports Collection</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/#ports-nextsteps">6. 安装之后还要做点什么？</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ports/#ports-broken">7. 如何处理坏掉的 Ports</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-e5a000ce7f50680a180e2c1b83c121bc" class="toggle"  />
          <label  class="icon cursor"  for="chapter-e5a000ce7f50680a180e2c1b83c121bc"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/">
              第 6 章 X Window 系统
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/#x11-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/#x-understanding">2. 理解 X</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/#x-install">3. 安装 X11</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/#x-config">4. 配置 X11</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/#x-fonts">5. 在 X11 中使用字体</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/#x-xdm">6. X 显示管理器</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/x11/#x11-wm">7. 桌面环境</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-5eb30759c3a2873e716dc31d7760054c" class="toggle"  />
          <label  for="chapter-5eb30759c3a2873e716dc31d7760054c"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/partii/">
              部分 II. 常见的任务
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-c96504f017c56f4bc7f71548cccf5382" class="toggle"  />
          <label  class="icon cursor"  for="chapter-c96504f017c56f4bc7f71548cccf5382"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/desktop/">
              第 7 章 桌面应用
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/desktop/#desktop-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/desktop/#desktop-browsers">2. 浏览器</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/desktop/#desktop-productivity">3. 办公、图象处理</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/desktop/#desktop-viewers">4. 文档查看器</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/desktop/#desktop-finance">5. 财务</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/desktop/#desktop-summary">6. 总结</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-e1898af36aaacc168e13b673d25b908f" class="toggle"  />
          <label  class="icon cursor"  for="chapter-e1898af36aaacc168e13b673d25b908f"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/multimedia/">
              第 8 章 多媒体
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/multimedia/#multimedia-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/multimedia/#sound-setup">2. 安装声卡</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/multimedia/#sound-mp3">3. MP3音频</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/multimedia/#video-playback">4. 视频回放</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/multimedia/#tvcard">5. 安装电视卡</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/multimedia/#scanners">6. 图象扫描仪</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-6926664836e63c5cae4b2fa60855f91d" class="toggle"  />
          <label  class="icon cursor"  for="chapter-6926664836e63c5cae4b2fa60855f91d"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/">
              第 9 章 配置FreeBSD的内核
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/#kernelconfig-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/#kernelconfig-custom-kernel">2. 为什么需要建立定制的内核?</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/#kernelconfig-devices">3. 发现系统硬件</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/#kernelconfig-modules">4. 内核驱动，子系统和模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/#kernelconfig-building">5. 建立并安装一个定制的内核</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/#kernelconfig-config">6. 配置文件</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/kernelconfig/#kernelconfig-trouble">7. 如果出现问题怎么办</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-19d36bd70a320268f0ea1f66e4f3e224" class="toggle"  />
          <label  class="icon cursor"  for="chapter-19d36bd70a320268f0ea1f66e4f3e224"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/">
              第 10 章 打印
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/#printing-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/#printing-intro-spooler">2. 介绍</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/#printing-intro-setup">3. 基本设置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/#printing-advanced">4. 高级设置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/#printing-using">5. 使用打印机</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/#printing-lpd-alternatives">6. 替换标准后台打印</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/printing/#printing-troubleshooting">7. 疑难问题</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-a07f539e6c18f2db4da5dbb2b5bb1e79" class="toggle"  />
          <label  class="icon cursor"  for="chapter-a07f539e6c18f2db4da5dbb2b5bb1e79"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/linuxemu/">
              第 11 章 Linux® 二进制兼容模式
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/linuxemu/#linuxemu-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/linuxemu/#linuxemu-lbc-install">2. 配置 Linux® 二进制兼容模式</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/linuxemu/#linuxemu-advanced">3. 高级主题</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-51416fdea9d5a1dfa1c2718cd825213a" class="toggle"  />
          <label  for="chapter-51416fdea9d5a1dfa1c2718cd825213a"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/partiii/">
              部分 III. 系统管理
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-532d0380ba66d66e033765a0b6930ee7" class="toggle"  />
          <label  class="icon cursor"  for="chapter-532d0380ba66d66e033765a0b6930ee7"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/">
              第 12 章 设置和调整
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#config-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-initial">2. 初步配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-core-configuration">3. 核心配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-appconfig">4. 应用程序配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-starting-services">5. 启动服务</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-cron">6. 配置 <code>cron</code></a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-rcd">7. 在 FreeBSD 中使用 rc</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#config-network-setup">8. 设置网卡</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-virtual-hosts">9. 虚拟主机</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-configfiles">10. 配置文件</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-sysctl">11. 用 sysctl 进行调整</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-disk">12. 调整磁盘</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#configtuning-kernel-limits">13. 调整内核限制</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#adding-swap-space">14. 添加交换空间</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#acpi-overview">15. 电源和资源管理</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/config/#ACPI-debug">16. 使用和调试 FreeBSD ACPI</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-d05f41680fb7e3d68b354ae03de368b1" class="toggle"  />
          <label  class="icon cursor"  for="chapter-d05f41680fb7e3d68b354ae03de368b1"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/">
              第 13 章 FreeBSD 引导过程
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/#boot-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/#boot-introduction">2. 引导问题</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/#boot-blocks">3. 引导管理器和各引导阶段</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/#boot-kernel">4. 内核在引导时的交互</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/#device-hints">5. Device Hints</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/#boot-init">6. Init：进程控制及初始化</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/boot/#boot-shutdown">7. 关机 (shutdown) 过程</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-17a53b356b407d9ed656b7babd2efa34" class="toggle"  />
          <label  class="icon cursor"  for="chapter-17a53b356b407d9ed656b7babd2efa34"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/">
              第 14 章 用户和基本的帐户管理
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-introduction">2. 介绍</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-superuser">3. 超级用户帐户</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-system">4. 系统帐户</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-user">5. 用户帐户</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-modifying">6. 修改帐户</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-limiting">7. 限制用户使用系统资源</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/users/#users-groups">8. 组</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-513e8e407c57354df334059688e9b60a" class="toggle"  />
          <label  class="icon cursor"  for="chapter-513e8e407c57354df334059688e9b60a"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/">
              第 15 章 安全
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#security-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#security-intro">2. 介绍</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#securing-freebsd">3. 确保 FreeBSD 的安全</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#crypt">4. DES、 Blowfish、 MD5， 以及 Crypt</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#one-time-passwords">5. 一次性口令</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#tcpwrappers">6. TCP Wrappers</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#kerberos5">7. Kerberos5</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#openssl">8. OpenSSL</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#ipsec">9. IPsec 上的 VPN</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#openssh">10. OpenSSH</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#fs-acl">11. 文件系统访问控制表</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#security-portaudit">12. 监视第三方安全问题</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#security-advisories">13. FreeBSD 安全公告</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/security/#security-accounting">14. 进程记帐</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-0f7d2858504c83a029928c048d394e2a" class="toggle"  />
          <label  class="icon cursor"  for="chapter-0f7d2858504c83a029928c048d394e2a"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/jails/">
              第 16 章 Jails
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/jails/#jails-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/jails/#jails-terms">2. 与 Jail 相关的一些术语</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/jails/#jails-intro">3. 介绍</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/jails/#jails-build">4. 建立和控制 jail</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/jails/#jails-tuning">5. 微调和管理</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/jails/#jails-application">6. Jail 的应用</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-15be125ce5997f51c5499e3a0dee6c2c" class="toggle"  />
          <label  class="icon cursor"  for="chapter-15be125ce5997f51c5499e3a0dee6c2c"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/">
              第 17 章 强制访问控制
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-synopsis">1. 概要</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-inline-glossary">2. 本章出现的重要术语</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-initial">3. 关于 MAC 的说明</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-understandlabel">4. 理解 MAC 标签</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-planning">5. 规划安全配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-modules">6. 模块配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-seeotheruids">7. MAC seeotheruids 模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-bsdextended">8. MAC bsdextended 模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-ifoff">9. MAC ifoff 模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-portacl">10. MAC portacl 模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-partition">11. MAC partition (分区) 模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-mls">12. MAC 多级 (Multi-Level) 安全模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-biba">13. MAC Biba 模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-lomac">14. MAC LOMAC 模块</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-implementing">15. MAC Jail 中的 Nagios</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-userlocked">16. User Lock Down</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mac/#mac-troubleshoot">17. MAC 框架的故障排除</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-3f7e8d763b17c7d0c44c60505cf0feea" class="toggle"  />
          <label  class="icon cursor"  for="chapter-3f7e8d763b17c7d0c44c60505cf0feea"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/audit/">
              第 18 章 安全事件审计
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/audit/#audit-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/audit/#audit-inline-glossary">2. 本章中的一些关键术语</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/audit/#audit-install">3. 安装审计支持</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/audit/#audit-config">4. 对审计进行配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/audit/#audit-administration">5. 管理审计子系统</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-7bb1cb2287cd08a3672cc878e604f0d0" class="toggle"  />
          <label  class="icon cursor"  for="chapter-7bb1cb2287cd08a3672cc878e604f0d0"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/">
              第 19 章 存储
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#disks-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#disks-naming">2. 设备命名</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#disks-adding">3. 添加磁盘</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#raid">4. RAID</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#usb-disks">5. USB 存储设备</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#creating-cds">6. 创建和使用光学介质(CD)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#creating-dvds">7. 创建和使用光学介质(DVD)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#floppies">8. 创建和使用软盘</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#backups-tapebackups">9. 用磁带机备份</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#backups-floppybackups">10. 用软盘备份</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#backup-strategies">11. 备份策略</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#backup-basics">12. 备份程序</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#disks-virtual">13. 网络、内存和 和以及映像文件为介质的虚拟文件系统</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#snapshots">14. 文件系统快照</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#quotas">15. 文件系统配额</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#disks-encrypting">16. 加密磁盘分区</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#swap-encrypting">17. 对交换区进行加密</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/disks/#disks-hast">18. 高可用性存储 (HAST)</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-dec5fc4f0100e5030db0fb188d8d4b2f" class="toggle"  />
          <label  class="icon cursor"  for="chapter-dec5fc4f0100e5030db0fb188d8d4b2f"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/">
              第 20 章 GEOM: 模块化磁盘变换框架
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#GEOM-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#GEOM-intro">2. GEOM 介绍</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#GEOM-striping">3. RAID0 - 条带</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#GEOM-mirror">4. RAID1 - 镜像</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#GEOM-raid3">5. RAID3 - 使用专用校验设备的字节级条带</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#geom-ggate">6. GEOM Gate 网络设备</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#geom-glabel">7. 为磁盘设备添加卷标</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/geom/#geom-gjournal">8. 通过 GEOM 实现 UFS 日志</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-4c6bf6828e601b79edb2813329ac6604" class="toggle"  />
          <label  class="icon cursor"  for="chapter-4c6bf6828e601b79edb2813329ac6604"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/filesystems/">
              第 21 章 文件系统 Support
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/filesystems/#filesystems-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/filesystems/#filesystems-zfs">2. Z 文件系统 (ZFS)</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-11d260f2685c0b17137e64887e1b1989" class="toggle"  />
          <label  class="icon cursor"  for="chapter-11d260f2685c0b17137e64887e1b1989"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/">
              第 22 章 Vinum 卷管理程序
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-intro">2. 磁盘容量太小</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-access-bottlenecks">3. 访问瓶颈</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-data-integrity">4. 数据的完整性</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-objects">5. Vinum 目标</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-examples">6. 一些例子</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-object-naming">7. 对象命名</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-config">8. 配置 Vinum</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/vinum/#vinum-root">9. 使用 Vinum 作为根文件系统</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-ae23289d4b6415f3f878893f9d3ef9b8" class="toggle"  />
          <label  class="icon cursor"  for="chapter-ae23289d4b6415f3f878893f9d3ef9b8"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/virtualization/">
              第 23 章 虚拟化
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/virtualization/#virtualization-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/virtualization/#virtualization-guest">2. 作为客户 OS 的 FreeBSD</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/virtualization/#virtualization-host">3. 作为宿主 OS 的 FreeBSD</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-b279d2b738963a45a059268d2fae00d5" class="toggle"  />
          <label  class="icon cursor"  for="chapter-b279d2b738963a45a059268d2fae00d5"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/l10n/">
              第 24 章 本地化－I18N/L10N使用和设置
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/l10n/#l10n-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/l10n/#l10n-basics">2. 基础知识</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/l10n/#using-localization">3. 使用本地化语言</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/l10n/#l10n-compiling">4. 编译I18N程序</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/l10n/#lang-setup">5. 本地化FreeBSD</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9e3f99bd76c861ab2e9a5f31ac421842" class="toggle"  />
          <label  class="icon cursor"  for="chapter-9e3f99bd76c861ab2e9a5f31ac421842"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/">
              第 25 章 更新与升级 FreeBSD
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#updating-upgrading-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate">2. FreeBSD 更新</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#updating-upgrading-portsnap">3. Portsnap： 一个 Ports Collection 更新工具</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#updating-upgrading-documentation">4. 更新系统附带的文档</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#current-stable">5. 追踪开发分支</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#synching">6. 同步您的源码</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#makeworld">7. 重新编译 "world"</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#make-delete-old">8. 删除过时的文件、 目录和函数库</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/cutting-edge/#small-lan">9. 跟踪多台机器</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-3ba999091575eb04ae88235cd0fb1afa" class="toggle"  />
          <label  class="icon cursor"  for="chapter-3ba999091575eb04ae88235cd0fb1afa"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/dtrace/">
              第 26 章 DTrace
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/dtrace/#dtrace-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/dtrace/#dtrace-implementation">2. 实现上的差异</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/dtrace/#dtrace-enable">3. 启用 DTrace 支持</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/dtrace/#dtrace-using">4. 使用 DTrace</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/dtrace/#dtrace-language">5. D 语言</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-6d4439926bb106ac084ecc88cfd3cfa4" class="toggle"  />
          <label  for="chapter-6d4439926bb106ac084ecc88cfd3cfa4"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/partiv/">
              部分 IV. 网络通讯
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-05a353fcb61d8e035f7c43e14725766e" class="toggle"  />
          <label  class="icon cursor"  for="chapter-05a353fcb61d8e035f7c43e14725766e"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/serialcomms/">
              第 27 章 串口通讯
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/serialcomms/#serial-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/serialcomms/#serial">2. 介绍</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/serialcomms/#term">3. 终端</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/serialcomms/#dialup">4. 拨入服务</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/serialcomms/#dialout">5. 拨出设备</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/serialcomms/#serialconsole-setup">6. 设置串口控制台</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-7f0cbcbf6701b86eba3bbd6fc829f1b8" class="toggle"  />
          <label  class="icon cursor"  for="chapter-7f0cbcbf6701b86eba3bbd6fc829f1b8"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/">
              第 28 章 PPP 和 SLIP
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/#userppp">2. 使用用户级 PPP</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/#ppp">3. 使用内核级PPP</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/#ppp-troubleshoot">4. PPP 连接故障排除</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/#pppoe">5. 使用基于以太网的PPP(PPPoE)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/#pppoa">6. 使用 ATM 上的 PPP (PPPoA)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/ppp-and-slip/#slip">7. 使用SLIP</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9d023b545804f197d195dd9412749943" class="toggle"  />
          <label  class="icon cursor"  for="chapter-9d023b545804f197d195dd9412749943"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/">
              第 29 章 电子邮件
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-using">2. 使用电子邮件</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#sendmail">3. sendmail 配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-changingmta">4. 改变您的邮件传输代理程序</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-trouble">5. 疑难解答</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-advanced">6. 高级主题</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#SMTP-UUCP">7. SMTP 与 UUCP</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#outgoing-only">8. 只发送邮件的配置</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#SMTP-dialup">9. 拨号连接时使用邮件传送</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#SMTP-Auth">10. SMTP 验证</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-agents">11. 邮件用户代理</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-fetchmail">12. 使用 fetchmail</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mail/#mail-procmail">13. 使用 procmail</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-42b19e05d30c4135c74b9878818747a9" class="toggle"  />
          <label  class="icon cursor"  for="chapter-42b19e05d30c4135c74b9878818747a9"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/">
              第 30 章 网络服务器
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-servers-synopsis">1. 概要</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-inetd">2. inetd"超级服务器"</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-nfs">3. 网络文件系统（NFS）</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-nis">4. 网络信息服务 (NIS/YP)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-dhcp">5. 网络自动配置 (DHCP)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-dns">6. 域名系统 (DNS)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-apache">7. Apache HTTP 服务器</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-ftp">8. 文件传输协议 (FTP)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-samba">9. 为 Microsoft® Windows® 客户机提供文件和打印服务 (Samba)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-ntp">10. 通过 NTP 进行时钟同步</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/network-servers/#network-syslogd">11. 使用 <code>syslogd</code> 记录远程主机的日志</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9554a5177d00d0e87ada408809a1fc67" class="toggle"  />
          <label  class="icon cursor"  for="chapter-9554a5177d00d0e87ada408809a1fc67"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/firewalls/">
              第 31 章 防火墙
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/firewalls/#firewalls-intro">1. 入门</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/firewalls/#firewalls-concepts">2. 防火墙的概念</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/firewalls/#firewalls-apps">3. 防火墙软件包</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/firewalls/#firewalls-pf">4. OpenBSD Packet Filter (PF) 和 ALTQ</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/firewalls/#firewalls-ipf">5. IPFILTER (IPF) 防火墙</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/firewalls/#firewalls-ipfw">6. IPFW</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9903a1d844ed803a436595e93ec33572" class="toggle"  checked  />
          <label  class="icon cursor"  for="chapter-9903a1d844ed803a436595e93ec33572"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/">
              第 32 章 高级网络
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#advanced-networking-synopsis">1. 概述</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-routing">2. 网关和路由</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-wireless">3. 无线网络</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-bluetooth">4. 蓝牙</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-bridging">5. 桥接</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-aggregation">6. 链路聚合与故障转移</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-diskless">7. 无盘操作</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-pxe-nfs">8. 从 PXE 启动一个 NFS 根文件系统</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-isdn">9. ISDN</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-natd">10. 网络地址转换</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-plip">11. 并口电缆 IP (PLIP)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-ipv6">12. IPv6</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#network-atm">13. 异步传输模式 (ATM)</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/advanced-networking/#carp">14. Common Address Redundancy Protocol (CARP， 共用地址冗余协议)</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-8ca29f99c249993ee9234cb4632af7a5" class="toggle"  />
          <label  for="chapter-8ca29f99c249993ee9234cb4632af7a5"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/partv/">
              部分 V. 附录
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-0229d553ebf23ffeb945be6f32836221" class="toggle"  />
          <label  class="icon cursor"  for="chapter-0229d553ebf23ffeb945be6f32836221"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/">
              附录 A. 获取 FreeBSD
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#mirrors-cdrom">1. CDROM 和 DVD 发行商</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#mirrors-ftp">2. FTP 站点</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#anoncvs">3. 匿名 CVS</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#ctm">4. 使用 CTM</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#cvsup">5. 使用 CVSup</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#cvs-tags">6. CVS 标签</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#mirrors-afs">7. AFS 站点</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/mirrors/#mirrors-rsync">8. rsync 站点</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-743c99fa278b8138914ff018e40c9231" class="toggle"  />
          <label  class="icon cursor"  for="chapter-743c99fa278b8138914ff018e40c9231"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/">
              附录 B. 参考文献
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-freebsd">1. 关于 FreeBSD 的专业书籍与杂志</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-userguides">2. 用户指南</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-adminguides">3. 管理员指南</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-programmers">4. 开发指南</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-osinternals">5. 操作系统原理</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-security">6. 安全方面的参考文献</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-hardware">7. 硬件参考</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-history">8. UNIX® 历史</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/bibliography/#bibliography-journals">9. 各种期刊</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-de7eade4b8b64f298c0cbac44c2278da" class="toggle"  />
          <label  class="icon cursor"  for="chapter-de7eade4b8b64f298c0cbac44c2278da"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/eresources/">
              附录 C. Internet上的资源
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/eresources/#eresources-mail">1. 邮件列表</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/eresources/#eresources-news">2. Usenet新闻组</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/eresources/#eresources-web">3. World Wide Web服务器</a></li>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/eresources/#eresources-email">4. Email地址</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-bfb0d4e71c3c1a18a8b75e03f4b48e26" class="toggle"  />
          <label  class="icon cursor"  for="chapter-bfb0d4e71c3c1a18a8b75e03f4b48e26"><a role="button"></a></label>

          
            
            <a href="http://127.0.0.1:5500/zh-cn/books/handbook/pgpkeys/">
              附录 D. PGP公钥
            </a>
            
            
  <ul>
    <li><a href="http://127.0.0.1:5500/zh-cn/books/handbook/pgpkeys/#pgpkeys-officers">1. Officers</a></li>
  </ul>

          

        
      </li>
    
      <li>
        
      </li>
    
  </ul>


      </nav>
    </div>
  </aside>
  
  <div class="book">
    
    <div class="book-menu-mobile">
      <label for="menu-control">
        <span class="menu-control-button">
          <i class="fa fa-list" aria-hidden="true" title="Book menu"></i>
          Book menu
        </span>
      </label>
    </div>
    
    <h1 class="title">第 32 章 高级网络</h1>
    
    
      <div class="admonitionblock note">
        <p>
          <i class="fa fa-exclamation-circle" aria-hidden="true"></i>
          This translation may be out of date. To help with the translations please access the <a href="https://translate-dev.freebsd.org/" target="_blank">FreeBSD translations instance</a>.
        </p>
      </div>
    
    
    
    <div class="toc-mobile">
      <h3>Table of Contents</h3>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#advanced-networking-synopsis">1. 概述</a></li>
    <li><a href="#network-routing">2. 网关和路由</a></li>
    <li><a href="#network-wireless">3. 无线网络</a></li>
    <li><a href="#network-bluetooth">4. 蓝牙</a></li>
    <li><a href="#network-bridging">5. 桥接</a></li>
    <li><a href="#network-aggregation">6. 链路聚合与故障转移</a></li>
    <li><a href="#network-diskless">7. 无盘操作</a></li>
    <li><a href="#network-pxe-nfs">8. 从 PXE 启动一个 NFS 根文件系统</a></li>
    <li><a href="#network-isdn">9. ISDN</a></li>
    <li><a href="#network-natd">10. 网络地址转换</a></li>
    <li><a href="#network-plip">11. 并口电缆 IP (PLIP)</a></li>
    <li><a href="#network-ipv6">12. IPv6</a></li>
    <li><a href="#network-atm">13. 异步传输模式 (ATM)</a></li>
    <li><a href="#carp">14. Common Address Redundancy Protocol (CARP， 共用地址冗余协议)</a></li>
  </ul>
</nav>
    </div>
    
      
      
    
    <div class="book-content">
      <div id="preamble">
<div class="sectionbody">

</div>
</div>
<div class="sect1">
<h2 id="advanced-networking-synopsis">1. 概述<a class="anchor" href="#advanced-networking-synopsis"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>本章将就一系列与网络有关的高级话题进行讨论。</p>
</div>
<div class="paragraph">
<p>读完这章，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>关于网关和路由的基础知识。</p>
</li>
<li>
<p>如何配置 IEEE® 802.11 和 Bluetooth® 设备。</p>
</li>
<li>
<p>如何用 FreeBSD 做网桥。</p>
</li>
<li>
<p>如何为无盘机上配置网络启动。</p>
</li>
<li>
<p>如何配置从网络 PXE 启动一个 NFS 根文件系统。</p>
</li>
<li>
<p>如何配置网络地址转换 (NAT)。</p>
</li>
<li>
<p>如何使用 PLIP 连接两台计算机。</p>
</li>
<li>
<p>如何在运行 FreeBSD 的计算机上配置 IPv6。</p>
</li>
<li>
<p>如何配置 ATM。</p>
</li>
<li>
<p>如何利用 CARP， FreeBSD 支持的 Common Address Redundancy Protocol (共用地址冗余协议)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在读这章之前， 您应：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>理解 <span class="filename">/etc/rc</span> 脚本的基本知识。</p>
</li>
<li>
<p>熟悉基本的网络术语。</p>
</li>
<li>
<p>了解如何配置和安装新的 FreeBSD 内核 (crossref:kernelconfig[kernelconfig,配置FreeBSD的内核])。</p>
</li>
<li>
<p>了解如何安装第三方软件 (crossref:ports[ports,安装应用程序. Packages 和 Ports])。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-routing">2. 网关和路由<a class="anchor" href="#network-routing"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>要让网络上的两台计算机能够相互通讯， 就必须有一种能够描述如何从一台计算机到另一台计算机的机制， 这一机制称作 <em>路由选择(routing)</em>。 &#34;路由项&#34; 是一对预先定义的地址： &#34;目的地(destination)&#34; 和 &#34;网关(gateway)&#34;。 这个地址对所表达的意义是， 通过 <em>网关</em> 能够完成与 <em>目的地</em> 的通信。 有三种类型的目的地址： 单个主机、 子网、 以及 &#34;默认&#34;。 如果没有可用的其它路由， 就会使用 &#34;默认路由&#34;， 有关默认路由的内容， 将在稍后的章节中进行讨论。 网关也有三种类型： 单个主机， 网络接口 (也叫 &#34;链路 (links)&#34;) 和以太网硬件地址 (MAC 地址)。</p>
</div>
<div class="sect2">
<h3 id="_实例">2.1. 实例<a class="anchor" href="#_实例"></a></h3>
<div class="paragraph">
<p>为了说明路由选择的各个部分， 首先来看看下面的例子。 这是 <code>netstat</code> 命令的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% netstat <span class="nt">-r</span>
Routing tables

Destination      Gateway            Flags     Refs     Use     Netif Expire

default          outside-gw         UGSc       37      418      ppp0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       ed0     77
10.20.30.255     <span class="nb">link</span><span class="c">#1             UHLW        1     2421</span>
example.com      <span class="nb">link</span><span class="c">#1             UC          0        0</span>
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class="o">=&gt;</span>
host2.example.com <span class="nb">link</span><span class="c">#1             UC          0        0</span>
224              <span class="nb">link</span><span class="c">#1             UC          0        0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>头两行给出了当前配置中的默认路由 (将在 <a href="#network-routing-default">下一节</a> 中进行介绍) 和 <code>localhost (本机)</code> 路由。</p>
</div>
<div class="paragraph">
<p>这里的路由表中给出的用于 <code>localhost</code> 的接口 (<code>Netif</code> 列) 是 <span class="filename">lo0</span>， 也就是大家熟知的 &#34;回环设备&#34;。 它表示所有以此为 &#34;目的地&#34; 的通信都留在本机， 而不通过 LAN 发出， 因为这些流量最终会回到起点。</p>
</div>
<div class="paragraph">
<p>接着出现的是以 <code>0:e0:</code> 开头的地址。这些是以太网硬件地址，也称为 MAC 地址。 FreeBSD 会自动识别在同一个以太网中的任何主机 (如 <code>test0</code>)， 并为其新增一个路由， 并通过那个以太网接口 - <span class="filename">ed0</span> 直接与它通讯 (译者注：那台主机)。与这类路由表相关的也有一个超时项 (<code>Expire</code>列)，当我们在指定时间内没有收到从那个主机发来的信息， 这项就派上用场了。这种情况下，到这个主机的路由就会被自动删除。 这些主机被使用一种叫做RIP(路由信息协议—​Routing Information Protocol)的机制所识别，这种机制利用基于&#34;最短路径选择 (shortest path determination)&#34;的办法计算出到本地主机的路由。</p>
</div>
<div class="paragraph">
<p>FreeBSD 也会为本地子网添加子网路由(<code>10.20.30.255</code> 是子网 <code>10.20.30</code> 的广播地址，而 <code>example.com</code> 是这个子网相联的域名)。 名称 <code>link#1</code> 代表主机上的第一块以太网卡。 您会发现，对于它们没有指定另外的接口。</p>
</div>
<div class="paragraph">
<p>这两个组(本地网络主机和本地子网)的路由是由守护进程 routed 自动配置的。如果它没有运行， 那就只有被静态定义 (例如，明确输入的) 的路由才存在了。</p>
</div>
<div class="paragraph">
<p><code>host1</code> 行代表我们的主机，它通过以太网地址来识别。 因为我们是发送端，FreeBSD知道使用回环接口 (<span class="filename">lo0</span>) 而不是通过以太网接口来进行发送。</p>
</div>
<div class="paragraph">
<p>两个 <code>host2</code> 行是我们使用 man:ifconfig[8] 别名 (请看关于以太网的那部分就会知道我们为什么这么做) 时产生的一个实例。在 <span class="filename">lo0</span> 接口之后的 <code>⇒</code> 符号表明我们不仅使用了回环 (因为这个地址也涉及了本地主机)，而且明确指出它是个别名。 这类路由只有在支持别名的主机上才能显现出来。 所有本地网上的其它的主机对于这类路由只会简单拥有 <code>link#1</code>。</p>
</div>
<div class="paragraph">
<p>最后一行 (目标子网<code>224</code>) 用于处理多播――它会覆盖到其它的区域。</p>
</div>
<div class="paragraph">
<p>最后，每个路由的不同属性可以在 <code>Flags</code> 列中看到。下边是个关于这些标志和它们的含义的一个简表：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Up: 路由处于活动状态。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">H</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Host: 路由目标是单个主机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">G</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gateway: 所有发到目的地的网络传到这一远程系统上， 并由它决定最后发到哪里。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Static: 这个路由是手工配置的，不是由系统自动生成的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Clone: 生成一个新的路由， 通过这个路由我们可以连接上这些机子。 这种类型的路由通常用于本地网络。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">WasCloned: 指明一个路由――它是基于本地区域网络 (克隆) 路由自动配置的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Link: 路由涉及到了以太网硬件。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="network-routing-default">2.2. 默认路由<a class="anchor" href="#network-routing-default"></a></h3>
<div class="paragraph">
<p>当本地系统需要与远程主机建立连接时， 它会检查路由表以决定是否有已知的路径存在。 如果远程主机属于一个我们已知如何到达 (克隆的路由) 的子网内，那么系统会检查看沿着那个接口是否能够连接。</p>
</div>
<div class="paragraph">
<p>如果所有已知路径都失败，系统还有最后一个选择： &#34;默认&#34;路由。这个路由是特殊类型的网关路由 (通常只有一个存在于系统里)，并且总是在标志栏使用一个 <code>c</code>来进行标识。对于本地区域网络里的主机， 这个网关被设置到任何与外界有直接连接的机子里 (无论是通过 PPP、DSL、cable modem、T1 或其它的网络接口连接)。</p>
</div>
<div class="paragraph">
<p>如果您正为某台本身就做为网关连接外界的机子配置默认路由的话， 那么该默认路由应该是您的&#34;互联网服务商 (ISP)&#34;那方的网关机子。</p>
</div>
<div class="paragraph">
<p>让我们来看一个关于默认路由的例子。这是个很普遍的配置：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/advanced-networking/net-routing.png" alt="net routing"/>
</div>
</div>
<div class="paragraph">
<p>主机 <code>Local1</code> 和 <code>Local2</code> 在您那边。<code>Local1</code> 通过 PPP 拨号连接到了 ISP。这个 PPP 服务器通过一个局域网连接到另一台网关机子――它又通过一个外部接口连接到 ISP 提供的互联网上。</p>
</div>
<div class="paragraph">
<p>您的每一台机子的默认路由应该是：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Host</th>
<th class="tableblock halign-left valign-top">Default Gateway</th>
<th class="tableblock halign-left valign-top">Interface</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Ethernet</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T1-GW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">PPP</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>一个常见的问题是&#34;我们为什么 (或怎样) 能将 <code>T1-GW</code> 设置成为 <code>Local1</code> 默认网关，而不是它所连接 ISP 服务器？&#34;</p>
</div>
<div class="paragraph">
<p>记住，因为 PPP 接口使用的一个地址是在 ISP 的局域网里的，用于您那边的连接，对于 ISP 的局域网里的其它机子，其路由会自动产生。 因此，您就已经知道了如何到达机子 <code>T1-GW</code>， 那么也就没必要中间那一步了――发送通信给 ISP 服务器。</p>
</div>
<div class="paragraph">
<p>通常使用地址 <code>X.X.X.1</code> 做为一个局域网的网关。 因此 (使用相同的例子)，如果您本地的 C 类地址空间是 <code>10.20.30</code>，而您的 ISP 使用的是 <code>10.9.9</code>， 那么默认路由表将是：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">Host</th>
<th class="tableblock halign-left valign-top">Default Route</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local2 (10.20.30.2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local1 (10.20.30.1)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Local1 (10.20.30.1, 10.9.9.30)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">T1-GW (10.9.9.1)</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>您可以很轻易地通过 <span class="filename">/etc/rc.conf</span> 文件设定默认路由。在我们的实例里，在主机 <code>Local2</code> 里，我们在文件 <span class="filename">/etc/rc.conf</span> 里增加了下边内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>defaultrouter=&#34;10.20.30.1&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>也可以直接在命令行使用 man:route[8] 命令:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># route add default 10.20.30.1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要了解关于如何手工维护网络路由表的进一步细节， 请参考 man:route[8] 联机手册。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-dual-homed-hosts">2.3. 重宿主机(Dual Homed Hosts)<a class="anchor" href="#network-dual-homed-hosts"></a></h3>
<div class="paragraph">
<p>还有一种其它的类型的配置是我们要提及的， 这就是一个主机处于两个不同的网络。技术上，任何作为网关 (上边的实例中，使用了 PPP 连接) 的机子就算作是重宿主机。 但这个词实际上仅用来指那种处于两个局域网之中的机子。</p>
</div>
<div class="paragraph">
<p>有一种情形，一台机子有两个网卡， 对于各个子网都有各自的一个地址。另一种情况， 这台机子仅有一张网卡，但使用 man:ifconfig[8] 做了别名。如果有两个独立的以太网在使用的情形就使用前者， 如果只有一个物理网段，但逻辑上分成了两个独立的子网， 就使用后者。</p>
</div>
<div class="paragraph">
<p>每种情况都要设置路由表以便两子网都知道这台主机是到其它子网的网关――入站路由 (inbound route)。将一台主机配置成两个子网间的路由器， 这种配置经常在我们需要实现单向或双向的包过滤或防火墙时被用到。</p>
</div>
<div class="paragraph">
<p>如果想让主机在两个接口间转发数据包，您需要激活 FreBSD 的这项功能。至于怎么做，请看下一部分了解更多。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-dedicated-router">2.4. 建立路由器<a class="anchor" href="#network-dedicated-router"></a></h3>
<div class="paragraph">
<p>网络路由器只是一个将数据包从一个接口转发到另一个接口的系统。 互联网标准和良好的工程实践阻止了 FreeBSD 计划在 FreeBSD 中把它置成默认值。您在可以在 man:rc.conf[5] 中改变下列变量的值为 <code>YES</code>，使这个功能生效：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre>
</div>
</div>
<div class="paragraph">
<p>这个选项会把man:sysctl[8] 变量――<code>net.inet.ip.forwarding</code> 设置成 <code>1</code>。如果您要临时地停止路由， 您可以把它重设为 <code>0</code>。</p>
</div>
<div class="paragraph">
<p>新的路由器需要有路由才知道将数据传向何处。 如果网络够简单，您可以使用静态路由。FreeBSD 也自带一个标准的BSD路由选择守护进程 man:routed[8]， 称之为 RIP ( version 1和 version 2) 和 IRDP。对 BGP v4，OSPF v2 和其它复杂路由选择协议的支持可以从 package:net/zebra[] 包中得到。 像 GateD® 一样的商业产品也提供了更复杂的网络路由解决方案。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-static-routes">2.5. 设置静态路由<a class="anchor" href="#network-static-routes"></a></h3>
<div class="sect3">
<h4 id="_手动配置">2.5.1. 手动配置<a class="anchor" href="#_手动配置"></a></h4>
<div class="paragraph">
<p>假设如下这样一个网络：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/advanced-networking/static-routes.png" alt="static routes"/>
</div>
</div>
<div class="paragraph">
<p>在这里，<code>RouterA</code> 是我们的 FreeBSD 机子，它充当连接到互联网其它部分的路由器的角色。 默认路由设置为<code>10.0.0.1</code>， 它就允许与外界连接。我们假定已经正确配置了 <code>RouterB</code>，并且知道如何连接到想去的任何地方。 (在这个图里很简单。只须在 <code>RouterB</code> 上增加默认路由，使用 <code>192.168.1.1</code> 做为网关。)</p>
</div>
<div class="paragraph">
<p>如果我们查看一下<code>RouterA</code>的路由表， 我们就会看到如下一些内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% netstat <span class="nt">-nr</span>
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        <span class="nb">link</span><span class="c">#1             UC          0        0    xl0</span>
192.168.1.0/24     <span class="nb">link</span><span class="c">#2             UC          0        0    xl1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用当前的路由表，<code>RouterA</code> 是不能到达我们的内网――Internal Net 2 的。它没有到 <code>192.168.2.0/24</code> 的路由。 一种可以接受的方法是手工增加这条路由。以下的命令会把 Internal Net 2 网络加入到 <code>RouterA</code> 的路由表中，使用<code>192.168.1.2</code> 做为下一个跳跃：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 <code>RouterA</code> 就可以到达 <code>192.168.2.0/24</code> 网络上的任何主机了。</p>
</div>
</div>
<div class="sect3">
<h4 id="_永久配置">2.5.2. 永久配置<a class="anchor" href="#_永久配置"></a></h4>
<div class="paragraph">
<p>上面的实例对于运行着的系统来说配置静态路由是相当不错了。 只是，有一个问题――如果您重启您的 FreeBSD 机子，路由信息就会消失。 处理附加的静态路由的方法是把它放到您的 <span class="filename">/etc/rc.conf</span> 文件里去。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Add Internal Net 2 as a static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>配置变量 <code>static_routes</code> 是一串以空格隔开的字符串。每一串表示一个路由名字。 在上面的例子中我们中有一个串在 <code>static_routes</code> 里。这个字符串中 <em>internalnet2</em>。 然后我们新增一个配置变量 <code>route_internalnet2</code>， 这里我们把所有传给 man:route[8]命令的参数拿了过来。 在上面的实例中的我使用的命令是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>因此，我们需要的是 <code>&#34;-net 192.168.2.0/24 192.168.1.2&#34;</code>。</p>
</div>
<div class="paragraph">
<p>前边已经提到， 可以把多个静态路由的名称， 放到 <code>static_routes</code> 里边。 接着我们就来建立多个静态路由。 下面几行所展示的， 是在一个假想的路由器上增加 <code>192.168.0.0/24</code> 和 <code>192.168.1.0/24</code> 之间静态路由的例子：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-routing-propagation">2.6. 路由传播<a class="anchor" href="#network-routing-propagation"></a></h3>
<div class="paragraph">
<p>我们已经讨论了如何定义通向外界的路由， 但未谈及外界是如何找到我们的。</p>
</div>
<div class="paragraph">
<p>我们已经知道可以设置路由表， 这样任何指向特定地址空间 (在我们的例子中是一个 C 类子网) 的数据都会被送往网络上特定的主机， 然后由这台主机向地址空间内部转发数据。</p>
</div>
<div class="paragraph">
<p>当您得到一个分配给您的网络的地址空间时， ISP(网络服务商)会设置它们的路由表， 这样指向您子网的数据就会通过 PPP 连接下传到您的网络。 但是其它跨越国界的网络是如何知道将数据传给您的 ISP 的呢？</p>
</div>
<div class="paragraph">
<p>有一个系统(很像分布式 DNS 信息系统)， 它一直跟踪被分配的地址空间， 并说明它们连接到互联网骨干(Internet backbone)的点。 &#34;骨干(Backbone)&#34; 指的是负责全世界和跨国的传输的主要干线。 每一台骨干主机(backbone machine)有一份主要表集的副本， 它将发送给特定网络的数据导向相应的骨干载体上(backbone carrier)， 从结点往下遍历服务提供商链，直到数据到达您的网络。</p>
</div>
<div class="paragraph">
<p>服务提供商的任务是向骨干网络广播，以声明它们就是通向您的网点的连接结点 (以及进入的路径)。这就是路由传播。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-routing-troubleshooting">2.7. 问题解答<a class="anchor" href="#network-routing-troubleshooting"></a></h3>
<div class="paragraph">
<p>有时候，路由传播会有一个问题，一些网络无法与您连接。 或许能帮您找出路由是在哪里中断的最有用的命令就是 man:traceroute[8]了。当您无法与远程主机连接时， 这个命令一样有用(例如 man:ping[8] 失败)。</p>
</div>
<div class="paragraph">
<p>man:traceroute[8] 命令将以您想连接的主机的名字作为参数执行。 不管是到达了目标，还是因为没有连接而终止， 它都会显示所经过的所有网关主机。</p>
</div>
<div class="paragraph">
<p>想了解更多的信息，查看 man:traceroute[8] 的手册。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-routing-multicast">2.8. 多播路由<a class="anchor" href="#network-routing-multicast"></a></h3>
<div class="paragraph">
<p>FreeBSD 一开始就支持多播应用软件和多播路由选择。 多播程序并不要求FreeBSD的任何特殊的配置， 就可以工作得很好。多播路由需要支持被编译入内核：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options MROUTING</pre>
</div>
</div>
<div class="paragraph">
<p>另外，多播路由守护进程――man:mrouted[8] 必须通过 <span class="filename">/etc/mrouted.conf</span> 配置来开启通道和 DVMRP。 更多关于多播路由配置的信息可以在 man:mrouted[8] 的手册里找到。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>多播路由服务 man:mrouted[8] 实现了 DVMRP 多播路由协议， 在许多采用多播的场合， 它已被 man:pim[4] 取代。 man:mrouted[8] 以及相关的 man:map-mbone[8] 和 man:mrinfo[8] 工具可以在 FreeBSD 的 Ports Collection package:net/mrouted[] 中找到。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-wireless">3. 无线网络<a class="anchor" href="#network-wireless"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_无线网络基础">3.1. 无线网络基础<a class="anchor" href="#_无线网络基础"></a></h3>
<div class="paragraph">
<p>绝大多数无线网络都采用了 IEEE® 802.11 标准。 基本的无线网络中， 都包含多个以 2.4GHz 或 5GHz 频段的无线电波广播的站点 (不过， 随所处地域的不同， 或者为了能够更好地进行通讯， 具体的频率会在 2.3GHz 和 4.9GHz 的范围内变化)。</p>
</div>
<div class="paragraph">
<p>802.11 网络有两种组织方式： 在 <em>infrastructure 模式</em> 中， 一个通讯站作为主站， 其他通讯站都与其关联； 这种网络称为 BSS， 而主站则成为无线访问点 (AP)。 在 BSS 中， 所有的通讯都是通过 AP 来完成的； 即使通讯站之间要相互通讯， 也必须将消息发给 AP。 在第二种形式的网络中， 并不存在主站， 通讯站之间是直接通讯的。 这种网络形式称作 IBSS， 通常也叫做 <em>ad-hoc 网络</em>。</p>
</div>
<div class="paragraph">
<p>802.11 网络最初在 2.4GHz 频段上部署， 并采用了由 IEEE® 802.11 和 802.11b 标准所定义的协议。 这些标准定义了采用的操作频率、 包括分帧和传输速率 (通讯过程中可以使用不同的速率) 在内的 MAC 层特性等。 稍后的 802.11a 标准定义了使用 5GHz 频段进行操作， 以及不同的信号机制和更高的传输速率。 其后定义的 802.11g 标准启用了在 2.4GHz 上如何使用 802.11a 信号和传输机制， 以提供对较早的 802.11b 网络的向前兼容。</p>
</div>
<div class="paragraph">
<p>802.11 网络中采用的各类底层传输机制提供了不同类型的安全机制。 最初的 802.11 标准定义了一种称为 WEP 的简单安全协议。 这个协议采用固定的预发布密钥， 并使用 RC4 加密算法来对在网络上传输的数据进行编码。 全部通讯站都必须采用同样的固定密钥才能通讯。 这一格局已经被证明很容易被攻破， 因此目前已经很少使用了， 采用这种方法只能让那些接入网络的用户迅速断开。 最新的安全实践是由 IEEE® 802.11i 标准给出的， 它定义了新的加密算法， 并通过一种附加的协议来让通讯站向无线访问点验证身份， 并交换用于进行数据通讯的密钥。 更进一步， 用于加密的密钥会定期地刷新， 而且有机制能够监测入侵的尝试 (并阻止这种尝试)。 无线网络中另一种常用的安全协议标准是 WPA。 这是在 802.11i 之前由业界组织定义的一种过渡性标准。 WPA 定义了在 802.11i 中所规定的要求的子集， 并被设计用来在旧式硬件上实施。 特别地， WPA 要求只使用由最初 WEP 所采用的算法派生的 TKIP 加密算法。 802.11i 则不但允许使用 TKIP， 而且还要求支持更强的加密算法 AES-CCM 来用于加密数据。 (在 WPA 中并没有要求使用 AES 加密算法， 因为在旧式硬件上实施这种算法时所需的计算复杂性太高。)</p>
</div>
<div class="paragraph">
<p>除了前面介绍的那些协议标准之外， 还有一种需要介绍的标准是 802.11e。 它定义了用于在 802.11 网络上运行多媒体应用， 如视频流和使用 IP 传送的语音 (VoIP) 的协议。 与 802.11i 类似， 802.11e 也有一个前身标准， 通常称作 WME (后改名为 WMM)， 它也是由业界组织定义的 802.11e 的子集， 以便能够在旧式硬件中使用多媒体应用。 关于 802.11e 与 WME/WMM 之间的另一项重要区别是， 前者允许对流量通过服务品质 (QoS) 协议和增强媒体访问协议来安排优先级。 对于这些协议的正确实现， 能够实现高速突发数据和流量分级。</p>
</div>
<div class="paragraph">
<p>FreeBSD 支持采用 802.11a, 802.11b 和 802.11g 的网络。 类似地， 它也支持 WPA 和 802.11i 安全协议 (与 11a、 11b 和 11g 配合)， 而 WME/WMM 所需要的 QoS 和流量分级， 则在部分无线设备上提供了支持。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-wireless-basic">3.2. 基本安装<a class="anchor" href="#network-wireless-basic"></a></h3>
<div class="sect3">
<h4 id="_内核配置">3.2.1. 内核配置<a class="anchor" href="#_内核配置"></a></h4>
<div class="paragraph">
<p>要使用无线网络， 您需要一块无线网卡， 并适当地配置内核令其提供无线网络支持。 后者被分成了多个模块， 因此您只需配置使用您所需要的软件就可以了。</p>
</div>
<div class="paragraph">
<p>首先您需要的是一个无线设备。 最为常用的一种无线配件是 Atheros 生产的。 这些设备由 man:ath[4] 驱动程序提供支持， 您需要把下面的配置加入到 <span class="filename">/boot/loader.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>if_ath_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>Atheros 驱动分为三个部分： 驱动部分 (man:ath[4])、 用于处理芯片专有功能的支持层 (man:ath_hal[4])， 以及一组用以选择传输帧速率的算法 (ath_rate_sample here)。 当以模块方式加载这一支持时， 所需的其它模块会自动加载。 如果您使用的不是 Atheros 设备， 则应选择对应的模块； 例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>if_wi_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>表示使用基于 Intersil Prism 产品的无线设备 (man:wi[4] 驱动)。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在这篇文档余下的部分中， 我们将以 man:ath[4] 卡来进行示范， 如果要套用这些配置的话， 可能需要根据您实际的配置情况来修改示例中的设备名称。 在 FreeBSD 兼容硬件说明中提供了目前可用的无线网络驱动， 以及兼容硬件的列表。 针对不同版本和硬件平台的说明可以在 FreeBSD 网站的 <a href="http://www.FreeBSD.org/releases/">Release Information</a> 页面找到。 如果您的无线设备没有与之对应的 FreeBSD 专用驱动程序， 也可以尝试使用 crossref:config[config-network-ndis,NDIS] 驱动封装机制来直接使用 Windows® 驱动。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于 FreeBSD 7.X， 在配置好设备驱动之后， 您还需要引入驱动程序所需要的 802.11 网络支持。 对于 man:ath[4] 驱动而言， 至少需要 man:wlan[4] <code>wlan_scan_ap</code> 和 <code>wlan_scan_sta</code> 模块； man:wlan[4] 模块会自动随无线设备驱动一同加载， 剩下的模块必须要在系统引导时加载， 就需要在 <span class="filename">/boot/loader.conf</span> 中加入下面的配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlan_scan_ap_load=&#34;YES&#34;
wlan_scan_sta_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>从 FreeBSD 8.0 起， 这些模块成为了 man:wlan[4] 驱动的基础组件， 并会随适配器驱动一起动态加载。</p>
</div>
<div class="paragraph">
<p>除此之外， 您还需要提供您希望使用的安全协议所需的加密支持模块。 这些模块是设计来让 man:wlan[4] 模块根据需要自动加载的， 但目前还必须手工进行配置。 您可以使用下面这些模块： man:wlan_wep[4]、 man:wlan_ccmp[4] 和 man:wlan_tkip[4]。 man:wlan_ccmp[4] 和 man:wlan_tkip[4] 这两个驱动都只有在您希望采用 WPA 和/或 802.11i 安全协议时才需要。 如果您的网络不采用加密， 就不需要 man:wlan_wep[4] 支持了。 要在系统引导时加载这些模块， 需要在 <span class="filename">/boot/loader.conf</span> 中加入下面的配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlan_wep_load=&#34;YES&#34;
wlan_ccmp_load=&#34;YES&#34;
wlan_tkip_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>通过系统引导配置文件 (也就是 <span class="filename">/boot/loader.conf</span>) 中的这些信息生效， 您必须重新启动运行 FreeBSD 的计算机。 如果不想立刻重新启动， 也可以使用 man:kldload[8] 来手工加载。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果不想加载模块， 也可以将这些驱动编译到内核中， 方法是在内核的编译配置文件中加入下面的配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device wlan              # 802.11 support
device wlan_wep          # 802.11 WEP support
device wlan_ccmp         # 802.11 CCMP support
device wlan_tkip         # 802.11 TKIP support
device wlan_amrr         # AMRR transmit rate control algorithm
device ath               # Atheros pci/cardbus NIC&#39;s
device ath_hal           # pci/cardbus chip support
options AH_SUPPORT_AR5416 # enable AR5416 tx/rx descriptors
device ath_rate_sample   # SampleRate tx rate control for ath</pre>
</div>
</div>
<div class="paragraph">
<p>使用 FreeBSD 7.X 时， 还需要配置下面这两行； FreeBSD 的其他版本不需要它们。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device wlan_scan_ap      # 802.11 AP mode scanning
device wlan_scan_sta     # 802.11 STA mode scanning</pre>
</div>
</div>
<div class="paragraph">
<p>将这些信息写到内核编译配置文件中之后， 您需要重新编译内核， 并重新启动运行 FreeBSD 的计算机。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在系统启动之后， 您会在引导时给出的信息中， 找到类似下面这样的关于无线设备的信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ath0: &lt;Atheros 5212&gt; mem 0x88000000-0x8800ffff irq 11 at device 0.0 on cardbus1
ath0: <span class="o">[</span>ITHREAD]
ath0: AR2413 mac 7.9 RF2413 phy 4.5</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_infrastructure_模式">3.3. Infrastructure 模式<a class="anchor" href="#_infrastructure_模式"></a></h3>
<div class="paragraph">
<p>通常的情形中使用的是 infrastructure 模式或称 BSS 模式。 在这种模式中， 有一系列无线访问点接入了有线网络。 每个无线网都会有自己的名字， 这个名字称作网络的 SSID。 无线客户端都通过无线访问点来完成接入。</p>
</div>
<div class="sect3">
<h4 id="_freebsd_客户机">3.3.1. FreeBSD 客户机<a class="anchor" href="#_freebsd_客户机"></a></h4>
<div class="sect4">
<h5 id="_如何查找无线访问点">3.3.1.1. 如何查找无线访问点<a class="anchor" href="#_如何查找无线访问点"></a></h5>
<div class="paragraph">
<p>您可以通过使用 <code>ifconfig</code> 命令来扫描网络。 由于系统需要在操作过程中切换不同的无线频率并探测可用的无线访问点， 这种请求可能需要数分钟才能完成。 只有超级用户才能启动这种扫描：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0</span>
<span class="c"># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
dlinkap         00:13:46:49:41:76   11   54M <span class="nt">-90</span>:96   100 EPS  WPA WME
freebsdap       00:11:95:c3:0d:ac    1   54M <span class="nt">-83</span>:96   100 EPS  WPA</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在开始扫描之前， 必须将网络接口设为 <code>up</code>。 后续的扫描请求就不需要再将网络接口设为 up 了。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 FreeBSD 7.X 中， 会直接适配器设备， 例如 <span class="filename">ath0</span>， 而不是 <span class="filename">wlan0</span> 设备。 因此您需要把前面的命令行改为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig ath0 up scan</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这份文档余下的部分中， 您也需要注意 FreeBSD 7.X 上的这些差异， 并对命令行示例进行类似的改动。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>扫描会列出所请求到的所有 BSS/IBSS 网络列表。 除了网络的名字 <code>SSID</code> 之外， 我们还会看到 <code>BSSID</code> 即无线访问点的 MAC 地址。 而 <code>CAPS</code> 字段则给出了网络类型及其提供的功能， 其中包括：</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 1. 通讯站功能代码</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">功能代码</th>
<th class="tableblock halign-left valign-top">含义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>E</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Extended Service Set (ESS)。 表示通讯站是 infrastructure 网络 (相对于 IBSS/ad-hoc 网络) 的成员。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>I</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IBSS/ad-hoc 网络。 表示通讯站是 ad-hoc 网络 (相对于 ESS 网络) 的成员。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>P</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">私密。 在 BSS 中交换的全部数据帧均需保证数据保密性。 这表示 BSS 需要通讯站使用加密算法， 例如 WEP、 TKIP 或 AES-CCMP 来加密/解密与其他通讯站交换的数据帧。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>S</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短前导码 (Short Preamble)。 表示网络采用的是短前导码 (由 802.11b High Rate/DSSS PHY 定义， 短前导码采用 56-位 同步字段， 而不是在长前导码模式中所采用的 128-位 字段)。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">短碰撞槽时间 (Short slot time)。 表示由于不存在旧式 (802.11b) 通讯站， 802.11g 网络正使用短碰撞槽时间。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>要显示目前已知的网络， 可以使用下面的命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 list scan</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些信息可能会由无线适配器自动更新， 也可使用 <code>scan</code> 手动更新。 快取缓存中的旧数据会自动删除， 因此除非进行更多扫描， 这个列表会逐渐缩小。</p>
</div>
</div>
<div class="sect4">
<h5 id="_基本配置">3.3.1.2. 基本配置<a class="anchor" href="#_基本配置"></a></h5>
<div class="paragraph">
<p>在这一节中我们将展示一个简单的例子来介绍如何让无线网络适配器在 FreeBSD 中以不加密的方式工作。 在您熟悉了这些概念之后， 我们强烈建议您在实际的使用中采用 <a href="#network-wireless-wpa">WPA</a> 来配置网络。</p>
</div>
<div class="paragraph">
<p>配置无线网络的过程可分为三个基本步骤： 选择无线访问点、 验证您的通讯站身份， 以及配置 IP 地址。 下面的几节中将分步骤地介绍它们。</p>
</div>
<div class="sect5">
<h6 id="_选择无线访问点">3.3.1.2.1. 选择无线访问点<a class="anchor" href="#_选择无线访问点"></a></h6>
<div class="paragraph">
<p>多数时候让系统以内建的探测方式选择无线访问点就可以了。 这是在您将网络接口置为 up 或在 <span class="filename">/etc/rc.conf</span> 中配置 IP 地址时的默认方式， 例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如前面提到的那样， FreeBSD 7.X 只需要一行配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_ath0=&#34;DHCP&#34;</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果存在多个无线访问点， 而您希望从中选择具体的一个， 则可以通过指定 SSID 来实现：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在某些环境中， 多个访问点可能会使用同样的 SSID (通常， 这样做的目的是简化漫游)， 这时可能就需要与某个具体的设备关联了。 这种情况下， 您还应指定无线访问点的 BSSID (这时可以不指定 SSID)：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;ssid your_ssid_here bssid xx:xx:xx:xx:xx:xx DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>除此之外， 还有一些其它的方法能够约束查找无线访问点的范围， 例如限制系统扫描的频段， 等等。 如果您的无线网卡支持多个频段， 这样做可能会非常有用， 因为扫描全部可用频段是一个十分耗时的过程。 要将操作限制在某个具体的频段， 可以使用 <code>mode</code> 参数； 例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;mode 11g ssid your_ssid_here DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>就会强制卡使用采用 2.4GHz 的 802.11g， 这样在扫描的时候， 就不会考虑那些 5GHz 的频段了。 除此之外， 还可以通过 <code>channel</code> 参数来将操作锁定在特定频率， 以及通过 <code>chanlist</code> 参数来指定扫描的频段列表。 关于这些参数的进一步信息， 可以在联机手册 man:ifconfig[8] 中找到。</p>
</div>
</div>
<div class="sect5">
<h6 id="_验证身份">3.3.1.2.2. 验证身份<a class="anchor" href="#_验证身份"></a></h6>
<div class="paragraph">
<p>一旦您选定了无线访问点， 您的通讯站就需要完成身份验证， 以便开始发送和接收数据。 身份验证可以通过许多方式进行， 最常用的一种方式称为开放式验证， 它允许任意通讯站加入网络并相互通信。 这种验证方式只应在您第一次配置无线网络进行测试时使用。 其它的验证方式则需要在进行数据通讯之前， 首先进行密钥协商握手； 这些方式要么使用预先分发的密钥或密码， 要么是用更复杂一些的后台服务， 如 RADIUS。 绝大多数用户会使用默认的开放式验证， 而第二多的则是 WPA-PSK， 它也称为个人 WPA， 在 <a href="#network-wireless-wpa-wpa-psk">下面</a> 的章节中将进行介绍。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果您使用 Apple® AirPort® Extreme 基站作为无线访问点， 则可能需要同时在两端配置 WEP 共享密钥验证。 这可以通过在 <span class="filename">/etc/rc.conf</span> 文件中进行设置， 或使用 man:wpa_supplicant[8] 程序来手工完成。 如果您只有一个 AirPort® 基站， 则可以用类似下面的方法来配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;authmode shared wepmode on weptxkey 1 wepkey 01234567 DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>一般而言， 应尽量避免使用共享密钥这种验证方法， 因为它以非常受限的方式使用 WEP 密钥， 使得攻击者能够很容易地破解密钥。 如果必须使用 WEP (例如， 为了兼容旧式的设备) 最好使用 WEP 配合 <code>open</code> 验证方式。 关于 WEP 的更多资料请参见 <a href="#network-wireless-wep">WEP</a>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect5">
<h6 id="_通过_dhcp_获取_ip_地址">3.3.1.2.3. 通过 DHCP 获取 IP 地址<a class="anchor" href="#_通过_dhcp_获取_ip_地址"></a></h6>
<div class="paragraph">
<p>在您选定了无线访问点， 并配置了验证参数之后， 还必须获得 IP 地址才能真正开始通讯。 多数时候， 您会通过 DHCP 来获得无线 IP 地址。 要达到这个目的， 需要编辑 <span class="filename">/etc/rc.conf</span> 并在配置中加入 <code>DHCP</code>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>现在您已经完成了启用无线网络接口的全部准备工作了， 下面的操作将启用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/netif start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦网络接口开始运行， 就可以使用 <code>ifconfig</code> 来查看网络接口 <span class="filename">ath0</span> 的状态了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0</span>
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        ether 00:11:95:d5:43:62
        inet 192.168.1.100 netmask 0xffffff00 broadcast 192.168.1.255
        media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
        status: associated
        ssid dlinkap channel 11 <span class="o">(</span>2462 Mhz 11g<span class="o">)</span> bssid 00:13:46:49:41:76
        country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
        scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
        roam:rate 5 protmode CTS wme burst</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>status: associated</code> 表示您已经连接到了无线网络 (在这个例子中， 这个网络的名字是 <code>dlinkap</code>)。 <code>bssid 00:13:46:49:41:76</code> 是指您所用无线访问点的 MAC 地址； <code>authmode OPEN</code> 表示您通讯的内容将将不加密。</p>
</div>
</div>
<div class="sect5">
<h6 id="_静态_ip_地址">3.3.1.2.4. 静态 IP 地址<a class="anchor" href="#_静态_ip_地址"></a></h6>
<div class="paragraph">
<p>如果无法从某个 DHCP 服务器获得 IP 地址， 则可以配置一个静态 IP 地址， 方法是将前面的 <code>DHCP</code> 关键字替换为地址信息。 请务必保持其他用于连接无线访问点的参数：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;inet 192.168.1.100 netmask 255.255.255.0 ssid your_ssid_here&#34;</pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="network-wireless-wpa">3.3.1.3. WPA<a class="anchor" href="#network-wireless-wpa"></a></h5>
<div class="paragraph">
<p>WPA (Wi-Fi 保护访问) 是一种与 802.11 网络配合使用的安全协议， 其目的是消除 <a href="#network-wireless-wep">WEP</a> 中缺少身份验证能力的问题， 以及一些其它的安全弱点。 WPA 采用了 802.1X 认证协议， 并采用从多种与 WEP 不同的加密算法中选择一种来保证数据保密性。 WPA 支持的唯一一种加密算法是 TKIP (临时密钥完整性协议)， TKIP 是一种对 WEP 所采用的基本 RC4 加密算法的扩展， 除此之外还提供了对检测到的入侵的响应机制。 TKIP 被设计用来与旧式硬件一同工作， 只需要进行部分软件修改； 它提供了一种改善安全性的折衷方案， 但仍有可能受到攻击。 WPA 也指定了 AES-CCMP 加密作为 TKIP 的替代品， 在可能时倾向于使用这种加密； 表达这一规范的常用术语是 WPA2 (或 RSN)。</p>
</div>
<div class="paragraph">
<p>WPA 定义了验证和加密协议。 验证通常是使用两种方法之一来完成的： 通过 802.1X 或类似 RADIUS 这样的后端验证服务， 或通过在通讯站和无线访问点之间通过事先分发的密码来进行最小握手。 前一种通常称作企业 WPA， 而后者通常也叫做个人 WPA。 因为多数人不会为无线网络配置 RADIUS 后端服务器， 因此 WPA-PSK 是在 WPA 中最为常见的一种。</p>
</div>
<div class="paragraph">
<p>对无线连接的控制和身份验证工作 (密钥协商或通过服务器验证) 是通过 man:wpa_supplicant[8] 工具来完成的。 这个程序运行时需要一个配置文件， <span class="filename">/etc/wpa_supplicant.conf</span>。 关于这个文件的更多信息， 请参考联机手册 man:wpa_supplicant.conf[5]。</p>
</div>
<div class="sect5">
<h6 id="network-wireless-wpa-wpa-psk">3.3.1.3.1. WPA-PSK<a class="anchor" href="#network-wireless-wpa-wpa-psk"></a></h6>
<div class="paragraph">
<p>WPA-PSK 也称作 个人-WPA， 它基于预先分发的密钥 (PSK)， 这个密钥是根据作为无线网络上使用的主密钥的密码生成的。 这表示每个无线用户都会使用同样的密钥。 WPA-PSK 主要用于小型网络， 在这种网络中， 通常不需要或没有办法架设验证服务器。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>无论何时， 都应使用足够长， 且包括尽可能多字母和数字的强口令， 以免被猜出和/或攻击。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>第一步是修改配置文件 <span class="filename">/etc/wpa_supplicant.conf</span>， 并在其中加入在您网络上使用的 SSID 和事先分发的密钥：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;freebsdap&#34;
  psk=&#34;freebsdmall&#34;
}</pre>
</div>
</div>
<div class="paragraph">
<p>接下来， 在 <span class="filename">/etc/rc.conf</span> 中， 我们将指定无线设备的配置， 令其采用 WPA， 并通过 DHCP 来获取 IP 地址：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下面启用无线网络接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 5
DHCPDISCOVER on wlan0 to 255.255.255.255 port 67 interval 6
DHCPOFFER from 192.168.0.1
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class="nt">--</span> renewal <span class="k">in </span>300 seconds.
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
<div class="paragraph">
<p>除此之外， 您也可以手动地使用 <a href="#network-wireless-wpa-wpa-psk">above</a> 中那份 <span class="filename">/etc/wpa_supplicant.conf</span> 来配置， 方法是执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:11:95:c3:0d:ac <span class="o">(</span><span class="nv">SSID</span><span class="o">=</span><span class="s1">&#39;freebsdap&#39;</span> <span class="nv">freq</span><span class="o">=</span>2412 MHz<span class="o">)</span>
Associated with 00:11:95:c3:0d:ac
WPA: Key negotiation completed with 00:11:95:c3:0d:ac <span class="o">[</span><span class="nv">PTK</span><span class="o">=</span>CCMP <span class="nv">GTK</span><span class="o">=</span>CCMP]
CTRL-EVENT-CONNECTED - Connection to 00:11:95:c3:0d:ac completed <span class="o">(</span>auth<span class="o">)</span> <span class="o">[</span><span class="nb">id</span><span class="o">=</span>0 <span class="nv">id_str</span><span class="o">=]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来的操作， 是运行 <code>dhclient</code> 命令来从 DHCP 服务器获取 IP：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dhclient wlan0</span>
DHCPREQUEST on wlan0 to 255.255.255.255 port 67
DHCPACK from 192.168.0.1
bound to 192.168.0.254 <span class="nt">--</span> renewal <span class="k">in </span>300 seconds.
<span class="c"># ifconfig wlan0</span>
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果在 <span class="filename">/etc/rc.conf</span> 中把 <code>ifconfig_wlan0</code> 设置成了 <code>DHCP</code> (像 <code>ifconfig_wlan0=&#34;DHCP&#34;</code> 这样)， 那么在 <code>wpa_supplicant</code> 连上了无线接入点 (AP) 之后，则会自动运行 <code>dhclient</code>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果不打算使用 DHCP 或者 DHCP 不可用， 您可以在 <code>wpa_supplicant</code> 为通讯站完成了身份认证之后， 指定静态 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 inet 192.168.0.100 netmask 255.255.255.0</span>
<span class="c"># ifconfig wlan0</span>
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.100 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet OFDM/36Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有使用 DHCP， 还需要手工配置默认网关， 以及域名服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># route add default your_default_router</span>
<span class="c"># echo &#34;nameserver your_DNS_server&#34; &gt;&gt; /etc/resolv.conf</span></code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="network-wireless-wpa-eap-tls">3.3.1.3.2. 使用 EAP-TLS 的 WPA<a class="anchor" href="#network-wireless-wpa-eap-tls"></a></h6>
<div class="paragraph">
<p>使用 WPA 的第二种方式是使用 802.1X 后端验证服务器。 在这个例子中， WPA 也称作 企业-WPA， 以便与安全性较差、 采用事先分发密钥的 个人-WPA 区分开来。 在 企业-WPA 中， 验证操作是采用 EAP 完成的 (可扩展认证协议)。</p>
</div>
<div class="paragraph">
<p>EAP 并未附带加密方法。 因此设计者决定将 EAP 放在加密信道中进行传送。 目前有许多 EAP 验证方法， 最常用的方法是 EAP-TLS、 EAP-TTLS 和 EAP-PEAP。</p>
</div>
<div class="paragraph">
<p>EAP-TLS (带 传输层安全 的 EAP) 是一种在无线世界中得到了广泛支持的验证协议， 因为它是 <a href="http://www.wi-fi.org/">Wi-Fi 联盟</a> 核准的第一个 EAP 方法。 EAP-TLS 需要使用三个证书： CA 证书 (在所有计算机上安装)、 用以向您证明服务器身份的服务器证书， 以及每个无线客户端用于证明身份的客户机证书。 在这种 EAP 方式中， 验证服务器和无线客户端均通过自己的证书向对方证明身份， 它们均验证对方的证书是本机构的证书发证机构 (CA) 签发的。</p>
</div>
<div class="paragraph">
<p>与之前介绍的方法类似， 配置也是通过 <span class="filename">/etc/wpa_supplicant.conf</span> 来完成的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;freebsdap&#34; <i class="conum" data-value="1"></i><b>(1)</b>
  proto=RSN  <i class="conum" data-value="2"></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class="conum" data-value="3"></i><b>(3)</b>
  eap=TLS <i class="conum" data-value="4"></i><b>(4)</b>
  identity=&#34;loader&#34; <i class="conum" data-value="5"></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class="conum" data-value="6"></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class="conum" data-value="7"></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class="conum" data-value="8"></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class="conum" data-value="9"></i><b>(9)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个字段表示网络名 (SSID)。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这里， 我们使用 RSN (IEEE® 802.11i) 协议， 也就是 WPA2。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>key_mgmt</code> 这行表示所用的密钥管理协议。 在我们的例子中， 它是使用 EAP 验证的 WPA： <code>WPA-EAP</code>。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>这个字段中， 提到了我们的连接采用 EAP 方式。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td><code>identity</code> 字段包含了 EAP 的实体串。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>ca_cert</code> 字段给出了 CA 证书文件的路径名。 在验证服务器证书时， 这个文件是必需的。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>client_cert</code> 这行给出了客户机证书的路径名。 对每个无线客户端而言， 这个证书都是在全网范围内唯一的。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>private_key</code> 字段是客户机证书私钥文件的路径名。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>private_key_passwd</code> 字段是私钥的口令字。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接着， 把下面的配置写入 <span class="filename">/etc/rc.conf</span>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是使用 <span class="filename">rc.d</span> 机制来启用网络接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class="nt">--</span> renewal <span class="k">in </span>300 seconds.
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
<div class="paragraph">
<p>如前面提到的那样， 也可以手工通过 <code>wpa_supplicant</code> 和 <code>ifconfig</code> 命令达到类似的目的。</p>
</div>
</div>
<div class="sect5">
<h6 id="network-wireless-wpa-eap-ttls">3.3.1.3.3. 使用 EAP-TTLS 的 WPA<a class="anchor" href="#network-wireless-wpa-eap-ttls"></a></h6>
<div class="paragraph">
<p>在使用 EAP-TLS 时， 参与验证过程的服务器和客户机都需要证书， 而在使用 EAP-TTLS (带传输层安全隧道的 EAP) 时， 客户机证书则是可选的。 这种方式与某些安全 web 站点更为接近， 即使访问者没有客户端证书， 这些 web 服务器也能建立安全的 SSL 隧道。 EAP-TTLS 会使用加密的 TLS 隧道来传送验证信息。</p>
</div>
<div class="paragraph">
<p>对于它的配置， 同样是通过 <span class="filename">/etc/wpa_supplicant.conf</span> 文件来进行的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class="conum" data-value="1"></i><b>(1)</b>
  identity=&#34;test&#34; <i class="conum" data-value="2"></i><b>(2)</b>
  password=&#34;test&#34; <i class="conum" data-value="3"></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class="conum" data-value="4"></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class="conum" data-value="5"></i><b>(5)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个字段是我们的连接所采用的 EAP 方式。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>identity</code> 字段中是在加密 TLS 隧道中用于 EAP 验证的身份串。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>password</code> 字段中是用于 EAP 验证的口令字。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>ca_cert</code> 字段给出了 CA 证书文件的路径名。 在验证服务器证书时， 这个文件是必需的。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这个字段中给出了加密 TLS 隧道中使用的验证方式。 在这个例子中， 我们使用的是带 MD5-加密口令 的 EAP。 &#34;inner authentication&#34; (译注：内部鉴定) 通常也叫 &#34;phase2&#34;。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还必须把下面的配置写入 <span class="filename">/etc/rc.conf</span>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是启用网络接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class="nt">--</span> renewal <span class="k">in </span>300 seconds.
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
</div>
<div class="sect5">
<h6 id="network-wireless-wpa-eap-peap">3.3.1.3.4. 使用 EAP-PEAP 的 WPA<a class="anchor" href="#network-wireless-wpa-eap-peap"></a></h6>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>PEAPv0/EAP-MSCHAPv2 是最常见的 PEAP 方法。 此文档的以下部分将使用 PEAP 指代这些方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>PEAP (受保护的 EAP) 被设计用以替代 EAP-TTLS， 并且是在 EAP-TLS 之后最为常用的 EAP 标准。 换言之， 如果您的网络中有多种不同的操作系统， PEAP 将是仅次于 EAP-TLS 的支持最广的标准。</p>
</div>
<div class="paragraph">
<p>PEAP 与 EAP-TTLS 很像： 它使用服务器端证书， 通过在客户端与验证服务器之间建立加密的 TLS 隧道来向用户验证身份， 这保护了验证信息的交换过程。 在安全方面， EAP-TTLS 与 PEAP 的区别是 PEAP 会以明文广播用户名， 只有口令是通过加密 TLS 隧道传送的。 而 EAP-TTLS 在传送用户名和口令时， 都使用 TLS 隧道。</p>
</div>
<div class="paragraph">
<p>我们需要编辑 <span class="filename">/etc/wpa_supplicant.conf</span> 文件， 并加入与 EAP-PEAP 有关的配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class="conum" data-value="1"></i><b>(1)</b>
  identity=&#34;test&#34; <i class="conum" data-value="2"></i><b>(2)</b>
  password=&#34;test&#34; <i class="conum" data-value="3"></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class="conum" data-value="4"></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class="conum" data-value="5"></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class="conum" data-value="6"></i><b>(6)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个字段的内容是用于连接的 EAP 方式。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>identity</code> 字段中是在加密 TLS 隧道中用于 EAP 验证的身份串。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>password</code> 字段中是用于 EAP 验证的口令字。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>ca_cert</code> 字段给出了 CA 证书文件的路径名。 在验证服务器证书时， 这个文件是必需的。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这个字段包含了第一阶段验证 (TLS 隧道) 的参数。 随您使用的验证服务器的不同， 您需要指定验证的标签。 多数时候， 标签应该是 &#34;客户端 EAP 加密&#34;， 这可以通过使用 <code>peaplabel=0</code> 来指定。 更多信息可以在联机手册 man:wpa_supplicant.conf[5] 中找到。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>这个字段的内容是验证协议在加密的 TLS 隧道中使用的信息。 对 PEAP 而言， 这是 <code>auth=MSCHAPV2</code>。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>您还必须把下面的配置加入到 <span class="filename">/etc/rc.conf</span>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是启用网络接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 <span class="nt">--</span> renewal <span class="k">in </span>300 seconds.
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="network-wireless-wep">3.3.1.4. WEP<a class="anchor" href="#network-wireless-wep"></a></h5>
<div class="paragraph">
<p>WEP (有线等效协议) 是最初 802.11 标准的一部分。 其中没有提供身份验证机制， 只提供了弱访问控制， 而且很容易破解。</p>
</div>
<div class="paragraph">
<p>WEP 可以通过 <code>ifconfig</code> 配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0</span>
<span class="c"># ifconfig wlan0 inet 192.168.1.100 netmask 255.255.255.0 \</span>
	    ssid my_net wepmode on weptxkey 3 wepkey 3:0x3456789012</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>weptxkey</code> 指明了使用哪个 WEP 密钥来进行数据传输。 这里我们使用第三个密钥。 它必须与无线接入点的配置一致。 如果你不清楚你的无线接入点， 尝试用 <code>1</code> （就是说第一个密钥）来设置这个变量。</p>
</li>
<li>
<p><code>wepkey</code> 用于选择 WEP 密钥。 其格式应为 <em>index:key</em>， key 默认为 <code>1</code>; 如果需要设置的密钥不是第一个， 就必需指定 index 了。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>您需要将 <code>0x3456789012</code> 改为在无线接入点上配置的那个。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>我们建议您阅读联机手册 man:ifconfig[8] 来了解进一步的信息。</p>
</div>
<div class="paragraph">
<p><code>wpa_supplicant</code> 机制也可以用来配置您的无线网卡使用 WEP。 前面的例子也可以通过在 <span class="filename">/etc/wpa_supplicant.conf</span> 中加入下述设置来实现：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;my_net&#34;
  key_mgmt=NONE
  wep_key3=3456789012
  wep_tx_keyidx=3
}</pre>
</div>
</div>
<div class="paragraph">
<p>接着：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># wpa_supplicant -i wlan0 -c /etc/wpa_supplicant.conf</span>
Trying to associate with 00:13:46:49:41:76 <span class="o">(</span><span class="nv">SSID</span><span class="o">=</span><span class="s1">&#39;dlinkap&#39;</span> <span class="nv">freq</span><span class="o">=</span>2437 MHz<span class="o">)</span>
Associated with 00:13:46:49:41:76</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_ad_hoc_模式">3.4. Ad-hoc 模式<a class="anchor" href="#_ad_hoc_模式"></a></h3>
<div class="paragraph">
<p>IBSS 模式， 也称为 ad-hoc 模式， 是为点对点连接设计的。 例如， 如果希望在计算机 <code>A</code> 和 <code>B</code> 之间建立 ad-hoc 网络， 我们只需选择两个 IP 地址和一个 SSID 就可以了。</p>
</div>
<div class="paragraph">
<p>在计算机 <code>A</code> 上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class="c"># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class="o">(</span>2417 Mhz 11g<span class="o">)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre>
</div>
</div>
<div class="paragraph">
<p>此处的 <code>adhoc</code> 参数表示无线网络接口应以 IBSS 模式运转。</p>
</div>
<div class="paragraph">
<p>此时， 在 <code>B</code> 上应该能够检测到 <code>A</code> 的存在了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class="c"># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M <span class="nt">-64</span>:-96  100 IS   WME</code></pre>
</div>
</div>
<div class="paragraph">
<p>在输出中的 <code>I</code> 再次确认了 <code>A</code> 机是以 ad-hoc 模式运行的。 我们只需给 <code>B</code> 配置一不同的 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class="o">(</span>2417 Mhz 11g<span class="o">)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样， <code>A</code> 和 <code>B</code> 就可以交换信息了。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-wireless-ap">3.5. FreeBSD 基于主机的（无线）访问接入点<a class="anchor" href="#network-wireless-ap"></a></h3>
<div class="paragraph">
<p>FreeBSD 可以作为一个（无线）访问接入点（AP）， 这样可以不必再去买一个硬件 AP 或者使用 ad-hoc 模式的网络。 当你的 FreeBSD 机器作为网关连接到另外一个网络的时候将非常有用。</p>
</div>
<div class="sect3">
<h4 id="network-wireless-ap-basic">3.5.1. 基本配置<a class="anchor" href="#network-wireless-ap-basic"></a></h4>
<div class="paragraph">
<p>在把你的 FreeBSD 机器配置成一个 AP 以前， 你首先需要先在内核配置好对你的无线网卡的无线网络支持。 当然你还需要加上你想用的安全协议。想获得更详细的信息， 请参阅 <a href="#network-wireless-basic">基本安装</a>。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>目前还不支持使用 Windows® 驱动和 NDIS 驱动包装的网卡做为 AP 使用。只有 FreeBSD 原生的无线驱动能够支持 AP 模式。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一旦装载了无线网络的支持， 你就可以检查一下看看你的无线设备是否支持基于主机的无线访问接入模式 （通常也被称为 hostap 模式）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0</span>
<span class="c"># ifconfig wlan0 list caps</span>
<span class="nv">drivercaps</span><span class="o">=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class="nv">cryptocaps</span><span class="o">=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>这段输出显示了网卡所支持的各种功能； 其中的关键字 <code>HOSTAP</code> 表示这块网卡可以作为无线网络接入点来使用。 此外， 这里还会给出所支持的加密算法： WEP、 TKIP、 AES， 等等。 这些信息对于知道在访问接入点上使用何种安全协议非常重要。</p>
</div>
<div class="paragraph">
<p>只有创建网络伪设备时能够配置无线设备是否以 hostap 模式运行， 如果之前已经存在了相应的设备， 则需要首先将其销毁：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 destroy</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接着， 在配置其它参数前， 以正确的选项重新生成设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class="c"># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>再次使用 <code>ifconfig</code> 检查 <span class="filename">wlan0</span> 网络接口的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 <span class="nt">-dfs</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hostap</code> 参数指定了接口以主机接入点的方式运行。</p>
</div>
<div class="paragraph">
<p>通过在 <span class="filename">/etc/rc.conf</span> 中加入下面的配置， 也可以在系统引导的过程中自动完成对于网络接口的配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_不使用认证或加密的无线访问接入点">3.5.2. 不使用认证或加密的（无线）访问接入点<a class="anchor" href="#_不使用认证或加密的无线访问接入点"></a></h4>
<div class="paragraph">
<p>尽管我们不推荐运行一个不使用任何认证或加密的 AP， 但这是一个非常简单的检测 AP 是否正常工作的方法。 这样配置对于调试客户端问题也非常重要。</p>
</div>
<div class="paragraph">
<p>一旦 AP 被配置成了我们前面所展示的那样， 就可以在另外一台无线机器上初始化一次扫描来找到这个 AP：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0</span>
<span class="c"># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M <span class="nt">-66</span>:-96  100 ES   WME</code></pre>
</div>
</div>
<div class="paragraph">
<p>在客户机上能看到已经连接上了（无线）访问接入点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_wpa_的无线访问接入点">3.5.3. 使用 WPA 的（无线）访问接入点<a class="anchor" href="#_使用_wpa_的无线访问接入点"></a></h4>
<div class="paragraph">
<p>这一段将注重介绍在 FreeBSD （无线）访问接入点上配置使用 WPA 安全协议。 更多有关 WPA 和配置基于 WPA 无线客户端的细节 请参阅 <a href="#network-wireless-wpa">WPA</a>。</p>
</div>
<div class="paragraph">
<p>hostapd 守护进程将被用于处理与客户端的认证和在启用 WPA （无线）访问接入点上的密钥管理。</p>
</div>
<div class="paragraph">
<p>接下来，所有的配置操作都将在作为 AP 的 FreeBSD 机器上完成。 一旦 AP 能够正确的工作了，便把如下这行加入 <span class="filename">/etc/rc.conf</span> 使得 hostapd 能在机器启动的时候自动运行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostapd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在配置 hostapd 以前， 请确保你已经完成了基本配置中所介绍的步骤 <a href="#network-wireless-ap-basic">基本配置</a>。</p>
</div>
<div class="sect4">
<h5 id="_wpa_psk">3.5.3.1. WPA-PSK<a class="anchor" href="#_wpa_psk"></a></h5>
<div class="paragraph">
<p>WPA-PSK 旨在为没有认证服务器的小型网络而设计的。</p>
</div>
<div class="paragraph">
<p>配置文件为 <span class="filename">/etc/hostapd.conf</span> file：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>interface=wlan0 <i class="conum" data-value="1"></i><b>(1)</b>
debug=1 <i class="conum" data-value="2"></i><b>(2)</b>
ctrl_interface=/var/run/hostapd <i class="conum" data-value="3"></i><b>(3)</b>
ctrl_interface_group=wheel <i class="conum" data-value="4"></i><b>(4)</b>
ssid=freebsdap <i class="conum" data-value="5"></i><b>(5)</b>
wpa=1 <i class="conum" data-value="6"></i><b>(6)</b>
wpa_passphrase=freebsdmall <i class="conum" data-value="7"></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK <i class="conum" data-value="8"></i><b>(8)</b>
wpa_pairwise=CCMP TKIP <i class="conum" data-value="9"></i><b>(9)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这一项标明了访问接入点所使用的无线接口。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>这一项设置了执行 hostapd 时候显示相关信息的详细程度。 <code>1</code> 表示最小的级别。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>ctrl_interface</code> 这项给出了 hostapd 存储与其他外部程序（比如 man:hostapd_cli[8]) 通信的域套接口文件路径。这里使用了默认值。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>ctrl_interface_group</code> 这行设置了允许访问控制界面文件的组属性 （这里我们使用了 <code>wheel</code> 组）。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这一项是设置网络的名称。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td><code>wpa</code> 这项表示启用了 WPA 而且指明要使用何种 WPA 认证协议。 值 <code>1</code> 表示 AP 将使用 WPA-PSK。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td><code>wpa_passphrase</code> 这项包含用于 WPA 认证的 ASCII 密码。</td>
</tr>
<tr>
<td><i class="conum" data-value="8"></i><b>8</b></td>
<td><code>wpa_key_mgmt</code> 这行表明了我们所使用的密钥管理协议。 在这个例子中是 WPA-PSK。</td>
</tr>
<tr>
<td><i class="conum" data-value="9"></i><b>9</b></td>
<td><code>wpa_pairwise</code> 这项表示（无线）访问接入点所接受的加密算法。 在这个例子中，TKIP(WPA) 和 CCMP(WPA2) 密码都会被接受。 CCMP 密码是除 TKIP 外的另一种选择， CCMP 一般作为首选密码； 仅有在 CCMP 不能被使用的环境中选择 TKIP。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接下来的一步就是运行 hostapd：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/hostapd forcestart</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 2290
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  inet6 fe80::211:95ff:fec3:dac%ath0 prefixlen 64 scopeid 0x4
	  ether 00:11:95:c3:0d:ac
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: associated
	  ssid freebsdap channel 1 bssid 00:11:95:c3:0d:ac
	  authmode WPA2/802.11i privacy MIXED deftxkey 2 TKIP 2:128-bit txpowmax 36 protmode CTS dtimperiod 1 bintval 100</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在客户端能够连接上运行的（无线）访问接入点了， 更多细节可以参阅 <a href="#network-wireless-wpa">WPA</a>。 查看有哪些客户连接上了 AP 可以运行命令 <code>ifconfig wlan0 list sta</code>。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_wep_的无线访问接入点">3.5.4. 使用 WEP 的（无线）访问接入点<a class="anchor" href="#_使用_wep_的无线访问接入点"></a></h4>
<div class="paragraph">
<p>我们不推荐使用 WEP 来设置一个（无线）访问接入点， 因为没有认证的机制并容易被破解。 一些历史遗留下的无线网卡仅支持 WEP 作为安全协议， 这些网卡仅允许搭建不含认证或 WEP 协议的 AP。</p>
</div>
<div class="paragraph">
<p>在设置了正确的 SSID 和 IP 地址后，无线设备就可以进入 hostap 模式了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class="c"># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 \</span>
	ssid freebsdap wepmode on weptxkey 3 wepkey 3:0x3456789012 mode 11g</code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>weptxkey</code> 表示传输中使用哪一个 WEP 密钥。 这个例子中用了第3把密钥（请注意密钥的编号从 <code>1</code>开始）。 这个参数必须设置以用来加密数据。</p>
</li>
<li>
<p><code>wepkey</code> 表示设置所使用的 WEP 密钥。 它应该符合 <em>index:key</em> 这样的格式。 如果没有指定 index，那么默认值为 <code>1</code>。 这就是说如果我们使用了除第一把以外的密钥， 那么就需要指定 index。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>再使用一次 <code>ifconfig</code> 命令查看 <span class="filename">wlan0</span> 接口的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 4 <span class="o">(</span>2427 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy ON deftxkey 3 wepkey 3:40-bit
	  txpower 21.5 scanvalid 60 protmode CTS wme burst dtimperiod 1 <span class="nt">-dfs</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以从另外一台无线机器上初始化一次扫描来找到这个 AP 了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0</span>
<span class="c"># ifconfig wlan0 up scan</span>
SSID            BSSID              CHAN RATE  S:N   INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M 22:1   100 EPS</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在客户机能够使用正确的参数（密钥等） 找到并连上（无线）访问接入点了， 更多细节请参阅<a href="#network-wireless-wep">WEP</a>。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_同时使用有线和无线连接">3.6. 同时使用有线和无线连接<a class="anchor" href="#_同时使用有线和无线连接"></a></h3>
<div class="paragraph">
<p>一般而言， 有线网络的速度更快而且更可靠， 而无线网络则提供更好的灵活及机动性， 使用笔记本的用户， 往往会希望结合两者的优点， 并能够在两种连接之间无缝切换。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 上可以将多个网络接口合并到一起， 并以 &#34;故障转移&#34; 的方式自动切换， 也就是说， 这一组网络接口有一定的优先顺序， 而操作系统在链路状态发生变化时则自动进行切换， 例如当同时存在有线和无线连接的时候优先使用有线网络， 而当有线网络断开时， 则自动切换到无线网络。</p>
</div>
<div class="paragraph">
<p>我们将在稍后的 <a href="#network-aggregation">链路聚合与故障转移</a> 中介绍链路聚合和故障转移， 并在 <a href="#networking-lagg-wired-and-wireless">有线网络和无线网络接口间的自动切换</a> 中对这种配置方式进行示范。</p>
</div>
</div>
<div class="sect2">
<h3 id="_故障排除">3.7. 故障排除<a class="anchor" href="#_故障排除"></a></h3>
<div class="paragraph">
<p>如果您在使用无线网络时遇到了麻烦， 此处提供了一系列用以帮助排除故障的步骤。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果您在列表中找不到无线访问点， 请确认您没有将无线设备配置为使用有限的一组频段。</p>
</li>
<li>
<p>如果您无法关联到无线访问点， 请确认您的通讯站配置与无线访问点的配置一致。 这包括认证模式以及安全协议。 尽可能简化您的配置。 如果您正使用类似 WPA 或 WEP 这样的安全协议， 请将无线访问点配置为开放验证和不采用安全措施， 并检查是否数据能够通过。</p>
</li>
<li>
<p>一旦您能够关联到无线访问点之后， 就可以使用简单的工具如 man:ping[8] 来诊断安全配置了。</p>
<div class="paragraph">
<p><code>wpa_supplicant</code> 提供了许多调试支持； 尝试手工运行它， 在启动时指定 <code>-dd</code> 选项， 并察看输出结果。</p>
</div>
</li>
<li>
<p>除此之外还有许多其它的底层调试工具。 您可以使用 <span class="filename">/usr/src/tools/tools/net80211</span> 中的 <code>wlandebug</code> 命令来启用 802.11 协议支持层的调试功能。 例如：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># wlandebug -i ath0 +scan+auth+debug+assoc</span>
  net.wlan.0.debug: 0 <span class="o">=&gt;</span> 0xc80000&lt;assoc,auth,scan&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以用来启用与扫描无线访问点和 802.11 协议在安排通讯时与握手有关的控制台信息。</p>
</div>
<div class="paragraph">
<p>还有许多有用的统计信息是由 802.11 层维护的； <code>wlanstats</code> 工具可以显示这些信息。 这些统计数据能够指出由 802.11 层识别出来的错误。 请注意某些错误可能是由设备驱动在 802.11 层之下识别出来的， 因此这些错误可能并不显示。 要诊断与设备有关的问题， 您需要参考设备驱动程序的文档。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果上述信息没能帮助您找到具体的问题所在， 请提交问题报告， 并在其中附上这些工具的输出。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-bluetooth">4. 蓝牙<a class="anchor" href="#network-bluetooth"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_简介">4.1. 简介<a class="anchor" href="#_简介"></a></h3>
<div class="paragraph">
<p>Bluetooth (蓝牙) 是一项无线技术， 用于建立带宽为 2.4GHZ，波长为 10 米的私有网络。 网络一般是由便携式设备，比加手机 (cellular phone)， 掌上电脑 (handhelds) 和膝上电脑 (laptops)) 以 ad-hoc 形式组成。不象其它流行的无线技术――Wi-Fi，Bluetooth 提供了更高级的服务层面，像类 FTP 的文件服务、文件推送 (file pushing)、语音传送、串行线模拟等等。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 里，蓝牙栈 (Bluetooth stack) 通过使用 Netgraph 框架 (请看 man:netgraph[4]) 来的实现。 大量的&#34;Bluetooth USB dongle&#34;由 man:ng_ubt[4] 驱动程序支持。 基于 Broadcom BCM2033 芯片组的 Bluetooth 设备可以通过 man:ubtbcmfw[4] 和 man:ng_ubt[4] 驱动程序支持。 3Com Bluetooth PC 卡 3CRWB60-A 由 man:ng_bt3c[4] 驱动程序支持。 基于 Serial 和 UART 的蓝牙设备由 man:sio[4]、man:ng_h4[4] 和 man:hcseriald[8]。本节介绍 USB Bluetooth dongle 的使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="_插入设备">4.2. 插入设备<a class="anchor" href="#_插入设备"></a></h3>
<div class="paragraph">
<p>默认的 Bluetooth 设备驱动程序已存在于内核模块里。 接入设备前，您需要将驱动程序加载入内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload ng_ubt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果系统启动时 Bluetooth 设备已经存在于系统里， 那么从 <span class="filename">/boot/loader.conf</span> 里加载这个模块：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ng_ubt_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>插入USB dongle。控制台(console)(或syslog中)会出现类似如下的信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class="nv">interrupt</span><span class="o">=</span>0x81, bulk-in<span class="o">=</span>0x82, bulk-out<span class="o">=</span>0x2
ubt0: Interface 1 <span class="o">(</span>alt.config 5<span class="o">)</span> endpoints: isoc-in<span class="o">=</span>0x83, isoc-out<span class="o">=</span>0x3,
      <span class="nv">wMaxPacketSize</span><span class="o">=</span>49, <span class="nv">nframes</span><span class="o">=</span>6, buffer <span class="nv">size</span><span class="o">=</span>294</code></pre>
</div>
</div>
<div class="paragraph">
<p>脚本 <span class="filename">/etc/rc.d/bluetooth</span> 是用来启动和停止 Bluetooth stack (蓝牙栈)的。 最好在拔出设备前停止 stack(stack)，当然也不是非做不可。 启动 stack (栈) 时，会得到如下的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
&lt;3-Slot&gt; &lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO <span class="nb">link</span><span class="o">&gt;</span>
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_主控制器接口_hci">4.3. 主控制器接口 (HCI)<a class="anchor" href="#_主控制器接口_hci"></a></h3>
<div class="paragraph">
<p>主控制器接口 (HCI) 提供了通向基带控制器和连接管理器的命令接口及访问硬件状态字和控制寄存器的通道。 这个接口提供了访问蓝牙基带 (Bluetooth baseband) 功能的统一方式。 主机上的 HCI 层与蓝牙硬件上的 HCI 固件交换数据和命令。 主控制器的传输层 (如物理总线) 驱动程序提供两个 HCI 层交换信息的能力。</p>
</div>
<div class="paragraph">
<p>为每个蓝牙 (Bluetooth) 设备创建一个 <em>hci</em> 类型的 Netgraph 结点。 HCI 结点一般连接蓝牙设备的驱动结点 (下行流) 和 L2CAP 结点 (上行流)。 所有的HCI操作必须在 HCI 结点上进行而不是设备驱动结点。HCI 结点的默认名是 &#34;devicehci&#34;。更多细节请参考 man:ng_hci[4] 的联机手册。</p>
</div>
<div class="paragraph">
<p>最常见的任务是发现在 RF proximity 中的蓝牙 (Bluetooth) 设备。这个就叫做 <em>质询(inquiry)</em>。质询及 HCI 相关的操作可以由 man:hccontrol[8] 工具来完成。 以下的例子展示如何找出范围内的蓝牙设备。 在几秒钟内您应该得到一张设备列表。 注意远程主机只有被置于 <em>discoverable(可发现)</em> 模式才能答应质询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% hccontrol <span class="nt">-n</span> ubt0hci inquiry
Inquiry result, <span class="nv">num_responses</span><span class="o">=</span>1
Inquiry result <span class="c">#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class="o">[</span>00]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>BD_ADDR</code> 是蓝牙设备的特定地址， 类似于网卡的 MAC 地址。需要用此地址与某个设备进一步地通信。 可以为 BD_ADDR 分配由人可读的名字 (human readable name)。 文件 <span class="filename">/etc/bluetooth/hosts</span> 包含已知蓝牙主机的信息。 下面的例子展示如何获得分配给远程设备的可读名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% hccontrol <span class="nt">-n</span> ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class="s1">&#39;s T39</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在远程蓝牙上运行质询，您会发现您的计算机是 &#34;your.host.name (ubt0)&#34;。 分配给本地设备的名字可随时改变。</p>
</div>
<div class="paragraph">
<p>蓝牙系统提供点对点连接 (只有两个蓝牙设备参与) 和点对多点连接。在点对多点连接中，连接由多个蓝牙设备共享。 以下的例子展示如何取得本地设备的活动基带 (baseband) 连接列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% hccontrol <span class="nt">-n</span> ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre>
</div>
</div>
<div class="paragraph">
<p><em>connection handle(连接柄)</em> 在需要终止基带连接时有用。注意：一般不需要手动完成。 栈 (stack) 会自动终止不活动的基带连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class="nb">local </span>host <span class="o">[</span>0x16]</code></pre>
</div>
</div>
<div class="paragraph">
<p>参考 <code>hccontrol help</code> 获取完整的 HCI 命令列表。大部分 HCI 命令不需要超级用户权限。</p>
</div>
</div>
<div class="sect2">
<h3 id="_逻辑连接控制和适配协议l2cap">4.4. 逻辑连接控制和适配协议(L2CAP)<a class="anchor" href="#_逻辑连接控制和适配协议l2cap"></a></h3>
<div class="paragraph">
<p>逻辑连接控制和适配协议 (L2CAP) 为上层协议提供面向连接和无连接的数据服务， 并提供多协议功能和分割重组操作。L2CAP 充许上层协议和应用软件传输和接收最大长度为 64K 的 L2CAP 数据包。</p>
</div>
<div class="paragraph">
<p>L2CAP 基于 <em>通道(channel)</em> 的概念。 通道 (Channel) 是位于基带 (baseband) 连接之上的逻辑连接。 每个通道以多对一的方式绑定一个单一协议 (single protocol)。 多个通道可以绑定同一个协议，但一个通道不可以绑定多个协议。 每个在通道里接收到的 L2CAP 数据包被传到相应的上层协议。 多个通道可共享同一个基带连接。</p>
</div>
<div class="paragraph">
<p>为每个蓝牙 (Bluetooth) 设备创建一个 <em>l2cap</em> 类型的 Netgraph 结点。 L2CAP 结点一般连接 HCI 结点(下行流)和蓝牙设备的驱动结点(上行流)。 L2CAP 结点的默认名是 &#34;devicel2cap&#34;。 更多细节请参考 man:ng_l2cap[4] 的联机手册。</p>
</div>
<div class="paragraph">
<p>一个有用的命令是 man:l2ping[8]， 它可以用来 ping 其它设备。 一些蓝牙实现可能不会返回所有发送给它们的数据， 所以下例中的 <code>0 bytes</code> 是正常的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>0 <span class="nb">time</span><span class="o">=</span>48.633 ms <span class="nv">result</span><span class="o">=</span>0
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>1 <span class="nb">time</span><span class="o">=</span>37.551 ms <span class="nv">result</span><span class="o">=</span>0
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>2 <span class="nb">time</span><span class="o">=</span>28.324 ms <span class="nv">result</span><span class="o">=</span>0
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>3 <span class="nb">time</span><span class="o">=</span>46.150 ms <span class="nv">result</span><span class="o">=</span>0</code></pre>
</div>
</div>
<div class="paragraph">
<p>man:l2control[8] 工具用于在 L2CAP 上进行多种操作。 以下这个例子展示如何取得本地设备的逻辑连接 (通道) 和基带连接的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% l2control <span class="nt">-a</span> 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
% l2control <span class="nt">-a</span> 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个诊断工具是 man:btsockstat[1]。 它完成与 man:netstat[1] 类似的操作， 只是用了蓝牙网络相关的数据结构。 以下这个例子显示与 man:l2control[8] 相同的逻辑连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_rfcomm_协议">4.5. RFCOMM 协议<a class="anchor" href="#_rfcomm_协议"></a></h3>
<div class="paragraph">
<p>RFCOMM 协议提供基于 L2CAP 协议的串行端口模拟。 该协议基于 ETSI TS 07.10 标准。RFCOMM 是一个简单的传输协议， 附加了摸拟 9 针 RS-232(EIATIA-232-E) 串行端口的定义。 RFCOMM 协议最多支持 60 个并发连接 (RFCOMM通道)。</p>
</div>
<div class="paragraph">
<p>为了实现 RFCOMM， 运行于不同设备上的应用程序建立起一条关于它们之间通信段的通信路径。 RFCOMM实际上适用于使用串行端口的应用软件。 通信段是一个设备到另一个设备的蓝牙连接 (直接连接)。</p>
</div>
<div class="paragraph">
<p>RFCOMM 关心的只是直接连接设备之间的连接， 或在网络里一个设备与 modem 之间的连接。RFCOMM 能支持其它的配置， 比如在一端通过蓝牙无线技术通讯而在另一端使用有线接口。</p>
</div>
<div class="paragraph">
<p>在FreeBSD，RFCOMM 协议在蓝牙套接字层 (Bluetooth sockets layer) 实现。</p>
</div>
</div>
<div class="sect2">
<h3 id="_设备的结对pairing_of_devices">4.6. 设备的结对(Pairing of Devices)<a class="anchor" href="#_设备的结对pairing_of_devices"></a></h3>
<div class="paragraph">
<p>默认情况下，蓝牙通信是不需要验证的， 任何设备可与其它任何设备对话。一个蓝牙设备 (比如手机) 可以选择通过验证以提供某种特殊服务 (比如拨号服务)。 蓝牙验证一般使用 <em>PIN码(PIN codes)</em>。 一个 PIN 码是最长为 16 个字符的 ASCII 字符串。 用户需要在两个设备中输入相同的PIN码。用户输入了 PIN 码后， 两个设备会生成一个 <em>连接密匙(link key)</em>。 接着连接密钥可以存储在设备或存储器中。 连接时两个设备会使用先前生成的连接密钥。 以上介绍的过程被称为 <em>结对(pairing)</em>。 注意如果任何一方丢失了连接密钥，必须重新进行结对。</p>
</div>
<div class="paragraph">
<p>守护进程 man:hcsecd[8] 负责处理所有蓝牙验证请求。 默认的配置文件是 <span class="filename">/etc/bluetooth/hcsecd.conf</span>。 下面的例子显示一个手机的 PIN 码被预设为&#34;1234&#34;：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre>
</div>
</div>
<div class="paragraph">
<p>PIN 码没有限制(除了长度)。有些设备 (例如蓝牙耳机) 会有一个预置的 PIN 码。<code>-d</code> 开关强制 man:hcsecd[8] 守护进程处于前台，因此很容易看清发生了什么。 设置远端设备准备接收结对 (pairing)，然后启动蓝牙连接到远端设备。 远端设备应该回应接收了结对并请求PIN码。输入与 <span class="filename">hcsecd.conf</span> 中一样的 PIN 码。 现在您的个人计算机已经与远程设备结对了。 另外您也可以在远程设备上初始结点。</p>
</div>
<div class="paragraph">
<p>可以通过在 <span class="filename">/etc/rc.conf</span> 文件中增加下面的行， 以便让 hcsecd 在系统启动时自动运行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hcsecd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>以下是简单的 hcsecd 服务输出样本：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_服务发现协议_sdp">4.7. 服务发现协议 (SDP)<a class="anchor" href="#_服务发现协议_sdp"></a></h3>
<div class="paragraph">
<p>服务发现协议 (SDP) 提供给客户端软件一种方法， 它能发现由服务器软件提供的服务及属性。 服务的属性包括所提供服务的类型或类别， 使用该服务所需要的机制或协议。</p>
</div>
<div class="paragraph">
<p>SDP 包括 SDP 服务器和 SDP 客户端之间的通信。 服务器维护一张服务记录列表，它介绍服务器上服务的特性。 每个服务记录包含关于单个服务的信息。通过发出 SDP 请求， 客户端会得到服务记录列表的信息。如果客户端 (或者客户端上的应用软件) 决定使用一个服务，为了使用这个服务它必须与服务提供都建立一个独立的连接。 SDP 提供了发现服务及其属性的机制，但它并不提供使用这些服务的机制。</p>
</div>
<div class="paragraph">
<p>一般地，SDP客户端按照服务的某种期望特征来搜索服务。 但是，即使没有任何关于由 SDP 服务端提供的服务的预设信息， 有时也能令人满意地发现它的服务记录里所描述的是哪种服务类型。 这种发现所提供服务的过程称为 <em>浏览(browsing)</em>。</p>
</div>
<div class="paragraph">
<p>蓝牙 SDP 服务端 man:sdpd[8] 和命令行客户端 man:sdpcontrol[8] 都包括在了标准的 FreeBSD 安装里。 下面的例子展示如何进行 SDP 浏览查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% sdpcontrol <span class="nt">-a</span> 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class="o">(</span>0x1000<span class="o">)</span>
Protocol Descriptor List:
        L2CAP <span class="o">(</span>0x0100<span class="o">)</span>
                Protocol specific parameter <span class="c">#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class="c">#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class="o">(</span>0x1001<span class="o">)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class="o">(</span>0x1102<span class="o">)</span>
Protocol Descriptor List:
        L2CAP <span class="o">(</span>0x0100<span class="o">)</span>
        RFCOMM <span class="o">(</span>0x0003<span class="o">)</span>
                Protocol specific parameter <span class="c">#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class="o">(</span>0x1102<span class="o">)</span> ver. 1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>等等。注意每个服务有一个属性 (比如 RFCOMM 通道)列表。 根据服务您可能需要为一些属性做个注释。 有些&#34;蓝牙实现 (Bluetooth implementation)&#34;不支持服务浏览， 可能会返回一个空列表。这种情况，可以搜索指定的服务。 下面的例子展示如何搜索 OBEX Object Push (OPUSH) 服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% sdpcontrol <span class="nt">-a</span> 00:01:03:fc:6e:ec search OPUSH</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在 FreeBSD 里为蓝牙客户端提供服务，可以使用 man:sdpd[8] 服务。 您可以通过在 <span class="filename">/etc/rc.conf</span> 中加入下面的行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>sdpd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后用下面的命令来启动 sdpd 服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/sdpd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>需要为远端提供蓝牙服务的本地的服务程序会使用本地 SDP 进程注册服务。像这样的程序就有 man:rfcomm_pppd[8]。 一旦启动它，就会使用本地 SDP 进程注册蓝牙 LAN 服务。</p>
</div>
<div class="paragraph">
<p>使用本地 SDP 进程注册的服务列表，可以通过本地控制通道发出 SDP 浏览查询获得：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sdpcontrol -l browse</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_拨号网络_dun_和使用_ppplan_层面的网络接入">4.8. 拨号网络 (DUN) 和使用 PPP(LAN) 层面的网络接入<a class="anchor" href="#_拨号网络_dun_和使用_ppplan_层面的网络接入"></a></h3>
<div class="paragraph">
<p>拨号网络 (DUN) 配置通常与 modem 和手机一起使用。 如下是这一配置所涉及的内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计算机使用手机或 modem 作为无线 modem 来连接拨号因特网连入服务器， 或者使用其它的拨号服务；</p>
</li>
<li>
<p>计算机使用手机或 modem 接收数据请求。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用 PPP(LAN) 层面的网络接入常使用在如下情形：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>单个蓝牙设备的局域网连入；</p>
</li>
<li>
<p>多个蓝牙设备的局域网接入；</p>
</li>
<li>
<p>PC 到 PC (使用基于串行线模拟的 PPP 网络)。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，两个层面使用 man:ppp[8] 和 man:rfcomm_pppd[8] (一种封装器，可以将 RFCOMM 蓝牙连接转换为 PPP 可操作的东西) 来实现。 在使用任何层面之前，一个新的 PPP 标识必须在 <span class="filename">/etc/ppp/ppp.conf</span> 中建立。 想要实例请参考 man:rfcomm_pppd[8]。</p>
</div>
<div class="paragraph">
<p>在下面的例子中，man:rfcomm_pppd[8] 用来在 NUN RFCOMM 通道上打开一个到 BD_ADDR 为 00:80:37:29:19:a4 的设备的 RFCOMM 连接。具体的 RFCOMM 通道号要通过 SDP 从远端设备获得。也可以手动指定通 RFCOMM，这种情况下 man:rfcomm_pppd[8] 将不能执行 SDP 查询。使用 man:sdpcontrol[8] 来查找远端设备上的 RFCOMM 通道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了提供 PPP(LAN) 网络接入服务，必须运行 man:sdpd[8] 服务。一个新的 LAN 客户端条目必须在 <span class="filename">/etc/ppp/ppp.conf</span> 文件中建立。 想要实例请参考 man:rfcomm_pppd[8]。 最后，在有效地通道号上开始 RFCOMM PPP 服务。 RFCOMM PPP 服务会使用本地 SDP 进程自动注册蓝牙 LAN 服务。下面的例子展示如何启动 RFCOMM PPP 服务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_obex_对象推送_obex_object_push_opush_层面">4.9. OBEX 对象推送 (OBEX Object Push - OPUSH) 层面<a class="anchor" href="#_obex_对象推送_obex_object_push_opush_层面"></a></h3>
<div class="paragraph">
<p>OBEX协议被广泛地用于移动设备之间简单的文件传输。 它的主要用处是在红外线通信领域， 被用于笔记本或手持设备之间的一般文件传输。</p>
</div>
<div class="paragraph">
<p>OBEX 服务器和客户端由第三方软件包 obexapp实现，它可以从 package:comms/obexapp[] port 安装。</p>
</div>
<div class="paragraph">
<p>OBEX 客户端用于向 OBEX 服务器推入或接出对象。 一个对像可以是(举个例子)商业卡片或约会。 OBEX 客户能通过 SDP 从远程设备取得 RFCOMM 通道号。这可以通过指定服务名代替 RFCOMM 通道号来完成。支持的服务名是有：IrMC、FTRN 和 OPUSH。 也可以用数字来指定 RFCOMM 通道号。下面是一个 OBEX 会话的例子，一个设备信息对像从手机中被拉出， 一个新的对像被推入手机的目录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% obexapp <span class="nt">-a</span> 00:80:37:29:19:a4 <span class="nt">-C</span> IrMC
obex&gt; get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class="o">(</span>0x20<span class="o">)</span>
obex&gt; put new.vcf
Success, response: OK, Success <span class="o">(</span>0x20<span class="o">)</span>
obex&gt; di
Success, response: OK, Success <span class="o">(</span>0x20<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了提供 OBEX 推入服务，man:sdpd[8] 必须处于运行状态。必须创建一个根目录用于存放所有进入的对象。 根文件夹的默认路径是 <span class="filename">/var/spool/obex</span>。 最后，在有效的 RFCOMM 通道号上开始 OBEX 服务。OBEX 服务会使用 SDP 进程自动注册 OBEX 对象推送 (OBEX Object Push) 服务。 下面的例子展示如何启动 OBEX 服务。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># obexapp -s -C 10</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_串口sp层面">4.10. 串口(SP)层面<a class="anchor" href="#_串口sp层面"></a></h3>
<div class="paragraph">
<p>串口(SP)层面允许蓝牙设备完成 RS232 (或类似) 串口线的仿真。 这个层面所涉及到情形是， 通过虚拟串口使用蓝牙代替线缆来处理以前的程序。</p>
</div>
<div class="paragraph">
<p>工具 man:rfcomm_sppd[1] 来实现串口层。 &#34;Pseudo tty&#34; 用来作为虚拟的串口。 下面的例子展示如何连接远程设备的串口服务。 注意您不必指定 RFCOMM 通道――man:rfcomm_sppd[1] 能够通过 SDP 从远端设备那里获得。 如果您想代替它的话，可以在命令行里指定 RFCOMM 通道来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rfcomm_sppd -a 00:07:E0:00:0B:CA -t /dev/ttyp6</span>
rfcomm_sppd[94692]: Starting on /dev/ttyp6...</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦连接上，&#34;pseudo tty&#34;就可以充当串口了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cu -l ttyp6</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_问题解答">4.11. 问题解答<a class="anchor" href="#_问题解答"></a></h3>
<div class="sect3">
<h4 id="_不能连接远端设备">4.11.1. 不能连接远端设备<a class="anchor" href="#_不能连接远端设备"></a></h4>
<div class="paragraph">
<p>一些较老的蓝牙设备并不支持角色转换 (role switching)。默认情况下，FreeBSD 接受一个新的连接时， 它会尝试进行角色转换并成为主控端 (master)。 不支持角色转换的设备将无法连接。 注意角色转换是在新连接建立时运行的， 因此如果远程设备不支持角色转换，就不可能向它发出请求。 一个 HCI 选项用来在本地端禁用角色转换。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_如果有错_能否知道到底正在发生什么">4.11.2. 如果有错， 能否知道到底正在发生什么？<a class="anchor" href="#_如果有错_能否知道到底正在发生什么"></a></h4>
<div class="paragraph">
<p>可以。 需要借助第三方软件包 hcidump， 它可以通过 package:comms/hcidump[] port 来安装。 hcidump 工具和 man:tcpdump[1] 非常相像。 它可以用来显示蓝牙数据包的内容， 并将其记录到文件中。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-bridging">5. 桥接<a class="anchor" href="#network-bridging"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_简介_2">5.1. 简介<a class="anchor" href="#_简介_2"></a></h3>
<div class="paragraph">
<p>有时， 会有需要将一个物理网络分成两个独立的网段， 而不是创建新的 IP 子网， 并将其通过路由器相连。 以这种方式连接两个网络的设备称为 &#34;网桥 (bridge)&#34;。 有两个网络接口的 FreeBSD 系统可以作为网桥来使用。</p>
</div>
<div class="paragraph">
<p>网桥通过学习每个网络接口上的 MAC 层地址 (以太网地址) 工作。 只当数据包的源地址和目标地址处于不同的网络时， 网桥才进行转发。</p>
</div>
<div class="paragraph">
<p>在很多方面，网桥就像一个带有很少端口的以太网交换机。</p>
</div>
</div>
<div class="sect2">
<h3 id="_适合桥接的情况">5.2. 适合桥接的情况<a class="anchor" href="#_适合桥接的情况"></a></h3>
<div class="paragraph">
<p>适合使用网桥的， 有许多种不同的情况。</p>
</div>
<div class="sect3">
<h4 id="_使多个网络相互联通">5.2.1. 使多个网络相互联通<a class="anchor" href="#_使多个网络相互联通"></a></h4>
<div class="paragraph">
<p>网桥的基本操作是将两个或多个网段连接在一起。 由于各式各样的原因， 人们会希望使用一台真正的计算机， 而不是网络设备来充任网桥的角色， 常见的原因包括线缆的限制、 需要进行防火墙， 或为虚拟机网络接口连接虚拟网络。 网桥也可以将无线网卡以 hostap 模式接入有线网络。</p>
</div>
</div>
<div class="sect3">
<h4 id="_过滤数据整形防火墙">5.2.2. 过滤/数据整形防火墙<a class="anchor" href="#_过滤数据整形防火墙"></a></h4>
<div class="paragraph">
<p>使用防火墙的常见情形是无需进行路由或网络地址转换的情况 (NAT)。</p>
</div>
<div class="paragraph">
<p>举例来说， 一家通过 DSL 或 ISDN 连接到 ISP 的小公司， 拥有 13 个 ISP 分配的全局 IP 地址和 10 台 PC。 在这种情况下， 由于划分子网的问题， 采用路由来实现防火墙会比较困难。</p>
</div>
<div class="paragraph">
<p>基于网桥的防火墙可以串接在 DSL/ISDN 路由器的后面， 而无需考虑 IP 编制的问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_网络监视">5.2.3. 网络监视<a class="anchor" href="#_网络监视"></a></h4>
<div class="paragraph">
<p>网桥可以用于连接两个不同的网段， 并用于监视往返的以太网帧。 这可以通过在网桥接口上使用 man:bpf[4]/man:tcpdump[1]， 或通过将全部以太网帧复制到另一个网络接口 (span 口) 来实现。</p>
</div>
</div>
<div class="sect3">
<h4 id="_2层_vpn">5.2.4. 2层 VPN<a class="anchor" href="#_2层_vpn"></a></h4>
<div class="paragraph">
<p>通过 IP 连接的网桥， 可以利用 EtherIP 隧道或基于 man:tap[4] 的解决方案， 如 OpenVPN 可以将两个以太网连接到一起。</p>
</div>
</div>
<div class="sect3">
<h4 id="_2层_冗余">5.2.5. 2层 冗余<a class="anchor" href="#_2层_冗余"></a></h4>
<div class="paragraph">
<p>网络可以通过多条链路连接在一起， 并使用生成树协议 (Spanning Tree Protocol) 来阻止多余的通路。 为使以太网能够正确工作， 两个设备之间应该只有一条激活通路， 而生成树能够检测环路， 并将多余的链路置为阻断状态。 当激活通路断开时， 协议能够计算另外一棵树， 并重新激活阻断的通路， 以恢复到网络各点的连通性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_内核配置_2">5.3. 内核配置<a class="anchor" href="#_内核配置_2"></a></h3>
<div class="paragraph">
<p>这一节主要介绍 man:if_bridge[4] 网桥实现。 除此之外， 还有一个基于 netgraph 的网桥实现， 如欲了解进一步细节， 请参见联机手册 man:ng_bridge[4]。</p>
</div>
<div class="paragraph">
<p>网桥驱动是一个内核模块， 并会随使用 man:ifconfig[8] 创建网桥接口时自动加载。 您也可以将 <code>device if_bridge</code> 加入到内核配置文件中， 以便将其静态联编进内核。</p>
</div>
<div class="paragraph">
<p>包过滤可以通过使用了 man:pfil[9] 框架的任意一种防火墙软件包来完成。 这些防火墙可以以模块形式加载， 也可以静态联编进内核。</p>
</div>
<div class="paragraph">
<p>通过配合 man:altq[4] 和 man:dummynet[4]， 网桥也可以用于流量控制。</p>
</div>
</div>
<div class="sect2">
<h3 id="_启用网桥">5.4. 启用网桥<a class="anchor" href="#_启用网桥"></a></h3>
<div class="paragraph">
<p>网桥是通过接口复制来创建的。 您可以使用 man:ifconfig[8] 来创建网桥接口， 如果内核不包括网桥驱动， 则它会自动将其载入。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge create</span>
bridge0
<span class="c"># ifconfig bridge0</span>
bridge0: <span class="nv">flags</span><span class="o">=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class="nb">id </span>00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class="nb">timeout </span>1200
        root <span class="nb">id </span>00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>如此就建立了一个网桥接口， 并为其随机分配了以太网地址。 <code>maxaddr</code> 和 <code>timeout</code> 参数能够控制网桥在转发表中保存多少个 MAC 地址， 以及表项中主机的过期时间。 其他参数控制生成树的运转方式。</p>
</div>
<div class="paragraph">
<p>将成员网络接口加入网桥。 为了让网桥能够为所有网桥成员接口转发包， 网桥接口和所有成员接口都需要处于启用状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class="c"># ifconfig fxp0 up</span>
<span class="c"># ifconfig fxp1 up</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>网桥现在会在 <span class="filename">fxp0</span> 和 <span class="filename">fxp1</span> 之间转发以太网帧。 等效的 <span class="filename">/etc/rc.conf</span> 配置如下， 如此配置将在系统启动时创建同样的网桥。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果网桥主机需要 IP 地址， 则应将其绑在网桥设备本身， 而不是某个成员设备上。 这可以通过静态设置或 DHCP 来完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除此之外， 也可以为网桥接口指定 IPv6 地址。</p>
</div>
</div>
<div class="sect2">
<h3 id="_防火墙">5.5. 防火墙<a class="anchor" href="#_防火墙"></a></h3>
<div class="paragraph">
<p>当启用包过滤时， 通过网桥的包可以分别在进入的网络接口、 网桥接口和发出的网络接口上进行过滤。 这些阶段均可禁用。 当包的流向很重要时， 最好在成员接口而非网桥接口上配置防火墙。</p>
</div>
<div class="paragraph">
<p>网桥上可以进行许多配置以决定非 IP 及 ARP 包能否通过， 以及通过 IPFW 实现二层防火墙。 请参见 man:if_bridge[4] 联机手册以了解进一步的细节。</p>
</div>
</div>
<div class="sect2">
<h3 id="_生成树">5.6. 生成树<a class="anchor" href="#_生成树"></a></h3>
<div class="paragraph">
<p>网桥驱动实现了快速生成树协议 (RSTP 或 802.1w)， 并与较早的生成树协议 (STP) 兼容。 生成树可以用来在网络拓扑中检测并消除环路。 RSTP 提供了比传统 STP 更快的生成树覆盖速度， 这种协议会在相邻的交换机之间交换信息， 以迅速进入转发状态， 并避免产生环路。 FreeBSD 支持以 RSTP 和 STP 模式运行， 而 RSTP 是默认模式。</p>
</div>
<div class="paragraph">
<p>使用 <code>stp</code> 命令可以在成员接口上启用生成树。 对包含 <span class="filename">fxp0</span> 和 <span class="filename">fxp1</span> 的网桥， 可以用下列命令启用 STP：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        <span class="nb">id </span>00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class="nb">timeout </span>1200
        root <span class="nb">id </span>00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre>
</div>
</div>
<div class="paragraph">
<p>网桥的生成树 ID 为 <code>00:01:02:4b:d4:50</code> 而优先级为 <code>32768</code>。 其中 <code>root id</code> 与生成树相同， 表示这是作为生成树根的网桥。</p>
</div>
<div class="paragraph">
<p>另一个网桥也启用了生成树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">bridge0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        <span class="nb">id </span>00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 <span class="nb">timeout </span>1200
        root <span class="nb">id </span>00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre>
</div>
</div>
<div class="paragraph">
<p>这里的 <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> 表示根网桥是前面的 <code>00:01:02:4b:d4:50</code>， 而从此网桥出发的通路代价为 <code>400000</code>, 此通路到根网桥是通过 <code>port 4</code> 即 <span class="filename">fxp0</span> 连接的。</p>
</div>
</div>
<div class="sect2">
<h3 id="_网桥的高级用法">5.7. 网桥的高级用法<a class="anchor" href="#_网桥的高级用法"></a></h3>
<div class="sect3">
<h4 id="_重建流量流">5.7.1. 重建流量流<a class="anchor" href="#_重建流量流"></a></h4>
<div class="paragraph">
<p>网桥支持监视模式， 在 man:bpf[4] 处理之后会将包丢弃， 而不是继续处理或转发。 这可以用于将两个或多个接口上的输入转化为一个 man:bpf[4] 流。 在将两个独立的接口上的传输的 RX/TX 信号重整为一个时， 这会非常有用。</p>
</div>
<div class="paragraph">
<p>如果希望将四个网络接口上的输入转成一个流：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class="c"># tcpdump -i bridge0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_镜像口_span_port">5.7.2. 镜像口 (Span port)<a class="anchor" href="#_镜像口_span_port"></a></h4>
<div class="paragraph">
<p>网桥收到的每个以太网帧都可以发到镜像口上。 网桥上的镜像口数量没有限制， 如果一个接口已经被配置为镜像口， 则它就不能再作为网桥的成员口来使用。 这种用法主要是为与网桥镜像口相连的监听机配合使用。</p>
</div>
<div class="paragraph">
<p>如果希望将所有帧发到名为 <span class="filename">fxp4</span> 的接口上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 span fxp4</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_专用接口_private_interface">5.7.3. 专用接口 (Private interface)<a class="anchor" href="#_专用接口_private_interface"></a></h4>
<div class="paragraph">
<p>专用接口不会转发流量到除专用接口之外的其他端口。 这些流量会无条件地阻断， 因此包括 ARP 在内的以太网帧均不会被转发。 如果需要选择性地阻断流量， 则应使用防火墙。</p>
</div>
</div>
<div class="sect3">
<h4 id="_自学习接口_sticky_interfaces">5.7.4. 自学习接口 (Sticky Interfaces)<a class="anchor" href="#_自学习接口_sticky_interfaces"></a></h4>
<div class="paragraph">
<p>如果网桥的成员接口标记为自学习， 则动态学习的地址项一旦进入转发快取缓存， 即被认为是静态项。 自学习项不会从快取缓存中过期或替换掉， 即使地址在另一接口上出现也是如此。 这使得不必事先发布转发表， 也能根据学习结果得到静态项的有点， 但在这些网段被网桥看到的客户机， 就不能漫游至另一网段了。</p>
</div>
<div class="paragraph">
<p>另一种用法是将网桥与 VLAN 功能连用， 这样客户网络会被隔离在一边， 而不会浪费 IP 地址空间。 考虑 <code>CustomerA</code> 在 <code>vlan100</code> 上， 而 <code>CustomerB</code> 则在 <code>vlan101</code> 上。 网桥地址为 <code>192.168.0.1</code>， 同时作为 internet 路由器使用。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class="c"># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>两台客户机均将 <code>192.168.0.1</code> 作为默认网关， 由于网桥快取缓存是自学习的， 因而它们无法伪造 MAC 地址来截取其他客户机的网络流量。</p>
</div>
<div class="paragraph">
<p>在 VLAN 之间的通讯可以通过专用接口 (或防火墙) 来阻断：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 private vlan100 private vlan101</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这样这些客户机就完全相互隔离了。 可以使用整个的 <code>/24</code> 地址空间， 而无需划分子网。</p>
</div>
</div>
<div class="sect3">
<h4 id="_地址限制">5.7.5. 地址限制<a class="anchor" href="#_地址限制"></a></h4>
<div class="paragraph">
<p>接口后的源 MAC 地址数量是可以控制的。 一旦到达了限制未知源地址的包将会被丢弃， 直至现有缓存中的一项过期或被移除。</p>
</div>
<div class="paragraph">
<p>下面的例子是设置 <code>CustomerA</code> 在 <code>vlan100</code> 上可连接的以太网设备最大值为 10。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_snmp_管理">5.7.6. SNMP 管理<a class="anchor" href="#_snmp_管理"></a></h4>
<div class="paragraph">
<p>网桥接口和 STP 参数能够由 FreeBSD 基本系统的 SNMP 守护进程进行管理。导出的网桥 MIB 符和 IETF 标准， 所以任何 SNMP 客户端或管理包都可以被用来接收数据。</p>
</div>
<div class="paragraph">
<p>在网桥机器上从<span class="filename">/etc/snmp.config</span> 文件中去掉以下这行的注释 <code>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</code> 并启动 bsnmpd 守护进程。 其他的配置选项诸如 community names 和 access lists 可能也许也需要修改。 参阅 man:bsnmpd[1] 和 man:snmp_bridge[3] 获取更多信息。</p>
</div>
<div class="paragraph">
<p>以下的例子中使用了 Net-SNMP 软件 (package:net-mgmt/net-snmp[]) 来查询一个网桥，当然同样也能够使用port package:net-mgmt/bsnmptools[]。 在 SNMP 客户端 Net-SNMP 的配置文件 <span class="filename">$HOME/.snmp/snmp.conf</span> 中 加入以下几行来导入网桥的 MIB 定义：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>mibdirs +/usr/shared/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre>
</div>
</div>
<div class="paragraph">
<p>通过 IETF BRIDGE-MIB(RFC4188) 监测一个单独的网桥</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% snmpwalk <span class="nt">-v</span> 2c <span class="nt">-c</span> public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class="o">=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class="o">=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class="o">=</span> Timeticks: <span class="o">(</span>189959<span class="o">)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class="o">=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class="o">=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class="o">=</span> INTEGER: forwarding<span class="o">(</span>5<span class="o">)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class="o">=</span> INTEGER: enabled<span class="o">(</span>1<span class="o">)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class="o">=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class="o">=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class="o">=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class="o">=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class="o">=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class="o">=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class="o">=</span> INTEGER: rstp<span class="o">(</span>2<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>dot1dStpTopChanges.0</code>的值为2 意味着 STP 网桥拓扑改变了2次，拓扑的改变表示1个或多个 网络中的连接改变或失效并且有一个新树生成。 <code>dot1dStpTimeSinceTopologyChange.0</code> 的值则能够显示这是何时改变的。</p>
</div>
<div class="paragraph">
<p>监测多个网桥接口可以使用 private BEGEMOT-BRIDGE-MIB：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% snmpwalk <span class="nt">-v</span> 2c <span class="nt">-c</span> public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> Timeticks: <span class="o">(</span>116927<span class="o">)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> Timeticks: <span class="o">(</span>82773<span class="o">)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过 <code>mib-2.dot1dBridge</code> 子树改变正在被监测的网桥接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">% snmpset <span class="nt">-v</span> 2c <span class="nt">-c</span> private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-aggregation">6. 链路聚合与故障转移<a class="anchor" href="#network-aggregation"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_介绍">6.1. 介绍<a class="anchor" href="#_介绍"></a></h3>
<div class="paragraph">
<p>使用 man:lagg[4] 接口， 能够将多个网络接口聚合为一个虚拟接口， 以提供容灾和高速连接的能力。</p>
</div>
</div>
<div class="sect2">
<h3 id="_运行模式">6.2. 运行模式<a class="anchor" href="#_运行模式"></a></h3>
<div class="dlist">
<dl>
<dt class="hdlist1">Failover (故障转移)</dt>
<dd>
<p>只通过主网口收发数据。 如果主网口不可用， 则使用下一个激活的网口。 您在这里加入的第一个网口便会被视为主网口； 此后加入的其他网口， 则会被视为故障转移的备用网口。 如果发生故障转移之后， 原先的网口又恢复了可用状态， 则它仍会作为主网口使用。</p>
</dd>
<dt class="hdlist1">Cisco® Fast EtherChannel®</dt>
<dd>
<p>Cisco® Fast EtherChannel® (FEC) 是一种静态配置， 并不进行节点间协商或交换以太网帧来监控链路情况。 如果交换机支持 LACP， 则应使用后者而非这种配置。</p>
<div class="paragraph">
<p>FEC 将输出流量在激活的网口之间以协议头散列信息为依据分拆， 并接收来自任意激活网口的入流量。 散列信息包含以太网源地址、 目的地址， 以及 (如果有的话) VLAN tag 和 IPv4/IPv6 源地址及目的地址信息。</p>
</div>
</dd>
<dt class="hdlist1">LACP</dt>
<dd>
<p>支持 IEEE® 802.3ad 链路聚合控制协议 (LACP) 和标记协议。 LACP 能够在节点与若干链路聚合组之间协商链路。 每一个链路聚合组 (LAG) 由一组相同速度、 以全双工模式运行的网口组成。 流量在 LAG 中的网口之间， 会以总速度最大的原则进行分摊。 当物理链路发生变化时， 链路聚合会迅速适应变动形成新的配置。</p>
<div class="paragraph">
<p>LACP 也是将输出流量在激活的网口之间以协议头散列信息为依据分拆， 并接收来自任意激活网口的入流量。 散列信息包含以太网源地址、 目的地址， 以及 (如果有的话) VLAN tag 和 IPv4/IPv6 源地址及目的地址信息。</p>
</div>
</dd>
<dt class="hdlist1">Loadbalance (负载均衡)</dt>
<dd>
<p>这是 <em>FEC</em> 模式的别名。</p>
</dd>
<dt class="hdlist1">Round-robin (轮转)</dt>
<dd>
<p>将输出流量以轮转方式在所有激活端口之间调度， 并从任意激活端口接收进入流量。 这种模式违反了以太网帧排序规则， 因此应小心使用。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="_例子">6.3. 例子<a class="anchor" href="#_例子"></a></h3>
<div id="networking-lacp-aggregation-cisco" class="exampleblock">
<div class="title">例 1. 与 Cisco® 交换机配合完成 LACP 链路聚合</div>
<div class="content">
<div class="paragraph">
<p>在这个例子中， 我们将 FreeBSD 的两个网口作为一个负载均衡和故障转移链路聚合组接到交换机上。 在此基础上， 还可以增加更多的网口， 以提高吞吐量和故障容灾能力。 由于以太网链路上两节点间的帧序是强制性的， 因此两个节点之间的连接速度， 会取决于一块网卡的最大速度。 传输算法会尽量采用更多的信息， 以便将不同的网络流量分摊到不同的网络接口上， 并平衡不同网口的负载。</p>
</div>
<div class="paragraph">
<p>在 Cisco® 交换机上将 <em>FastEthernet0/1</em> 和 <em>FastEthernet0/2</em> 这两个网口添加到 channel-group <em>1</em>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
<span class="o">!</span>
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <em>fxp0</em> 和 <em>fxp1</em> 创建 man:lagg[4] 接口， 启用这个接口并配置 IP 地址 <em>10.0.0.3/24</em>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig fxp0 up</span>
<span class="c"># ifconfig fxp1 up</span>
<span class="c"># ifconfig lagg0 create</span>
<span class="c"># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>用下面的命令查看接口状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig lagg0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>标记为 <em>ACTIVE</em> 的接口是激活据合组的部分， 这表示它们已经完成了与远程交换机的协商， 同时， 流量将通过这些接口来收发。 在 man:ifconfig[8] 的详细输出中会给出 LAG 的标识。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">lagg0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class="nv">options</span><span class="o">=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class="nv">flags</span><span class="o">=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class="nv">flags</span><span class="o">=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要查看交换机上的端口状态， 则应使用 <code>show lacp neighbor</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">switch# show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class="k">in </span>Active mode       P - Device is <span class="k">in </span>Passive mode

Channel group 1 neighbors

Partner<span class="s1">&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如欲查看进一步的详情， 则需要使用 <code>show lacp neighbor detail</code> 命令。</p>
</div>
<div class="paragraph">
<p>如果希望在系统重启时保持这些设置， 应在 <span class="filename">/etc/rc.conf</span> 中增加如下配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre>
</div>
</div>
</div>
</div>
<div id="networking-lagg-failover" class="exampleblock">
<div class="title">例 2. 故障转移模式</div>
<div class="content">
<div class="paragraph">
<p>故障转移模式中， 当首选链路发生问题时， 会自动切换到备用端口。 首先启用成员接口， 接着是配置 man:lagg[4] 接口， 其中， 使用 <em>fxp0</em> 作为首选接口， <em>fxp1</em> 作为备用接口， 并在整个接口上配置 IP 地址 <em>10.0.0.15/24</em>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig fxp0 up</span>
<span class="c"># ifconfig fxp1 up</span>
<span class="c"># ifconfig lagg0 create</span>
<span class="c"># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建成功之后， 接口状态会是类似下面这样， 主要的区别是 MAC 地址和设备名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig lagg0</span>
lagg0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class="nv">options</span><span class="o">=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class="nv">flags</span><span class="o">=</span>0&lt;<span class="o">&gt;</span>
        laggport: fxp0 <span class="nv">flags</span><span class="o">=</span>5&lt;MASTER,ACTIVE&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>系统将在 <em>fxp0</em> 上进行流量的收发。 如果 <em>fxp0</em> 的连接中断， 则 <em>fxp1</em> 会自动成为激活连接。 如果主端口的连接恢复， 则它又会成为激活连接。</p>
</div>
<div class="paragraph">
<p>如果希望在系统重启时保持这些设置， 应在 <span class="filename">/etc/rc.conf</span> 中增加如下配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre>
</div>
</div>
</div>
</div>
<div id="networking-lagg-wired-and-wireless" class="exampleblock">
<div class="title">例 3. 有线网络和无线网络接口间的自动切换</div>
<div class="content">
<div class="paragraph">
<p>对于使用笔记本的用户来说， 通常会希望使用无线网络接口作为备用接口， 以便在有线网络不可用时继续保持网络连接。 通过使用 man:lagg[4]， 我们可以只使用一个 IP 地址的情况下， 优先使用性能和安全性都更好的有线网络， 同时保持通过无线网络连接来传输数据的能力。</p>
</div>
<div class="paragraph">
<p>要实现这样的目的， 就需要将用于连接无线网络的物理接口的 MAC 地址修改为与所配置的 man:lagg[4] 一致， 后者是从主网络接口， 也就是有线网络接口， 继承而来。</p>
</div>
<div class="paragraph">
<p>在这个配置中， 我们将优先使用有线网络接口 <em>bge0</em> 作为主网络接口， 而将无线网络接口 <em>wlan0</em> 作为备用网络接口。 这里的 <em>wlan0</em> 使用的物理设备是 <em>iwn0</em>， 我们需要将它的 MAC 地址修改为与有线网络接口一致。 为了达到这个目的首先要得到有线网络接口上的 MAC 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bge0</span>
bge0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	<span class="nv">options</span><span class="o">=</span>19b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,TSO4&gt;
	ether 00:21:70:da:ae:37
	inet6 fe80::221:70ff:feda:ae37%bge0 prefixlen 64 scopeid 0x2
	nd6 <span class="nv">options</span><span class="o">=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;
	media: Ethernet autoselect <span class="o">(</span>1000baseT &lt;full-duplex&gt;<span class="o">)</span>
	status: active</code></pre>
</div>
</div>
<div class="paragraph">
<p>您可能需要将 <em>bge0</em> 改为您系统上实际使用的接口， 并从输出结果中的 <code>ether</code> 这行找出有线网络的 MAC 地址。 接着是修改物理的无线网络接口， <em>iwn0</em>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig iwn0 ether 00:21:70:da:ae:37</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启用无线网络接口， 但不在其上配置 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev iwn0 ssid my_router up</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启用 <em>bge0</em> 接口。 创建 man:lagg[4] 接口， 其中 <em>bge0</em> 作为主网络接口， 而以 <em>wlan0</em> 作为备选接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bge0 up</span>
<span class="c"># ifconfig lagg0 create</span>
<span class="c"># ifconfig lagg0 up laggproto failover laggport bge0 laggport wlan0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>新创建的接口的状态如下， 您系统上的 MAC 地址和设备名等可能会有所不同：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig lagg0</span>
lagg0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class="nv">options</span><span class="o">=</span>8&lt;VLAN_MTU&gt;
        ether 00:21:70:da:ae:37
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: wlan0 <span class="nv">flags</span><span class="o">=</span>0&lt;<span class="o">&gt;</span>
        laggport: bge0 <span class="nv">flags</span><span class="o">=</span>5&lt;MASTER,ACTIVE&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接着用 DHCP 客户端来获取 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dhclient lagg0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果希望在系统重启时保持这些设置， 应在 <span class="filename">/etc/rc.conf</span> 中增加如下配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_bge0=&#34;up&#34;
ifconfig_iwn0=&#34;ether 00:21:70:da:ae:37&#34;
wlans_iwn0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport bge0 laggport wlan0 DHCP&#34;</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-diskless">7. 无盘操作<a class="anchor" href="#network-diskless"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>FreeBSD 主机可以从网络启动而无需本地磁盘就可操作， 使用的是从 NFS 服务器装载的文件系统。 除了标准的配置文件，无需任何的系统修改。 很容易设置这样的系统因为所有必要的元素都很容易得到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>至少有两种可能的方法从网络加载内核：</p>
<div class="ulist">
<ul>
<li>
<p>PXE：Intel® 的先启动执行环境 (Preboot eXecution Environment) 系统是一种灵活的引导 ROM 模式，这个 ROM 内建在一些网卡或主板的中。查看 man:pxeboot[8] 以获取更多细节。</p>
</li>
<li>
<p>Etherboot port (package:net/etherboot[]) 产生通过网络加载内核的可 ROM 代码。这些代码可以烧入网卡上的 PROM 上，或从本地软盘 (或硬盘) 驱动器加载，或从运行着的 MS-DOS® 系统加载。它支持多种网卡。</p>
</li>
</ul>
</div>
</li>
<li>
<p>一个样板脚本 (<span class="filename">/usr/shared/examples/diskless/clone_root</span>) 简化了对服务器上的工作站根文件系统的创建和维护。 这个脚本需要少量的自定义，但您能很快的熟悉它。</p>
</li>
<li>
<p><span class="filename">/etc</span> 存在标准的系统启动文件用于侦测和支持无盘的系统启动。</p>
</li>
<li>
<p>可以向 NFS 文件或本地磁盘进行交换(如果需要的话)。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>设置无盘工作站有许多方法。 有很多相关的元素大部分可以自定义以适合本地情况。 以下将介绍一个完整系统的安装，强调的是简单性和与标准 FreeBSD 启动脚本的兼容。介绍的系统有以下特性：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>无盘工作站使用一个共享的只读 <span class="filename">/</span> 文件系统和一个共享的只读<span class="filename">/usr</span>。</p>
<div class="paragraph">
<p>root 文件系统是一份标准的 FreeBSD 根文件系统 (一般是服务器的)，只是一些配置文件被特定于无盘操作的配置文件覆盖。</p>
</div>
<div class="paragraph">
<p>root 文件系统必须可写的部分被 man:md[4] 文件系统覆盖。 任何的改写在重启后都会丢失。</p>
</div>
</li>
<li>
<p>内核由 etherboot 或 PXE 传送和加载， 有些情况可能会指定使用其中之一。</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如上所述，这个系统是不安全的。 它应该处于网络的受保护区域并不被其它主机信任。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这部分所有的信息均在 5.2.1-RELEASE 上测试过。</p>
</div>
<div class="sect2">
<h3 id="_背景信息">7.1. 背景信息<a class="anchor" href="#_背景信息"></a></h3>
<div class="paragraph">
<p>设置无盘工作站相对要简单而又易出错。 有时分析一些原因是很难的。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>编译时选项在运行时可能产生不同的行为。</p>
</li>
<li>
<p>出错信息经常是加密了的或根本就没有。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在这里， 涉及到的一些背景知识对于可能出现的问题的解决是很有帮助的。</p>
</div>
<div class="paragraph">
<p>要成功地引导系统还有些操作需要做。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>机子需要获取初始的参数，如它的 IP 地址、执行文件、服务器名、根路径。这个可以使用 或 BOOTP 协议来完成。 DHCP 是 BOOTP 的兼容扩展， 并使用相同的端口和基本包格式。</p>
<div class="paragraph">
<p>只使用 BOOTP 来配置系统也是可行的。 man:bootpd[8] 服务程序被包含在基本的 FreeBSD 系统里。</p>
</div>
<div class="paragraph">
<p>不过，DHCP 相比 BOOTP 有几个好处 (更好的配置文件，使用 PXE 的可能性，以及许多其它并不直接相关的无盘操作)， 接着我们会要描述一个 DHCP 配置， 可能的话会利用与使用 man:bootpd[8] 相同的例子。这个样板配置会使用ISC DHCP 软件包 (3.0.1.r12 发行版安装在测试服务器上)。</p>
</div>
</li>
<li>
<p>机子需要传送一个或多个程序到本地内存。 TFTP 或 NFS 会被使用。选择TFTP 还是 NFS 需要在几个地方的&#34;编译时间&#34;选项里设置。 通常的错误源是为文件名指定了错误的协议：TFTP 通常从服务器里的一个单一目录传送所有文件，并需要相对这个目录的文件名。 NFS 需要的是绝对文件路径。</p>
</li>
<li>
<p>介于启动程序和内核之间的可能的部分需要被初始化并执行。 在这部分有几个重要的变量：</p>
<div class="ulist">
<ul>
<li>
<p>PXE 会装入 man:pxeboot[8]――它是 FreeBSD 第三阶段装载器的修改版。 man:loader[8] 会获得许多参数用于系统启动， 并在传送控制之前把它们留在内核环境里。 在这种情况下，使用 <span class="filename">GENERIC</span> 内核就可能了。</p>
</li>
<li>
<p>Etherboot 会做很少的准备直接装载内核。 您要使用指定的选项建立 (build) 内核。</p>
<div class="paragraph">
<p>PXE 和 Etherboot 工作得一样的好。 不过， 因为一般情况下内核希望 man:loader[8] 做了更多的事情， PXE 是推荐的方法。</p>
</div>
<div class="paragraph">
<p>如果您的 BIOS 和网卡都支持 PXE， 就应该使用它。</p>
</div>
</li>
</ul>
</div>
</li>
<li>
<p>最后，机子需要访问它的文件系统。 NFS 使用在所有的情况下。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>查看 man:diskless[8] 手册页。</p>
</div>
</div>
<div class="sect2">
<h3 id="_安装说明">7.2. 安装说明<a class="anchor" href="#_安装说明"></a></h3>
<div class="sect3">
<h4 id="_配置使用isc_dhcp">7.2.1. 配置使用ISC DHCP<a class="anchor" href="#_配置使用isc_dhcp"></a></h4>
<div class="paragraph">
<p>ISC DHCP 服务器可以回应 BOOTP 和 DHCP 的请求。</p>
</div>
<div class="paragraph">
<p>ISC DHCP 4.2 并不属于基本系统。首先您需要安装 package:net/isc-dhcp42-server[] port 或相应的&#34;包&#34;。</p>
</div>
<div class="paragraph">
<p>一旦安装了 ISC DHCP， 还需要一个配置文件才能运行 (通常名叫 <span class="filename">/usr/local/etc/dhcpd.conf</span>)。 这里有个注释过的例子，里边主机 <code>margaux</code> 使用 Etherboot， 而主机<code>corbieres</code> 使用 PXE：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>default-lease-time 600;
max-lease-time 7200;
authoritative;

option domain-name &#34;example.com&#34;;
option domain-name-servers 192.168.4.1;
option routers 192.168.4.1;

subnet 192.168.4.0 netmask 255.255.255.0 {
  use-host-decl-names on; <i class="conum" data-value="1"></i><b>(1)</b>
  option subnet-mask 255.255.255.0;
  option broadcast-address 192.168.4.255;

  host margaux {
    hardware ethernet 01:23:45:67:89:ab;
    fixed-address margaux.example.com;
    next-server 192.168.4.4; <i class="conum" data-value="2"></i><b>(2)</b>
    filename &#34;/data/misc/kernel.diskless&#34;; <i class="conum" data-value="3"></i><b>(3)</b>
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;; <i class="conum" data-value="4"></i><b>(4)</b>
  }
  host corbieres {
    hardware ethernet 00:02:b3:27:62:df;
    fixed-address corbieres.example.com;
    next-server 192.168.4.4;
    filename &#34;pxeboot&#34;;
    option root-path &#34;192.168.4.4:/data/misc/diskless&#34;;
  }
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个选项告诉 dhcpd 发送<code>host</code> 里声明的用于无盘主机的主机名的值。 另外可能会增加一个 <code>option host-name margaux</code> 到 <code>host</code> 声明里。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td><code>next-server</code> 正式指定 TFTP 或 NFS 服务用于载入装载器或内核文件 (默认使用的是相同的主机作为DHCP 服务器)。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td><code>filename</code> 正式定义这样的文件――etherboot 或 PXE 为执行下一步将装载它。 根据使用的传输方式，它必须要指定。 Etherboot 可以被编译来使用 NFS 或 TFTP。 FreeBSD port 默认配置了NFS。 PXE 使用 TFTP， 这就是为什么在这里使用相对文件名 (这可能依赖于 TFTP 服务器配置，不过会相当典型)。 同样，PXE 会装载 <span class="filename">pxeboot</span>， 而不是内核。另外有几个很有意思的可能，如从 FreeBSD CD-ROM 的 <span class="filename">/boot</span> 目录装载 <span class="filename">pxeboot</span> (因为 man:pxeboot[8] 能够装载 <span class="filename">GENERIC</span> 内核，这就使得可以使用 PXE 从远程的 CD-ROM 里启动)。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td><code>root-path</code> 选项定义到根 (root) 文件系统的路径，通常是 NFS 符号。当使用 PXE 时，只要您不启用内核里的 BOOTP 选项，可以不管主机的IP。NFS 服务器然后就如同 TFTP 一样。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_配置使用bootp">7.2.2. 配置使用BOOTP<a class="anchor" href="#_配置使用bootp"></a></h4>
<div class="paragraph">
<p>这里紧跟的是一个等效的 bootpd 配置 (减少到一个客户端)。这个可以在 <span class="filename">/etc/bootptab</span> 里找到。</p>
</div>
<div class="paragraph">
<p>请注意：为了使用BOOTP，etherboot 必须使用非默认选项 <code>NO_DHCP_SUPPORT</code> 来进行编译，而且 PXE <em>需要</em> DHCP。bootpd 的唯一可见的好处是它存在于基本系统中。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>.def100:\
  :hn:ht=1:sa=192.168.4.4:vm=rfc1048:\
  :sm=255.255.255.0:\
  :ds=192.168.4.1:\
  :gw=192.168.4.1:\
  :hd=&#34;/tftpboot&#34;:\
  :bf=&#34;/kernel.diskless&#34;:\
  :rp=&#34;192.168.4.4:/data/misc/diskless&#34;:

margaux:ha=0123456789ab:tc=.def100</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用etherboot准备启动程序">7.2.3. 使用Etherboot准备启动程序<a class="anchor" href="#_使用etherboot准备启动程序"></a></h4>
<div class="paragraph">
<p><a href="http://etherboot.sourceforge.net">Etherboot 的网站</a> 包含有<a href="http://etherboot.sourceforge.net/doc/html/userman/t1.html">更多的文档 </a>――主要瞄准的是 Linux 系统，但无疑包含有有用的信息。 如下列出的是关于在 FreeBSD 系统里使用 Etherboot。</p>
</div>
<div class="paragraph">
<p>首先您必须安装package:net/etherboot[] 包或 port。</p>
</div>
<div class="paragraph">
<p>您可以改变 Etherboot 的配置 (如使用 TFTP 来代替 NFS)， 方法是修改 <span class="filename">Config</span> 文件――在 Etherboot 源目录里。</p>
</div>
<div class="paragraph">
<p>对于我们的设置，我们要使用一张启动软盘。 对于其它的方法(PROM，或 MS-DOS®程序)， 请参考 Etherboot 文档。</p>
</div>
<div class="paragraph">
<p>想要使用启动软盘，先插入一张软盘到安装有 Etherboot 的机器的驱动器里， 然后把当前路径改到 <span class="filename">src</span> 目录――在 Etherboot 树下， 接着输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmake bin32/devicetype.fd0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>devicetype</em> 依赖于无盘工作站上的以太网卡的类型。 参考在同一个目录下的 <span class="filename">NIC</span> 文件确认正确的 <em>devicetype</em>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用pxe启动">7.2.4. 使用PXE启动<a class="anchor" href="#_使用pxe启动"></a></h4>
<div class="paragraph">
<p>默认地，man:pxeboot[8] 装载器通过 NFS 装载内核。它可以编译来使用 TFTP――通过在文件 <span class="filename">/etc/make.conf</span> 里指定 <code>LOADER_TFTP_SUPPORT</code> 选项来代替。 请参见 <span class="filename">/usr/shared/examples/etc/make.conf</span> 里的注释 了解如何配置。</p>
</div>
<div class="paragraph">
<p>除此之外还有两个未说明的 <span class="filename">make.conf</span> 选项――它可能对于设置一系列控制台无盘机器会有用： <code>BOOT_PXELDR_PROBE_KEYBOARD</code>和 <code>BOOT_PXELDR_ALWAYS_SERIAL</code>。</p>
</div>
<div class="paragraph">
<p>当机器启动里，要使用 PXE， 通常需要选择 <code>Boot from network</code> 选项――在 BIOS 设置里， 或者在 PC 初始化的时候输入一个功能键 (function key)。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置_tftp_和_nfs_服务器">7.2.5. 配置 TFTP 和 NFS 服务器<a class="anchor" href="#_配置_tftp_和_nfs_服务器"></a></h4>
<div class="paragraph">
<p>如果您正在使用 PXE 或 Etherboot――配置使用了 TFTP，那么您需要在文件服务器上启用 tftpd：</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>建立一个目录――从那里 tftpd 可以提供文件服务，如 <span class="filename">/tftpboot</span>。</p>
</li>
<li>
<p>把这一行加入到 <span class="filename">/etc/inetd.conf</span>里：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>tftp	dgram	udp	wait	root	/usr/libexec/tftpd	tftpd -l -s /tftpboot</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>好像有一些版本的 PXE 需要 TCP 版本的 TFTP。 在这种情况下，加入第二行，使用 <code>stream tcp</code> 来代替 <code>dgram udp</code>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>让 inetd 重读其配置文件。 要正确执行这个命令， 在 <span class="filename">/etc/rc.conf</span> 文件中必须加入 <code>inetd_enable=&#34;YES&#34;</code>：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/inetd restart</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>您可把 <span class="filename">tftpboot</span> 目录放到服务器上的什何地方。 确定这个位置设置在 <span class="filename">inetd.conf</span> 和 <span class="filename">dhcpd.conf</span> 里。</p>
</div>
<div class="paragraph">
<p>在所有的情况下，您都需要启用 NFS， 并且 NFS 服务器上导出相应的文件系统。</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>把这一行加入到<span class="filename">/etc/rc.conf</span>里：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>nfs_server_enable=&#34;YES&#34;</pre>
</div>
</div>
</li>
<li>
<p>通过往 <span class="filename">/etc/exports</span> 里加入下面几行(调整&#34;载入点&#34;列， 并且使用无盘工作站的名字替换 <em>margaux corbieres</em>)， 导出文件系统――无盘根目录存在于此：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>/data/misc -alldirs -ro margaux corbieres</pre>
</div>
</div>
</li>
<li>
<p>让 mountd 重读它的配置文件。如果您真的需要启用第一步的 <span class="filename">/etc/rc.conf</span> 里 NFS， 您可能就要重启系统了。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/mountd restart</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_建立无盘内核">7.2.6. 建立无盘内核<a class="anchor" href="#_建立无盘内核"></a></h4>
<div class="paragraph">
<p>如果您在使用 Etherboot， 您需要为无盘客户端建立内核配置文件， 使用如下选项(除了常使用的外)：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options     BOOTP          # Use BOOTP to obtain IP address/hostname
options     BOOTP_NFSROOT  # NFS mount root filesystem using BOOTP info</pre>
</div>
</div>
<div class="paragraph">
<p>您可能也想使用 <code>BOOTP_NFSV3</code>， <code>BOOT_COMPAT</code> 和 <code>BOOTP_WIRED_TO</code> (参考 <span class="filename">NOTES</span> 文件)。</p>
</div>
<div class="paragraph">
<p>这些名字具有历史性，并且有些有些误导， 因为它们实际上启用了内核里 (它可能强制限制 BOOTP 或 DHCP 的使用)，与 DHCP 和 BOOTP 的无关的应用。</p>
</div>
<div class="paragraph">
<p>编译内核(参考crossref:kernelconfig[kernelconfig,配置FreeBSD的内核])， 然后将它复制到 <span class="filename">dhcpd.conf</span> 里指定的地方。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当使用 PXE 里， 使用以上选项建立内核并不做严格要求(尽管建议这样做)。 启用它们会在内核启动时引起更多的 DHCP 提及过的请求，带来的小小的风险是在有些特殊情况下新值和由 man:pxeboot[8] 取回的值之间的不一致性。 使用它们的好处是主机名会被附带设置。否则， 您就需要使用其它的方法来设置主机名，如在客户端指定的 <span class="filename">rc.conf</span> 文件里。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了使带有 Etherboot 的内核可引导，就需要把设备提示 (device hint) 编译进去。通常要在配置文件(查看 <span class="filename">NOTES</span> 配置注释文件) 里设置下列选项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hints		&#34;GENERIC.hints&#34;</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_准备根root文件系统">7.2.7. 准备根(root)文件系统<a class="anchor" href="#_准备根root文件系统"></a></h4>
<div class="paragraph">
<p>您需要为无盘工作站建立根文件系统， 它就是 <span class="filename">dhcpd.conf</span> 里的 <code>root-path</code> 所指定的目录。</p>
</div>
<div class="sect4">
<h5 id="_使用_make_world_来复制根文件系统">7.2.7.1. 使用 <code>make world</code> 来复制根文件系统<a class="anchor" href="#_使用_make_world_来复制根文件系统"></a></h5>
<div class="paragraph">
<p>这种方法可以迅速安装一个彻底干净的系统 (不仅仅是根文件系统) 到 <code>DESTDIR</code>。 您要做的就是简单地执行下面的脚本：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
export DESTDIR=/data/misc/diskless
mkdir -p ${DESTDIR}
cd /usr/src; make buildworld &amp;&amp; make buildkernel
make installworld &amp;&amp; make installkernel
cd /usr/src/etc; make distribution</pre>
</div>
</div>
<div class="paragraph">
<p>一旦完成，您可能需要定制 <span class="filename">/etc/rc.conf</span> 和 <span class="filename">/etc/fstab</span>――根据您的需要放到 <code>DESTDIR</code>里。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置_swap交换">7.2.8. 配置 swap(交换)<a class="anchor" href="#_配置_swap交换"></a></h4>
<div class="paragraph">
<p>如果需要，位于服务器上的交换文件可以通过 NFS 来访问。</p>
</div>
<div class="sect4">
<h5 id="_nfs_交换区">7.2.8.1. NFS 交换区<a class="anchor" href="#_nfs_交换区"></a></h5>
<div class="paragraph">
<p>内核并不支持在引导时启用 NFS 交换区。 交换区必须通过启动脚本启用， 其过程是挂接一个可写的文件系统， 并在其上创建并启用交换文件。 要建立尺寸合适的交换文件， 可以这样做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/zero of=/path/to/swapfile bs=1k count=1 oseek=100000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要启用它，您须要把下面几行加到 <span class="filename">rc.conf</span>里：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>swapfile=/path/to/swapfile</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_杂项问题">7.2.9. 杂项问题<a class="anchor" href="#_杂项问题"></a></h4>
<div class="sect4">
<h5 id="_运行时_usr_是只读在">7.2.9.1. 运行时 <span class="filename">/usr</span> 是只读在<a class="anchor" href="#_运行时_usr_是只读在"></a></h5>
<div class="paragraph">
<p>如果无盘工作站是配置来支持 X， 那么您就必须调整 XDM 配置文件，因为它默认把错误信息写到 <span class="filename">/usr</span>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_使用非_freebsd_服务器">7.2.9.2. 使用非 FreeBSD 服务器<a class="anchor" href="#_使用非_freebsd_服务器"></a></h5>
<div class="paragraph">
<p>当用作根文件系统的服务器运行的是不 FreeBSD，您须要在 FreeBSD 机器上建立根文件系统， 然后把它复制到它的目的地，使用的命令可以是 <code>tar</code> 或 <code>cpio</code>。</p>
</div>
<div class="paragraph">
<p>在这种情况下，有时对于 <span class="filename">/dev</span> 里的一些特殊的文件会有问题，原因就是不同的 &#34;最大/最小&#34;整数大小。 一种解决的方法就是从非 FreeBSD 服务里导出一个目录， 并把它载入 FreeBSD 到机子上， 并使用 man:devfs[5] 来为用户透明地分派设备节点。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-pxe-nfs">8. 从 PXE 启动一个 NFS 根文件系统<a class="anchor" href="#network-pxe-nfs"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Intel® 预启动执行环境 （PXE） 能让操作系统从网络启动。 通常由近代主板的 BIOS 提供 PXE 支持，它可以通过在 BIOS 设置里选择从网络启动开启。 一个功能完整的 PXE 配置还需要正确地设置 DHCP 和 TFTP 服务。</p>
</div>
<div class="paragraph">
<p>当计算机启动的时候， 通过 DHCP 获取关于 从 TFTP 得到引导加载器（boot loader）的信息。 在计算机接受此信息以后， 便通过 TFTP 下载并执行引导加载器。 这些记载于 <a href="http://download.intel.com/design/archives/wfm/downloads/pxespec.pdf"> 预启动执行环境 (PXE) 规范</a> 的 2.2.1 章节中。 在 FreeBSD 中， 在 PXE 过程中获取的引导加载器为 <span class="filename">/boot/pxeboot</span>。 在 <span class="filename">/boot/pxeboot</span> 执行之后， FreeBSD 的内核被加载， 接着是其他的 FreeBSD 相关引导部分依次被执行。 更多关于 FreeBSD 启动过程的详细信息请参阅 crossref:boot[boot,FreeBSD 引导过程]。</p>
</div>
<div class="sect2">
<h3 id="_配置用于_nfs_根文件系统的_chroot_环境">8.1. 配置用于 NFS 根文件系统的 <code>chroot</code> 环境<a class="anchor" href="#_配置用于_nfs_根文件系统的_chroot_环境"></a></h3>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Choose a directory which will have a FreeBSD installation which will be NFS mountable. For example, a directory such as <span class="filename">/b/tftpboot/FreeBSD/install</span> can be used.</p>
<div class="paragraph">
<p>选择一个可被用户 NFS 挂载并安装有 FreeBSD 的目录。 比如可以使用像 <span class="filename">/b/tftpboot/FreeBSD/install</span> 这样的一个目录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class="c"># mkdir -p ${NFSROOTDIR}</span></code></pre>
</div>
</div>
</li>
<li>
<p>使用如下的命令开启 NFS 服务 crossref:network-servers[network-configuring-nfs,配置NFS].</p>
</li>
<li>
<p>将下面这行加入 <span class="filename">/etc/exports</span> 用以通过 NFS 导出此目录：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>/b -ro -alldirs</pre>
</div>
</div>
</li>
<li>
<p>重起 NFS 服务：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/nfsd restart</span></code></pre>
</div>
</div>
</li>
<li>
<p>按照 crossref:network-servers[network-inetd-settings,设置] 中标明的步骤启用 man:inetd[8]。</p>
</li>
<li>
<p>将如下这行加入到 <span class="filename">/etc/inetd.conf</span>：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd -l -s /b/tftpboot</pre>
</div>
</div>
</li>
<li>
<p>重启 inetd：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/rc.d/inetd restart</span></code></pre>
</div>
</div>
</li>
<li>
<p>crossref:cutting-edge[makeworld,重新编译 FreeBSD 内核和用户态]：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># make buildworld</span>
<span class="c"># make buildkernel</span></code></pre>
</div>
</div>
</li>
<li>
<p>把 FreeBSD 安装到 NFS 挂载目录：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make installworld DESTDIR=${NFSROOTDIR}</span>
<span class="c"># make installkernel DESTDIR=${NFSROOTDIR}</span>
<span class="c"># make distribution DESTDIR=${NFSROOTDIR}</span></code></pre>
</div>
</div>
</li>
<li>
<p>测试 TFTP 服务是否能下载将从 PXE 获取的引导加载器：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tftp localhost</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class="k">in </span>0.1 seconds</code></pre>
</div>
</div>
</li>
<li>
<p>编辑 <span class="filename">${NFSROOTDIR}/etc/fstab</span> 并加入以下这行挂载 NFS 根文件系统：</p>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre>
</div>
</div>
<div class="paragraph">
<p>用你的 NFS 服务器主机名或者 IP 地址替换 <em>myhost.example.com</em>。 在此例中， 根文件系统是以&#34;<code>只读</code>&#34;的方式挂载用来防止 NFS 客户端可能意外删除根文件系统上的文件。</p>
</div>
</li>
<li>
<p>设置 man:chroot[8] 环境中的 root 密码。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chroot ${NFSROOTDIR}</span>
<span class="c"># passwd</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此为设置从 PXE 启动的客户机的 root 密码。</p>
</div>
</li>
<li>
<p>允许 ssh root 登录从 PXE 启动的客户机， 编辑 <span class="filename">${NFSROOTDIR}/etc/ssh/sshd_config</span> 并开启 <code>PermitRootLogin</code> 选项。 关于此选项的说明请参阅 man:sshd_config[5]。</p>
</li>
<li>
<p>对 ${NFSROOTDIR} 的 man:chroot[8] 环境做些其他的定制。 这可以是像使用 man:pkg_add[1] 安装二进制包， 使用 man:vipw[8] 修改密码， 或者编辑 man:amd.conf[8] 映射自动挂载等。例如：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chroot ${NFSROOTDIR}</span>
<span class="c"># pkg_add -r bash</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_etcrc_initdiskless_中用到的内存文件系统">8.2. 配置 <span class="filename">/etc/rc.initdiskless</span> 中用到的内存文件系统<a class="anchor" href="#_配置_etcrc_initdiskless_中用到的内存文件系统"></a></h3>
<div class="paragraph">
<p>如果你从一个 NFS 根卷启动， <span class="filename">/etc/rc</span> 如果检测到是从 NFS 启动便会运行 <span class="filename">/etc/rc.initdiskless</span> 脚本。 请阅读此脚本中的注释部分以便了解到底发生了什么。 我们需要把 <span class="filename">/etc</span> 和 <span class="filename">/var</span> 做成内存文件系统的原因是这些目录需要能被写入， 但 NFS 根文件系统是只读的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chroot ${NFSROOTDIR}</span>
<span class="c"># mkdir -p conf/base</span>
<span class="c"># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class="c"># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当系统启动的时候， <span class="filename">/etc</span> 和 <span class="filename">/var</span> 内存文件系统就会被创建并挂载， <span class="filename">cpio.gz</span> 就会被复制进去。</p>
</div>
</div>
<div class="sect2">
<h3 id="_配置_dhcp_服务">8.3. 配置 DHCP 服务<a class="anchor" href="#_配置_dhcp_服务"></a></h3>
<div class="paragraph">
<p>PXE 需要配置一个 TFTP 服务器和一个 DHCP 服务器。 DHCP 服务并不要求与 TFTP 服务在同一台机器上， 但是必须能够从你的网络访问到它。</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>按照此文档处 crossref:network-servers[network-dhcp-server,安装和配置 DHCP 服务器] 方法安装 DHCP 服务。 确保 <span class="filename">/etc/rc.conf</span> 和 <span class="filename">/usr/local/etc/dhcpd.conf</span> 都配置正确。</p>
</li>
<li>
<p>在 <span class="filename">/usr/local/etc/dhcpd.conf</span> 中配置 <code>next-server</code>， <code>filename</code>， <code>option root-path</code> 选项指向你的 TFTP 服务器的 IP 地址， 以及 TFTP 上 <span class="filename">/boot/pxeboot</span> 文件的路径， 和 NFS 根文件系统的路径。 这里一份 <span class="filename">dhcpd.conf</span> 实例：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-server 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained
   # via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_配置_pxe_客户端与调试连接问题">8.4. 配置 PXE 客户端与调试连接问题<a class="anchor" href="#_配置_pxe_客户端与调试连接问题"></a></h3>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>当客户端启动的时候， 进入 BIOS 配置菜单。 设置 BIOS 从网络启动。 如果之前你所有的配置步骤都正确的话， 那么所有部分应该能 &#34;正常工作&#34;。</p>
</li>
<li>
<p>使用 package:net/wireshark[] port 查看 DHCP 和 TFTP 的网络流量来调试各种问题。</p>
</li>
<li>
<p>确保 <span class="filename">pxeboot</span> 能从 TFTP 获取。 在你的 TFTP 服务器上检查 <span class="filename">/var/log/xferlog</span> 日志确保 <span class="filename">pxeboot</span> 被从正确的位置获取。 可以这样测试上面例子 <span class="filename">dhcpd.conf</span> 中所设置的：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tftp 192.168.0.1</span>
tftp&gt; get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class="k">in </span>0.1 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>请阅读 man:tftpd[8] 和 man:tftp[1]。 其中的 <code>BUGS</code> 列出了 TFTP 的一些限制。</p>
</div>
</li>
<li>
<p>确保根文件系统能够从 NFS 挂载。 可以这样测试上面例子 <span class="filename">dhcpd.conf</span> 中所设置的：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre>
</div>
</div>
</li>
<li>
<p>阅读 <span class="filename">src/sys/boot/i386/libi386/pxe.c</span> 中的代码以了解 <span class="filename">pxeboot</span> 加载器如何设置诸如 <code>boot.nfsroot.server</code> 和 <code>boot.nfsroot.path</code> 之类的变量。 这些变量被用在了 <span class="filename">src/sys/nfsclient/nfs_diskless.c</span> 的 NFS 无盘根挂载代码中。</p>
</li>
<li>
<p>Read man:pxeboot[8] and man:loader[8].</p>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-isdn">9. ISDN<a class="anchor" href="#network-isdn"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>关于 ISDN 技术和硬件的一个好的资源是<a href="http://www.alumni.caltech.edu/~dank/isdn/">Dan Kegel 的 ISDN 主页</a>。</p>
</div>
<div class="paragraph">
<p>一个快速简单的到 ISDN 的路线图如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果您住在欧洲，您可能要查看一下 ISDN 卡部分。</p>
</li>
<li>
<p>如果您正计划首要地使用 ISDN 基于拨号非专用线路连接到带有提供商的互联网， 您可能要了解一下终端适配器。如果您更改提供商的话， 这会给您带来最大的灵活性、最小的麻烦。</p>
</li>
<li>
<p>如果您连接了两个局域网 (LAN)，或使用了专用的 ISDN 连线连接到互联网，您可能要考虑选择单独的路由器/网桥。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在决定选择哪一种方案的时候，价格是个很关键的因素。 下面列有从不算贵到最贵的选择：</p>
</div>
<div class="sect2">
<h3 id="network-isdn-cards">9.1. ISDN 卡<a class="anchor" href="#network-isdn-cards"></a></h3>
<div class="paragraph">
<p>FreeBSD 的 ISDN 工具通过被动卡 (passive card) 仅支持 DSS1/Q.931(或 Euro-ISDN) 标准。 此外也支持一些 active card， 它们的固件也支持其它信号协议， 这其中包括最先得到支持的 &#34;Primary Rate (PRI) ISDN&#34;卡。</p>
</div>
<div class="paragraph">
<p>isdn4bsd 软件允许连接到其它 ISDN 路由器，使用的是原始的 HDLC 上的 IP 或利用同步 PPP：使用带有 <code>isppp</code> (一个修改过的 man:sppp[4] 驱动程序)的 PPP 内核，或使用用户区 (userland) man:ppp[8]。通过使用 userland man:ppp[8]，两个或更多 ISDN 的 B 通道联结变得可能。 除了许多如 300 波特 (Baud) 的软 modem 一样的工具外， 还可以实现电话应答机应用。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 里，正有更多的 PC ISDN 卡被支持； 报告显示在整个欧洲及世界的其它许多地区可以成功使用。</p>
</div>
<div class="paragraph">
<p>被支持的主动型 ISDN 卡主要是带有 Infineon (以前的 Siemens) ISAC/HSCX/IPAC ISDN 芯片组，另外还有带有 Cologne (只有 ISA 总线) 芯片的 ISDN 卡、带有 Winbond W6692 芯片的 PCI 卡、一部分带有 Tiger300/320/ISAC 芯片组的卡以及带有一些商家专有的芯片组的卡 (如 AVM FritzCard PCI V.1.0 和 the AVM FritzCard PnP)。</p>
</div>
<div class="paragraph">
<p>当前积极的支持的 ISDN 卡有 AVM B1 (ISA 和 PCI) BRI 卡和 AVM T1 PCI PRI 卡。</p>
</div>
<div class="paragraph">
<p>关于 isdn4bsd 的文档，请查看 <a href="http://www.freebsd-support.de/i4b/">isdn4bsd的主页</a>， 那里也有提示、勘误表以及更多的文档 (如 <a href="http://people.FreeBSD.org/~hm/">isdn4bsd手册</a>)。</p>
</div>
<div class="paragraph">
<p>要是您有兴趣增加对不同 ISDN 协议的支持，对当前还不支持的 ISDN PC 卡的支持或想增强 isdn4bsd 的性能，请联系 Hellmuth Michaelis &lt;<a href="mailto:hm@FreeBSD.org">hm@FreeBSD.org</a>&gt;。</p>
</div>
<div class="paragraph">
<p>对于安装、配置以及 isdn4bsd 故障排除的问题，可以利用 <a href="https://lists.FreeBSD.org/subscription/freebsd-isdn">freebsd-isdn</a> 邮件列表。</p>
</div>
</div>
<div class="sect2">
<h3 id="_isdn_终端适配器">9.2. ISDN 终端适配器<a class="anchor" href="#_isdn_终端适配器"></a></h3>
<div class="paragraph">
<p>终端适配器 (TA) 对于 ISDN 就好比 modem 对于常规电话线。</p>
</div>
<div class="paragraph">
<p>许多 TA 使用标准的 Hayes modem AT 命令集，并且可以降级来代替 modem。</p>
</div>
<div class="paragraph">
<p>TA 基本的运作同 modem 一样，不同之处是连接和整个速度更比老 modem 更快。同 modem 的安装一样，您也需要配置 crossref:ppp-and-slip[ppp,PPP]。确认您的串口速度已足够高。</p>
</div>
<div class="paragraph">
<p>使用 TA 连接互联网提供商的主要好处是您可以做动态的 PPP。 由于 IP 地址空间变得越来越紧张，许多提供商都不愿再提供静态 IP。许多的独立的路由器是不支持动态 IP 分配的。</p>
</div>
<div class="paragraph">
<p>TA 完全依赖于您在运行的 PPP 进程， 以完成它们的功能和稳定的连接。这可以让您在 FreeBSD 机子里轻易地从使用 modem 升级到 ISDN，要是您已经安装了 PPP 的话。只是，在您使用 PPP 程序时所体验到任何问题同时也存在。</p>
</div>
<div class="paragraph">
<p>如果您想要最大的稳定性，请使用 crossref:ppp-and-slip[ppp,PPP] 内核选项，而不要使用 crossref:ppp-and-slip[userppp,userland PPP]。</p>
</div>
<div class="paragraph">
<p>下面的 TA 就可以同 FreeBSD 一起工作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Motorola BitSurfer 和 Bitsurfer Pro</p>
</li>
<li>
<p>Adtran</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大部分其它的 TA 也可能工作，TA 提供商试图让他们的产品可以接受大部分的标准 modem AT 命令集。</p>
</div>
<div class="paragraph">
<p>对于外置 TA 的实际问题是：象 modem 要一样，您机子需要有一个好的串行卡。</p>
</div>
<div class="paragraph">
<p>想要更深入地理解串行设备以及异步和同步串口这间的不同点， 您就要读读 extref:https://docs.freebsd.org/en/articles/serial-uart/[FreeBSD 串行硬件]教程了。</p>
</div>
<div class="paragraph">
<p>TA 将标准的 PC 串口 (同步的) 限制到了 115.2 Kbs，即使您有 128 Kbs 的连接。 想要完全利用 ISDN 有能力达到的 128 Kbs，您就需要把 TA 移到同步串行卡上。</p>
</div>
<div class="paragraph">
<p>当心被骗去买一个内置的 TA 以及自认为可以避免同步/异步问题。内置的 TA 只是简单地将一张标准 PC 串口芯片内建在里边。 所做的这些只是让您省去买另一根串行线以及省去寻找另一个空的插孔。</p>
</div>
<div class="paragraph">
<p>带有 TA 的同步卡至少和一个独立的路由器同一样快地， 而且仅使用一个简单的 386 FreeBSD 盒驱动它。</p>
</div>
<div class="paragraph">
<p>选择同步卡/TA 还是独立的路由器，是个要高度谨慎的问题。 在邮件列表里有些相关的讨论。我们建议您去搜索一下关于完整讨论的<a href="https://www.FreeBSD.org/search/">记录</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_单独的_isdn_桥路由器">9.3. 单独的 ISDN 桥/路由器<a class="anchor" href="#_单独的_isdn_桥路由器"></a></h3>
<div class="paragraph">
<p>ISDN 桥或路由器根本就没有指定要 FreeBSD 或其它任何的操作系统。更多完整的关于路由和桥接技术的描述， 请参考网络指南的书籍。</p>
</div>
<div class="paragraph">
<p>这部分的内容里，路由器和桥接这两个词汇将会交替地使用。</p>
</div>
<div class="paragraph">
<p>随着 ISDN 路由器/桥的价格下滑，对它们的选择也会变得越来越流行。 ISDN 路由器是一个小盒子，可以直接地接入您的本地以太网， 并且自我管理到其它桥/路由器的连接。它有个内建的软件用于与通信――通过 PPP 和其它流行的协议。</p>
</div>
<div class="paragraph">
<p>路由器有比标准 TA 更快的吞吐量，因为它会使用完全同步的 ISDN 连接。</p>
</div>
<div class="paragraph">
<p>使用 ISDN 路由器和桥的主要问题是两个生产商之间的协同性仍存在问题。 如果您计划连接到互联网提供商，您应该跟他们进行交涉。</p>
</div>
<div class="paragraph">
<p>如果您计划连接两个局域网网段，如您的家庭网和办公网， 这将是最简单最低维护的解决方案。因为您买的设备是用于连接两边的， 可以保证这种连接一定会成功。</p>
</div>
<div class="paragraph">
<p>例如连接到家里的计算机，或者是办公网里的一个分支连接到办公主网， 那么下面的设置就可能用到：</p>
</div>
<div class="exampleblock">
<div class="title">例 4. 办公室局部或家庭网</div>
<div class="content">
<div class="paragraph">
<p>网络使用基于总线拓扑的 10 base 2 以太网 (&#34;瘦网(thinnet)&#34;)。如果有必要，用网线连接路由器和 AUI/10BT 收发器。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/advanced-networking/isdn-bus.png" alt="10 Base 2 Ethernet"/>
</div>
</div>
<div class="paragraph">
<p>如果您的家里或办公室支部里只有一台计算机， 您可以使用一根交叉的双绞线直接连接那台独立路由器。</p>
</div>
</div>
</div>
<div class="exampleblock">
<div class="title">例 5. 主办公室或其它网络</div>
<div class="content">
<div class="paragraph">
<p>网络使用的是星形拓扑的 10 base T 以太网(&#34;双绞线&#34;)。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/advanced-networking/isdn-twisted-pair.png" alt="ISDN Network Diagram"/>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>大部分路由器/网桥有一大好处就是，它们允许您在 <em>同一</em> 时间，有两个 <em>分开独立的</em> PPP 连接到两个分开的点上。这点在许多的 TA 上是不支持的， 除非带有两个串口的特定模式(通常都很贵)。请不要把它与通道连接、MPP 等相混淆。</p>
</div>
<div class="paragraph">
<p>这是个非常有用的功能，例如，如果在您的办公室里您有个专有的 ISDN 连接，而且您想接入到里边，但休想让另一根 ISDN 线也能工作。 办公室里的路由器能够管理专有的B通道连接到互联网 (64 Kbps) 以及使用另一个通道 B 来完成单独的数据连接。 第二个 B 通道可以用于拨进、拨出或动态与第一个B通道进行连接 (MPP等)，以获取更大宽带。</p>
</div>
<div class="paragraph">
<p>以太网桥也允许您传输的不仅仅是 IP 通信。您也可以发送 IPX/SPX 或其它任何您所使用的协议。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-natd">10. 网络地址转换<a class="anchor" href="#network-natd"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="network-natoverview">10.1. 概要<a class="anchor" href="#network-natoverview"></a></h3>
<div class="paragraph">
<p>FreeBSD 的网络地址转换服务， 通常也被叫做 man:natd[8]， 是一个能够接收连入的未处理 IP 包， 将源地址修改为本级地址然后重新将这些包注入到发出 IP 包流中。 man:natd[8] 同时修改源地址和端口， 当接收到响应数据时，它作逆向转换以便把数据发回原先的请求者。</p>
</div>
<div class="paragraph">
<p>NAT 最常见的用途是为人们所熟知的 Internet 连接共享。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-natsetup">10.2. 安装<a class="anchor" href="#network-natsetup"></a></h3>
<div class="paragraph">
<p>随着 IPv4 的 IP 地址空间的日益枯竭， 以及使用如 DSL 和电缆等高速连接的用户的逐渐增多， 越来越多的人开始需要 Internet 连接共享这样的解决方案。 由于能够将许多计算机通过一个对外的 IP 地址进行接入， man:natd[8] 成为了一个理想的选择。</p>
</div>
<div class="paragraph">
<p>更为常见的情况， 一个用户通过电缆或者 DSL 线路 接入，并拥有一个 IP 地址，同时，希望通过这台接入 Internet 的计算机来为 LAN 上更多的计算机提供接入服务。</p>
</div>
<div class="paragraph">
<p>为了完成这一任务， 接入 Internet 的 FreeBSD 机器必须扮演网关的角色。 这台网关必须有两块网卡 - 一块用于连接 Internet 路由器， 另一块用来连接 LAN。 所有 LAN 上的机器通过 Hub 或交换机进行连接。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有多种方法能够通过 FreeBSD 网关将 LAN 接入 Internet。 这个例子只介绍了有至少两块网卡的网关。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/advanced-networking/natd.png" alt="Network Layout"/>
</div>
</div>
<div class="paragraph">
<p>上述配置被广泛地用于共享 Internet 连接。 LAN 中的一台机器连接到 Internet 中。 其余的计算机则通过那台 &#34;网关&#34; 机来连接 Internet。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-natdloaderconfiguration">10.3. 引导加载器配置<a class="anchor" href="#network-natdloaderconfiguration"></a></h3>
<div class="paragraph">
<p>在默认的 <span class="filename">GENERIC</span> 内核中， 并没有启用通过 man:natd[8] 进行网址翻译的功能， 不过， 这一功能可以通过在 <span class="filename">/boot/loader.conf</span> 中添加两项配置来在引导时自动予以加载：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipfw_load=&#34;YES&#34;
ipdivert_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>此外， 还可以将引导加载器变量 <code>net.inet.ip.fw.default_to_accept</code> 设为 <code>1</code>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在刚开始配置防火墙和 NAT 网关时， 增加这个配置是个好主意。 默认的 man:ipfw[8] 规则将是 <code>allow ip from any to any</code> 而不是默认的 <code>deny ip from any to any</code>， 这样， 在系统重启时， 也就不太容易被反锁在外面。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="network-natdkernconfiguration">10.4. 内核配置<a class="anchor" href="#network-natdkernconfiguration"></a></h3>
<div class="paragraph">
<p>当不能使用内核模块， 或更希望将全部需要的功能联编进内核时， 可以在内核配置中添加下面的设置来实现：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options IPFIREWALL
options IPDIVERT</pre>
</div>
</div>
<div class="paragraph">
<p>此外，下列是一些可选的选项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options IPFIREWALL_DEFAULT_TO_ACCEPT
options IPFIREWALL_VERBOSE</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-natdsystemconfiguration">10.5. 系统引导时的配置<a class="anchor" href="#network-natdsystemconfiguration"></a></h3>
<div class="paragraph">
<p>如果希望在系统引导过程中启用防火墙和 NAT 支持， 应在 <span class="filename">/etc/rc.conf</span>中添加下列配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34; <i class="conum" data-value="1"></i><b>(1)</b>
firewall_enable=&#34;YES&#34; <i class="conum" data-value="2"></i><b>(2)</b>
firewall_type=&#34;OPEN&#34; <i class="conum" data-value="3"></i><b>(3)</b>
natd_enable=&#34;YES&#34;
natd_interface=&#34;fxp0&#34; <i class="conum" data-value="4"></i><b>(4)</b>
natd_flags=&#34;&#34; <i class="conum" data-value="5"></i><b>(5)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将机器配置为网关。 执行 <code>sysctl net.inet.ip.forwarding=1</code> 效果相同。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在启动时启用 <span class="filename">/etc/rc.firewall</span> 中的防火墙规则。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>指定一个预定义的允许所有包进入的防火墙规则集。 参见 <span class="filename">/etc/rc.firewall</span> 以了解其他类型的规则集。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>指定通过哪个网络接口转发包 (接入 Internet 的那一个)。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>其他希望在启动时传递给 man:natd[8] 的参数。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在 <span class="filename">/etc/rc.conf</span> 中加入上述选项将在系统启动时运行 <code>natd -interface fxp0</code>。 这一工作也可以手工完成。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当有太多选项要传递时，也可以使用一个 man:natd[8] 的配置文件来完成。这种情况下，这个配置文件必须通过在 <span class="filename">/etc/rc.conf</span> 里增加下面内容来定义：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">/etc/natd.conf</span> 文件会包含一个配置选项列表， 每行一个。在紧跟部分的例子里将使用下面的文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre>
</div>
</div>
<div class="paragraph">
<p>关于配置文件的更多信息，参考 man:natd[8] 手册页中关于 <code>-f</code> 选项那一部分。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在LAN后面的每一台机子和接口应该被分配私有地址空间(由<a href="ftp://ftp.isi.edu/in-notes/rfc1918.txt">RFC 1918</a>定义) 里的 IP 地址，并且默认网关设成 natd 机子的内连 IP 地址。</p>
</div>
<div class="paragraph">
<p>例如：客户端 <code>A</code> 和 <code>B</code> 在 LAN 后面，IP 地址是 <code>192.168.0.2</code> 和 <code>192.168.0.3</code>，同时 natd 机子的 LAN 接口上的 IP 地址是 <code>192.168.0.1</code>。客户端 <code>A</code> 和 <code>B</code> 的默认网关必须要设成 natd 机子的 IP――<code>192.168.0.1</code>。natd 机子外连，或互联网接口不需要为了 man:natd[8] 而做任何特别的修改就可工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-natdport-redirection">10.6. 端口重定向<a class="anchor" href="#network-natdport-redirection"></a></h3>
<div class="paragraph">
<p>使用 man:natd[8] 的缺点就是 LAN 客户不能从互联网访问。LAN 上的客户可以进行到外面的连接，而不能接收进来的连接。如果想在 LAN 的客户端机子上运行互联网服务，这就会有问题。 对此的一种简单方法是在 natd 机子上重定向选定的互联网端口到 LAN 客户端。</p>
</div>
<div class="paragraph">
<p>例如：在客户端 <code>A</code> 上运行 IRC 服务，而在客户端 <code>B</code> 上运行 web 服务。 想要正确的工作，在端口 6667 (IRC) 和 80 (web) 上接收到的连接就必须重定向到相应的机子上。</p>
</div>
<div class="paragraph">
<p><code>-redirect_port</code> 需要使用适当的选项传送给 man:natd[8]。语法如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>     -redirect_port proto targetIP:targetPORT[-targetPORT]
                 [aliasIP:]aliasPORT[-aliasPORT]
                 [remoteIP[:remotePORT[-remotePORT]]]</pre>
</div>
</div>
<div class="paragraph">
<p>在上面的例子中，参数应该是：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>    -redirect_port tcp 192.168.0.2:6667 6667
    -redirect_port tcp 192.168.0.3:80 80</pre>
</div>
</div>
<div class="paragraph">
<p>这就会重定向适当的 <em>tcp</em> 端口到 LAN 上的客户端机子。</p>
</div>
<div class="paragraph">
<p><code>-redirect_port</code> 参数可以用来指出端口范围来代替单个端口。例如， <em>tcp 192.168.0.2:2000-3000 2000-3000</em> 就会把所有在端口 2000 到 3000 上接收到的连接重定向到主机 <code>A</code> 上的端口 2000 到 3000。</p>
</div>
<div class="paragraph">
<p>当直接运行 man:natd[8] 时，就可以使用这些选项， 把它们放到 <span class="filename">/etc/rc.conf</span> 里的 <code>natd_flags=&#34;&#34;</code> 选项上， 或通过一个配置文件进行传送。</p>
</div>
<div class="paragraph">
<p>想要更多配置选项，请参考 man:natd[8]。</p>
</div>
</div>
<div class="sect2">
<h3 id="network-natdaddress-redirection">10.7. 地址重定向<a class="anchor" href="#network-natdaddress-redirection"></a></h3>
<div class="paragraph">
<p>如果有几个 IP 地址提供，那么地址重定向就会很有用， 然而他们必须在一个机子上。使用它，man:natd[8] 就可以分配给每一个 LAN 客户端它们自己的外部 IP 地址。man:natd[8] 然后会使用适当的处部 IP 地址重写从 LAN 客户端外出的数据包， 以及重定向所有进来的数据包――一定的 IP 地址回到特定的 LAN 客户端。这也叫做静态 NAT。例如，IP 地址 <code>128.1.1.1</code>、 <code>128.1.1.2</code> 和 <code>128.1.1.3</code> 属于 natd 网关机子。 <code>128.1.1.1</code> 可以用来作 natd 网关机子的外连 IP 地址，而 <code>128.1.1.2</code> 和 <code>128.1.1.3</code> 用来转发回 LAN 客户端 <code>A</code> 和 <code>B</code>。</p>
</div>
<div class="paragraph">
<p><code>-redirect_address</code> 语法如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>-redirect_address localIP publicIP</pre>
</div>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">localIP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LAN 客户端的内部 IP 地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">publicIP</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">相应 LAN 客户端的外部 IP 地址。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在这个例子里，参数是：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>-redirect_address 192.168.0.2 128.1.1.2 -redirect_address 192.168.0.3 128.1.1.3</pre>
</div>
</div>
<div class="paragraph">
<p>象 <code>-redirect_port</code> 一样，这些参数也是放在 <span class="filename">/etc/rc.conf</span> 里的 <code>natd_flags=&#34;&#34;</code> 选项上， 或通过一个配置文件传送给它。使用地址重定向， 就没有必要用端口重定向了，因为所有在某个 IP 地址上收到的数据都被重定向了。</p>
</div>
<div class="paragraph">
<p>在 natd 机子上的外部 IP 地址必须激活并且别名到 (aliased) 外连接口。要这做就看看 man:rc.conf[5]。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-plip">11. 并口电缆 IP (PLIP)<a class="anchor" href="#network-plip"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>PLIP 允许我们在两个并口间运行 TCP/IP。 在使用笔记本电脑， 或没有网卡的计算机时， 这会非常有用。 这一节中， 我们将讨论：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>制作用于并口的 (laplink) 线缆。</p>
</li>
<li>
<p>使用 PLIP 连接两台计算机。</p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="network-create-parallel-cable">11.1. 制作并口电缆。<a class="anchor" href="#network-create-parallel-cable"></a></h3>
<div class="paragraph">
<p>您可以在许多计算机供应店里买到并口电缆。 如果买不到， 或者希望自行制作， 则可以参阅下面的表格， 它介绍了如何利用普通的打印机并口电缆来改制：</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 2. 用于网络连接的并口电缆接线方式</caption>
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">A-name</th>
<th class="tableblock halign-left valign-top">A 端</th>
<th class="tableblock halign-left valign-top">B 端</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">Post/Bit</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
DATA0 -ERROR
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
2 15
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
15 2
....</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
0/0x01 1/0x08
....</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
DATA1 +SLCT
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
3 13
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
13 3
....</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
0/0x02 1/0x10
....</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
DATA2 +PE
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
4 12
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
12 4
....</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
0/0x04 1/0x20
....</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
DATA3 -ACK
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
5 10
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
10 5
....</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">脉冲 (Strobe)</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
0/0x08 1/0x40
....</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
DATA4 BUSY
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
6 11
....</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
11 6
....</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>....
0/0x10 1/0x80
....</pre></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>GND</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>18-25</pre></div></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>18-25</pre></div></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GND</p></td>
<td class="tableblock halign-left valign-top"><div class="literal"><pre>-</pre></div></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="network-plip-setup">11.2. 设置 PLIP<a class="anchor" href="#network-plip-setup"></a></h3>
<div class="paragraph">
<p>首先，您需要一根 laplink 线。然后， 确认两台计算机的内核都有对 man:lpt[4] 驱动程序的支持：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># grep lp /var/run/dmesg.boot</span>
lpt0: Printer on ppbus0
lpt0: Interrupt-driven port</code></pre>
</div>
</div>
<div class="paragraph">
<p>并口必须是一个中断驱动的端口， 您应在 <span class="filename">/boot/device.hints</span> 文件中配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hint.ppc.0.at=&#34;isa&#34;
hint.ppc.0.irq=&#34;7&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后检查内核配置文件中是否有一行 <code>device plip</code> 或加载了 <span class="filename">plip.ko</span> 内核模块。 这两种情况下， 在使用 man:ifconfig[8] 命令时都会显示并口对应的网络接口， 类似这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig plip0</span>
plip0: <span class="nv">flags</span><span class="o">=</span>8810&lt;POINTOPOINT,SIMPLEX,MULTICAST&gt; mtu 1500</code></pre>
</div>
</div>
<div class="paragraph">
<p>用 laplink 线接通两台计算机的并口。</p>
</div>
<div class="paragraph">
<p>在两边以 <code>root</code> 身份配置通讯参数。 例如， 如果你希望将 <code>host1</code> 通过另一台机器 <code>host2</code> 连接：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>                 host1 ----- host2
IP Address    10.0.0.1      10.0.0.2</pre>
</div>
</div>
<div class="paragraph">
<p>配置 <code>host1</code> 上的网络接口，照此做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig plip0 10.0.0.1 10.0.0.2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>配置 <code>host2</code> 上的网络接口，照此做：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig plip0 10.0.0.2 10.0.0.1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>您现在应该有个工作的连接了。想要更详细的信息， 请阅读 man:lp[4] 和 man:lpt[4] 手册页。</p>
</div>
<div class="paragraph">
<p>您还应该增加两个主机到 <span class="filename">/etc/hosts</span>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>127.0.0.1               localhost.my.domain localhost
10.0.0.1                host1.my.domain host1
10.0.0.2                host2.my.domain host2</pre>
</div>
</div>
<div class="paragraph">
<p>要确认连接是否工作，可以到每一台机子上，然后 ping 另外一台。例如，在 <code>host1</code> 上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig plip0</span>
plip0: <span class="nv">flags</span><span class="o">=</span>8851&lt;UP,POINTOPOINT,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
        inet 10.0.0.1 <span class="nt">--</span><span class="o">&gt;</span> 10.0.0.2 netmask 0xff000000
<span class="c"># netstat -r</span>
Routing tables

Internet:
Destination        Gateway          Flags     Refs     Use      Netif Expire
host2              host1            UH          0       0       plip0
<span class="c"># ping -c 4 host2</span>
PING host2 <span class="o">(</span>10.0.0.2<span class="o">)</span>: 56 data bytes
64 bytes from 10.0.0.2: <span class="nv">icmp_seq</span><span class="o">=</span>0 <span class="nv">ttl</span><span class="o">=</span>255 <span class="nb">time</span><span class="o">=</span>2.774 ms
64 bytes from 10.0.0.2: <span class="nv">icmp_seq</span><span class="o">=</span>1 <span class="nv">ttl</span><span class="o">=</span>255 <span class="nb">time</span><span class="o">=</span>2.530 ms
64 bytes from 10.0.0.2: <span class="nv">icmp_seq</span><span class="o">=</span>2 <span class="nv">ttl</span><span class="o">=</span>255 <span class="nb">time</span><span class="o">=</span>2.556 ms
64 bytes from 10.0.0.2: <span class="nv">icmp_seq</span><span class="o">=</span>3 <span class="nv">ttl</span><span class="o">=</span>255 <span class="nb">time</span><span class="o">=</span>2.714 ms

<span class="nt">---</span> host2 ping statistics <span class="nt">---</span>
4 packets transmitted, 4 packets received, 0% packet loss
round-trip min/avg/max/stddev <span class="o">=</span> 2.530/2.643/2.774/0.103 ms</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-ipv6">12. IPv6<a class="anchor" href="#network-ipv6"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>IPv6 (也被称作 IPng &#34;下一代 IP&#34;) 是众所周知的 IP 协议 (也叫 IPv4) 的新版本。 和其他现代的 *BSD 系统一样， FreeBSD 包含了 KAME 的 IPv6 参考实现。 因此， 您的 FreeBSD 系统包含了尝试 IPv6 所需要的所有工具。 这一节主要集中讨论如何配置和使用 IPv6。</p>
</div>
<div class="paragraph">
<p>在 1990 年代早期， 人们开始担心可用的 IPv4 地址空间在不断地缩小。 随着 Internet 的爆炸式发展， 主要的两个担心是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用尽所有的地址。 当然现在这个问题已经不再那样尖锐， 因为 RFC1918 私有地址空间 (<code>10.0.0.0/8</code>、 <code>172.16.0.0/12</code>， 以及 <code>192.168.0.0/16</code>) 和网络地址转换 (NAT) 技术已经被广泛采用。</p>
</li>
<li>
<p>路由表条目变得太大。这点今天仍然是焦点。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>IPv6 解决这些和其它许多的问题：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>128 位地址空间。换句话，理论上有 340,282,366,920,938,463,463,374,607,431,768,211,456 个地址可以使用。这意味着在我们的星球上每平方米大约有 6.67 * 10^27 个 IPv6 地址。</p>
</li>
<li>
<p>路由器仅在它们的路由表里存放网络地址集， 这就减少路由表的平均空间到 8192 个条目。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>IPv6 还有其它许多有用的功能，如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>地址自动配置 (<a href="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</a>)</p>
</li>
<li>
<p>Anycast (任意播) 地址(&#34;一对多&#34;)</p>
</li>
<li>
<p>强制的多播地址</p>
</li>
<li>
<p>IPsec (IP 安全)</p>
</li>
<li>
<p>简单的头结构</p>
</li>
<li>
<p>移动的 (Mobile) IP</p>
</li>
<li>
<p>IPv6 到 IPv4 的转换机制</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要更多信息，请查看：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>IPv6 概观，在<a href="http://playground.sun.com/pub/ipng/html/ipng-main.html">playground.sun.com</a></p>
</li>
<li>
<p><a href="http://www.kame.net">KAME.net</a></p>
</li>
</ul>
</div>
<div class="sect2">
<h3 id="_关于_ipv6_地址的背景知识">12.1. 关于 IPv6 地址的背景知识<a class="anchor" href="#_关于_ipv6_地址的背景知识"></a></h3>
<div class="paragraph">
<p>有几种不同类型的 IPv6 地址：Unicast，Anycast 和 Multicast。</p>
</div>
<div class="paragraph">
<p>Unicast 地址是为人们所熟知的地址。一个被发送到 unicast 地址的包实际上会到达属于这个地址的接口。</p>
</div>
<div class="paragraph">
<p>Anycast 地址语义上与 unicast 地址没有差别， 只是它们强调一组接口。指定为 anycast 地址的包会到达最近的 (以路由为单位) 接口。Anycast 地址可能只被路由器使用。</p>
</div>
<div class="paragraph">
<p>Multicast 地址标识一组接口。指定为 multicast 地址的包会到达属于 multicast 组的所有的接口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>IPv4 广播地址 (通常为 <code>xxx.xxx.xxx.255</code>) 由 IPv6 的 multicast 地址来表示。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 3. 保留的 IPv6 地址</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">IPv6 地址</th>
<th class="tableblock halign-left valign-top">预定长度 (bits)</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">备注</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未指定</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 IPv4 中的 <code>0.0.0.0</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">环回地址</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 IPv4 中的 <code>127.0.0.1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::00:xx:xx:xx:xx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">96 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">嵌入的 IPv4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">低 32 bits 是 IPv4 地址。这也称作 &#34;IPv4 兼容 IPv6 地址&#34;</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::ff:xx:xx:xx:xx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">96 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4 影射的 IPv6 地址</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">低的 32 bits 是 IPv4 地址。 用于那些不支持 IPv6 的主机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fe80::</code> - <code>feb::</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链路环回</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">类似 IPv4 的环回地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fec0::</code> - <code>fef::</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">站点环回</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ff::</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">多播</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>001</code> (base 2)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 bits</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全球多播</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有的全球多播地址都指定到这个地址池中。前三个二进制位是 &#34;001&#34;。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="_ipv6_地址的读法">12.2. IPv6 地址的读法<a class="anchor" href="#_ipv6_地址的读法"></a></h3>
<div class="paragraph">
<p>规范形式被描述为：<code>x:x:x:x:x:x:x:x</code>， 每一个&#34;x&#34;就是一个 16 位的 16 进制值。当然， 每个十六进制块以三个&#34;0&#34;开始头的也可以省略。如 <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code></p>
</div>
<div class="paragraph">
<p>通常一个地址会有很长的子串全部为零， 因此每个地址的这种子串常被简写为&#34;::&#34;。 例如：<code>fe80::1</code> 对应的规范形式是 <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>。</p>
</div>
<div class="paragraph">
<p>第三种形式是以众所周知的用点&#34;.&#34;作为分隔符的十进制 IPv4 形式，写出最后 32 Bit 的部分。例如 <code>2002::10.0.0.1</code> 对应的十进制正规表达方式是 <code>2002:0000:0000:0000:0000:0000:0a00:0001</code> 它也相当于写成 <code>2002::a00:1</code>.</p>
</div>
<div class="paragraph">
<p>到现在，读者应该能理解下面的内容了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig</span></code></pre>
</div>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rl0: flags=8943UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST mtu 1500
         inet 10.0.0.10 netmask 0xffffff00 broadcast 10.0.0.255
         inet6 fe80::200:21ff:fe03:8e1%rl0 prefixlen 64 scopeid 0x1
         ether 00:00:21:03:08:e1
         media: Ethernet autoselect (100baseTX )
         status: active</pre>
</div>
</div>
<div class="paragraph">
<p><code>fe80::200:21ff:fe03:8e1%rl0</code> 是一个自动配置的链路环回地址。它作为自动配置的一部分由 MAC 生成。</p>
</div>
<div class="paragraph">
<p>关于 IPv6 地址的结构的更多信息，请参看 <a href="http://www.ietf.org/rfc/rfc3513.txt">RFC3513</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="_进行连接">12.3. 进行连接<a class="anchor" href="#_进行连接"></a></h3>
<div class="paragraph">
<p>目前，有四种方式可以连接到其它 IPv6 主机和网络：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>咨询你的互联网服务提供商是否提供 IPv6。</p>
</li>
<li>
<p><a href="http://www.sixxs.net">SixXS</a> 向全球范围提供通道。</p>
</li>
<li>
<p>使用 6-to-4 通道 (<a href="http://www.ietf.org/rfc/rfc3068.txt">RFC3068</a>)</p>
</li>
<li>
<p>如果您使用的是拨号连接， 则可以使用 package:net/freenet6[] port。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="_ipv6_世界里的_dns">12.4. IPv6 世界里的 DNS<a class="anchor" href="#_ipv6_世界里的_dns"></a></h3>
<div class="paragraph">
<p>对于 IPv6 有两种类型的 DNS 记录：IETF 已经宣布 A6 是过时标准；现行的标准是 AAAA 记录。</p>
</div>
<div class="paragraph">
<p>使用AAAA记录是很简单的。通过增加下面内容， 给您的主机分配置您刚才接收到的新的 IPv6 地址：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>MYHOSTNAME           AAAA    MYIPv6ADDR</pre>
</div>
</div>
<div class="paragraph">
<p>到您的主域 DNS 文件里，就可以完成。要是您自已没有 DNS 域服务，您可以询问您的 DNS 提供商。目前的 bind 版本 (version 8.3 与 9) 和 package:dns/djbdns[](含IPv6补丁) 支持 AAAA 记录。</p>
</div>
</div>
<div class="sect2">
<h3 id="_在_etcrc_conf_中进行所需的修改">12.5. 在 <span class="filename">/etc/rc.conf</span> 中进行所需的修改<a class="anchor" href="#_在_etcrc_conf_中进行所需的修改"></a></h3>
<div class="sect3">
<h4 id="_ipv6_客户机设置">12.5.1. IPv6 客户机设置<a class="anchor" href="#_ipv6_客户机设置"></a></h4>
<div class="paragraph">
<p>这些设置将帮助您把一台您 LAN 上的机器配置为一台客户机， 而不是路由器。 要让 man:rtsol[8] 在启动时自动配置您的网卡， 只需添加：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipv6_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要自动地静态指定 IP 地址， 例如 <code>2001:471:1f11:251:290:27ff:fee0:2093</code>， 到 <span class="filename">fxp0</span> 上， 则写上：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipv6_ifconfig_fxp0=&#34;2001:471:1f11:251:290:27ff:fee0:2093&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要指定 <code>2001:471:1f11:251::1</code> 作为默认路由， 需要在 <span class="filename">/etc/rc.conf</span> 中加入：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipv6_defaultrouter=&#34;2001:471:1f11:251::1&#34;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ipv6_路由器网关配置">12.5.2. IPv6 路由器/网关配置<a class="anchor" href="#_ipv6_路由器网关配置"></a></h4>
<div class="paragraph">
<p>这将帮助您从隧道提供商那里取得必要的资料， 并将这些资料转化为在重启时能够保持住的设置。 要在启动时恢复您的隧道， 需要在 <span class="filename">/etc/rc.conf</span> 中增加：</p>
</div>
<div class="paragraph">
<p>列出要配置的通用隧道接口， 例如 <span class="filename">gif0</span>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gif_interfaces=&#34;gif0&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>配置该接口使用本地端地址 <em>MY_IPv4_ADDR</em> 和远程端地址 <em>REMOTE_IPv4_ADDR</em>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gifconfig_gif0=&#34;MY_IPv4_ADDR REMOTE_IPv4_ADDR&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>应用分配给您用于 IPv6 隧道远端的 IPv6 地址， 需要增加：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipv6_ifconfig_gif0=&#34;MY_ASSIGNED_IPv6_TUNNEL_ENDPOINT_ADDR&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>此后十设置 IPv6 的默认路由。 这是 IPv6 隧道的另一端：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipv6_defaultrouter=&#34;MY_IPv6_REMOTE_TUNNEL_ENDPOINT_ADDR&#34;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_ipv6_隧道配置">12.5.3. IPv6 隧道配置<a class="anchor" href="#_ipv6_隧道配置"></a></h4>
<div class="paragraph">
<p>如果服务器将您的网络通过 IPv6 路由到世界的其他角落， 您需要在 <span class="filename">/etc/rc.conf</span> 中添加下面的配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipv6_gateway_enable=&#34;YES&#34;</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="_路由宣告和主机自动配置">12.6. 路由宣告和主机自动配置<a class="anchor" href="#_路由宣告和主机自动配置"></a></h3>
<div class="paragraph">
<p>这节将帮助您配置 man:rtadvd[8] 来宣示默认的 IPv6 路由。</p>
</div>
<div class="paragraph">
<p>要启用 man:rtadvd[8] 您需要在 <span class="filename">/etc/rc.conf</span> 中添加：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rtadvd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>指定由哪个网络接口来完成 IPv6 路由请求非常重要。 举例来说， 让 man:rtadvd[8] 使用 <span class="filename">fxp0</span>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rtadvd_interfaces=&#34;fxp0&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>接下来我们需要创建配置文件， <span class="filename">/etc/rtadvd.conf</span>。 示例如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>fxp0:\
	:addrs#1:addr=&#34;2001:471:1f11:246::&#34;:prefixlen#64:tc=ether:</pre>
</div>
</div>
<div class="paragraph">
<p>将 <span class="filename">fxp0</span> 改为您打算使用的接口名。</p>
</div>
<div class="paragraph">
<p>接下来， 将 <code>2001:471:1f11:246::</code> 改为分配给您的地址前缀。</p>
</div>
<div class="paragraph">
<p>如果您拥有专用的 <code>/64</code> 子网， 则不需要修改其他设置。 反之， 您需要把 <code>prefixlen#</code> 改为正确的值。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-atm">13. 异步传输模式 (ATM)<a class="anchor" href="#network-atm"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_配置_classical_ip_over_atm_pvcs">13.1. 配置 classical IP over ATM (PVCs)<a class="anchor" href="#_配置_classical_ip_over_atm_pvcs"></a></h3>
<div class="paragraph">
<p>Classical IP over ATM (CLIP) 是一种最简单的使用带 IP 的 ATM 的方法。 这种方法可以用在交换式连接 (SVC) 和永久连接 (PVC) 上。这部分描述的就是配置基于 PVC 的网络。</p>
</div>
<div class="sect3">
<h4 id="_完全互连的配置">13.1.1. 完全互连的配置<a class="anchor" href="#_完全互连的配置"></a></h4>
<div class="paragraph">
<p>第一种使用PVC来设置 CLIP 的方式就是通过专用的 PVC 让网络里的每一台机子都互连在一起。 尽管这样配置起来很简单，但对于数量更多一点的机子来说就有些不切实际了。 例如我们有四台机子在网络里，每一台都使用一张 ATM 适配器卡连接到 ATM 网络。第一步就是规划 IP 地址和机子间的 ATM 连接。我们使用下面的：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">主机</th>
<th class="tableblock halign-left valign-top">IP 地址</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostA</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>192.168.173.1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostB</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>192.168.173.2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>192.168.173.3</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>192.168.173.4</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>为了建造完全交错的网络，我们需要在第一对机子间有一个 ATM 连接：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">机器</th>
<th class="tableblock halign-left valign-top">VPI.VCI 对</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostA</code> - <code>hostB</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.100</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostA</code> - <code>hostC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.101</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostA</code> - <code>hostD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.102</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostB</code> - <code>hostC</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.103</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostB</code> - <code>hostD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.104</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>hostC</code> - <code>hostD</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">0.105</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在每一个连接端 VPI 和 VCI 的值都可能会不同， 只是为了简单起见，我们假定它们是一样的。 下一步我们需要配置每一个主机上的 ATM 接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">hostA# ifconfig hatm0 192.168.173.1 up
hostB# ifconfig hatm0 192.168.173.2 up
hostC# ifconfig hatm0 192.168.173.3 up
hostD# ifconfig hatm0 192.168.173.4 up</code></pre>
</div>
</div>
<div class="paragraph">
<p>假定所有主机上的 ATM 接口都是 <span class="filename">hatm0</span>。 现在 PVC 需要配置到 <code>hostA</code> 上 (我们假定它们都已经配置在了 ATM 交换机上，至于怎么做的， 您就需要参考一下该交换机的手册了)。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">hostA# atmconfig natm add 192.168.173.2 hatm0 0 100 llc/snap ubr
hostA# atmconfig natm add 192.168.173.3 hatm0 0 101 llc/snap ubr
hostA# atmconfig natm add 192.168.173.4 hatm0 0 102 llc/snap ubr

hostB# atmconfig natm add 192.168.173.1 hatm0 0 100 llc/snap ubr
hostB# atmconfig natm add 192.168.173.3 hatm0 0 103 llc/snap ubr
hostB# atmconfig natm add 192.168.173.4 hatm0 0 104 llc/snap ubr

hostC# atmconfig natm add 192.168.173.1 hatm0 0 101 llc/snap ubr
hostC# atmconfig natm add 192.168.173.2 hatm0 0 103 llc/snap ubr
hostC# atmconfig natm add 192.168.173.4 hatm0 0 105 llc/snap ubr

hostD# atmconfig natm add 192.168.173.1 hatm0 0 102 llc/snap ubr
hostD# atmconfig natm add 192.168.173.2 hatm0 0 104 llc/snap ubr
hostD# atmconfig natm add 192.168.173.3 hatm0 0 105 llc/snap ubr</code></pre>
</div>
</div>
<div class="paragraph">
<p>当然，除 UBR 外其它的通信协定也可让 ATM 适配器支持这些。 此种情况下，通信协定的名字要跟人通信参数后边。工具 man:atmconfig[8] 的帮助可以这样得到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># atmconfig help natm add</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在 man:atmconfig[8] 手册页里得到。</p>
</div>
<div class="paragraph">
<p>相同的配置也可以通过 <span class="filename">/etc/rc.conf</span> 来完成。对于 <code>hostA</code>，看起来就象这样：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network_interfaces=&#34;lo0 hatm0&#34;
ifconfig_hatm0=&#34;inet 192.168.173.1 up&#34;
natm_static_routes=&#34;hostB hostC hostD&#34;
route_hostB=&#34;192.168.173.2 hatm0 0 100 llc/snap ubr&#34;
route_hostC=&#34;192.168.173.3 hatm0 0 101 llc/snap ubr&#34;
route_hostD=&#34;192.168.173.4 hatm0 0 102 llc/snap ubr&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>所有 CLIP 路由的当前状态可以使用如下命令获得：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">hostA# atmconfig natm show</code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="carp">14. Common Address Redundancy Protocol (CARP， 共用地址冗余协议)<a class="anchor" href="#carp"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>Common Address Redundancy Protocol， 或简称 CARP 能够使多台主机共享同一 IP 地址。 在某些配置中， 这样做可以提高可用性， 或实现负载均衡。 下面的例子中， 这些主机也可以同时使用其他的不同的 IP 地址。</p>
</div>
<div class="paragraph">
<p>要启用 CARP 支持， 必须在 FreeBSD 内核配置中增加下列选项， 并按照 crossref:kernelconfig[kernelconfig,配置FreeBSD的内核] 章节介绍的方法重新联编内核：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device	carp</pre>
</div>
</div>
<div class="paragraph">
<p>另外的一个方法是在启动时加载 <span class="filename">if_carp.ko</span> 模块。 把如下的这行加入到 <span class="filename">/boot/loader.conf</span>：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>if_carp_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>这样就可以使用 CARP 功能了， 一些具体的参数， 可以通过一系列 <code>sysctl</code>OID 来调整。</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">OID</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>net.inet.carp.allow</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接受进来的 CARP 包。 默认启用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>net.inet.carp.preempt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当主机中有一个 CARP 网络接口失去响应时， 这个选项将停止这台主机上所有的 CARP 接口。 默认禁用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>net.inet.carp.log</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当值为 <code>0</code> 表示禁止记录所有日志。 值为 <code>1</code> 表示记录损坏的 CARP 包。任何大于 <code>1</code> 表示记录 CARP 网络接口的状态变化。默认值为 <code>1</code>。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>net.inet.carp.arpbalance</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 ARP 均衡本地网络流量。 默认禁用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>net.inet.carp.suppress_preempt</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此只读 OID 显示抑制抢占的状态。 如果一个接口上的连接失去响应, 则抢占会被抑制。 当这个变量的值为 <code>0</code> 时，表示抢占未被抑制。 任何问题都会使 OID 递增。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>CARP 设备可以通过 <code>ifconfig</code> 命令来创建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig carp0 create</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在真实环境中， 这些接口需要一个称作 VHID 的标识编号。 这个 VHID 或 Virtual Host Identification (虚拟主机标识) 用于在网络上区分主机。</p>
</div>
<div class="sect2">
<h3 id="_使用_carp_来改善服务的可用性_carp">14.1. 使用 CARP 来改善服务的可用性 (CARP)<a class="anchor" href="#_使用_carp_来改善服务的可用性_carp"></a></h3>
<div class="paragraph">
<p>如前面提到的那样， CARP 的作用之一是改善服务的可用性。 这个例子中， 将为三台主机提供故障转移服务， 这三台服务器各自有独立的 IP 地址， 并提供完全一样的 web 内容。 三台机器以 DNS 轮询的方式提供服务。 用于故障转移的机器有两个 CARP 接口， 分别配置另外两台服务器的 IP 地址。 当有服务器发生故障时， 这台机器会自动得到故障机的 IP 地址。 这样以来， 用户就完全感觉不到发生了故障。 故障转移的服务器提供的内容和服务， 应与其为之提供热备份的服务器一致。</p>
</div>
<div class="paragraph">
<p>两台机器的配置， 除了主机名和 VHID 之外应完全一致。 在我们的例子中， 这两台机器的主机名分别是 <code>hosta.example.org</code> 和 <code>hostb.example.org</code>。 首先， 需要将 CARP 配置加入到 <span class="filename">rc.conf</span>。 对于 <code>hosta.example.org</code> 而言， <span class="filename">rc.conf</span> 文件中应包含下列配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>hostb.example.org</code> 上， 对应的 <span class="filename">rc.conf</span> 配置则是：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在两台机器上由 <code>ifconfig</code> 的 <code>pass</code> 选项指定的密码必须是一致的， 这一点非常重要。 <span class="filename">carp</span> 设备只会监听和接受来自持有正确密码的机器的公告。 此外， 不同虚拟主机的 VHID 必须不同。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>第三台机器， <code>provider.example.org</code> 需要进行配置， 以便在另外两台机器出现问题时接管。 这台机器需要两个 <span class="filename">carp</span> 设备， 分别处理两个机器。 对应的 <span class="filename">rc.conf</span> 配置类似下面这样：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;provider.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>配置两个 <span class="filename">carp</span> 设备， 能够让 <code>provider.example.org</code> 在两台机器中的任何一个停止响应时， 立即接管其 IP 地址。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认的 FreeBSD 内核 <em>可能</em> 启用了主机间抢占。 如果是这样的话， <code>provider.example.org</code> 可能在正式的内容服务器恢复时不释放 IP 地址。 此时， 管理员必须手工强制 IP 回到原来内容服务器。 具体做法是在 <code>provider.example.org</code> 上使用下面的命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig carp0 down  ifconfig carp0 up</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个操作需要在与出现问题的主机对应的那个 <span class="filename">carp</span> 接口上进行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在您已经完成了 CARP 的配置， 并可以开始测试了。 测试过程中， 可以随时重启或切断两台机器的网络。</p>
</div>
<div class="paragraph">
<p>如欲了解更多细节， 请参见 man:carp[4] 联机手册。</p>
</div>
</div>
</div>
</div>

    </div>
    
    <div class="buttons">
      
      <div class="prev">
        <i class="fa fa-angle-left" aria-hidden="true" title="Prev"></i>
        <div class="container">
          
            <a href=http://127.0.0.1:5500/zh-cn/books/handbook/firewalls class="direction">Prev</a>
          
        </div>
      </div>
      
      <div class="home">
        <i class="fa fa-home" aria-hidden="true" title="Home"></i>
        <div class="container">
          
            <a href="../" class="direction">Home</a>
          
        </div>
      </div>
      
      <div class="next">
        <div class="container">
          
            <a href=http://127.0.0.1:5500/zh-cn/books/handbook/partv  class="direction">Next</a>
          
        </div>
        <i class="fa fa-angle-right" aria-hidden="true" title="Next"></i>
      </div>
      
    </div>
    <label class="hidden book-menu-overlay" for="menu-control"></label>
  </div>
  <aside class="toc">
    <div class="toc-content">
      <h3>Table of Contents</h3>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#advanced-networking-synopsis">1. 概述</a></li>
    <li><a href="#network-routing">2. 网关和路由</a></li>
    <li><a href="#network-wireless">3. 无线网络</a></li>
    <li><a href="#network-bluetooth">4. 蓝牙</a></li>
    <li><a href="#network-bridging">5. 桥接</a></li>
    <li><a href="#network-aggregation">6. 链路聚合与故障转移</a></li>
    <li><a href="#network-diskless">7. 无盘操作</a></li>
    <li><a href="#network-pxe-nfs">8. 从 PXE 启动一个 NFS 根文件系统</a></li>
    <li><a href="#network-isdn">9. ISDN</a></li>
    <li><a href="#network-natd">10. 网络地址转换</a></li>
    <li><a href="#network-plip">11. 并口电缆 IP (PLIP)</a></li>
    <li><a href="#network-ipv6">12. IPv6</a></li>
    <li><a href="#network-atm">13. 异步传输模式 (ATM)</a></li>
    <li><a href="#carp">14. Common Address Redundancy Protocol (CARP， 共用地址冗余协议)</a></li>
  </ul>
</nav>
      <hr />
      
    </div>
  </aside>
  <a class="to-top" href="#top">
    <i class="fa fa-arrow-circle-up" aria-hidden="true"></i>
  </a>
</main>

    <footer>
  <div class="footer-container">
    <section class="logo-column">
          <img src="/images/FreeBSD-colors.svg" width="160" height="50" alt="FreeBSD logo" />
        <div class="options-container">
          
            <div class="language-container">
              <a id="languages" href="http://127.0.0.1:5500/zh-cn/languages">
                
                <img src="/images/language.png" class="language-image" alt="Choose language">
                <span>简体中文</span>
              </a>
            </div>
          
          <div class="theme-container">
            <select id="theme-chooser">
	      <option value="theme-system">System</option>
              <option value="theme-light">Light</option>
              <option value="theme-dark">Dark</option>
              <option value="theme-high-contrast">High contrast</option>
            </select>
          </div>
        </div>
      </section>
      
      <section class="copyright-column">
        <p>&copy; 1994-2023 The FreeBSD Project. All rights reserved</p>
        <span>Made with <span class="heart">♥</span> by the FreeBSD Community</span>
      </section>
  </div>
</footer>

  </body>
</html>
