---
description: 'FreeBSD 操作系统的基本命令和功能'
next: books/handbook/ports
part: 第一部分：入门指南
path: /books/handbook/
prev: books/handbook/bsdinstall
showBookMenu: true
tags: '["basics", "virtual consoles", "users", "management", "permissions", "directory structure", "disk organization", "mounting", "processes", "daemons", "shell", "editor", "manual pages", "devices"]'
title: '第三章. FreeBSD 基础知识'
weight: 5
---

[[basics]]
= FreeBSD 基础知识
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 3
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/basics/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[] include::shared/{{% lang %}}/teams.adoc[] include::shared/{{% lang %}}/mailing-lists.adoc[] include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[basics-synopsis]]
== 概要

本章介绍了 FreeBSD 操作系统的基本命令和功能。其中很多内容对于任何类 UNIX 操作系统都是相关的。鼓励新的 FreeBSD 用户仔细阅读本章。

阅读完本章后，您将了解：

* 如何使用和配置虚拟控制台。
* 如何在 FreeBSD 上创建和管理用户和组。
* UNIX(R) 文件权限和 FreeBSD 文件标志的工作原理。
* 默认的 FreeBSD 文件系统布局。
* FreeBSD 磁盘组织。
* 如何挂载和卸载文件系统。
* 进程、守护进程和信号是什么。
* 什么是 shell ，以及如何更改默认的登录环境。
* 如何使用基本文本编辑器。
* 设备和设备节点是什么。
* 如何阅读手册页以获取更多信息。

[[consoles]]
== 虚拟控制台和终端

除非 FreeBSD 已经配置为在启动时自动启动图形环境，否则系统将启动到一个命令行登录提示符，如下面的示例所示：

[.programlisting]
....
FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:
....

第一行包含了关于系统的一些信息。 `amd64` 表示 FreeBSD 运行在一个 64 位的 x86 系统上。主机名是 `pc3.example.org` ，而 `ttyv0` 表示这是“系统控制台”。第二行是登录提示符。

由于 FreeBSD 是一个多用户系统，它需要一种区分不同用户的方式。这通过要求每个用户在访问系统上的程序之前先登录系统来实现。每个用户都有一个唯一的“用户名”和个人的“密码”。

要登录系统控制台，请输入在系统安装过程中配置的用户名，如 crossref:bsdinstall[bsdinstall-addusers , Add Users] 中所述，并按下 kbd:[Enter] 键。然后输入与用户名关联的密码并按下 kbd:[Enter] 键。出于安全原因，密码不会显示出来。

一旦输入正确的密码，将显示当天的消息（ MOTD ），然后显示命令提示符。根据创建用户时选择的 shell 不同，该提示符可能是 `+#+` 、 `$` 或 `%` 字符。提示符表示用户已成功登录到 FreeBSD 系统控制台，并准备尝试可用的命令。

[[consoles-virtual]]
=== 虚拟控制台

虽然系统控制台可以用于与系统进行交互，但在 FreeBSD 系统的键盘命令行上工作的用户通常会登录到虚拟控制台。这是因为系统消息默认配置为显示在系统控制台上。这些消息会出现在用户正在操作的命令或文件上，使得集中注意力于手头的工作变得困难。

默认情况下，FreeBSD 配置了多个虚拟控制台用于输入命令。每个虚拟控制台都有自己的登录提示符和 Shell ，并且可以轻松地在虚拟控制台之间切换。这基本上提供了在图形环境中同时打开多个窗口的命令行等效功能。

组合键 kbd:[Alt + F1] 到 kbd:[Alt + F8] 已被 FreeBSD 保留用于在虚拟控制台之间切换。使用 kbd:[Alt + F1] 切换到系统控制台（ `ttyv0` ），使用 kbd:[Alt + F2] 访问第一个虚拟控制台（ `ttyv1` ），使用 kbd:[Alt + F3] 访问第二个虚拟控制台（ `ttyv2` ），依此类推。当使用 Xorg 作为图形控制台时，组合键变为 kbd:[Ctrl + Alt + F1] 以返回到基于文本的虚拟控制台。

当从一个控制台切换到下一个控制台时，FreeBSD 会管理屏幕输出。结果是有多个虚拟屏幕和键盘可以用来键入命令以供 FreeBSD 运行。当用户切换到不同的虚拟控制台时，在一个虚拟控制台中启动的程序不会停止运行

请参考 man:kbdcontrol[1] 、 man:vidcontrol[1] 、 man:atkbd[4] 、 man:syscons[4] 和 man:vt[4] ，以获取更详细的 FreeBSD 控制台及其键盘驱动程序的技术描述。

在 FreeBSD 中，可用的虚拟控制台数量是在 `/etc/ttys` 文件的这个部分进行配置的：

[.programlisting]
....
# name    getty                         type  status comments
#
ttyv0   "/usr/libexec/getty Pc"         xterm   on  secure
# Virtual terminals
ttyv1   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv2   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv3   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv4   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv5   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv6   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv7   "/usr/libexec/getty Pc"         xterm   on  secure
ttyv8   "/usr/X11R6/bin/xdm -nodaemon"  xterm   off secure
....

要禁用虚拟控制台，请在表示该虚拟控制台的行的开头放置一个注释符号（ `+#+` ）。例如，要将可用虚拟控制台的数量从八个减少到四个，请在表示虚拟控制台 `ttyv5` 到 `ttyv8` 的最后四行前面放置一个 `+#+` 。 **不要** 注释掉系统控制台 `ttyv0` 的行。请注意，如果已经安装并配置了 Xorg （如 crossref:x11[x11,X Window 系统] 中所述），则最后一个虚拟控制台（ `ttyv8` ）用于访问图形环境。

有关此文件中每个列的详细描述以及虚拟控制台的可用选项，请参阅 man:ttys[5] 。

[[consoles-singleuser]]
=== 单用户模式

FreeBSD 引导菜单提供了一个标有“单用户启动”的选项。如果选择了这个选项，系统将启动到一个称为“单用户模式”的特殊模式。通常情况下，这个模式用于修复无法启动的系统或者在不知道 `root` 密码时重置密码。在单用户模式下，网络和其他虚拟控制台是不可用的。然而，系统完全支持 `root` 访问，并且默认情况下不需要 `root` 密码。因此，需要有对键盘的物理访问权限才能进入该模式，确定谁对键盘有物理访问权是保护 FreeBSD 系统安全时需要考虑的问题

控制单用户模式的设置位于 `/etc/ttys` 文件的这个部分。

[.programlisting]
....
# name  getty                           type  status  comments
#
# If console is marked "insecure", then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure
....

默认情况下，状态被设置为 `secure`。这意味着对键盘具有物理访问权限的人要么不重要，要么受到物理安全策略的控制。如果将此设置更改为 `insecure`，则假设环境本身是不安全的，因为任何人都可以访问键盘。当将此行更改为 `insecure` 时， FreeBSD 将在用户选择进入单用户模式时提示输入 `root` 密码。

[NOTE]
====
在更改此设置为 `insecure` 时要小心！如果忘记了 `root` 密码，仍然可以启动到单用户模式，但对于不熟悉 FreeBSD 启动过程的人来说可能会有困难。
====

[[consoles-vidcontrol]]
=== 更改控制台视频模式

FreeBSD 控制台的默认视频模式可以调整为 1024x768 、 1280x1024 或其他由图形芯片和显示器支持的尺寸。要使用不同的视频模式，请加载 `VESA` 模块：

[source, shell]
....
# kldload vesa
....

要确定硬件支持哪些视频模式，请使用 man:vidcontrol[1] 。要获取支持的视频模式列表，请执行以下操作：

[source, shell]
....
# vidcontrol -i mode
....

该命令的输出列出了硬件支持的视频模式。要选择一个新的视频模式，请使用 man:vidcontrol[1] 作为 `root` 用户指定该模式：

[source, shell]
....
# vidcontrol MODE_279
....

如果新的视频模式可接受，可以通过将其添加到 `/etc/rc.conf` 来在启动时永久设置。

[.programlisting]
....
allscreens_flags="MODE_279"
....

[[users-synopsis]]
== 用户和基本账户管理

FreeBSD 允许多个用户同时使用计算机。虽然一次只能有一个用户坐在屏幕前使用键盘，但任意数量的用户可以通过网络登录系统。为了使用系统，每个用户都应该有自己的用户账户。

本章描述了：

* FreeBSD 系统上的不同类型的用户账户。
* 如何添加、删除和修改用户账户。
* 如何设置限制以控制用户和组可以访问的资源。
* 如何创建组并将用户添加为组的成员。

[[users-introduction]]
=== 账户类型

由于所有对 FreeBSD 系统的访问都是通过账户实现的，并且所有进程都是由用户运行的，因此用户和账户管理非常重要。

有三种主要类型的账户：系统账户、用户账户和超级用户账户。

[[users-system]]
==== 系统账户

系统账户用于运行诸如 DNS、邮件和 Web 服务器等服务。这样做的原因是出于安全考虑；如果所有服务都以超级用户身份运行，它们就可以无限制地执行操作。

系统账户的例子包括 `daemon`、`operator`、`bind`、`news` 和 `www`。

`nobody` 是一个通用的非特权系统账户。然而，使用 `nobody` 的服务越多，与该用户相关联的文件和进程也就越多，因此该用户的特权也就越高。

[[users-user]]
==== 用户账户

用户账户分配给真实的人，并用于登录和使用系统。每个访问系统的人都应该拥有一个唯一的用户账户。这使管理员能够查明谁在做什么，并防止用户破坏其他用户的设置。

每个用户都可以设置自己的环境以适应他们对系统的使用，通过配置他们的默认 shell 、编辑器、键绑定和语言设置。

在 FreeBSD 系统上，每个用户账户都有与之关联的特定信息：

User name::
用户名称是在 `login:` 提示处输入的。每个用户必须有一个唯一的用户名。有一些创建有效用户名的规则，这些规则在 man:passwd[5] 中有详细说明。建议使用由八个或更少个小写字符组成的用户名，以保持与应用程序的向后兼容性。

Password::
每个账户都有一个关联的密码。

User ID (UID)::
用户 ID (UID) 是一个用于在 FreeBSD 系统中唯一标识用户的数字。允许指定用户名的命令将首先将其转换为 UID 。建议使用小于 65535 的 UID ，因为较高的值可能会导致某些软件的兼容性问题。

Group ID (GID)::
组 ID (GID) 是一个用于唯一标识用户所属的主要组的数字。组是一种基于用户的 GID 而不是 UID 来控制对资源访问的机制。这可以显著减小某些配置文件的大小，并允许用户成为多个组的成员。建议使用 65535 或更低的 GID ，因为较高的 GID 可能会破坏某些软件。

Login class::
登录分级是组机制的扩展，为定制系统以适应不同用户提供了额外的灵活性。有关登录类的详细讨论，请参阅 crossref:security[users-limiting ,配置登录分级] 。

Password change time::
默认情况下，密码不会过期。然而，可以根据每个用户的情况启用密码过期功能，强制一些或所有用户在一定时间后更改他们的密码。

Account expiration time::
默认情况下， FreeBSD 不会使账户过期。当创建需要有限生命周期的账户时，比如学校的学生账户，可以使用 man:pw[8] 命令指定账户的过期日期。在过期时间到达后，该账户将无法用于登录系统，但账户的目录和文件将保留。

User's full name::
用户名在 FreeBSD 中唯一标识账户，但不一定反映用户的真实姓名。与注释类似，此信息可以包含空格、大写字符，并且可以超过 8 个字符的长度。

Home directory::
主目录是系统上一个目录的完整路径。这是用户登录时的起始目录。一个常见的约定是将所有用户的主目录放在 `/home/username` 或 `/usr/home/username` 下。每个用户在自己的主目录中存储个人文件和子目录。

User shell::
Shell 提供了用户与系统进行交互的默认环境。有许多不同类型的 shell ，有经验的用户会根据自己的偏好进行设置，这些设置可以反映在他们的账户设置中。

[[users-superuser]]
==== 超级用户账户

超级用户账户通常被称为 `root` ，用于无限制地管理系统。因此，不应将其用于日常任务，如发送和接收邮件、系统的一般探索或编程。

与其他用户账户不同，超级用户可以无限制地操作，滥用超级用户账户可能导致灾难性后果。用户账户无法通过错误操作销毁操作系统，因此建议以用户账户登录，并且只在需要额外权限的命令时切换为超级用户。

作为超级用户，始终要仔细检查任何发出的命令，因为额外的空格或缺失的字符可能导致无法修复的数据丢失。

有几种方法可以获得超级用户权限。虽然可以使用 `root` 账户登录，但这是极不推荐的。

相反，使用 man:su[1] 命令成为超级用户。如果在运行此命令时指定了 `-` ，用户还将继承 root 用户的环境。运行此命令的用户必须属于 `wheel` 组，否则命令将失败。用户还必须知道 `root` 用户账户的密码。

在这个例子中，用户只是为了运行 `make install` 这个步骤需要超级用户权限，才成为超级用户。一旦命令完成，用户输入 `exit` 来退出超级用户账户，返回到他们的用户账户的权限。

.以超级用户身份安装程序
[example]
====
[source, shell]
....
% configure
% make
% su -
Password:
# make install
# exit
%
....
====

内置的 man:su[1] 框架适用于单个系统或只有一个系统管理员的小型网络。另一种选择是安装 package:security/sudo[] 软件包或 port。该软件提供活动日志记录，并允许管理员配置哪些用户可以以超级用户身份运行哪些命令。

[[users-modifying]]
=== 管理账户

FreeBSD 提供了多种不同的命令来管理用户账户。最常见的命令在 <<users-modifying-utilities>> 中进行了总结，并附有一些使用示例。有关每个实用程序的更多详细信息和使用示例，请参阅其手册页面。

[[users-modifying-utilities]]
.管理用户账户的实用工具
[cols="25h,~"]
|===
| 命令
| 摘要

|man:adduser[8]
|用于添加新用户的推荐命令行应用程序。

|man:rmuser[8]
|用于删除用户的推荐命令行应用程序。

|man:chpass[1]
|用于更改用户数据库信息的灵活工具。

|man:passwd[1]
|用于更改用户密码的命令行工具。

|man:pw[8]
|功能强大而灵活的工具，可对用户账户进行全方位修改。

|man:bsdconfig[8]
|具有账户管理支持的系统配置工具。
|===

[[users-adduser]]
==== 添加用户

添加新用户的推荐程序是 man:adduser[8] 。当添加新用户时，该程序会自动更新 `/etc/passwd` 和 `/etc/group` 文件。它还会为新用户创建一个家目录，并从 `/usr/share/skel` 目录中复制默认配置文件，并可选择向新用户发送欢迎消息。此实用程序必须以超级用户身份运行。

man:adduser[8] 实用程序是交互式的，并且会引导用户完成创建新用户账户的步骤。如在 <<users-modifying-adduser>> 中所示，可以输入所需信息，或按 kbd:[Return] 键接受方括号中显示的默认值。在本示例中，用户已被邀请加入 `wheel` 组，允许他们通过 man:su[1] 成为超级用户。完成后，实用程序将提示是否创建另一个用户或退出。

[[users-modifying-adduser]]
.在 FreeBSD 上添加用户
[example]
====
[source, shell]
....
# adduser
....

输出应该类似于以下内容：

[.programlisting]
....
Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!
....
====

[NOTE]
====
由于密码在输入时不会显示出来，请在创建用户账户时小心不要输入错误的密码。
====

[[users-rmuser]]
==== 删除用户

要完全从系统中删除用户，请以超级用户身份运行 man:rmuser[8] 。该命令执行以下步骤：

[.procedure]
====
. 如果存在用户的 man:crontab[1] 条目，则删除它。
. 删除用户拥有的所有 man:at[1] 作业。
. 向用户拥有的所有进程发送 SIGKILL 信号。
. 从系统的本地密码文件中删除用户。
. 删除用户的主目录（如果该目录属于该用户），包括处理路径中符号链接指向实际主目录的情况。
. 从 `/var/mail` 目录中删除属于用户的传入邮件文件。
. 从 `/tmp`、`/var/tmp` 和 `/var/tmp/vi.recover` 中删除用户所有拥有的文件。
. 将用户名从 `/etc/group` 中所属的所有组中删除。（如果一个组变为空，并且组名与用户名相同，则删除该组；这与 man:adduser[8] 的每个用户唯一组相对应。）
. 删除用户拥有的所有消息队列、共享内存段和信号量。
====

man:rmuser[8] 不能用于删除超级用户账户，因为这几乎总是意味着大规模破坏的迹象。

默认情况下，使用交互模式，如下例所示。

.`rmuser` 交互式账户删除
[example]
====
[source, shell]
....
# rmuser jru

....

输出应该类似于以下内容：

[.programlisting]
....
Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user's home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.
....
====

[[users-chpass]]
==== 更改用户信息

任何用户都可以使用 man:chpass[1] 命令来更改其默认 shell 和与其用户账户关联的个人信息。超级用户可以使用此实用程序来更改任何用户的其他账户信息。

当没有传递任何选项时，除了可选的用户名外， man:chpass[1] 会显示一个包含用户信息的编辑器。当用户从编辑器退出时，用户数据库将会更新为新的信息。

[NOTE]
====
该实用程序在退出编辑器时会提示用户输入密码，除非以超级用户身份运行该实用程序。
====

在 <<users-modifying-chpass-su>> 中，超级用户输入了 `chpass jru` ，现在正在查看可以更改该用户的字段。如果 `jru` 运行此命令，只有最后六个字段将被显示并可供编辑。这在 <<users-modifying-chpass-ru>> 中显示。

[[users-modifying-chpass-su]]
.以超级用户身份使用 `chpass` 命令
[example]
====
[source, shell]
....
# chpass
....

输出应该类似于以下内容：

[.programlisting]
....
# Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[[users-modifying-chpass-ru]]
.以普通用户身份使用 `chpass` 命令
[example]
====
[source, shell]
....
#Changing user database information for jru.
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:
....
====

[NOTE]
====
命令 man:chfn[1] 和 man:chsh[1] 是指向 man:chpass[1] 的链接，同样 man:ypchpass[1] 、 man:ypchfn[1] 和 man:ypchsh[1] 也是。由于 NIS 支持是自动的，所以在命令之前指定 `yp` 是不必要的。如何配置 NIS 在 crossref:network-servers[network-servers ,网络服务器] 中有介绍。
====

[[users-passwd]]
==== 更改用户密码

任何用户都可以使用 man:passwd[1] 轻松更改他们的密码。为了防止意外或未经授权的更改，在设置新密码之前，该命令会提示用户输入原始密码：

.更改密码
[example]
====
[source, shell]
....
% passwd
....

输出应该类似于以下内容：

[.programlisting]
....
Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done
....
====

超级用户可以通过在运行 man:passwd[1] 时指定用户名来更改任何用户的密码。当以超级用户身份运行此实用程序时，它不会提示用户输入当前密码。这允许在用户无法记住原始密码时更改密码。

.以超级用户身份更改另一个用户的密码
[example]
====
[source, shell]
....
# passwd jru
....

输出应该类似于以下内容：

[.programlisting]
....
Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done
....
====

[NOTE]
====
与 man:chpass[1] 一样， man:yppasswd[1] 是指向 man:passwd[1] 的链接，因此 NIS 可以与任一命令一起使用。
====

[[users-pw]]
==== 创建、删除、修改和显示系统用户和组

man:pw[8] 实用程序可以创建、删除、修改和显示用户和组。它作为系统用户和组文件的前端工具。 man:pw[8] 具有一套非常强大的命令行选项，使其适用于在 shell 脚本中使用，但新用户可能会发现它比本节中介绍的其他命令更复杂。

[[users-groups]]
=== 管理群组

A group is a list of users. A group is identified by its group name and GID. In FreeBSD, the kernel uses the UID of a process, and the list of groups it belongs to, to determine what the process is allowed to do. Most of the time, the GID of a user or process usually means the first group in the list.

The group name to GID mapping is listed in `/etc/group`. This is a plain text file with four colon-delimited fields. The first field is the group name, the second is the encrypted password, the third the GID, and the fourth the comma-delimited list of members. For a more complete description of the syntax, refer to man:group[5].

The superuser can modify `/etc/group` using a text editor, although editing the group file using man:vigr[8] is preferred because it can catch some common mistakes. Alternatively, man:pw[8] can be used to add and edit groups. For example, to add a group called `teamtwo` and then confirm that it exists:

[WARNING]
====
Care must be taken when using the operator group, as unintended superuser-like access privileges may be granted, including but not limited to shutdown, reboot, and access to all items in `/dev` in the group.
====

.Adding a Group Using man:pw[8]
[example]
====
[source, shell]
....
# pw groupadd teamtwo
# pw groupshow teamtwo
....

输出应该类似于以下内容：

[.programlisting]
....
teamtwo:*:1100:
....
====

In this example, `1100` is the GID of `teamtwo`. Right now, `teamtwo` has no members. This command will add `jru` as a member of `teamtwo`.

.Adding User Accounts to a New Group Using man:pw[8]
[example]
====
[source, shell]
....
# pw groupmod teamtwo -M jru
# pw groupshow teamtwo
....

输出应该类似于以下内容：

[.programlisting]
....
teamtwo:*:1100:jru
....
====

The argument to `-M` is a comma-delimited list of users to be added to a new (empty) group or to replace the members of an existing group. To the user, this group membership is different from (and in addition to) the user's primary group listed in the password file. This means that the user will not show up as a member when using `groupshow` with man:pw[8], but will show up when the information is queried via man:id[1] or a similar tool. When man:pw[8] is used to add a user to a group, it only manipulates `/etc/group` and does not attempt to read additional data from `/etc/passwd`.

.Adding a New Member to a Group Using man:pw[8]
[example]
====
[source, shell]
....
# pw groupmod teamtwo -m db
# pw groupshow teamtwo
....

输出应该类似于以下内容：

[.programlisting]
....
teamtwo:*:1100:jru,db
....
====

In this example, the argument to `-m` is a comma-delimited list of users who are to be added to the group. Unlike the previous example, these users are appended to the group and do not replace existing users in the group.

.Using man:id[1] to Determine Group Membership
[example]
====
[source, shell]
....
% id jru
....

输出应该类似于以下内容：

[.programlisting]
....
uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)
....
====

In this example, `jru` is a member of the groups `jru` and `teamtwo`.

For more information about this command and the format of `/etc/group`, refer to man:pw[8] and man:group[5].

[[permissions]]
== Permissions

In FreeBSD, every file and directory has an associated set of permissions and several utilities are available for viewing and modifying these permissions. Understanding how permissions work is necessary to make sure that users are able to access the files that they need and are unable to improperly access the files used by the operating system or owned by other users.

This section discusses the traditional UNIX(R) permissions used in FreeBSD. For finer-grained file system access control, refer to crossref:security[fs-acl,Access Control Lists].

In UNIX(R), basic permissions are assigned using three types of access: read, write, and execute. These access types are used to determine file access to the file's owner, group, and others (everyone else). The read, write, and execute permissions can be represented as the letters `r`, `w`, and `x`. They can also be represented as binary numbers as each permission is either on or off (`0`). When represented as a number, the order is always read as `rwx`, where `r` has an on value of `4`, `w` has an on value of `2` and `x` has an on value of `1`.

Table 4.1 summarizes the possible numeric and alphabetic possibilities. When reading the "Directory Listing" column, a `-` is used to represent a permission that is set to off.

.UNIX(R) 权限
[cols="1,1,1", frame="none", options="header"]
|===
| 值
| 权限
| 目录列表

|0
|无读取，无写入，无执行
|`---`

|1
|不读，不写，只执行
|`--x`

|2
|不可读取、写入，不可执行
|`-w-`

|3
|不可读取、写入、执行
|`-wx`

|4
|读取，无写入，无执行
|`r--`

|5
|读取，无写入，执行
|`r-x`

|6
|读取、写入，不执行
|`rw-`

|7
|读取，写入，执行
|`rwx`
|===

使用 `-l` 参数与 `man:ls[1]` 一起，可以查看一个包含有关文件所有者、组和其他人权限的列的长目录列表。例如，在任意目录中使用 `ls -l` 可能会显示：

[source, shell]
....
% ls -l
....

输出应该类似于以下内容：

[.programlisting]
....
total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt
....

Focusing on the line for `myfile`, the first `(leftmost)` character indicates whether this file is a regular file, a directory, a special character device, a socket, or any other special pseudo-file device. In this example, the `-` indicates a regular file. The next three characters, `rw-` in this example, give the permissions for the owner of the file. The next three characters, `r--`, give the permissions for the group that the file belongs to. The final three characters, `r--`, give the permissions for the rest of the world. A dash means that the permission is turned off. In this example, the permissions are set so the owner can read and write to the file, the group can read the file, and the rest of the world can only read the file. According to the table above, the permissions for this file would be `644`, where each digit represents the three parts of the file's permission.

How does the system control permissions on devices? FreeBSD treats most hardware devices as a file that programs can open, read, and write data to. These special device files are stored in `/dev/`.

Directories are also treated as files. They have read, write, and execute permissions. The executable bit for a directory has a slightly different meaning than that of files. When a directory is marked executable, it means it is possible to change into that directory using man:cd[1]. This also means that it is possible to access the files within that directory, subject to the permissions on the files themselves.

In order to perform a directory listing, the read permission must be set on the directory. In order to delete a file that one knows the name of, it is necessary to have write _and_ execute permissions to the directory containing the file.

There are more permission bits, but they are primarily used in special circumstances such as setuid binaries and sticky directories. For more information on file permissions and how to set them, refer to man:chmod[1].

=== 符号权限

符号权限使用字符而不是八进制值来为文件或目录分配权限。符号权限使用以下语法： (用户) (动作) (权限) ，可用的值如下：

[.informaltable]
[cols="1,1,1", frame="none", options="header"]
|===
| 选项
| 参数
| 意义

|(用户)
|u
|用户

|(用户)
|g
|组所有者

|(用户)
|o
|其他

|(用户)
|a
|所有（"全部"）

|（动作）
|+
|添加权限

|（动作）
|-
|移除权限

|（动作）
|=
|指定权限

|（权限）
|r
|读

|（权限）
|w
|写

|（权限）
|x
|执行

|（权限）
|t
|粘性位

|（权限）
|s
|设置用户 ID 或组 ID
|===

These values are used with man:chmod[1], but with letters instead of numbers. For example, the following command would block both members of the group associated with _FILE_ and all other users from accessing _FILE_:

[source, shell]
....
% chmod go= FILE
....

A comma separated list can be provided when more than one set of changes to a file must be made. For example, the following command removes the group and "world" write permission on _FILE_, and adds the execute permissions for everyone:

[source, shell]
....
% chmod go-w,a+x FILE
....

=== FreeBSD File Flags

In addition to file permissions, FreeBSD supports the use of "file flags". These flags add an additional level of security and control over files, but not directories. With file flags, even `root` can be prevented from removing or altering files.

File flags are modified using man:chflags[1]. For example, to enable the system undeletable flag on the file `file1`, issue the following command:

[source, shell]
....
# chflags sunlink file1
....

To disable the system undeletable flag, put a "no" in front of the `sunlink`:

[source, shell]
....
# chflags nosunlink file1
....

To view the flags of a file, use `-lo` with man:ls[1]:

[source, shell]
....
# ls -lo file1
....

[.programlisting]
....
-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1
....

Several file flags may only be added or removed by the `root` user. In other cases, the file owner may set its file flags. Refer to man:chflags[1] and man:chflags[2] for more information.

=== The setuid, setgid, and sticky Permissions

Other than the permissions already discussed, there are three other specific settings that all administrators should know about. They are the `setuid`, `setgid`, and `sticky` permissions.

These settings are important for some UNIX(R) operations as they provide functionality not normally granted to normal users. To understand them, the difference between the real user ID and effective user ID must be noted.

The real user ID is the UID who owns or starts the process. The effective UID is the user ID the process runs as. As an example, man:passwd[1] runs with the real user ID when a user changes their password. However, in order to update the password database, the command runs as the effective ID of the `root` user. This allows users to change their passwords without seeing a `Permission Denied` error.

The setuid permission may be added symbolically by adding the `s` permission for the user as in the following example:
 
[source, shell]
....
# chmod u+s suidexample.sh
....

The setuid permission may also be set by prefixing a permission set with the number four (4) as shown in the following example:

[source, shell]
....
# chmod 4755 suidexample.sh
....

The permissions on `suidexample.sh` now look like the following:

[.programlisting]
....
-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh
....

Note that a `s` is now part of the permission set designated for the file owner, replacing the executable bit. This allows utilities which need elevated permissions, such as man:passwd[1].

[NOTE]
====
The `nosuid` man:mount[8] option will cause such binaries to silently fail without alerting the user. That option is not completely reliable as a `nosuid` wrapper may be able to circumvent it.
====

To view this in real time, open two terminals. On one, type `passwd` as a normal user. While it waits for a new password, check the process table and look at the user information for man:passwd[1]:

In terminal A:

[source, shell]
....
Changing local password for trhodes
Old Password:
....

In terminal B:

[source, shell]
....
# ps aux | grep passwd
....

[source, shell]
....
trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd
....

Although man:passwd[1] is run as a normal user, it is using the effective UID of `root`.

The `setgid` permission performs the same function as the `setuid` permission; except that it alters the group settings. When an application or utility executes with this setting, it will be granted the permissions based on the group that owns the file, not the user who started the process.

To set the `setgid` permission on a file symbolically, add the `s` permission for the group with man:chmod[1]:

[source, shell]
....
# chmod g+s sgidexample.sh
....
 
Alternatively, provide man:chmod[1] with a leading two (2):

[source, shell]
....
# chmod 2755 sgidexample.sh
....

In the following listing, notice that the `s` is now in the field designated for the group permission settings:

[source, shell]
....
-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh
....

[NOTE]
====
In these examples, even though the shell script in question is an executable file, it will not run with a different EUID or effective user ID. This is because shell scripts may not access the man:setuid[2] system calls.
====

The `setuid` and `setgid` permission bits may lower system security, by allowing for elevated permissions. The third special permission, the `sticky bit`, can strengthen the security of a system.

When the `sticky bit` is set on a directory, it allows file deletion only by the file owner. This is useful to prevent file deletion in public directories, such as `/tmp`, by users who do not own the file. To utilize this permission, add the `t` mode to the file:

[source, shell]
....
# chmod +t /tmp
....

Alternatively, prefix the permission set with a one (1):

[source, shell]
....
# chmod 1777 /tmp
....

The `sticky bit` permission will display as a `t` at the very end of the permission set:

[source, shell]
....
# ls -al / | grep tmp
....

[source, shell]
....
drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp
....

[[dirstructure]]
== Directory Structure

The FreeBSD directory hierarchy is fundamental to obtaining an overall understanding of the system. The most important directory is root or, "/". This directory is the first one mounted at boot time and it contains the base system necessary to prepare the operating system for multi-user operation. The root directory also contains mount points for other file systems that are mounted during the transition to multi-user operation.

A mount point is a directory where additional file systems can be grafted onto a parent file system (usually the root file system). This is further described in <<disk-organization>>. Standard mount points include `/usr/`, `/var/`, `/tmp/`, `/mnt/`, and `/cdrom/`. These directories are usually referenced to entries in `/etc/fstab`. This file is a table of various file systems and mount points and is read by the system. Most of the file systems in `/etc/fstab` are mounted automatically at boot time from the script man:rc[8] unless their entry includes `noauto`. Details can be found in <<disks-fstab>>.

文件系统层次结构的完整描述可以在 man:hier[7] 中找到。下表提供了最常见目录的简要概述。

[cols="25h,~"]
|===
| 目录
| 描述

|`/`
|文件系统的根目录。

|`/bin/`
|单用户和多用户环境的基本用户实用程序。

|`/boot/`
|操作系统引导过程中使用的程序和配置文件。

|`/boot/defaults/`
|默认的启动配置文件。有关详细信息，请参阅 man:loader.conf[5] 。

|`/dev/`
|由 man:devfs[5] 管理的设备特殊文件。

|`/etc/`
|系统配置文件和脚本。

|`/etc/defaults/`
|默认系统配置文件。有关详细信息，请参阅 man:rc[8] 。

|`/etc/periodic/`
|通过 man:cron[8] 每天、每周和每月运行的脚本。有关详细信息，请参阅 man:periodic[8] 。

|`/lib/`
|`/bin` 和 `/sbin` 目录中的二进制文件所需的关键系统库。

|`/libexec/`
|关键系统文件

|`/media/`
|包含用作可移动介质（如 CD、USB 驱动器和软盘）的挂载点的子目录。

|`/mnt/`
|空目录通常被系统管理员用作临时挂载点。

|`/net/`
|自动挂载的 NFS 共享；请参阅 man:auto_master[5] 。

|`/proc/`
|进程文件系统。有关详细信息，请参阅 man:procfs[5] 和 man:mount_procfs[8] 。

|`/rescue/`
|用于紧急恢复的静态链接程序，如 man:rescue[8] 中所述。

|`/root/`
|`root` 账户的主目录。

|`/sbin/`
|单用户和多用户环境的基本系统程序和管理工具。

|`/tmp/`
|通常在系统重新启动后不会保留的临时文件。基于内存的文件系统通常会挂载在 `/tmp` 目录下。可以使用 man:rc.conf[5] 中与 tmpmfs 相关的变量或在 `/etc/fstab` 中添加条目来自动化此过程；有关详细信息，请参阅 man:mdmfs[8] 。

|`/usr/`
|大多数用户工具和应用程序。

|`/usr/bin/`
|常用工具、编程工具和应用程序。

|`/usr/include/`
|标准的 C 头文件。

|`/usr/lib/`
|库文件

|`/usr/libdata/`
|杂项实用数据文件。

|`/usr/libexec/`
|系统守护进程和由其他程序执行的系统实用工具。

|`/usr/local/`
|本地可执行文件和库。也被用作 FreeBSD ports 框架的默认目的地。在 `/usr/local` 中，应使用 `man:hier[7]` 为 `/usr` 预设的一般布局。man 目录例外，它直接位于 `/usr/local` 而不是 `/usr/local/share` 下，而 ports 文档位于 `share/doc/port` 中。

|`/usr/ports/`
|FreeBSD Ports 集合（可选）。

|`/usr/sbin/`
|System daemons and system utilities executed by users.

|`/usr/share/`
|与体系结构无关的文件。

|`/usr/src/`
|BSD 或本地源文件。

|`/var/`
|多用途日志、临时、暂存和溢出文件。

|`/var/log/`
|Miscellaneous system log files.

|`/var/tmp/`
|通常在系统重启后保留的临时文件。

|===

[[disk-organization]]
== 磁盘组织

The smallest unit of organization that FreeBSD uses to find files is the filename. Filenames are case-sensitive, which means that `readme.txt` and `README.TXT` are two separate files. FreeBSD does not use the extension of a file to determine whether the file is a program, document, or some other form of data.

Files are stored in directories. A directory may contain no files, or it may contain many hundreds of files. A directory can also contain other directories, allowing a hierarchy of directories within one another in order to organize data.

Files and directories are referenced by giving the file or directory name, followed by a forward slash, `/`, followed by any other directory names that are necessary. For example, if the directory `foo` contains a directory `bar` which contains the file `readme.txt`, the full name, or _path_, to the file is `foo/bar/readme.txt`. Note that this is different from Windows(R) which uses `\` to separate file and directory names. FreeBSD does not use drive letters, or other drive names in the path. For example, one would not type `c:\foo\bar\readme.txt` on FreeBSD.

[[disks-file-systems]]
=== File systems

Directories and files are stored in a file system. Each file system contains exactly one directory at the very top level, called the _root directory_ for that file system. This root directory can contain other directories. One file system is designated the _root file system_ or `/`. Every other file system is _mounted_ under the root file system. No matter how many disks are on the FreeBSD system, every directory appears to be part of the same disk.

Consider three file systems, called `A`, `B`, and `C`. Each file system has one root directory, which contains two other directories, called `A1`, `A2` (and likewise `B1`, `B2` and `C1`, `C2`).

Call `A` the root file system. If man:ls[1] is used to view the contents of this directory, it will show two subdirectories, `A1` and `A2`. The directory tree looks like this:

image::example-dir1.png["Directory tree with the root directory and two subdirectories", A1 and A2]

A file system must be mounted on to a directory in another file system. When mounting file system `B` on to the directory `A1`, the root directory of `B` replaces `A1`, and the directories in `B` appear accordingly:

image::example-dir2.png["Directory tree with the root directory and two subdirectories", A1 and A2. And more subdirectories, B1 and B2 hanging from A1]

Any files that are in the `B1` or `B2` directories can be reached with the path `/A1/B1` or `/A1/B2` as necessary. Any files that were in `/A1` have been temporarily hidden. They will reappear if `B` is _unmounted_ from `A`.

If `B` had been mounted on `A2` then the diagram would look like this:

image::example-dir3.png["Directory tree with the root directory and two subdirectories", A1 and A2. And more subdirectories, B1 and B2 hanging from A2]

and the paths would be `/A2/B1` and `/A2/B2` respectively.

File systems can be mounted on top of one another. Continuing the last example, the `C` file system could be mounted on top of the `B1` directory in the `B` file system, leading to this arrangement:

image::example-dir4.png["A complex directory tree. With different subdirectories hanging from root."]

Or `C` could be mounted directly on to the `A` file system, under the `A1` directory:

image::example-dir5.png["A complex directory tree. With different subdirectories hanging from root."]

It is entirely possible to have one large root file system, and not need to create any others. There are some drawbacks to this approach, and one advantage.

.Benefits of Multiple File Systems
* Different file systems can have different _mount options_. For example, the root file system can be mounted read-only, making it impossible for users to inadvertently delete or edit a critical file. Separating user-writable file systems, such as `/home`, from other file systems allows them to be mounted _nosuid_. This option prevents the _suid_/_guid_ bits on executables stored on the file system from taking effect, possibly improving security.
* FreeBSD automatically optimizes the layout of files on a file system, depending on how the file system is being used. So a file system that contains many small files that are written frequently will have a different optimization to one that contains fewer, larger files. By having one big file system this optimization breaks down.
* FreeBSD's file systems are robust if power is lost. However, a power loss at a critical point could still damage the structure of the file system. By splitting data over multiple file systems it is more likely that the system will still come up, making it easier to restore from backup as necessary.

.Benefit of a Single File System
* File systems are a fixed size. If you create a file system when you install FreeBSD and give it a specific size, you may later discover that you need to make the partition bigger. This is not easily accomplished without backing up, recreating the file system with the new size, and then restoring the backed up data.
+
[IMPORTANT]
====
FreeBSD features the man:growfs[8] command, which makes it possible to increase the size of file system on the fly, removing this limitation. A file system can only be expanded into free space in the partition in which it resides. If there is space after the partition, the partition can be expanded with man:gpart[8]. If the partition is the last one on a virtual disk, and the disk is expanded, the partition can then be expanded.
====

[[disks-partitions]]
=== Disk partitions

File systems are contained in _partitions_. Disks are divided into partitions using one of several partitioning schemes; see <<bsdinstall-part-manual>>. The newer scheme is GPT; older BIOS-based computers use MBR. GPT supports division of a disk into partitions with a size, offset, and type. It supports a large number of partitions and partition types, and is recommended whenever its use is possible. GPT partitions use the disk name with a suffix, where the suffix is `p1` for the first partition, `p2` for the second, and so on. MBR, however, supports only a small number of partitions. The MBR partitions are known in FreeBSD as `slices`. Slices may be used for different operating systems. FreeBSD slices are subdivided into partitions using BSD labels (see man:bsdlabel[8]).
 
Slice numbers follow the device name, prefixed with an `s`, starting at 1. So "da0__s1__" is the first slice on the first SCSI drive. There can only be four physical slices on a disk, but there can be logical slices inside physical slices of the appropriate type. These extended slices are numbered starting at 5, so "ada0__s5__" is the first extended slice on the first SATA disk. These devices are used by file systems that expect to occupy a slice.

Each GPT or BSD partition can contain only one file system, which means that file systems are often described by either their typical mount point in the file system hierarchy, or the name of the partition they are contained in.

FreeBSD also uses disk space for _swap space_ to provide _virtual memory_. This allows your computer to behave as though it has much more memory than it actually does. When FreeBSD runs out of memory, it moves some of the data that is not currently being used to the swap space, and moves it back in (moving something else out) when it needs it. This is called _paging_.

Some BSD partitions have certain conventions associated with them.

[cols="25h,~"]
|===
| Partition
| Convention

|`a`
|Normally contains the root file system.

|`b`
|Normally contains swap space.

|`c`
|Normally the same size as the enclosing slice. This allows utilities that need to work on the entire slice, such as a bad block scanner, to work on the `c` partition. A file system would not normally be created on this partition.

|`d`
|Partition `d` used to have a special meaning associated with it, although that is now gone and `d` may work as any normal partition.
|===

Slices and "dangerously dedicated" physical drives contain BSD partitions, which are represented as letters from `a` to `h`. This letter is appended to the device name, so "da0__a__" is the `a` partition on the first `da` drive, which is "dangerously dedicated". "ada1s3__e__" is the fifth partition in the third slice of the second SATA disk drive.

Finally, each disk on the system is identified. A disk name starts with a code that indicates the type of disk, and then a number, indicating which disk it is. Unlike partitions and slices, disk numbering starts at 0. Common codes are listed in <<disks-naming>>.

When referring to a partition in a slice, include the disk name, `s`, the slice number, and then the partition letter. Examples are shown in <<basics-disk-slice-part>>. GPT partitions include the disk name, `p`, and then the partition number.

<<basics-concept-disk-model>> shows a conceptual model of a disk layout using MBR slices.

When installing FreeBSD, configure the disk slices if using MBR, and create partitions within the slice to be used for FreeBSD. If using GPT, configure partitions for each file system. In either case, create a file system or swap space in each partition, and decide where each file system will be mounted. See man:gpart[8] for information on manipulating partitions.

[[disks-naming]]
.磁盘设备名称
[cols="1,1", frame="none", options="header"]
|===
| 驱动类型
| 驱动设备名称

|SATA 和 IDE 硬盘
|`ada`

|SCSI 硬盘和 USB 存储设备
|`da`

|NVMe 存储
|`nvd` or `nda`

|SATA 和 IDE CD-ROM 驱动器
|`cd`

|SCSI CD-ROM 驱动器
|`cd`

|软盘驱动器
|`fd`

|SCSI 磁带驱动器
|`sa`

|RAID 驱动器
|例如，Adaptec(R) AdvancedRAID 的 `aacd`、Mylex(R) 的 `mlxd` 和 `mlyd`、AMI MegaRAID(R) 的 `amrd`、Compaq Smart RAID 的 `idad`、3ware(R) RAID 的 `twed`。
|===

[example]
====
[[basics-disk-slice-part]]
.示例磁盘、分片和分区名称
[.informaltable]
[cols="1,1", frame="none", options="header"]
|===
| 名称
| 意义

|`ada0s1a`
|第一个 SATA 磁盘（`ada0`）上的第一个分片（`s1`）上第一个分区（`a`）。

|`da1s2e`
|第二个 SCSI 磁盘（`da1`）上第二个分片（`s2`）上的第五个分区（`e`）。
|===
====

[[basics-concept-disk-model]]
.磁盘的概念模型
[example]
====
这个图示展示了 FreeBSD 对系统上连接的第一个 SATA 硬盘的视图。假设该硬盘的容量为 250GB ，包含一个 80GB 的分区和一个 170GB 的分区（MS-DOS(R) 分区）。第一个分区包含一个 Windows(R) NTFS 文件系统，即 `C:` ，而第二个分区包含一个 FreeBSD 安装。这个示例的 FreeBSD 安装有四个数据分区和一个交换分区。

The four partitions each hold a file system. Partition `a` is used for the root file system, `d` for `/var/`, `e` for `/tmp/`, and `f` for `/usr/`. Partition letter `c` refers to the entire slice, and so is not used for ordinary partitions.

image::disk-layout.png["Layout of a shared drive between Windows and FreeBSD"]
====

[[mount-unmount]]
== Mounting and Unmounting File Systems

The file system is best visualized as a tree, rooted, as it were, at `/`. `/dev`, `/usr`, and the other directories in the root directory are branches, which may have their own branches, such as `/usr/local`, and so on.

There are various reasons to house some of these directories on separate file systems. `/var` contains the directories `log/`, `spool/`, and various types of temporary files, and as such, may get filled up. Filling up the root file system is not a good idea, so splitting `/var` from `/` is often favorable.

Another common reason to contain certain directory trees on other file systems is if they are to be housed on separate physical disks, or are separate virtual disks, such as Network File System mounts, described in crossref:network-servers[network-nfs,“Network File System (NFS)”], or CDROM drives.

[[disks-fstab]]
=== fstab 文件

在引导过程中 (crossref:boot[boot,FreeBSD 引导过程]) ，除了包含 `noauto` 条目的条目外，`/etc/fstab` 中列出的文件系统会自动挂载。该文件以以下格式包含条目：

[.programlisting]
....
device       /mount-point fstype     options      dumpfreq     passno
....

`device`::
如 <<disks-naming>> 中所解释的，现有设备名称。

`mount-point`::
一个现有的目录，用于挂载文件系统。

`fstype`::
传递给 man:mount[8] 的文件系统类型。默认的 FreeBSD 文件系统是 `ufs`。

`options`::
可以选择 `rw` 表示读写文件系统，或者 `ro` 表示只读文件系统，后面可以添加其他可能需要的选项。常见的选项是 `noauto` ，用于在启动序列期间通常不挂载的文件系统。其他选项可以在 man:mount[8] 中找到。

`dumpfreq`::
man:dump[8] 使用此字段来确定哪些文件系统需要进行备份。如果该字段缺失，则默认为零值。

`passno`::
确定在重新启动后， man:fsck[8] 应该按照什么顺序检查 UFS 文件系统。应该跳过的文件系统应该将其 `passno` 设置为零。根文件系统需要在其他所有文件系统之前进行检查，并且其 `passno` 应该设置为一。其他文件系统的 `passno` 应该设置为大于一的值。如果有多个文件系统具有相同的 `passno` ， man:fsck[8] 将尝试在可能的情况下并行检查文件系统。

请参考 man:fstab[5] 以获取有关 `/etc/fstab` 格式及其选项的更多信息。

[[disks-mount]]
=== Using man:mount[8]

File systems are mounted using man:mount[8]. The most basic syntax is as follows:

[example]
====
[source, shell]
....
# mount device mountpoint
....
====

A file system listed in `/etc/fstab` can also be mounted by providing just the mountpoint.

This command provides many options which are described in man:mount[8]. The most commonly used options include:

.Mount Options
`-a`::
Mount all the file systems listed in `/etc/fstab`, except those marked as "noauto", excluded by the `-t` flag, or those that are already mounted.

`-d`::
Do everything except for the actual mount system call. This option is useful in conjunction with the `-v` flag to determine what man:mount[8] is actually trying to do.

`-f`::
Force the mount of an unclean file system (dangerous), or the revocation of write access when downgrading a file system's mount status from read-write to read-only.

`-r`::
Mount the file system read-only. This is identical to using `-o ro`.

``-t _fstype_``::
Mount the specified file system type or mount only file systems of the given type, if `-a` is included. "ufs" is the default file system type.

`-u`::
Update mount options on the file system.

`-v`::
Be verbose.

`-w`::
Mount the file system read-write.

The following options can be passed to `-o` as a comma-separated list:

nosuid::
Do not interpret setuid or setgid flags on the file system. This is also a useful security option.

[[disks-umount]]
=== Using man:umount[8]

To unmount a file system use man:umount[8]. This command takes one parameter which can be a mountpoint, device name, `-a` or `-A`.

All forms take `-f` to force unmounting, and `-v` for verbosity. Be warned that `-f` is not generally a good idea as it might crash the computer or damage data on the file system.

To unmount all mounted file systems, or just the file system types listed after `-t`, use `-a` or `-A`. Note that `-A` does not attempt to unmount the root file system.

[[basics-processes]]
== Processes and Daemons

FreeBSD is a multi-tasking operating system. Each program running at any one time is called a _process_. Every running command starts at least one new process and there are a number of system processes that are run by FreeBSD.

Each process is uniquely identified by a number called a _process ID_ (PID). Similar to files, each process has one owner and group, and the owner and group permissions are used to determine which files and devices the process can open. Most processes also have a parent process that started them. For example, the shell is a process, and any command started in the shell is a process which has the shell as its parent process. The exception is a special process called man:init[8] which is always the first process to start at boot time and which always has a PID of `1`.

Some programs are not designed to be run with continuous user input and disconnect from the terminal at the first opportunity. For example, a web server responds to web requests, rather than user input. Mail servers are another example of this type of application. These types of programs are known as _daemons_. The term daemon comes from Greek mythology and represents an entity that is neither good nor evil, and which invisibly performs useful tasks. This is why the BSD mascot is the cheerful-looking daemon with sneakers and a pitchfork.

There is a convention to name programs that normally run as daemons with a trailing "d". For example, BIND is the Berkeley Internet Name Domain, but the actual program that executes is `named`. The Apache web server program is `httpd` and the line printer spooling daemon is `lpd`. This is only a naming convention. For example, the main mail daemon for the Sendmail application is `sendmail`, and not `maild`.

=== Viewing Processes

To see the processes running on the system, use man:ps[1] or man:top[1]. To display a static list of the currently running processes, their PIDs, how much memory they are using, and the command they were started with, use man:ps[1]. To display all the running processes and update the display every few seconds in order to interactively see what the computer is doing, use man:top[1].

By default, man:ps[1] only shows the commands that are running and owned by the user. For example:

[source, shell]
....
% ps
....

输出应该类似于以下内容：

[.programlisting]
....
 PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps
....

The output from man:ps[1] is organized into a number of columns. The `PID` column displays the process ID. PIDs are assigned starting at 1, go up to 99999, then wrap around back to the beginning. However, a PID is not reassigned if it is already in use. The `TT` column shows the tty the program is running on and `STAT` shows the program's state. `TIME` is the amount of time the program has been running on the CPU. This is usually not the elapsed time since the program was started, as most programs spend a lot of time waiting for things to happen before they need to spend time on the CPU. Finally, `COMMAND` is the command that was used to start the program.

A number of different options are available to change the information that is displayed. One of the most useful sets is `auxww`, where `a` displays information about all the running processes of all users, `u` displays the username and memory usage of the process' owner, `x` displays information about daemon processes, and `ww` causes man:ps[1] to display the full command line for each process, rather than truncating it once it gets too long to fit on the screen.

The output from man:top[1] is similar:

[source, shell]
....
% top
....

输出应该类似于以下内容：

[.programlisting]
....
last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4
....

The output is split into two sections. The header (the first five or six lines) shows the PID of the last process to run, the system load averages (which are a measure of how busy the system is), the system uptime (time since the last reboot) and the current time. The other figures in the header relate to how many processes are running, how much memory and swap space has been used, and how much time the system is spending in different CPU states. If the ZFS file system module has been loaded, an `ARC` line indicates how much data was read from the memory cache instead of from disk.

Below the header is a series of columns containing similar information to the output from man:ps[1], such as the PID, username, amount of CPU time, and the command that started the process. By default, man:top[1] also displays the amount of memory space taken by the process. This is split into two columns: one for total size and one for resident size. Total size is how much memory the application has needed and the resident size is how much it is actually using now.

man:top[1] automatically updates the display every two seconds. A different interval can be specified with `-s`.

[[basics-daemons]]
=== Killing Processes

One way to communicate with any running process or daemon is to send a _signal_ using man:kill[1]. There are a number of different signals; some have a specific meaning while others are described in the application's documentation. A user can only send a signal to a process they own and sending a signal to someone else's process will result in a permission denied error. The exception is the `root` user, who can send signals to anyone's processes.

The operating system can also send a signal to a process. If an application is badly written and tries to access memory that it is not supposed to, FreeBSD will send the process the "Segmentation Violation" signal (`SIGSEGV`). If an application has been written to use the man:alarm[3] system call to be alerted after a period of time has elapsed, it will be sent the "Alarm" signal (`SIGALRM`).

Two signals can be used to stop a process: `SIGTERM` and `SIGKILL`. `SIGTERM` is the polite way to kill a process as the process can read the signal, close any log files it may have open, and attempt to finish what it is doing before shutting down. In some cases, a process may ignore `SIGTERM` if it is in the middle of some task that cannot be interrupted.

`SIGKILL` cannot be ignored by a process. Sending a `SIGKILL` to a process will usually stop that process there and then. footnote:[There are a few tasks that cannot be interrupted. For example, if the process is trying to read from a file that is on another computer on the network, and the other computer is unavailable, the process is said to be uninterruptible. Eventually the process will time out, typically after two minutes. As soon as this time out occurs the process will be killed.].

Other commonly used signals are `SIGHUP`, `SIGUSR1`, and `SIGUSR2`. Since these are general purpose signals, different applications will respond differently.

For example, after changing a web server's configuration file, the web server needs to be told to re-read its configuration. Restarting `httpd` would result in a brief outage period on the web server. Instead, send the daemon the `SIGHUP` signal. Be aware that different daemons will have different behavior, so refer to the documentation for the daemon to determine if `SIGHUP` will achieve the desired results.

[IMPORTANT]
====
Killing a random process on the system is a bad idea. In particular, man:init[8], PID 1, is special. Running `/bin/kill -s KILL 1` is a quick, and unrecommended, way to shutdown the system. _Always_ double check the arguments to man:kill[1] _before_ pressing kbd:[Return].
====

[[shells]]
== Shells

A _shell_ provides a command line interface for interacting with the operating system. A shell receives commands from the input channel and executes them. Many shells provide built in functions to help with everyday tasks such as file management, file globbing, command line editing, command macros, and environment variables. FreeBSD comes with several shells, including the Bourne shell (man:sh[1]) and the extended C shell (man:tcsh[1]). Other shells are available from the FreeBSD Ports Collection, such as `zsh` and `bash`.

The shell that is used is really a matter of taste. A C programmer might feel more comfortable with a C-like shell such as man:tcsh[1]. A Linux(R) user might prefer `bash`. Each shell has unique properties that may or may not work with a user's preferred working environment, which is why there is a choice of which shell to use.

One common shell feature is filename completion. After a user types the first few letters of a command or filename and presses kbd:[Tab], the shell completes the rest of the command or filename. Consider two files called `foobar` and `football`. To delete `foobar`, the user might type `rm foo` and press kbd:[Tab] to complete the filename.

But the shell only shows `rm foo`. It was unable to complete the filename because both `foobar` and `football` start with `foo`. Some shells sound a beep or show all the choices if more than one name matches. The user must then type more characters to identify the desired filename. Typing a `t` and pressing kbd:[Tab] again is enough to let the shell determine which filename is desired and fill in the rest.

Another feature of the shell is the use of environment variables. Environment variables are a variable/key pair stored in the shell's environment. This environment can be read by any program invoked by the shell, and thus contains a lot of program configuration. <<shell-env-vars>> provides a list of common environment variables and their meanings. Note that the names of environment variables are always in uppercase.

[[shell-env-vars]]
.常见的环境变量
[cols="25h,~"]
|===
| 变量
| 描述

|`USER`
|当前登录用户的名称。

|`PATH`
|以冒号分隔的目录列表，用于搜索二进制文件。

|`DISPLAY`
|如果可用，连接到的 Xorg 显示器的网络名称。

|`SHELL`
|当前的 Shell 。

|`TERM`
|用户终端的类型名称。用于确定终端的功能。

|`TERMCAP`
|终端转义码的数据库条目，用于执行各种终端功能。

|`OSTYPE`
|Type of operating system.

|`MACHTYPE`
|系统的 CPU 架构。

|`EDITOR`
|用户首选的文本编辑器。

|`PAGER`
|用户首选的逐页查看文本的实用工具。

|`MANPATH`
|以冒号分隔的目录列表，用于搜索手册页。
|===

How to set an environment variable differs between shells. In man:tcsh[1] and man:csh[1], use `setenv` to set environment variables. In man:sh[1] and `bash`, use `export` to set the current environment variables. This example sets the default `EDITOR` to `/usr/local/bin/emacs` for the man:tcsh[1] shell:

[source, shell]
....
% setenv EDITOR /usr/local/bin/emacs
....

The equivalent command for `bash` would be:

[source, shell]
....
% export EDITOR="/usr/local/bin/emacs"
....

To expand an environment variable in order to see its current setting, type a `$` character in front of its name on the command line. For example, `echo $TERM` displays the current `$TERM` setting.

Shells treat special characters, known as meta-characters, as special representations of data. The most common meta-character is `\*`, which represents any number of characters in a filename. Meta-characters can be used to perform filename globbing. For example, `echo *` is equivalent to `ls` because the shell takes all the files that match `*` and `echo` lists them on the command line.

To prevent the shell from interpreting a special character, escape it from the shell by starting it with a backslash (`\`). For example, `echo $TERM` prints the terminal setting whereas `echo \$TERM` literally prints the string `$TERM`.

[[changing-shells]]
=== Changing the Shell

The easiest way to permanently change the default shell is to use `chsh`. Running this command will open the editor that is configured in the `EDITOR` environment variable, which by default is set to man:vi[1]. Change the `Shell:` line to the full path of the new shell.

Alternately, use `chsh -s` which will set the specified shell without opening an editor. For example, to change the shell to `bash`:

[source, shell]
....
% chsh -s /usr/local/bin/bash
....

Enter your password at the prompt and press kbd:[Return] to change your shell. Log off and log in again to start using the new shell.

[NOTE]
====
The new shell _must_ be present in `/etc/shells`. If the shell was installed from the FreeBSD Ports Collection as described in crossref:ports[ports,Installing Applications: Packages and Ports], it should be automatically added to this file. If it is missing, add it using this command, replacing the path with the path of the shell:

[source, shell]
....
# echo /usr/local/bin/bash >> /etc/shells
....

Then, rerun man:chsh[1].
====

=== Advanced Shell Techniques

The UNIX(R) shell is not just a command interpreter, it acts as a powerful tool which allows users to execute commands, redirect their output, redirect their input and chain commands together to improve the final command output. When this functionality is mixed with built in commands, the user is provided with an environment that can maximize efficiency.

Shell redirection is the action of sending the output or the input of a command into another command or into a file. To capture the output of the man:ls[1] command, for example, into a file, redirect the output:

[source, shell]
....
% ls > directory_listing.txt
....

The directory contents will now be listed in `directory_listing.txt`. Some commands can be used to read input, such as man:sort[1]. To sort this listing, redirect the input:

[source, shell]
....
% sort < directory_listing.txt
....

The input will be sorted and placed on the screen. To redirect that input into another file, one could redirect the output of man:sort[1] by mixing the direction:

[source, shell]
....
% sort < directory_listing.txt > sorted.txt
....

In all of the previous examples, the commands are performing redirection using file descriptors. Every UNIX(R) system has file descriptors, which include standard input (stdin), standard output (stdout), and standard error (stderr). Each one has a purpose, where input could be a keyboard or a mouse, something that provides input. Output could be a screen or paper in a printer. And error would be anything that is used for diagnostic or error messages. All three are considered I/O based file descriptors and sometimes considered streams.

Through the use of these descriptors, the shell allows output and input to be passed around through various commands and redirected to or from a file. Another method of redirection is the pipe operator.

The UNIX(R) pipe operator, "|" allows the output of one command to be directly passed or directed to another program. Basically, a pipe allows the standard output of a command to be passed as standard input to another command, for example:

[source, shell]
....
% cat directory_listing.txt | sort | less
....

In that example, the contents of `directory_listing.txt` will be sorted and the output passed to man:less[1]. This allows the user to scroll through the output at their own pace and prevent it from scrolling off the screen.

[[editors]]
== Text Editors

Most FreeBSD configuration is done by editing text files, so it is a good idea to become familiar with a text editor. FreeBSD comes with a few as part of the base system, and many more are available in the Ports Collection.

A simple editor to learn is man:ee[1], which stands for easy editor. To start this editor, type `ee _filename_` where _filename_ is the name of the file to be edited. Once inside the editor, all of the commands for manipulating the editor's functions are listed at the top of the display. The caret (`^`) represents kbd:[Ctrl], so `^e` expands to kbd:[Ctrl+e]. To leave man:ee[1], press kbd:[Esc], then choose the "leave editor" option from the main menu. The editor will prompt to save any changes if the file has been modified.

FreeBSD also comes with more powerful text editors, such as man:vi[1], as part of the base system. Other editors, like package:editors/emacs[] and package:editors/vim[], are part of the FreeBSD Ports Collection. These editors offer more functionality at the expense of being more complicated to learn. Learning a more powerful editor such as vim or Emacs can save more time in the long run.

Many applications which modify files or require typed input will automatically open a text editor. To change the default editor, set the `EDITOR` environment variable as described in <<shells>>.

[[basics-devices]]
== Devices and Device Nodes

A device is a term used mostly for hardware-related activities in a system, including disks, printers, graphics cards, and keyboards. When FreeBSD boots, the majority of the boot messages refer to devices being detected. A copy of the boot messages is saved to `/var/run/dmesg.boot`.

Each device has a device name and number. For example, `ada0` is the first SATA hard drive, while `kbd0` represents the keyboard.

Most devices in FreeBSD must be accessed through special files called device nodes, which are located in `/dev`.

[[basics-more-information]]
== Manual Pages

The most comprehensive documentation on FreeBSD is in the form of manual pages. Nearly every program on the system comes with a short reference manual explaining the basic operation and available arguments. These manuals can be viewed using `man`:

[source, shell]
....
% man command
....

where _command_ is the name of the command to learn about. For example, to learn more about man:ls[1], type:

[source, shell]
....
% man ls
....

Manual pages are divided into sections which represent the type of topic. In FreeBSD, the following sections are available:

. User commands.
. System calls and error numbers.
. Functions in the C libraries.
. Device drivers.
. File formats.
. Games and other diversions.
. Miscellaneous information.
. System maintenance and operation commands.
. System kernel interfaces.

In some cases, the same topic may appear in more than one section of the online manual. For example, there is a `chmod` user command and a `chmod()` system call. To tell man:man[1] which section to display, specify the section number:

[source, shell]
....
% man 1 chmod
....

This will display the manual page for the user command man:chmod[1]. References to a particular section of the online manual are traditionally placed in parenthesis in written documentation, so man:chmod[1] refers to the user command and man:chmod[2] refers to the system call.

If the name of the manual page is unknown, use `man -k` to search for keywords in the manual page descriptions:

[source, shell]
....
% man -k mail
....

This command displays a list of commands that have the keyword "mail" in their descriptions. This is equivalent to using man:apropos[1].

To read the descriptions for all of the commands in `/usr/sbin`, type:

[source, shell]
....
% cd /usr/sbin
% man -f * | more
....

or

[source, shell]
....
% cd /usr/sbin
% whatis * |more
....

[[basics-info]]
=== GNU Info Files

FreeBSD includes several applications and utilities produced by the Free Software Foundation (FSF). In addition to manual pages, these programs may include hypertext documents called `info` files. These can be viewed using man:info[1] or, if package:editors/emacs[] is installed, the info mode of emacs.

To use man:info[1], type:

[source, shell]
....
% info
....

For a brief introduction, type `h`. For a quick command reference, type `?`.
