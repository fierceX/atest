---
description: FreeBSD提供与Linux的二进制兼容性，允许用户在FreeBSD系统上安装和运行大多数Linux二进制文件，而无需先修改二进制文件。
next: books/handbook/wine
part: 第二部分：常见任务
path: /books/handbook/
prev: books/handbook/printing
showBookMenu: true
tags: '["linux", "linuxulator", "emulation", "binary", "compatibility"]'
title: '第12章. Linux二进制兼容性'
weight: 15
---

[[linuxemu]]
= Linux二进制兼容性
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: 12
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/linuxemu/

ifdef::env-beastie[]
ifdef::backend-html5[]
:imagesdir: ../../../../images/{images-path}
endif::[]
ifndef::book[]
include::shared/authors.adoc[]
include::shared/mirrors.adoc[]
include::shared/releases.adoc[]
include::shared/attributes/attributes-{{% lang %}}.adoc[] include::shared/{{% lang %}}/teams.adoc[] include::shared/{{% lang %}}/mailing-lists.adoc[] include::shared/{{% lang %}}/urls.adoc[]
toc::[]
endif::[]
ifdef::backend-pdf,backend-epub3[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]
endif::[]

ifndef::env-beastie[]
toc::[]
include::../../../../../shared/asciidoctor.adoc[]
endif::[]

[[linuxemu-synopsis]]
== 概要

FreeBSD提供与Linux(R)的二进制兼容性，通常称为Linuxulator，允许用户安装和运行未经修改的Linux二进制文件。它适用于x86（32位和64位）和AArch64架构。目前还不支持一些特定于Linux的操作系统功能，主要是与硬件相关或与系统管理相关的功能，例如cgroups或命名空间。

在阅读本章之前，你应该：

* 了解如何安装crossref:ports[ports,其他第三方软件]。

阅读完本章后，您将了解：

* 如何在FreeBSD系统上启用Linux二进制兼容性。
* 如何安装额外的Linux共享库。
* 如何在FreeBSD系统上安装Linux应用程序。
* FreeBSD中Linux兼容性的实现细节。

[[linuxemu-lbc-install]]
== 配置Linux二进制兼容性

默认情况下，不启用 man:linux[4] 二进制兼容性。

要在启动时启用Linux ABI，请执行以下命令：

[.programlisting]
....
# sysrc linux_enable="YES"
....

一旦启用，可以通过执行以下命令来启动，无需重新启动：

[source, shell]
....
# service linux start
....

这对于静态链接的Linux二进制文件来说已经足够了。

Linux服务将加载Linux应用程序所需的内核模块并挂载文件系统，这些文件系统位于[/compat/linux]目录下。它们可以像本机FreeBSD二进制文件一样启动；它们的行为几乎与本机进程完全相同，并且可以按照通常的方式进行跟踪和调试。

可以通过执行以下命令来检查[.filename]#/compat/linux#的当前内容：

[source, shell]
....
# ls -l /compat/linux/
....

输出应该类似于以下内容：

[.programlisting]
....
total 1
dr-xr-xr-x  13 root  wheel  512 Apr 11 19:12 dev
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:03 proc
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:03 sys
....

[[linux-userlands]]
== Linux用户空间

Linux软件需要的不仅仅是一个ABI才能运行。为了运行Linux软件，首先必须安装Linux用户空间。

[TIP]
====
如果只是想运行已包含在Ports树中的一些软件，可以通过软件包管理器进行安装，并且man:pkg[8]将自动设置所需的Linux用户空间。

例如，要安装Sublime Text 4以及它所依赖的所有Linux库，请运行以下命令：
 
[source, shell]
....
# pkg install linux-sublime-text4
....
====

[[linuxemu-packages]]
=== 从FreeBSD软件包中获取的CentOS基本系统

要安装CentOS用户空间，请执行以下命令：

[source, shell]
....
# pkg install linux_base-c7
....

package:emulators/linux_base-c7[] 将基于 CentOS 7 的基本系统放置在 [.filename]#/compat/linux# 中。

安装完软件包后，可以通过运行以下命令来验证[.filename]#/compat/linux#的内容，以检查是否已安装CentOS用户空间：

[source, shell]
....
# ls -l /compat/linux/
....

输出应该类似于以下内容：

[.programlisting]
....
total 30
lrwxr-xr-x   1 root  wheel    7 Apr 11  2018 bin -> usr/bin
drwxr-xr-x  13 root  wheel  512 Apr 11 21:10 dev
drwxr-xr-x  25 root  wheel   64 Apr 11 21:10 etc
lrwxr-xr-x   1 root  wheel    7 Apr 11  2018 lib -> usr/lib
lrwxr-xr-x   1 root  wheel    9 Apr 11  2018 lib64 -> usr/lib64
drwxr-xr-x   2 root  wheel    2 Apr 11 21:10 opt
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:25 proc
lrwxr-xr-x   1 root  wheel    8 Feb 18 02:10 run -> /var/run
lrwxr-xr-x   1 root  wheel    8 Apr 11  2018 sbin -> usr/sbin
drwxr-xr-x   2 root  wheel    2 Apr 11 21:10 srv
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:25 sys
drwxr-xr-x   8 root  wheel    9 Apr 11 21:10 usr
drwxr-xr-x  16 root  wheel   17 Apr 11 21:10 var
....

[[linuxemu-debootstrap]]
=== 使用debootstrap创建Debian / Ubuntu基础系统

提供Linux共享库的另一种方式是使用package:sysutils/debootstrap[]。这样做的优点是可以提供完整的Debian或Ubuntu发行版。

要安装debootstrap，请执行以下命令：

[source, shell]
....
# pkg install debootstrap
....

man:debootstrap[8]需要启用man:linux[4] ABI。启用后，执行以下命令在[.filename]#/compat/ubuntu#中安装Ubuntu或Debian：

[source, shell]
....
# debootstrap focal /compat/ubuntu
....

[NOTE]
====
虽然从技术上讲可以安装到 [.filename]#/compat/linux# 目录中，但由于可能与基于 CentOS 的软件包发生冲突，不建议这样做。相反，应根据发行版或版本名称派生目录名称，例如 [.filename]#/compat/ubuntu#。
====

输出应该类似于以下内容：

[.programlisting]
....
I: Retrieving InRelease 
I: Checking Release signature
I: Valid Release signature (key id F6ECB3762474EDA9D21B7022871920D1991BC93C)
I: Retrieving Packages 
I: Validating Packages 
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
I: Checking component main on http://archive.ubuntu.com/ubuntu...
[...]
I: Configuring console-setup...
I: Configuring kbd...
I: Configuring ubuntu-minimal...
I: Configuring libc-bin...
I: Configuring ca-certificates...
I: Base system installed successfully.
....

然后在`/etc/fstab`中设置挂载点。

[TIP]
====
如果要共享主目录的内容并且能够运行X11应用程序，应该使用man:nullfs[5]将[.filename]#/home#和[.filename]#/tmp#挂载到Linux兼容区域中，以实现回环。

以下示例可以添加到[/etc/fstab]文件中：

[.programlisting]
....
# Device        Mountpoint              FStype          Options                      Dump    Pass#
devfs           /compat/ubuntu/dev      devfs           rw,late                      0       0
tmpfs           /compat/ubuntu/dev/shm  tmpfs           rw,late,size=1g,mode=1777    0       0
fdescfs         /compat/ubuntu/dev/fd   fdescfs         rw,late,linrdlnk             0       0
linprocfs       /compat/ubuntu/proc     linprocfs       rw,late                      0       0
linsysfs        /compat/ubuntu/sys      linsysfs        rw,late                      0       0
/tmp            /compat/ubuntu/tmp      nullfs          rw,late                      0       0
/home           /compat/ubuntu/home     nullfs          rw,late                      0       0
....

然后执行 man:mount[8]：

[source, shell]
....
# mount -al
....
====

要使用man:chroot[8]访问系统，请执行以下命令：

[source, shell]
....
# chroot /compat/ubuntu /bin/bash
....

然后可以执行 man:uname[1] 命令来检查 Linux 环境：

[source, shell]
....
# uname -s -r -m
....

输出应该类似于以下内容：

[.programlisting]
....
Linux 3.17.0 x86_64
....

一旦进入chroot环境，系统的行为就像在正常的Ubuntu安装中一样。虽然systemd不起作用，但man:service[8]命令仍然像往常一样工作。

[TIP]
====
要添加默认缺失的软件包仓库，请编辑文件[.filename]#/compat/ubuntu/etc/apt/sources.list#。

对于amd64架构，可以使用以下示例：

[.programlisting]
....
deb http://archive.ubuntu.com/ubuntu focal main universe restricted multiverse
deb http://security.ubuntu.com/ubuntu/ focal-security universe multiverse restricted main
deb http://archive.ubuntu.com/ubuntu focal-backports universe multiverse restricted main
deb http://archive.ubuntu.com/ubuntu focal-updates universe multiverse restricted main
....

对于arm64架构，可以使用以下示例：

[.programlisting]
....
deb http://ports.ubuntu.com/ubuntu-ports bionic main universe restricted multiverse
....
====

[[linuxemu-advanced]]
== 高级主题

所有与Linux相关的man:sysctl[8]参数列表可以在man:linux[4]中找到。

有些应用程序需要挂载特定的文件系统。

这通常由[.filename]#/etc/rc.d/linux#脚本处理，但可以通过执行以下命令在启动时禁用：

[.programlisting]
....
sysrc linux_mounts_enable="NO"
....

通过rc脚本挂载的文件系统在chroots或jails中的Linux进程中将无法工作；如果需要，在/etc/fstab中进行配置：

[.programlisting]
....
devfs      /compat/linux/dev      devfs      rw,late                    0  0
tmpfs      /compat/linux/dev/shm  tmpfs      rw,late,size=1g,mode=1777  0  0
fdescfs    /compat/linux/dev/fd   fdescfs    rw,late,linrdlnk           0  0
linprocfs  /compat/linux/proc     linprocfs  rw,late                    0  0
linsysfs   /compat/linux/sys      linsysfs   rw,late                    0  0
....

由于Linux二进制兼容层已经支持运行32位和64位Linux二进制文件，因此不再可能将仿真功能静态链接到自定义内核中。

[[linuxemu-libs-manually]]
=== 手动安装额外的库

在某些情况下，您可能需要手动安装一些额外的库来满足您的项目需求。以下是手动安装额外库的步骤：

1. 首先，您需要确定您需要安装的库的名称和版本。您可以在库的官方网站或文档中找到这些信息。

2. 打开命令行界面，并导航到您项目的根目录。

3. 使用适合您操作系统的包管理器来安装库的依赖项。例如，如果您使用的是Linux系统，您可以使用apt-get或yum来安装所需的依赖项。

4. 下载库的源代码或二进制文件。您可以在库的官方网站或其他可信来源上找到这些文件。

5. 解压缩下载的文件，并进入解压缩后的目录。

6. 根据库的文档或说明，执行适当的安装步骤。这可能包括运行配置脚本、编译源代码或执行其他必要的操作。

7. 安装完成后，您可以在您的项目中引用该库，并开始使用它。

请注意，手动安装库可能会比使用包管理器更复杂，并且可能需要更多的配置和设置。确保您仔细阅读库的文档，并按照说明进行操作。

[NOTE]
====
对于使用man:debootstrap[8]创建的基本系统子目录，请使用上述说明。
====

如果在配置Linux二进制兼容性后，一个Linux应用程序抱怨缺少共享库，那么需要确定Linux二进制文件需要哪些共享库，并手动安装它们。

在使用相同的CPU架构的Linux系统上，可以使用`ldd`命令来确定应用程序需要哪些共享库。

例如，要检查`linuxdoom`需要哪些共享库，请从已安装Doom的Linux系统上运行以下命令：

[source, shell]
....
% ldd linuxdoom
....

输出应该类似于以下内容：

[.programlisting]
....
libXt.so.3 (DLL Jump 3.1) => /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 (DLL Jump 3.1) => /usr/X11/lib/libX11.so.3.1.0
libc.so.4 (DLL Jump 4.5pl26) => /lib/libc.so.4.6.29
....

然后，将Linux系统输出的最后一列中的所有文件复制到FreeBSD系统的[.filename]#/compat/linux#目录中。复制完成后，创建指向第一列中的文件名的符号链接。

这个例子将在FreeBSD系统上生成以下文件：

[.programlisting]
....
/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -> libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -> libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -> libc.so.4.6.29
....

如果在`ldd`输出的第一列中存在一个与Linux共享库的主要修订号匹配的库，则无需将其复制到最后一列中指定的文件中，因为现有库应该可以正常工作。但是，如果共享库是较新版本，则建议复制它。只要符号链接指向新的库，就可以删除旧的库。

例如，这些库已经存在于FreeBSD系统上：

[.programlisting]
....
/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -> libc.so.4.6.27
....

而`ldd`指示一个二进制文件需要一个较新的版本：

[.programlisting]
....
libc.so.4 (DLL Jump 4.5pl26) -> libc.so.4.6.29
....

由于现有的库只是在最后一位数字上过时了一到两个版本，所以程序应该仍然可以与稍旧的版本一起工作。然而，将现有的 [.filename]#libc.so# 替换为更新的版本是安全的。

[.programlisting]
....
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -> libc.so.4.6.29
....

通常情况下，在FreeBSD上首次安装Linux程序时，需要查找Linux二进制文件所依赖的共享库。然而，随着时间的推移，系统上会积累足够的Linux共享库，可以在安装新的Linux二进制文件时无需额外操作即可运行。

=== 为 Linux ELF 可执行文件进行品牌化

FreeBSD内核使用多种方法来确定要执行的二进制文件是否为Linux文件：它检查ELF文件头中的品牌，查找已知的ELF解释器路径并检查ELF注释；最后，默认情况下，未标记品牌的ELF可执行文件被认为是Linux文件。

如果所有这些方法都失败了，尝试执行二进制文件可能会导致错误消息：

[source, shell]
....
% ./my-linux-elf-binary
....

输出应该类似于以下内容：

[.programlisting]
....
ELF binary type not known
Abort
....

为了帮助FreeBSD内核区分FreeBSD ELF二进制文件和Linux二进制文件，请使用man:brandelf[1]命令。

[source, shell]
....
% brandelf -t Linux my-linux-elf-binary
....

=== 安装基于Linux RPM的应用程序

要安装一个基于Linux RPM的应用程序，首先安装`archivers/rpm4`包或端口。安装完成后，`root`用户可以使用以下命令来安装`.rpm`文件：

[source, shell]
....
# cd /compat/linux
# rpm2cpio < /path/to/linux.archive.rpm | cpio -id
....

如果需要的话，对已安装的ELF二进制文件进行`brandelf`处理。请注意，这将阻止干净卸载。

=== 配置主机名解析器

如果DNS不工作或出现此错误：

[.programlisting]
....
resolv+: "bind" is an invalid keyword resolv+:
"hosts" is an invalid keyword
....

将[.filename]#/compat/linux/etc/host.conf#配置如下：

[.programlisting]
....
order hosts, bind
multi on
....

这指定了首先搜索[.filename]#/etc/hosts#，其次搜索DNS。当[.filename]#/compat/linux/etc/host.conf#不存在时，Linux应用程序使用主机系统中的[.filename]#/etc/host.conf#，但它们会抱怨因为在FreeBSD中该文件不存在。如果没有配置名称服务器，请删除`bind`，使用[.filename]#/etc/resolv.conf#。

[[linuxemu-misc]]
=== 杂项

有关Linux(R)与二进制兼容性的更多信息，请参阅文章链接：{linux-emulation}[FreeBSD中的Linux模拟]。
