<!DOCTYPE html>
<html class="theme-light" lang="zh-cn-auto">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="ZFS 是一种先进的文件系统，旨在解决以前存储子系统软件中存在的主要问题。"/>
  <meta name="keywords" content="91, 34, 90, 70, 83, 34, 44, 32, 34, 102, 105, 108, 101, 115, 121, 115, 116, 101, 109, 34, 44, 32, 34, 97, 100, 109, 105, 110, 105, 115, 116, 114, 97, 116, 105, 111, 110, 34, 44, 32, 34, 122, 112, 111, 111, 108, 34, 44, 32, 34, 102, 101, 97, 116, 117, 114, 101, 115, 34, 44, 32, 34, 116, 101, 114, 109, 105, 110, 111, 108, 111, 103, 121, 34, 44, 32, 34, 82, 65, 73, 68, 45, 90, 34, 93"/>
  <meta name="copyright" content="1995-2023 The FreeBSD Foundation" />
  <link rel="canonical" href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/" />

  <title>第 22 章 Z 文件系统（ ZFS ） |  FreeBSD Documentation Portal</title>

  <meta name="theme-color" content="#790000">
  <meta name="color-scheme" content="system light dark high-contrast">

    <link rel="shortcut icon" href="https://free.bsd-doc.org/favicon.ico">
    <link rel="stylesheet" href="/styles/main.min.css">
    <link rel="stylesheet" href="https://free.bsd-doc.org/css/font-awesome-min.css">
    <script defer src="/js/theme-chooser.min.js"></script>
    <script defer src="/js/copy-clipboard.min.js"></script>
    <script defer src="/js/search.min.js"></script>

  
  
    <meta name="twitter:card" content="summary"/>
    <meta name="twitter:domain" content="docs.FreeBSD.org"/>
    <meta name="twitter:site" content="@freebsd"/>
    <meta name="twitter:url" content="https://twitter.com/freebsd"/>
    <meta property="og:title" content="第 22 章 Z 文件系统（ ZFS ）" />
    <meta property="og:description" content="ZFS 是一种先进的文件系统，旨在解决以前存储子系统软件中存在的主要问题。" />
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://free.bsd-doc.orgfavicon.ico"/>
    <meta property="og:image:alt" content="FreeBSD Logo">
    <meta property="og:locale" content="zh-cn-auto" />
    <meta property="og:url" content="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/" />
    <meta property="og:site_name" content="FreeBSD Documentation Portal" />
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Article",
        "url": "https:\/\/free.bsd-doc.org\/zh-cn-auto\/books\/handbook\/zfs\/",
        "name": "FreeBSD Documentation Portal",
        "headline": "FreeBSD Documentation Portal",
        "description": "FreeBSD Documentation Portal"
      }
    </script>
    

  
</head>


  <body>
    <header>
  <div class="header-container">
    <div class="logo-menu-bars-container">
      <a href="https://free.bsd-doc.org" class="logo">
        <img src="https://free.bsd-doc.org/images/FreeBSD-monochromatic.svg" width="160" height="50" alt="FreeBSD logo" />
      </a>
      <label class="menu-bars" for="menu-bars">
        <i class="fa fa-bars" aria-hidden="true"></i>
      </label>
    </div>
    <input id="menu-bars" type="checkbox" />
    
    <div class="search-donate-container">
      
      <div class="donate">
        <a href="https://github.com/fierceX/freebsd-doc-cn" target="_blank">
          <span class="heart">♥</span>
          GitHub
        </a>
      </div>
    </div>
  </div>
</header>

    
<input type="checkbox" class="hidden toggle" id="menu-control">
<main class="main-wrapper-book">
  <a id="top"></a>
  
  <aside class="book-menu">
    <div class="book-menu-content">
      <input id="search-book" type="text" placeholder="Search" aria-label="Search" maxlength="128" />
      <nav id="MenuContents">
        
  <ul>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-8ada319c45e780947f82b569049480cc" class="toggle"  />
          <label  class="icon cursor"  for="chapter-8ada319c45e780947f82b569049480cc"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/">
              前言
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-audience">预期读者</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-changes-from4">第四版</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-changes-from3">第三版</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-changes-from2">第二版（2004 年）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-changes">第一版（2001 年）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-overview">本书的组织结构</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-conv">本书中使用的约定</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/preface/#preface-acknowledgements">致谢</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-32a83d18a326852a8d9ae2582360bbc8" class="toggle"  />
          <label  for="chapter-32a83d18a326852a8d9ae2582360bbc8"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/parti/">
              第一部分：入门指南
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-a4909db05d872d16d5be86a57cbc2dc7" class="toggle"  />
          <label  class="icon cursor"  for="chapter-a4909db05d872d16d5be86a57cbc2dc7"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/introduction/">
              第一章 引言
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/introduction/#introduction-synopsis">1.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/introduction/#nutshell">1.2. 欢迎来到 FreeBSD ！</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/introduction/#history">1.3. 关于 FreeBSD 项目</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-3c2455cadf89eadd3f6e77461085d5e9" class="toggle"  />
          <label  class="icon cursor"  for="chapter-3c2455cadf89eadd3f6e77461085d5e9"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/">
              第二章 安装 FreeBSD
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-synopsis">2.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-hardware">2.2. 最低硬件要求</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-pre">2.3. 安装前的任务</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-start">2.4. 开始安装</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#using-bsdinstall">2.5. 使用 bsdinstall</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-partitioning">2.6. 分配磁盘空间</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-fetching-distribution">2.7. 获取分发文件</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-post">2.8. 网络接口，账户，时区，服务和加固</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#bsdinstall-install-trouble">2.9. 故障排除</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bsdinstall/#using-live-cd">2.10. 使用 Live CD</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-709481b75d22ad36960f7ac166b3306c" class="toggle"  />
          <label  class="icon cursor"  for="chapter-709481b75d22ad36960f7ac166b3306c"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/">
              第三章. FreeBSD 基础知识
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#basics-synopsis">3.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#consoles">3.2. 虚拟控制台和终端</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#users-synopsis">3.3. 用户和基本账户管理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#permissions">3.4. 权限</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#dirstructure">3.5. 目录结构</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#disk-organization">3.6. 磁盘组织</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#mount-unmount">3.7. 挂载和卸载文件系统</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#basics-processes">3.8. 进程和守护进程</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#shells">3.9. Shells</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#editors">3.10. 文本编辑器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#basics-devices">3.11. 设备和设备节点</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/basics/#basics-more-information">3.12. 手册页</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-58c050d31a1fbecd859248dacefeb567" class="toggle"  />
          <label  class="icon cursor"  for="chapter-58c050d31a1fbecd859248dacefeb567"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/">
              第四章 安装应用程序：软件包和 Ports
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#ports-synopsis">4.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#ports-overview">4.2. 软件安装概述</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#ports-finding-applications">4.3. 寻找软件</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#pkgng-intro">4.4. 使用 pkg 进行二进制包管理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#ports-using">4.5. 使用 Ports 集合</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#ports-poudriere">4.6. 使用 poudriere 构建软件包</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#ports-nextsteps">4.7. 安装后的考虑事项</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ports/#ports-broken">4.8. 处理损坏的 ports</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-e5a000ce7f50680a180e2c1b83c121bc" class="toggle"  />
          <label  class="icon cursor"  for="chapter-e5a000ce7f50680a180e2c1b83c121bc"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/x11/">
              第五章 X Window 系统
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/x11/#x11-synopsis">5.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/x11/#x-install">5.2. 安装 Xorg</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/x11/#x-graphic-card-drivers">5.3. 显卡驱动程序</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/x11/#x-config">5.4. Xorg 配置</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/x11/#x-fonts">5.5. 在 Xorg 中使用字体</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-235af08fb87fd7a58003348706d2111d" class="toggle"  />
          <label  class="icon cursor"  for="chapter-235af08fb87fd7a58003348706d2111d"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/">
              第六章 Wayland
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-synopsis">6.1. Wayland 概述</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-wayfire">6.2. Wayfire 合成器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-hikari">6.3. Hikari Compositor</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-sway">6.4. Sway 合成器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-xwayland">6.5. 使用 Xwayland</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-remotedesktop">6.6. 使用 VNC 进行远程桌面访问</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-ly">6.7. Wayland 登录管理器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wayland/#wayland-utilities">6.8. 有用的工具</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-4de18483dde20bf9ed0024176afd09da" class="toggle"  />
          <label  class="icon cursor"  for="chapter-4de18483dde20bf9ed0024176afd09da"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/">
              第 7 章 网络
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/#network-synopsis">7.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/#config-network-setup">7.2. 设置网络</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/#config-network-connection">7.3. 有线网络</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/#network-wireless">7.4. 无线网络</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/#hostname">7.5. 主机名</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/#dns">7.6. DNS （ Domain Name System ）是一种用于将域名转换为 IP 地址的互联网服务。它充当了互联网上的电话簿，将人类可读的域名（例如 www.example.com ）转换为计算机可理解的 IP 地址（例如 192.0.2.1 ）。 DNS 还负责将域名解析为其他类型的记录，如电子邮件服务器和其他网络服务的地址。通过使用 DNS ，用户可以轻松地访问互联网上的各种资源，而无需记住复杂的 IP 地址。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network/#troubleshooting">7.7. 故障排除</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-5eb30759c3a2873e716dc31d7760054c" class="toggle"  />
          <label  for="chapter-5eb30759c3a2873e716dc31d7760054c"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/partii/">
              第二部分：常见任务
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-c96504f017c56f4bc7f71548cccf5382" class="toggle"  />
          <label  class="icon cursor"  for="chapter-c96504f017c56f4bc7f71548cccf5382"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/">
              第 8 章 桌面环境
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/#desktop-synopsis">8.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/#desktop-environments">8.2. 桌面环境</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/#desktop-browsers">8.3. 浏览器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/#desktop-development">8.4. 开发工具</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/#desktop-productivity">8.5. 桌面办公生产力</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/#desktop-viewers">8.6. 文档查看器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/desktop/#desktop-finance">8.7. 金融</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-e1898af36aaacc168e13b673d25b908f" class="toggle"  />
          <label  class="icon cursor"  for="chapter-e1898af36aaacc168e13b673d25b908f"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/multimedia/">
              第 9 章 多媒体
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/multimedia/#multimedia-synopsis">9.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/multimedia/#sound-setup">9.2. 设置声卡</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/multimedia/#audio-ports">9.3. 音频播放器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/multimedia/#video-ports">9.4. 视频播放器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/multimedia/#conferencing-meetings">9.5. 会议和会议</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/multimedia/#scanners">9.6. 图像扫描仪</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-6926664836e63c5cae4b2fa60855f91d" class="toggle"  />
          <label  class="icon cursor"  for="chapter-6926664836e63c5cae4b2fa60855f91d"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/kernelconfig/">
              第 10 章 配置 FreeBSD 内核
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/kernelconfig/#kernelconfig-synopsis">10.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/kernelconfig/#kernelconfig-custom-kernel">10.2. 为什么要构建自定义内核？</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/kernelconfig/#kernelconfig-devices">10.3. 查找系统硬件</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/kernelconfig/#kernelconfig-config">10.4. 配置文件</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/kernelconfig/#kernelconfig-building">10.5. 构建和安装自定义内核</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/kernelconfig/#kernelconfig-trouble">10.6. 如果出现问题</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-19d36bd70a320268f0ea1f66e4f3e224" class="toggle"  />
          <label  class="icon cursor"  for="chapter-19d36bd70a320268f0ea1f66e4f3e224"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/printing/">
              第 11 章 打印
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/printing/#printing-quick-start">11.1. 快速入门</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/printing/#printing-connections">11.2. 打印机连接</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/printing/#printing-pdls">11.3. 常见的页面描述语言</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/printing/#printing-direct">11.4. 直接打印</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/printing/#printing-lpd">11.5. LPD （ Line Printer Daemon ）是一种用于打印机的网络协议。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/printing/#printing-other">11.6. 其他打印系统</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-a07f539e6c18f2db4da5dbb2b5bb1e79" class="toggle"  />
          <label  class="icon cursor"  for="chapter-a07f539e6c18f2db4da5dbb2b5bb1e79"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/linuxemu/">
              第 12 章 . Linux 二进制兼容性
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/linuxemu/#linuxemu-synopsis">12.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/linuxemu/#linuxemu-lbc-install">12.2. 配置 Linux 二进制兼容性</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/linuxemu/#linux-userlands">12.3. Linux 用户空间</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/linuxemu/#linuxemu-advanced">12.4. 高级主题</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-af234c193ce95c480af0ff5ec3f32f5c" class="toggle"  />
          <label  class="icon cursor"  for="chapter-af234c193ce95c480af0ff5ec3f32f5c"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/">
              第 13 章 WINE
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#wine-synopsis">13.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#wine-overview-concepts">13.2. WINE 概述与概念</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#installing-wine-on-freebsd">13.3. 在 FreeBSD 上安装 WINE</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#running-first-wine-program">13.4. 在 FreeBSD 上运行第一个 WINE 程序</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#configuring-wine-installation">13.5. 配置 WINE 安装</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#wine-management-guis">13.6. WINE 管理图形界面</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#wine-in-multi-user-os-installations">13.7. 在多用户的 FreeBSD 安装中使用 WINE</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/wine/#wine-on-os-faq">13.8. 在 FreeBSD 上使用 WINE 的常见问题解答</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-51416fdea9d5a1dfa1c2718cd825213a" class="toggle"  />
          <label  for="chapter-51416fdea9d5a1dfa1c2718cd825213a"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/partiii/">
              第三部分：系统管理
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-532d0380ba66d66e033765a0b6930ee7" class="toggle"  />
          <label  class="icon cursor"  for="chapter-532d0380ba66d66e033765a0b6930ee7"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/">
              第 14 章 配置、服务、日志和电源管理
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/#config-synopsis">14.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/#configtuning-configfiles">14.2. 配置文件</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/#configtuning-rcd">14.3. 在 FreeBSD 中管理服务</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/#cron-periodic">14.4. Cron 和周期性任务</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/#configtuning-syslog">14.5. 配置系统日志</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/#acpi-overview">14.6. 功耗和资源管理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/config/#adding-swap-space">14.7. 添加交换空间</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-d05f41680fb7e3d68b354ae03de368b1" class="toggle"  />
          <label  class="icon cursor"  for="chapter-d05f41680fb7e3d68b354ae03de368b1"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/boot/">
              第 15 章 . FreeBSD 的启动过程
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/boot/#boot-synopsis">15.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/boot/#boot-introduction">15.2. FreeBSD 引导过程</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/boot/#device-hints">15.3. 设备提示</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/boot/#boot-shutdown">15.4. 关机序列</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-513e8e407c57354df334059688e9b60a" class="toggle"  />
          <label  class="icon cursor"  for="chapter-513e8e407c57354df334059688e9b60a"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/">
              第 16 章 安全
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-synopsis">16.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-intro">16.2. 介绍</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#sec-accounts">16.3. 保护账户安全</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-ids">16.4. 入侵检测系统（ IDS ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-secure-levels">16.5. 安全级别</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-file-flags">16.6. 文件标志</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#openssh">16.7. OpenSSH 是一个用于安全远程登录和文件传输的开源软件套件。它提供了加密的通信通道，以防止未经授权的访问和数据泄露。 OpenSSH 支持 SSH 协议，可以在不同的操作系统上运行，并且具有强大的身份验证和加密功能。它被广泛用于管理远程服务器和保护敏感数据的传输。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#openssl">16.8. OpenSSL 是一个开源的软件库，提供了一套用于安全通信的加密工具。它支持多种加密算法和协议，包括 SSL 和 TLS 。 OpenSSL 广泛用于网络通信、数字证书管理和数据加密等领域。它是一个功能强大且可靠的工具，被广泛应用于各种计算机系统和应用程序中。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#kerberos5">16.9. Kerberos 是一种网络身份验证协议，用于在计算机网络中验证用户的身份。它使用加密技术来确保通信的安全性，并防止身份伪造和中间人攻击。 Kerberos 还提供了单点登录功能，允许用户在一次身份验证后访问多个网络服务。它是计算机领域中常用的身份验证解决方案之一。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#tcpwrappers">16.10. TCP 包装器（ TCP Wrappers ）是一种网络访问控制工具，用于在 TCP/IP 网络上限制对特定服务的访问。它通过检查远程主机的 IP 地址和主机名来决定是否允许连接到受保护的服务。 TCP 包装器可以用于增强网络安全性，防止未经授权的访问和恶意活动。它通常与网络服务（如 SSH 、 FTP 和 Telnet ）一起使用，以提供对这些服务的访问控制。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#fs-acl">16.11. 访问控制列表</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#capsicum">16.12. Capsicum 是一种辣椒植物，属于茄科。它的果实通常被用作调味品和食材，具有辛辣的味道。 Capsicum 也被用于药用目的，具有抗氧化和抗炎作用。它含有丰富的维生素 C 和维生素 A ，对于保持健康非常重要。 Capsicum 在烹饪中被广泛使用，可以用于制作各种菜肴和调味品。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-accounting">16.13. 进程账户</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-resourcelimits">16.14. 资源限制</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-pkg">16.15. 监控第三方安全问题</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/security/#security-advisories">16.16. FreeBSD 安全公告</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-0f7d2858504c83a029928c048d394e2a" class="toggle"  />
          <label  class="icon cursor"  for="chapter-0f7d2858504c83a029928c048d394e2a"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/">
              第 17 章 监狱和容器
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#jails-synopsis">17.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#jail-types">17.2. 监狱类型</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#host-configuration">17.3. 主机配置</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#classic-jail">17.4. 经典监狱（厚重监狱）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#thin-jail">17.5. 薄型监狱</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#jail-management">17.6. 监狱管理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#jail-upgrading">17.7. 监狱升级</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#jail-resource-limits">17.8. 监狱资源限制</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/jails/#jail-managers-and-containers">17.9. 监狱管理员和容器</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-15be125ce5997f51c5499e3a0dee6c2c" class="toggle"  />
          <label  class="icon cursor"  for="chapter-15be125ce5997f51c5499e3a0dee6c2c"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/">
              第 18 章 强制访问控制
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-synopsis">18.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-inline-glossary">18.2. 关键术语</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-understandlabel">18.3. 理解 MAC 标签</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-planning">18.4. 规划安全配置</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-policies">18.5. 可用的 MAC 策略</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-userlocked">18.6. 用户锁定</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-implementing">18.7. 在 MAC 监狱中的 Nagios</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mac/#mac-troubleshoot">18.8. 解决 MAC 框架的问题</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-3f7e8d763b17c7d0c44c60505cf0feea" class="toggle"  />
          <label  class="icon cursor"  for="chapter-3f7e8d763b17c7d0c44c60505cf0feea"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/audit/">
              第 19 章 安全事件审计
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/audit/#audit-synopsis">19.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/audit/#audit-inline-glossary">19.2. 关键术语</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/audit/#audit-config">19.3. 审计配置</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/audit/#audit-administration">19.4. 使用审计跟踪功能</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-7bb1cb2287cd08a3672cc878e604f0d0" class="toggle"  />
          <label  class="icon cursor"  for="chapter-7bb1cb2287cd08a3672cc878e604f0d0"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/">
              第 20 章 存储
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#disks-synopsis">20.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#disks-adding">20.2. 添加磁盘</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#disks-growing">20.3. 调整和扩展磁盘大小</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#usb-disks">20.4. USB 存储设备</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#creating-cds">20.5. 创建和使用 CD 媒体</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#creating-dvds">20.6. 创建和使用 DVD 媒体</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#floppies">20.7. 创建和使用软盘</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#using-ntfs">20.8. 使用 NTFS 磁盘</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#backup-basics">20.9. 备份基础知识</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#disks-virtual">20.10. 内存磁盘</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#snapshots">20.11. 文件系统快照</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#quotas">20.12. 磁盘配额</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#disks-encrypting">20.13. 加密磁盘分区</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#swap-encrypting">20.14. 加密交换分区</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/disks/#disks-hast">20.15. 高可用存储（ Highly Available Storage ， HAST ）</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-dec5fc4f0100e5030db0fb188d8d4b2f" class="toggle"  />
          <label  class="icon cursor"  for="chapter-dec5fc4f0100e5030db0fb188d8d4b2f"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/">
              第 21 章 GEOM ：模块化磁盘转换框架
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-synopsis">21.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-striping">21.2. RAID0 - 条带化</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-mirror">21.3. RAID1 - 镜像</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-raid3">21.4. RAID3 - 以字节为单位的条带化和专用奇偶校验</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-graid">21.5. 软件 RAID 设备</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-ggate">21.6. GEOM Gate Network 是一种计算机网络技术。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-glabel">21.7. 标记磁盘设备</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom/#geom-gjournal">21.8. 通过 GEOM 实现的 UFS 日志记录</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-7f1657a05627dd16bad31d4c7f675604" class="toggle"  checked  />
          <label  class="icon cursor"  for="chapter-7f1657a05627dd16bad31d4c7f675604"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/">
              第 22 章 Z 文件系统（ ZFS ）
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-differences">22.1. ZFS 有何不同之处</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-quickstart">22.2. 快速入门指南</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-zpool">22.3. <code>zpool</code> 管理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-zfs">22.4. <code>zfs</code> 管理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-zfs-allow">22.5. 委派管理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-advanced">22.6. 高级主题</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-links">22.7. 进一步资源</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/zfs/#zfs-term">22.8. ZFS 功能和术语</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-4c6bf6828e601b79edb2813329ac6604" class="toggle"  />
          <label  class="icon cursor"  for="chapter-4c6bf6828e601b79edb2813329ac6604"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/filesystems/">
              第 23 章 其他文件系统
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/filesystems/#filesystems-synopsis">23.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/filesystems/#filesystems-linux">23.2. Linux® 文件系统</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-ae23289d4b6415f3f878893f9d3ef9b8" class="toggle"  />
          <label  class="icon cursor"  for="chapter-ae23289d4b6415f3f878893f9d3ef9b8"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/">
              第 24 章 虚拟化
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/#virtualization-synopsis">24.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/#virtualization-guest-parallelsdesktop">24.2. 在 Parallels Desktop for macOS® 上作为客户机的 FreeBSD</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/#virtualization-guest-vmware">24.3. 在 macOS 上使用 VMware Fusion 作为客户机的 FreeBSD</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/#virtualization-guest-virtualbox">24.4. 在 VirtualBox™ 上作为客户机的 FreeBSD</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/#virtualization-host-virtualbox">24.5. 使用 VirtualBox™ 将 FreeBSD 作为主机</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/#virtualization-host-bhyve">24.6. 使用 bhyve 作为 FreeBSD 主机</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/virtualization/#virtualization-host-xen">24.7. FreeBSD 作为 Xen™ 主机</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-b279d2b738963a45a059268d2fae00d5" class="toggle"  />
          <label  class="icon cursor"  for="chapter-b279d2b738963a45a059268d2fae00d5"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/l10n/">
              第 25 章 本地化 - i18n/L10n 的使用和设置
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/l10n/#l10n-synopsis">25.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/l10n/#using-localization">25.2. 使用本地化</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/l10n/#l10n-compiling">25.3. 寻找国际化应用程序</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/l10n/#lang-setup">25.4. 特定语言的区域配置</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9e3f99bd76c861ab2e9a5f31ac421842" class="toggle"  />
          <label  class="icon cursor"  for="chapter-9e3f99bd76c861ab2e9a5f31ac421842"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/">
              第 26 章 更新和升级 FreeBSD
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#updating-upgrading-synopsis">26.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#updating-upgrading-freebsdupdate">26.2. FreeBSD 更新</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#updating-bootcode">26.3. 更新引导代码</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#updating-upgrading-documentation">26.4. 更新文档集合</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#current-stable">26.5. 跟踪开发分支</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#makeworld">26.6. 从源代码更新 FreeBSD</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#small-lan">26.7. 多台机器的追踪</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/cutting-edge/#building-on-non-freebsd-hosts">26.8. 在非 FreeBSD 主机上构建</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-3ba999091575eb04ae88235cd0fb1afa" class="toggle"  />
          <label  class="icon cursor"  for="chapter-3ba999091575eb04ae88235cd0fb1afa"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/dtrace/">
              第 27 章 DTrace
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/dtrace/#dtrace-synopsis">27.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/dtrace/#dtrace-implementation">27.2. 实现差异</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/dtrace/#dtrace-enable">27.3. 启用 DTrace 支持</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/dtrace/#dtrace-using">27.4. 使用 DTrace</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-bdb217202a0a3eef4571dd1fcd50863c" class="toggle"  />
          <label  class="icon cursor"  for="chapter-bdb217202a0a3eef4571dd1fcd50863c"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/usb-device-mode/">
              第 28 章 USB 设备模式 /USB OTG
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/usb-device-mode/#usb-device-mode-synopsis">28.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/usb-device-mode/#usb-device-mode-terminals">28.2. USB 虚拟串口</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/usb-device-mode/#usb-device-mode-network">28.3. USB 设备模式网络接口</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/usb-device-mode/#usb-device-mode-storage">28.4. USB 虚拟存储设备</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-6d4439926bb106ac084ecc88cfd3cfa4" class="toggle"  />
          <label  for="chapter-6d4439926bb106ac084ecc88cfd3cfa4"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/partiv/">
              第四部分：网络通信
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-05a353fcb61d8e035f7c43e14725766e" class="toggle"  />
          <label  class="icon cursor"  for="chapter-05a353fcb61d8e035f7c43e14725766e"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/serialcomms/">
              第 29 章 串行通信
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/serialcomms/#serial-synopsis">29.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/serialcomms/#serial">29.2. 串行术语和硬件</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/serialcomms/#term">29.3. 终端</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/serialcomms/#dialup">29.4. 拨入服务</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/serialcomms/#dialout">29.5. 拨出服务</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/serialcomms/#serialconsole-setup">29.6. 设置串行控制台</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-7f0cbcbf6701b86eba3bbd6fc829f1b8" class="toggle"  />
          <label  class="icon cursor"  for="chapter-7f0cbcbf6701b86eba3bbd6fc829f1b8"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ppp-and-slip/">
              第 30 章 PPP
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ppp-and-slip/#ppp-and-slip-synopsis">30.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ppp-and-slip/#userppp">30.2. 配置 PPP</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ppp-and-slip/#ppp-troubleshoot">30.3. PPP 连接故障排除</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ppp-and-slip/#pppoe">30.4. 使用以太网上的点对点协议（ PPP over Ethernet ， PPPoE ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/ppp-and-slip/#pppoa">30.5. 使用 ATM 上的 PPP （ PPPoA ）</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9d023b545804f197d195dd9412749943" class="toggle"  />
          <label  class="icon cursor"  for="chapter-9d023b545804f197d195dd9412749943"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/">
              第 31 章 电子邮件
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/#mail-synopsis">31.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/#mail-using">31.2. 邮件组件</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/#dragonFly-mail-agent">31.3. DragonFly Mail Agent （ DMA ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/#sendmail">31.4. Sendmail 是一种用于电子邮件传输的开源软件。它是一种邮件传输代理（ MTA ），用于将电子邮件从发送者的计算机发送到接收者的计算机。 Sendmail 具有广泛的功能和灵活性，可以在各种操作系统上运行，并且被广泛用于互联网上的电子邮件传输。它支持多种邮件协议和格式，并提供了丰富的配置选项，使用户能够根据自己的需求进行定制。 Sendmail 是互联网上最早的邮件传输代理之一，至今仍然被广泛使用。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/#mail-changingmta">31.5. 更改邮件传输代理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/#mail-agents">31.6. 邮件用户代理</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mail/#mail-advanced">31.7. 高级主题</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-42b19e05d30c4135c74b9878818747a9" class="toggle"  />
          <label  class="icon cursor"  for="chapter-42b19e05d30c4135c74b9878818747a9"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/">
              第 32 章 网络服务器
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-servers-synopsis">32.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-inetd">32.2. inetd 超级服务器</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-nfs">32.3. 网络文件系统（ NFS ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-nis">32.4. 网络信息系统（ NIS ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-ldap">32.5. 轻量级目录访问协议（ LDAP ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-dhcp">32.6. 动态主机配置协议（ DHCP ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-dns">32.7. 域名系统（ DNS ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-apache">32.8. Apache HTTP Server 是一个开源的 Web 服务器软件，它是目前最流行的 Web 服务器之一。它由 Apache 软件基金会开发和维护，可运行在多种操作系统上，包括 Windows 、 Linux 和 Unix 等。 Apache HTTP Server 具有高度可扩展性和灵活性，支持多种模块和插件，可以实现各种功能，如动态内容生成、虚拟主机配置和安全性控制等。它还提供了丰富的文档和社区支持，使得用户能够轻松地学习和使用。无论是个人网站还是大型企业应用， Apache HTTP Server 都是一个可靠和强大的选择。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-ftp">32.9. 文件传输协议（ FTP ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-samba">32.10. 适用于 Microsoft® Windows® 客户端的文件和打印服务（ Samba ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-ntp">32.11. 使用 NTP 进行时钟同步</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/network-servers/#network-iscsi">32.12. iSCSI 发起者和目标配置</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9554a5177d00d0e87ada408809a1fc67" class="toggle"  />
          <label  class="icon cursor"  for="chapter-9554a5177d00d0e87ada408809a1fc67"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/firewalls/">
              第 33 章 防火墙
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/firewalls/#firewalls-intro">33.1. 简介</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/firewalls/#firewalls-concepts">33.2. 防火墙概念</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/firewalls/#firewalls-pf">33.3. PF 可以有多种含义，根据上下文不同可能指：</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/firewalls/#firewalls-ipfw">33.4. IPFW 是指 Internet 协议防火墙，是一种用于网络安全的技术。它可以通过过滤和监控网络流量来保护计算机和网络免受恶意攻击和未经授权的访问。 IPFW 可以根据预先定义的规则集来控制网络流量的进出，以实现对网络连接的管理和保护。它是一种常见的防火墙解决方案，被广泛应用于企业和个人网络环境中。</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/firewalls/#firewalls-ipf">33.5. IPFILTER （ IPF ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/firewalls/#firewalls-blacklistd">33.6. 黑名单服务</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-9903a1d844ed803a436595e93ec33572" class="toggle"  />
          <label  class="icon cursor"  for="chapter-9903a1d844ed803a436595e93ec33572"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/">
              第 34 章 . 高级网络
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#advanced-networking-synopsis">34.1. 概要</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-routing">34.2. 网关和路由</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#configtuning-virtual-hosts">34.3. 虚拟主机</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-advanced-wireless">34.4. 无线高级认证</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#wireless-ad-hoc-mode">34.5. 无线自组网模式</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-usb-tethering">34.6. USB 网络共享</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-bluetooth">34.7. 蓝牙</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-bridging">34.8. 桥接</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-aggregation">34.9. 链路聚合和故障转移</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-diskless">34.10. 使用 PXE 进行无盘操作</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#carp">34.11. 常见地址冗余协议（ CARP ）</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/advanced-networking/#network-vlan">34.12. 虚拟局域网（ VLANs ）</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-8ca29f99c249993ee9234cb4632af7a5" class="toggle"  />
          <label  for="chapter-8ca29f99c249993ee9234cb4632af7a5"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/partv/">
              第五部分. 附录
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-0229d553ebf23ffeb945be6f32836221" class="toggle"  />
          <label  for="chapter-0229d553ebf23ffeb945be6f32836221"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/mirrors/">
              附录 A. 获取 FreeBSD
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-743c99fa278b8138914ff018e40c9231" class="toggle"  />
          <label  class="icon cursor"  for="chapter-743c99fa278b8138914ff018e40c9231"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bibliography/">
              附录 B. 参考文献
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bibliography/#bibliography-freebsd">B.1. FreeBSD 参考文献</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bibliography/#bibliography-security">B.2. 安全参考</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bibliography/#bibliography-history">B.3. UNIX® 历史</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/bibliography/#bibliography-journals">B.4. 期刊、杂志和期刊</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-de7eade4b8b64f298c0cbac44c2278da" class="toggle"  />
          <label  class="icon cursor"  for="chapter-de7eade4b8b64f298c0cbac44c2278da"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/eresources/">
              附录 C. 互联网资源
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/eresources/#eresources-www">C.1. 网站</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/eresources/#eresources-mail">C.2. 邮件列表</a></li>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/eresources/#eresources-news">C.3. Usenet 新闻组</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-bfb0d4e71c3c1a18a8b75e03f4b48e26" class="toggle"  />
          <label  class="icon cursor"  for="chapter-bfb0d4e71c3c1a18a8b75e03f4b48e26"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/pgpkeys/">
              附录 D. OpenPGP 密钥
            </a>
            
            
  <ul>
    <li><a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/pgpkeys/#pgpkeys-officers">D.1. 官员们</a></li>
  </ul>

          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-2a8deedf14429128049622ec007c9d3f" class="toggle"  />
          <label  for="chapter-2a8deedf14429128049622ec007c9d3f"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/glossary/">
              FreeBSD 词汇表
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-110dbb242491bf200e51e76db171f670" class="toggle"  />
          <label  for="chapter-110dbb242491bf200e51e76db171f670"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/colophon/">
              后记
            </a>
            
            
          

        
      </li>
    
      <li>
        

          
          
          

          <input type="checkbox" id="chapter-caffbcba74982e4b26b9263ac0232bc3" class="toggle"  />
          <label  for="chapter-caffbcba74982e4b26b9263ac0232bc3"><a role="button"></a></label>

          
            
            <a href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/introduction/">
              
            </a>
            
            
          

        
      </li>
    
      <li>
        
      </li>
    
  </ul>


      </nav>
    </div>
  </aside>
  
  <div class="book">
    
    <div class="book-menu-mobile">
      <label for="menu-control">
        <span class="menu-control-button">
          <i class="fa fa-list" aria-hidden="true" title="Book menu"></i>
          Book menu
        </span>
      </label>
    </div>
    
    <h1 class="title">第 22 章 Z 文件系统（ ZFS ）</h1>
    
    
      <div class="admonitionblock note">
        <p>
          <i class="fa fa-exclamation-circle" aria-hidden="true"></i>
          如果发现翻译错误，请直接 <a href="https://github.com/fierceX/freebsd-doc-cn/pulls" target="_blank">发起PR修改</a>。
        </p>
      </div>
    
    
    
    <div class="toc-mobile">
      <h3>Table of Contents</h3>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#zfs-differences">22.1. ZFS 有何不同之处</a></li>
    <li><a href="#zfs-quickstart">22.2. 快速入门指南</a></li>
    <li><a href="#zfs-zpool">22.3. <code>zpool</code> 管理</a></li>
    <li><a href="#zfs-zfs">22.4. <code>zfs</code> 管理</a></li>
    <li><a href="#zfs-zfs-allow">22.5. 委派管理</a></li>
    <li><a href="#zfs-advanced">22.6. 高级主题</a></li>
    <li><a href="#zfs-links">22.7. 进一步资源</a></li>
    <li><a href="#zfs-term">22.8. ZFS 功能和术语</a></li>
  </ul>
</nav>
    </div>
    
      
      
    
    <div class="book-content">
      <div id="preamble">
<div class="sectionbody">

<div class="paragraph">
<p>ZFS 是一种先进的文件系统，旨在解决以前存储子系统软件中存在的主要问题。</p>
</div>
<div class="paragraph">
<p>最初由 Sun™ 开发，持续的开源 ZFS 开发已经转移到了 <a href="http://open-zfs.org">OpenZFS 项目</a> 。</p>
</div>
<div class="paragraph">
<p>ZFS 有三个主要的设计目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据完整性：所有数据都包含数据的校验和。 ZFS 会计算校验和并将其与数据一起写入。当以后读取该数据时， ZFS 会重新计算校验和。如果校验和不匹配，即检测到一个或多个数据错误， ZFS 将尝试在可用的副本、镜像或奇偶块时自动纠正错误。</p>
</li>
<li>
<p>汇集存储：将物理存储设备添加到一个池中，并从该共享池中分配存储空间。空间可供所有文件系统和卷使用，并通过添加新的存储设备到池中来增加。</p>
</li>
<li>
<p>性能：缓存机制提供了更高的性能。 <a href="#zfs-term-arc ">ARC</a> 是一种先进的基于内存的读取缓存。 ZFS 提供了第二级基于磁盘的读取缓存 <a href="#zfs-term-l2arc ">L2ARC</a> ，以及一种基于磁盘的同步写入缓存，名为 <a href="#zfs-term-zil ">ZIL</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>完整的功能和术语列表请参见 <a href="#zfs-term">ZFS 功能和术语</a> 。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-differences">22.1. ZFS 有何不同之处<a class="anchor" href="#zfs-differences"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>ZFS 不仅仅是一个文件系统，它在根本上与传统的文件系统有所不同。将卷管理器和文件系统的传统分离角色结合起来，为 ZFS 提供了独特的优势。文件系统现在能够意识到底层磁盘的结构。传统的文件系统一次只能存在于单个磁盘上。如果有两个磁盘，那么就需要创建两个单独的文件系统。传统的硬件 RAID 配置通过将操作系统呈现为由物理磁盘提供的空间组成的单个逻辑磁盘来避免这个问题，操作系统在其上放置一个文件系统。即使使用像 GEOM 提供的软件 RAID 解决方案，位于 RAID 之上的 UFS 文件系统也认为它正在处理一个单一设备。 ZFS 的卷管理器和文件系统的组合解决了这个问题，并允许创建共享可用存储池的文件系统。 ZFS 意识到物理磁盘布局的一个重要优势是，当向池中添加额外的磁盘时，现有的文件系统会自动增长。然后，这个新空间就可以供文件系统使用。 ZFS 还可以为每个文件系统应用不同的属性。这使得创建单独的文件系统和数据集比创建单个的整体文件系统更有用。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-quickstart">22.2. 快速入门指南<a class="anchor" href="#zfs-quickstart"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>FreeBSD 可以在系统初始化期间挂载 ZFS 池和数据集。要启用它，请将以下行添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>zfs_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后启动服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service zfs start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>本节中的示例假设有三个 SCSI 磁盘，设备名称分别为 <span class="filename">da0</span> 、 <span class="filename">da1</span> 和 <span class="filename">da2</span> 。使用 SATA 硬件的用户应该使用 <span class="filename">ada</span> 设备名称。</p>
</div>
<div class="sect2">
<h3 id="zfs-quickstart-single-disk-pool">22.2.1. 单磁盘池<a class="anchor" href="#zfs-quickstart-single-disk-pool"></a></h3>
<div class="paragraph">
<p>要使用单个磁盘设备创建一个简单且非冗余的池，请按以下步骤操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create example /dev/da0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要查看新的存储池，请查看 <code>df</code> 命令的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个输出显示了创建和挂载 <code>example</code> 池，并且现在可以作为文件系统访问。为用户创建文件以供浏览：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /example</span>
<span class="c"># ls</span>
<span class="c"># touch testfile</span>
<span class="c"># ls -al</span>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile</code></pre>
</div>
</div>
<div class="paragraph">
<p>此池尚未使用任何高级的 ZFS 功能和属性。要在此池上创建启用了压缩的数据集，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create example/compressed</span>
<span class="c"># zfs set compression=gzip example/compressed</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>example/compressed</code> 数据集现在是一个 ZFS 压缩文件系统。尝试将一些大文件复制到 <code>/example/compressed</code> 。</p>
</div>
<div class="paragraph">
<p>禁用压缩功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set compression=off example/compressed</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要卸载文件系统，请使用 <code>zfs umount</code> 命令，然后使用 <code>df</code> 命令进行验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs umount example/compressed</span>
<span class="c"># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example</code></pre>
</div>
</div>
<div class="paragraph">
<p>要重新挂载文件系统以使其再次可访问，请使用 <code>zfs mount</code> 命令，并使用 <code>df</code> 命令进行验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs mount example/compressed</span>
<span class="c"># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行 <code>mount</code> 命令会显示池和文件系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount</span>
/dev/ad0s1a on / <span class="o">(</span>ufs, <span class="nb">local</span><span class="o">)</span>
devfs on /dev <span class="o">(</span>devfs, <span class="nb">local</span><span class="o">)</span>
/dev/ad0s1d on /usr <span class="o">(</span>ufs, <span class="nb">local</span>, soft-updates<span class="o">)</span>
example on /example <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span>
example/compressed on /example/compressed <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建后，可以像任何文件系统一样使用 ZFS 数据集。根据需要，可以在每个数据集上设置其他可用的功能。下面的示例创建了一个名为 <code>data</code> 的新文件系统。它假设该文件系统包含重要文件，并将其配置为存储每个数据块的两个副本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create example/data</span>
<span class="c"># zfs set copies=2 example/data</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>df</code> 命令查看数据和空间使用情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，池中的所有文件系统都具有相同的可用空间。在这些示例中使用 <code>df</code> 命令显示，文件系统使用它们所需的空间，并且都从同一个池中获取。 ZFS 摒弃了卷和分区等概念，允许多个文件系统共享同一个池。</p>
</div>
<div class="paragraph">
<p>销毁不再需要的文件系统和池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs destroy example/compressed</span>
<span class="c"># zfs destroy example/data</span>
<span class="c"># zpool destroy example</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-quickstart-raid-z">22.2.2. RAID-Z<a class="anchor" href="#zfs-quickstart-raid-z"></a></h3>
<div class="paragraph">
<p>磁盘会出现故障。避免因磁盘故障导致数据丢失的一种方法是使用 RAID 。 ZFS 在其存储池设计中支持此功能。 RAID-Z 存储池需要三个或更多的磁盘，但提供比镜像存储池更多的可用空间。</p>
</div>
<div class="paragraph">
<p>这个示例创建了一个 RAID-Z 池，指定要添加到池中的磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create storage raidz da0 da1 da2</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Sun™ 建议在 RAID-Z 配置中使用的设备数量应在三到九之间。对于需要由 10 个或更多磁盘组成的单个池的环境，考虑将其分成较小的 RAID-Z 组。如果有两个磁盘可用，可以使用 ZFS 镜像提供冗余性（如果需要）。有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的示例创建了名为 <code>storage</code> 的 <code>zpool</code> 。这个示例在该池中创建了一个名为 <code>home</code> 的新文件系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create storage/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启用压缩并存储目录和文件的额外副本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set copies=2 storage/home</span>
<span class="c"># zfs set compression=gzip storage/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要将此目录设置为用户的新家目录，请将用户数据复制到此目录并创建相应的符号链接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp -rp /home/* /storage/home</span>
<span class="c"># rm -rf /home /usr/home</span>
<span class="c"># ln -s /storage/home /home</span>
<span class="c"># ln -s /storage/home /usr/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>用户数据现在存储在新创建的 <span class="filename">/storage/home</span> 上。通过添加一个新用户并以该用户身份登录来进行测试。</p>
</div>
<div class="paragraph">
<p>创建一个文件系统快照，以便以后可以回滚：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot storage/home@08-30-08</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ZFS 创建数据集的快照，而不是单个目录或文件。</p>
</div>
<div class="paragraph">
<p>` @ ` 字符是文件系统名称或卷名称之间的分隔符。在删除重要目录之前，先备份文件系统，然后回滚到一个早期的快照，其中目录仍然存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs rollback storage/home@08-30-08</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要列出所有可用的快照，请在文件系统的 <code>.zfs/snapshot</code> 目录中运行 <code>ls</code> 命令。例如，要查看已拍摄的快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls /storage/home/.zfs/snapshot</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编写一个脚本来定期对用户数据进行快照。随着时间的推移，快照可能会占用大量的磁盘空间。使用以下命令删除先前的快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs destroy storage/home@08-30-08</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>经过测试，使用以下命令将 <span class="filename">/storage/home</span> 设置为真实的 <span class="filename">/home</span> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set mountpoint=/home storage/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>运行 <code>df</code> 和 <code>mount</code> 命令来确认系统现在将文件系统视为真实的 <span class="filename">/home</span> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount</span>
/dev/ad0s1a on / <span class="o">(</span>ufs, <span class="nb">local</span><span class="o">)</span>
devfs on /dev <span class="o">(</span>devfs, <span class="nb">local</span><span class="o">)</span>
/dev/ad0s1d on /usr <span class="o">(</span>ufs, <span class="nb">local</span>, soft-updates<span class="o">)</span>
storage on /storage <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span>
storage/home on /home <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span>
<span class="c"># df</span>
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样就完成了 RAID-Z 的配置。通过将以下行添加到 <span class="filename">/etc/periodic.conf</span> ，可以将关于创建的文件系统的每日状态更新添加到夜间的 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 运行中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>daily_status_zfs_enable=&#34;YES&#34;</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-quickstart-recovering-raid-z">22.2.3. 恢复 RAID-Z<a class="anchor" href="#zfs-quickstart-recovering-raid-z"></a></h3>
<div class="paragraph">
<p>每个软件 RAID 都有一种监控其 <code>state</code> 的方法。使用以下命令查看 RAID-Z 设备的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status -x</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果所有池都处于在线状态，并且一切正常，消息将显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">all pools are healthy</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果出现问题，比如磁盘处于离线状态（ <a href="#zfs-term-offline ">Offline</a> ），池的状态将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist <span class="k">for </span>the pool to <span class="k">continue </span>functioning <span class="k">in </span>a
	degraded state.
action: Online the device using <span class="s1">&#39;zpool online&#39;</span> or replace the device with
	<span class="s1">&#39;zpool replace&#39;</span>.
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#34;OFFLINE&#34;显示管理员使用以下方式将 <span class="filename">da1</span> 下线：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool offline storage da1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>立即关闭计算机并更换 <span class="filename">da1</span> 。重新启动计算机并将 <span class="filename">da1</span> 返回到池中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool replace storage da1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，再次检查状态，这次不使用 <code>-x</code> 选项以显示所有的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，一切都正常。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-quickstart-data-verification">22.2.4. 数据验证<a class="anchor" href="#zfs-quickstart-data-verification"></a></h3>
<div class="paragraph">
<p>ZFS 使用校验和来验证存储数据的完整性。创建文件系统时会自动启用校验和功能。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>禁用校验和是可能的，但 <strong> 不推荐 </strong> ！校验和占用很少的存储空间，并提供数据完整性。大多数 ZFS 功能在禁用校验和的情况下将无法正常工作。禁用这些校验和不会明显提高性能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>验证数据校验和（称为“ scrubbing ”）可以确保 <code>storage</code> 池的完整性，具体操作如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool scrub storage</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个 scrub 的持续时间取决于存储的数据量。数据量越大，验证所需的时间就越长。由于 scrub 是 I/O 密集型操作， ZFS 只允许同时运行一个 scrub 。在 scrub 完成后，可以使用 <code>zpool status</code> 命令查看状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示最后一次清洗的完成日期有助于决定何时开始下一次清洗。例行清洗有助于保护数据免受静默损坏，并确保池的完整性。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> 了解其他 ZFS 选项。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-zpool">22.3. <code>zpool</code> 管理<a class="anchor" href="#zfs-zpool"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>ZFS 管理使用两个主要工具。 <code>zpool</code> 工具控制池的操作，允许添加、删除、替换和管理磁盘。 <code>zfs</code> 工具允许创建、销毁和管理数据集，包括文件系统和卷。</p>
</div>
<div class="sect2">
<h3 id="zfs-zpool-create">22.3.1. 创建和销毁存储池<a class="anchor" href="#zfs-zpool-create"></a></h3>
<div class="paragraph">
<p>创建一个 ZFS 存储池需要做出永久性的决策，因为在创建后无法更改池的结构。最重要的决策是将物理磁盘分组成哪种类型的 vdev 。有关可能选项的详细信息，请参阅 <a href="#zfs-term-vdev ">vdev 类型 </a> 列表。创建池后，大多数 vdev 类型不允许向 vdev 添加磁盘。例外情况是镜像，它允许向 vdev 添加新磁盘，并且条带可以通过将新磁盘附加到 vdev 来升级为镜像。虽然添加新的 vdev 可以扩展池，但池的布局在创建后无法更改。相反，备份数据，销毁池，然后重新创建池。</p>
</div>
<div class="paragraph">
<p>创建一个简单的镜像池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create mypool mirror /dev/ada1 /dev/ada2</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用单个命令创建多个 vdev ，请使用以 vdev 类型关键字 <code>mirror</code> 分隔的磁盘组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>池还可以使用分区而不是整个磁盘。将 ZFS 放在单独的分区中可以使同一磁盘具有其他用途的分区。特别是，它允许添加带有引导代码和用于引导的文件系统的分区。这允许从也是池成员的磁盘引导。在 FreeBSD 上，使用分区而不是整个磁盘时， ZFS 不会带来性能损失。使用分区还允许管理员对磁盘进行“欠配置”，使用不到全部容量。如果将来替换的磁盘与原始磁盘的名义大小相同，但实际容量略小，较小的分区仍将适应替换磁盘。</p>
</div>
<div class="paragraph">
<p>使用分区创建一个 <a href="#zfs-term-vdev-raidz ">RAID-Z2</a> 池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>销毁一个不再需要的池以重用磁盘。销毁池需要先卸载该池中的文件系统。如果有任何数据集正在使用中，卸载操作将失败，不会销毁池。可以使用“ -f ”强制销毁池。这可能会导致应用程序中对这些数据集有打开文件的未定义行为。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-attach">22.3.2. 添加和移除设备<a class="anchor" href="#zfs-zpool-attach"></a></h3>
<div class="paragraph">
<p>有两种方法可以将磁盘添加到池中：使用 <code>zpool attach</code> 将磁盘附加到现有的 vdev 上，或者使用 <code>zpool add</code> 将 vdev 添加到池中。一些 <a href="#zfs-term-vdev ">vdev 类型 </a> 允许在创建后向 vdev 添加磁盘。</p>
</div>
<div class="paragraph">
<p>使用单个磁盘创建的池缺乏冗余性。它可以检测到损坏，但无法修复，因为没有其他数据的副本。 <a href="#zfs-term-copies ， copies">[zfs-term-copies ， copies]</a> 属性可以从小故障（如坏扇区）中恢复，但不提供与镜像或 RAID-Z 相同级别的保护。从由单个磁盘 vdev 组成的池开始，使用 <code>zpool attach</code> 将新磁盘添加到 vdev 中，创建镜像。还可以使用 <code>zpool attach</code> 将新磁盘添加到镜像组，增加冗余性和读取性能。在为池分区的磁盘上，将第一个磁盘的布局复制到第二个磁盘上。使用 <code>gpart backup</code> 和 <code>gpart restore</code> 可以使这个过程更容易。</p>
</div>
<div class="paragraph">
<p>通过连接 ada1p3 ，将单个磁盘（条带） vdev ada0p3 升级为镜像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          ada0p3    ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool attach mypool ada0p3 ada1p3</span>
Make sure to <span class="nb">wait </span><span class="k">until </span>resilvering finishes before rebooting.

If you boot from pool <span class="s1">&#39;mypool&#39;</span>, you may need to update boot code on newly attached disk _ada1p3_.

Assuming you use GPT partitioning and _da0_ is your new boot disk you may use the following <span class="nb">command</span>:

        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span>
bootcode written to ada1
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class="k">continue </span>to <span class="k">function</span>, possibly <span class="k">in </span>a degraded state.
action: Wait <span class="k">for </span>the resilver to complete.
  scan: resilver <span class="k">in </span>progress since Fri May 30 08:19:19 2014
        527M scanned out of 781M at 47.9M/s, 0h0m to go
        527M resilvered, 67.53% <span class="k">done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0  <span class="o">(</span>resilvering<span class="o">)</span>

errors: No known data errors
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:15:58 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>当无法将磁盘添加到现有的 vdev 时，例如对于 RAID-Z ，一种替代方法是向池中添加另一个 vdev 。添加 vdev 可以通过在 vdev 之间分布写操作来提供更高的性能。每个 vdev 都提供自己的冗余性。可以混合使用 <code>mirror</code> 和 <code>RAID-Z</code> 等不同类型的 vdev ，但不建议这样做。向包含镜像或 RAID-Z vdev 的池中添加一个非冗余的 vdev 会对整个池中的数据造成风险。分布写操作意味着非冗余磁盘的故障将导致丢失对池中每个块的一部分数据。</p>
</div>
<div class="paragraph">
<p>ZFS 将数据跨越每个 vdev 进行条带化。例如，使用两个镜像 vdev ，这实际上是一个 RAID 10 ，将写操作跨越两组镜像。 ZFS 分配空间以使每个 vdev 在同一时间达到 100 ％的使用率。如果 vdev 具有不同数量的可用空间，性能将降低，因为更多的数据写入将发送到使用率较低的 vdev 。</p>
</div>
<div class="paragraph">
<p>在将新设备连接到引导池时，请记得更新引导代码。</p>
</div>
<div class="paragraph">
<p>将第二个镜像组（ <span class="filename">ada2p3</span> 和 <span class="filename">ada3p3</span> ）附加到现有的镜像中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:19:35 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool add mypool mirror ada2p3 ada3p3</span>
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
bootcode written to ada2
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3</span>
bootcode written to ada3
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>从池中删除 vdev 是不可能的，如果剩余的冗余足够，从镜像中删除磁盘是独占的。如果镜像组中只剩下一个磁盘，该组将不再是镜像，而变成条带，如果该剩余磁盘故障，将会危及整个池。</p>
</div>
<div class="paragraph">
<p>从三路镜像组中移除一个磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool detach mypool ada2p3</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-status">22.3.3. 检查池的状态<a class="anchor" href="#zfs-zpool-status"></a></h3>
<div class="paragraph">
<p>池状态非常重要。如果驱动器离线或 ZFS 检测到读取、写入或校验错误，相应的错误计数会增加。 <code>status</code> 输出显示了池中每个设备的配置和状态，以及整个池的状态。还显示了要采取的操作和有关上次 <code>scrub</code> 的详细信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>2h25m with 0 errors on Sat Sep 14 04:25:50 2013
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-clear">22.3.4. 清除错误<a class="anchor" href="#zfs-zpool-clear"></a></h3>
<div class="paragraph">
<p>当检测到错误时， ZFS 会增加读取、写入或校验和错误计数。使用 <code>zpool clear <em>mypool</em></code> 命令清除错误消息并重置计数。清除错误状态对于自动化脚本非常重要，这些脚本在池遇到错误时会通知管理员。如果不清除旧错误，这些脚本可能无法报告后续的错误。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-replace">22.3.5. 替换一个正常工作的设备<a class="anchor" href="#zfs-zpool-replace"></a></h3>
<div class="paragraph">
<p>可能需要用不同的磁盘替换一个磁盘。当替换一个工作中的磁盘时，该过程会在替换期间保持旧磁盘在线。池永远不会进入 <a href="#zfs-term-degraded ">degraded</a> 状态，从而降低数据丢失的风险。运行 <code>zpool replace</code> 命令将数据从旧磁盘复制到新磁盘。操作完成后， ZFS 会将旧磁盘与 vdev 断开连接。如果新磁盘比旧磁盘大，可能可以使用新空间来扩展 zpool 。请参见 <a href="#zfs-zpool-online ">扩展池 </a> 。</p>
</div>
<div class="paragraph">
<p>替换池中的一个正常工作设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool replace mypool ada1p3 ada2p3</span>
Make sure to <span class="nb">wait </span><span class="k">until </span>resilvering finishes before rebooting.

When booting from the pool <span class="s1">&#39;zroot&#39;</span>, update the boot code on the newly attached disk <span class="s1">&#39;ada2p3&#39;</span>.

Assuming GPT partitioning is used and <span class="o">[</span>.filename]#da0# is the new boot disk, use the following <span class="nb">command</span>:

        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class="k">continue </span>to <span class="k">function</span>, possibly <span class="k">in </span>a degraded state.
action: Wait <span class="k">for </span>the resilver to complete.
  scan: resilver <span class="k">in </span>progress since Mon Jun  2 14:21:35 2014
        604M scanned out of 781M at 46.5M/s, 0h0m to go
        604M resilvered, 77.39% <span class="k">done
</span>config:

        NAME             STATE     READ WRITE CKSUM
        mypool           ONLINE       0     0     0
          mirror-0       ONLINE       0     0     0
            ada0p3       ONLINE       0     0     0
            replacing-1  ONLINE       0     0     0
              ada1p3     ONLINE       0     0     0
              ada2p3     ONLINE       0     0     0  <span class="o">(</span>resilvering<span class="o">)</span>

errors: No known data errors
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Mon Jun  2 14:21:52 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-resilver">22.3.6. 处理故障设备<a class="anchor" href="#zfs-zpool-resilver"></a></h3>
<div class="paragraph">
<p>当池中的磁盘发生故障时，该磁盘所属的 vdev 将进入降级状态。数据仍然可用，但性能降低，因为 ZFS 会通过可用的冗余计算缺失的数据。为了将 vdev 恢复到完全功能状态，需要替换故障的物理设备。然后， ZFS 会开始重新同步操作。 ZFS 会通过可用的冗余重新计算故障设备上的数据，并将其写入替代设备。完成后， vdev 将返回在线状态。</p>
</div>
<div class="paragraph">
<p>如果 vdev 没有任何冗余，或者设备已经损坏且没有足够的冗余来弥补，那么存储池将进入“故障”状态。除非有足够的设备重新连接存储池，否则存储池将无法运行，需要从备份中恢复数据。</p>
</div>
<div class="paragraph">
<p>当替换一个失败的磁盘时，失败磁盘的名称会变为新磁盘的 GUID 。如果替换设备具有相同的设备名称，则不需要为 <code>zpool replace</code> 指定新的设备名称参数。</p>
</div>
<div class="paragraph">
<p>使用 <code>zpool replace</code> 命令替换故障的磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices could not be opened.  Sufficient replicas exist <span class="k">for
        </span>the pool to <span class="k">continue </span>functioning <span class="k">in </span>a degraded state.
action: Attach the missing device and online it using <span class="s1">&#39;zpool online&#39;</span>.
   see: http://illumos.org/msg/ZFS-8000-2Q
  scan: none requested
config:

        NAME                    STATE     READ WRITE CKSUM
        mypool                  DEGRADED     0     0     0
          mirror-0              DEGRADED     0     0     0
            ada0p3              ONLINE       0     0     0
            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3

errors: No known data errors
<span class="c"># zpool replace mypool 316502962686821739 ada2p3</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices is currently being resilvered.  The pool will
        <span class="k">continue </span>to <span class="k">function</span>, possibly <span class="k">in </span>a degraded state.
action: Wait <span class="k">for </span>the resilver to complete.
  scan: resilver <span class="k">in </span>progress since Mon Jun  2 14:52:21 2014
        641M scanned out of 781M at 49.3M/s, 0h0m to go
        640M resilvered, 82.04% <span class="k">done
</span>config:

        NAME                        STATE     READ WRITE CKSUM
        mypool                      DEGRADED     0     0     0
          mirror-0                  DEGRADED     0     0     0
            ada0p3                  ONLINE       0     0     0
            replacing-1             UNAVAIL      0     0     0
              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old
              ada2p3                ONLINE       0     0     0  <span class="o">(</span>resilvering<span class="o">)</span>

errors: No known data errors
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Mon Jun  2 14:52:38 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-scrub">22.3.7. 清洁游泳池<a class="anchor" href="#zfs-zpool-scrub"></a></h3>
<div class="paragraph">
<p>定期对池进行 <a href="#zfs-term-scrub ">scrub</a> 操作，最好每个月至少一次。 <code>scrub</code> 操作对磁盘的使用较高，运行时会降低性能。在安排 <code>scrub</code> 操作时避免高负载时段，或者使用 <a href="#zfs-advanced-tuning-scrub_delay "><code>vfs.zfs.scrub_delay</code></a> 来调整 <code>scrub</code> 操作的相对优先级，以防止其影响其他工作负载的速度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool scrub mypool</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub <span class="k">in </span>progress since Wed Feb 19 20:52:54 2014
        116G scanned out of 8.60T at 649M/s, 3h48m to go
        0 repaired, 1.32% <span class="k">done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要取消一个 scrub 操作，请运行 <code>zpool scrub -s <em>mypool</em></code> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-selfheal">22.3.8. 自愈<a class="anchor" href="#zfs-zpool-selfheal"></a></h3>
<div class="paragraph">
<p>存储在数据块中的校验和使文件系统能够自我修复。这个功能会自动修复数据，如果其校验和与存储池中另一个设备上记录的校验和不匹配。例如，一个具有两个磁盘的镜像配置，其中一个驱动器开始出现故障，无法正确存储数据。当数据长时间未被访问时，如长期存档存储，情况会更糟。传统的文件系统需要运行检查和修复数据的命令，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 。这些命令需要时间，在严重情况下，管理员必须决定执行哪个修复操作。当 ZFS 检测到一个数据块的校验和不匹配时，它会尝试从镜像磁盘中读取数据。如果该磁盘能提供正确的数据， ZFS 将将其提供给应用程序，并纠正具有错误校验和的磁盘上的数据。在正常存储池操作期间，这一切都在没有任何系统管理员干预的情况下发生。</p>
</div>
<div class="paragraph">
<p>下一个示例通过创建一个镜像磁盘池来展示这种自愈行为，其中包括 <span class="filename">/dev/ada0</span> 和 <span class="filename">/dev/ada1</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create healer mirror /dev/ada0 /dev/ada1</span>
<span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: none requested
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool list</span>
NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>将一些重要数据复制到池中，以使用自愈功能保护免受数据错误，并为池创建校验和以备后续比较。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /some/important/data /healer</span>
<span class="c"># zfs list</span>
NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT
healer   960M  67.7M   892M     7%  1.00x  ONLINE  -
<span class="c"># sha1 /healer &gt; checksum.txt</span>
<span class="c"># cat checksum.txt</span>
SHA1 <span class="o">(</span>/healer<span class="o">)</span> <span class="o">=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过向镜像中的一个磁盘的开头写入随机数据来模拟数据损坏。为了防止 ZFS 在检测到数据损坏时修复数据，可以在损坏之前导出池，并在之后重新导入。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这是一个危险的操作，可能会破坏重要数据，仅用于演示目的。在存储池的正常运行期间，请 * 不要尝试 * 执行此操作。此意外损坏示例也不应在任何使用 ZFS 以外的文件系统的磁盘上运行，该磁盘上的另一个分区中也不应该有 ZFS 。请不要使用除了存储池中的设备名称之外的任何其他磁盘设备名称。确保存储池有适当的备份，并在执行命令之前对其进行测试！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool export healer</span>
<span class="c"># dd if=/dev/random of=/dev/ada1 bs=1m count=200</span>
200+0 records <span class="k">in
</span>200+0 records out
209715200 bytes transferred <span class="k">in </span>62.992162 secs <span class="o">(</span>3329227 bytes/sec<span class="o">)</span>
<span class="c"># zpool import healer</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>池状态显示一个设备发生了错误。请注意，从池中读取数据的应用程序没有接收到任何错误数据。 ZFS 从 <code>.filename</code><mark>ada0</mark> 设备提供了正确校验和的数据。要找到校验和错误的设备，请查找 <code>CKSUM</code> 列中包含非零值的设备。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status healer</span>
    pool: healer
   state: ONLINE
  status: One or more devices has experienced an unrecoverable error.  An
          attempt was made to correct the error.  Applications are unaffected.
  action: Determine <span class="k">if </span>the device needs to be replaced, and clear the errors
          using <span class="s1">&#39;zpool clear&#39;</span> or replace the device with <span class="s1">&#39;zpool replace&#39;</span>.
     see: http://illumos.org/msg/ZFS-8000-4J
    scan: none requested
  config:

      NAME        STATE     READ WRITE CKSUM
      healer      ONLINE       0     0     0
        mirror-0  ONLINE       0     0     0
         ada0     ONLINE       0     0     0
         ada1     ONLINE       0     0     1

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>ZFS 检测到错误，并通过使用未受影响的 <span class="filename">ada0</span> 镜像磁盘中的冗余来处理该错误。通过与原始数据进行校验比较，可以确定池是否恢复一致。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sha1 /healer &gt;&gt; checksum.txt</span>
<span class="c"># cat checksum.txt</span>
SHA1 <span class="o">(</span>/healer<span class="o">)</span> <span class="o">=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f
SHA1 <span class="o">(</span>/healer<span class="o">)</span> <span class="o">=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre>
</div>
</div>
<div class="paragraph">
<p>在故意篡改之前和之后生成校验和，同时池数据仍然匹配。这显示了当校验和不同时， ZFS 能够自动检测和纠正任何错误。请注意，这需要池中具有足够的冗余。由单个设备组成的池没有自我修复能力。这也是为什么在 ZFS 中校验和如此重要的原因；不要出于任何原因禁用它们。 ZFS 不需要 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 或类似的文件系统一致性检查程序来检测和纠正这个问题，并且在出现问题时保持池可用。现在需要进行一次 scrub 操作来覆盖在 <span class="filename">ada1</span> 上的损坏数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool scrub healer</span>
<span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
            attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class="k">if </span>the device needs to be replaced, and clear the errors
            using <span class="s1">&#39;zpool clear&#39;</span> or replace the device with <span class="s1">&#39;zpool replace&#39;</span>.
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub <span class="k">in </span>progress since Mon Dec 10 12:23:30 2012
        10.4M scanned out of 67.0M at 267K/s, 0h3m to go
        9.63M repaired, 15.56% <span class="k">done
</span>config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0   627  <span class="o">(</span>repairing<span class="o">)</span>

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Scrub 操作从 ada0 读取数据，并将任何具有错误校验和的数据重写到 ada1 上，这可以通过 zpool status 中的 <code>(repairing)</code> 输出来显示。操作完成后，池的状态将发生变化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
        attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class="k">if </span>the device needs to be replaced, and clear the errors
             using <span class="s1">&#39;zpool clear&#39;</span> or replace the device with <span class="s1">&#39;zpool replace&#39;</span>.
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub repaired 66.5M <span class="k">in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0 2.72K

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>在从 ada0 同步所有数据到 ada1 后，完成了清洗操作，请通过运行 <code>zpool clear</code> 命令清除池状态中的错误消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool clear healer</span>
<span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: scrub repaired 66.5M <span class="k">in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，池已经恢复到完全正常的状态，所有错误计数都为零。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-online">22.3.9. 扩大人才库<a class="anchor" href="#zfs-zpool-online"></a></h3>
<div class="paragraph">
<p>每个 vdev 中最小的设备限制了冗余池的可用大小。用一个更大的设备替换最小的设备。在完成 <a href="#zfs-zpool-replace ">replace</a> 或 <a href="#zfs-term-resilver ">resilver</a> 操作后，池可以扩展到使用新设备的容量。例如，考虑一个由 1 TB 驱动器和 2 TB 驱动器组成的镜像。可用空间为 1 TB 。当用另一个 2 TB 驱动器替换 1 TB 驱动器时，重新同步过程将现有数据复制到新驱动器上。由于两个设备现在都具有 2 TB 的容量，镜像的可用空间增长到 2 TB 。</p>
</div>
<div class="paragraph">
<p>通过在每个设备上使用 <code>zpool online -e</code> 来开始扩展。在扩展所有设备之后，额外的空间将可用于池。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-import">22.3.10. 导入和导出存储池<a class="anchor" href="#zfs-zpool-import"></a></h3>
<div class="paragraph">
<p>在将存储池移动到另一个系统之前，请先导出它们。 ZFS 会卸载所有数据集，并将每个设备标记为已导出，但仍然锁定以防止其他磁盘使用。这使得存储池可以在其他支持 ZFS 的机器、其他操作系统甚至不同的硬件架构上导入（有一些注意事项，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> ）。当数据集有打开的文件时，请使用 <code>zpool export -f</code> 强制导出存储池。请谨慎使用此功能。数据集将被强制卸载，可能导致那些数据集上有打开文件的应用程序出现意外行为。</p>
</div>
<div class="paragraph">
<p>导出一个未使用的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool export mypool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>导入一个存储池会自动挂载数据集。如果不希望出现这种行为，请使用 <code>zpool import -N</code> 来阻止它。 <code>zpool import -o</code> 为此特定导入设置临时属性。 <code>zpool import altroot = ` 允许使用基本挂载点而不是文件系统的根来导入存储池。如果该存储池最后在另一个系统上使用并且没有正确导出，请使用 `zpool import -f</code> 来强制导入。 <code>zpool import -a</code> 导入所有未被其他系统使用的存储池。</p>
</div>
<div class="paragraph">
<p>列出所有可导入的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool import</span>
   pool: mypool
     id: 9930174748043525076
  state: ONLINE
 action: The pool can be imported using its name or numeric identifier.
 config:

        mypool      ONLINE
          ada2p3    ONLINE</code></pre>
</div>
</div>
<div class="paragraph">
<p>导入具有替代根目录的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool import -o altroot=/mnt mypool</span>
<span class="c"># zfs list</span>
zfs list
NAME                 USED  AVAIL  REFER  MOUNTPOINT
mypool               110K  47.0G    31K  /mnt/mypool</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-upgrade">22.3.11. 升级存储池<a class="anchor" href="#zfs-zpool-upgrade"></a></h3>
<div class="paragraph">
<p>在升级 FreeBSD 之后，或者从使用较旧版本的系统导入池时，需要手动将池升级到最新的 ZFS 版本以支持新功能。在升级之前，请考虑池是否可能需要在较旧的系统上导入。升级是一个单向过程。升级较旧的池是可能的，但是无法降级具有较新功能的池。</p>
</div>
<div class="paragraph">
<p>将 v28 池升级以支持“功能标志”。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: The pool is formatted using a legacy on-disk format.  The pool can
        still be used, but some features are unavailable.
action: Upgrade the pool using <span class="s1">&#39;zpool upgrade&#39;</span>.  Once this is <span class="k">done</span>, the
        pool will no longer be accessible on software that does not support feat
        flags.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool upgrade</span>
This system supports ZFS pool feature flags.

The following pools are formatted with legacy version numbers and are upgraded to use feature flags.
After being upgraded, these pools will no longer be accessible by software that does not support feature flags.

VER  POOL
---  ------------
28   mypool

Use <span class="s1">&#39;zpool upgrade -v&#39;</span> <span class="k">for </span>a list of available legacy versions.
Every feature flags pool has all supported features enabled.
<span class="c"># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Successfully upgraded <span class="s1">&#39;mypool&#39;</span> from version 28 to feature flags.
Enabled the following features on <span class="s1">&#39;mypool&#39;</span>:
  async_destroy
  empty_bpobj
  lz4_compress
  multi_vdev_crash_dump</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有在完成 <code>zpool upgrade</code> 之后， ZFS 的新功能才会可用。使用 <code>zpool upgrade -v</code> 命令查看升级提供的新功能，以及已经支持的功能。</p>
</div>
<div class="paragraph">
<p>升级一个池子以支持新的功能标志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: Some supported features are not enabled on the pool. The pool can
        still be used, but some features are unavailable.
action: Enable all features using <span class="s1">&#39;zpool upgrade&#39;</span>. Once this is <span class="k">done</span>,
        the pool may no longer be accessible by software that does not support
        the features. See zpool-features<span class="o">(</span>7<span class="o">)</span> <span class="k">for </span>details.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool upgrade</span>
This system supports ZFS pool feature flags.

All pools are formatted using feature flags.

Some supported features are not enabled on the following pools. Once a
feature is enabled the pool may become incompatible with software
that does not support the feature. See zpool-features<span class="o">(</span>7<span class="o">)</span> <span class="k">for </span>details.

POOL  FEATURE
---------------
zstore
      multi_vdev_crash_dump
      spacemap_histogram
      enabled_txg
      hole_birth
      extensible_dataset
      bookmarks
      filesystem_limits
<span class="c"># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Enabled the following features on <span class="s1">&#39;mypool&#39;</span>:
  spacemap_histogram
  enabled_txg
  hole_birth
  extensible_dataset
  bookmarks
  filesystem_limits</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>更新从池中引导的系统的引导代码，以支持新的池版本。在包含引导代码的分区上使用 <code>gpart bootcode</code> 命令。根据系统的引导方式，有两种类型的引导代码可用： GPT （最常见的选项）和 EFI （适用于更现代的系统）。</p>
</div>
<div class="paragraph">
<p>对于使用 GPT 的传统引导，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于使用 EFI 引导的系统，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart bootcode -p /boot/boot1.efifat -i 1 ada1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将引导代码应用于池中的所有可引导磁盘。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-history">22.3.12. 显示记录的池历史<a class="anchor" href="#zfs-zpool-history"></a></h3>
<div class="paragraph">
<p>ZFS 记录更改池的命令，包括创建数据集、更改属性或替换磁盘。查看关于池创建的历史记录很有用，还可以检查哪个用户执行了特定的操作以及何时执行的。历史记录不会保存在日志文件中，而是作为池本身的一部分。用于查看这个历史记录的命令被恰当地命名为 <code>zpool history</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool history</span>
History <span class="k">for</span> <span class="s1">&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1
2013-02-27.18:50:58 zfs <span class="nb">set </span><span class="nv">atime</span><span class="o">=</span>off tank
2013-02-27.18:51:09 zfs <span class="nb">set </span><span class="nv">checksum</span><span class="o">=</span>fletcher4 tank
2013-02-27.18:51:18 zfs create tank/backup</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示了 <code>zpool</code> 和 <code>zfs</code> 命令以某种方式修改了池，并附带了时间戳。不包括像 <code>zfs list</code> 这样的命令。当未指定池名称时， ZFS 会显示所有池的历史记录。</p>
</div>
<div class="paragraph">
<p>当使用选项 <code>-i</code> 或 <code>-l</code> 时， <code>zpool history</code> 命令可以显示更多的信息。 <code>-i</code> 选项会显示用户发起的事件以及内部记录的 ZFS 事件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool history -i</span>
History <span class="k">for</span> <span class="s1">&#39;tank&#39;</span>:
2013-02-26.23:02:35 <span class="o">[</span>internal pool create txg:5] pool spa 28; zfs spa 28; zpl 5;uts  9.1-RELEASE 901000 amd64
2013-02-27.18:50:53 <span class="o">[</span>internal property <span class="nb">set </span>txg:50] <span class="nv">atime</span><span class="o">=</span>0 dataset <span class="o">=</span> 21
2013-02-27.18:50:58 zfs <span class="nb">set </span><span class="nv">atime</span><span class="o">=</span>off tank
2013-02-27.18:51:04 <span class="o">[</span>internal property <span class="nb">set </span>txg:53] <span class="nv">checksum</span><span class="o">=</span>7 dataset <span class="o">=</span> 21
2013-02-27.18:51:09 zfs <span class="nb">set </span><span class="nv">checksum</span><span class="o">=</span>fletcher4 tank
2013-02-27.18:51:13 <span class="o">[</span>internal create txg:55] dataset <span class="o">=</span> 39
2013-02-27.18:51:18 zfs create tank/backup</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过添加 <code>-l</code> 来显示更多详细信息。以长格式显示历史记录，包括发出命令的用户的名称和发生更改的主机名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool history -l</span>
History <span class="k">for</span> <span class="s1">&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on :global]
2013-02-27.18:50:58 zfs <span class="nb">set </span><span class="nv">atime</span><span class="o">=</span>off tank <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on myzfsbox:global]
2013-02-27.18:51:09 zfs <span class="nb">set </span><span class="nv">checksum</span><span class="o">=</span>fletcher4 tank <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on myzfsbox:global]
2013-02-27.18:51:18 zfs create tank/backup <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on myzfsbox:global]</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示 <code>root</code> 用户使用磁盘 <span class="filename">/dev/ada0</span> 和 <span class="filename">/dev/ada1</span> 创建了镜像池。在池创建后的命令中还显示了主机名 <code>myzfsbox</code> 。主机名的显示在将池从一个系统导出并在另一个系统导入时变得重要。可以通过为每个命令记录的主机名来区分在另一个系统上发出的命令。</p>
</div>
<div class="paragraph">
<p>将两个选项 <code>zpool history</code> 结合起来，以便为任何给定的池提供尽可能详细的信息。池历史记录在追踪执行的操作或需要更详细的输出进行调试时提供有价值的信息。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-iostat">22.3.13. 性能监控<a class="anchor" href="#zfs-zpool-iostat"></a></h3>
<div class="paragraph">
<p>内置的监控系统可以实时显示池的 I/O 统计信息。它显示池中的可用空间和已使用空间的数量，每秒执行的读写操作次数以及使用的 I/O 带宽。默认情况下， ZFS 监视并显示系统中的所有池。提供池名称以限制监控到该池。一个基本示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool iostat</span>
               capacity     operations    bandwidth
pool        alloc   free   <span class="nb">read  </span>write   <span class="nb">read  </span>write
----------  -----  -----  -----  -----  -----  -----
data         288G  1.53T      2     11  11.3K  57.1K</code></pre>
</div>
</div>
<div class="paragraph">
<p>要持续查看 I/O 活动，请在最后一个参数中指定一个数字，表示更新之间等待的秒数间隔。每个间隔后都会打印下一个统计行。按下 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span> 停止此连续监视。在间隔之后的命令行上给出第二个数字，以指定要显示的统计总数。</p>
</div>
<div class="paragraph">
<p>使用 <code>-v</code> 参数可以显示更详细的 I/O 统计信息。池中的每个设备都会显示一行统计信息。这对于查看在每个设备上执行的读写操作非常有用，并且可以帮助确定是否有任何单个设备导致池变慢。以下示例显示了一个具有两个设备的镜像池。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool iostat -v</span>
                            capacity     operations    bandwidth
pool                     alloc   free   <span class="nb">read  </span>write   <span class="nb">read  </span>write
-----------------------  -----  -----  -----  -----  -----  -----
data                      288G  1.53T      2     12  9.23K  61.5K
  mirror                  288G  1.53T      2     12  9.23K  61.5K
    ada1                     -      -      0      4  5.61K  61.7K
    ada2                     -      -      1      4  5.04K  61.7K
-----------------------  -----  -----  -----  -----  -----  -----</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool-split">22.3.14. 分割存储池<a class="anchor" href="#zfs-zpool-split"></a></h3>
<div class="paragraph">
<p>ZFS 可以将由一个或多个镜像 vdev 组成的池分割成两个池。除非另有指定， ZFS 会分离每个镜像的最后一个成员，并创建一个包含相同数据的新池。请务必先使用 <code>-n</code> 进行试运行。这将显示所请求操作的详细信息，但不会实际执行操作。这有助于确认操作是否符合用户的意图。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-zfs">22.4. <code>zfs</code> 管理<a class="anchor" href="#zfs-zfs"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p><code>zfs</code> 实用程序可以在池中创建、销毁和管理所有现有的 ZFS 数据集。要管理池本身，请使用 <code>zpool</code> 。</p>
</div>
<div class="sect2">
<h3 id="zfs-zfs-create">22.4.1. 创建和销毁数据集<a class="anchor" href="#zfs-zfs-create"></a></h3>
<div class="paragraph">
<p>与传统的磁盘和卷管理器不同， ZFS 中的空间是 <em>不预分配</em> 的。在传统文件系统中，分区和分配空间后，无法在不添加新磁盘的情况下添加新的文件系统。而在 ZFS 中，可以随时创建新的文件系统。每个 <a href="#zfs-term-dataset ">数据集 </a> 都有属性，包括压缩、去重、缓存和配额等功能，以及其他有用的属性，如只读、大小写敏感、网络文件共享和挂载点。可以将数据集嵌套在彼此之间，并且子数据集将继承其祖先的属性。 <a href="#zfs-zfs-allow ">委派 </a> 、 <a href="#zfs-zfs-send ">复制 </a> 、 <a href="#zfs-zfs-snapshot ">快照 </a> 、 <a href="#zfs-zfs-jail ">监狱 </a> 允许将每个数据集作为一个单元进行管理和销毁。为每种不同类型或文件集创建单独的数据集具有优势。拥有大量数据集的缺点是，某些命令（如 <code>zfs list</code> ）的速度会变慢，并且挂载数百甚至数千个数据集会减慢 FreeBSD 的启动过程。</p>
</div>
<div class="paragraph">
<p>创建一个新的数据集，并在其上启用 LZ4 压缩。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.20M  93.2G   608K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp
<span class="c"># zfs create -o compress=lz4 mypool/usr/mydataset</span>
<span class="c"># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 781M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.20M  93.2G   610K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>销毁数据集比删除数据集上的文件要快得多，因为它不涉及扫描文件和更新相应的元数据。</p>
</div>
<div class="paragraph">
<p>销毁已创建的数据集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 880M  93.1G   144K  none
mypool/ROOT            777M  93.1G   144K  none
mypool/ROOT/default    777M  93.1G   777M  /
mypool/tmp             176K  93.1G   176K  /tmp
mypool/usr             101M  93.1G   144K  /usr
mypool/usr/home        184K  93.1G   184K  /usr/home
mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
mypool/usr/ports       144K  93.1G   144K  /usr/ports
mypool/usr/src         144K  93.1G   144K  /usr/src
mypool/var            1.20M  93.1G   610K  /var
mypool/var/crash       148K  93.1G   148K  /var/crash
mypool/var/log         178K  93.1G   178K  /var/log
mypool/var/mail        144K  93.1G   144K  /var/mail
mypool/var/tmp         152K  93.1G   152K  /var/tmp
<span class="c"># zfs destroy mypool/usr/mydataset</span>
<span class="c"># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.21M  93.2G   612K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>在现代版本的 ZFS 中， <code>zfs destroy</code> 是异步的，释放的空间可能需要几分钟才会在池中显示出来。使用 <code>zpool get freeing <em>poolname</em></code> 命令来查看 <code>freeing</code> 属性，该属性显示了哪些数据集正在后台释放其块。如果存在子数据集，例如快照或其他数据集，那么无法销毁父数据集。要销毁一个数据集及其子数据集，可以使用 <code>-r</code> 选项递归地销毁数据集及其子数据集。使用 <code>-n -v</code> 选项列出此操作销毁的数据集和快照，而不实际销毁任何内容。销毁快照释放的空间也会显示出来。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-volume">22.4.2. 创建和销毁卷<a class="anchor" href="#zfs-zfs-volume"></a></h3>
<div class="paragraph">
<p>卷是一种特殊的数据集类型。它不像文件系统那样挂载，而是在 <code>/dev/zvol/poolname/dataset</code> 下以块设备的形式公开。这使得可以将卷用于其他文件系统，用于虚拟机的磁盘备份，或者通过 iSCSI 或 HAST 等协议使其对其他网络主机可用。</p>
</div>
<div class="paragraph">
<p>使用任何文件系统或者不使用文件系统来格式化一个卷，以存储原始数据。对于用户来说，一个卷看起来就像一个普通的磁盘。在这些_zvol_上放置普通的文件系统提供了普通磁盘或文件系统所没有的功能。例如，使用压缩属性在一个 250MB 的卷上可以创建一个压缩的 FAT 文件系统。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -V 250m -o compression=on tank/fat32</span>
<span class="c"># zfs list tank</span>
NAME USED AVAIL REFER MOUNTPOINT
tank 258M  670M   31K /tank
<span class="c"># newfs_msdos -F32 /dev/zvol/tank/fat32</span>
<span class="c"># mount -t msdosfs /dev/zvol/tank/fat32 /mnt</span>
<span class="c"># df -h /mnt | grep fat32</span>
Filesystem           Size Used Avail Capacity Mounted on
/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
<span class="c"># mount | grep fat32</span>
/dev/zvol/tank/fat32 on /mnt <span class="o">(</span>msdosfs, <span class="nb">local</span><span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>销毁一个卷与销毁一个常规文件系统数据集基本相同。该操作几乎是瞬时完成的，但在后台重新获取空闲空间可能需要几分钟的时间。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-rename">22.4.3. 重命名数据集<a class="anchor" href="#zfs-zfs-rename"></a></h3>
<div class="paragraph">
<p>要更改数据集的名称，请使用 <code>zfs rename</code> 命令。要更改数据集的父级，请同样使用此命令。将数据集重命名为具有不同父级的数据集将更改从父级数据集继承的属性的值。将数据集重命名为新位置（从新父级数据集继承）将卸载然后重新挂载它。要防止此行为，请使用 <code>-u</code> 选项。</p>
</div>
<div class="paragraph">
<p>重命名数据集并将其移动到不同的父数据集下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 780M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.21M  93.2G   614K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp
<span class="c"># zfs rename mypool/usr/mydataset mypool/var/newname</span>
<span class="c"># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                780M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.29M  93.2G   614K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>重命名快照使用相同的命令。由于快照的特性，重命名不能改变它们的父数据集。要重命名递归快照，请指定“ -r ”；这也会重命名所有子数据集中具有相同名称的快照。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -t snapshot</span>
NAME                                USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@first_snapshot      0      -  87.5K  -
<span class="c"># zfs rename mypool/var/newname@first_snapshot new_snapshot_name</span>
<span class="c"># zfs list -t snapshot</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@new_snapshot_name      0      -  87.5K  -</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-set">22.4.4. 设置数据集属性<a class="anchor" href="#zfs-zfs-set"></a></h3>
<div class="paragraph">
<p>每个 ZFS 数据集都有控制其行为的属性。大多数属性会自动从父数据集继承，但可以在本地进行覆盖。使用 <code>zfs set <em>property = value dataset</em></code> 在数据集上设置属性。大多数属性有一组有限的有效值， <code>zfs get</code> 将显示每个可能的属性和有效值。使用 <code>zfs inherit</code> 将大多数属性恢复为其继承的值。还可以定义用户自定义属性。它们成为数据集配置的一部分，并提供有关数据集或其内容的进一步信息。为了区分这些自定义属性和作为 ZFS 的一部分提供的属性，可以使用冒号（ <code>:</code> ）为属性创建自定义命名空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set custom:costcenter=1234 tank</span>
<span class="c"># zfs get custom:costcenter tank</span>
NAME PROPERTY           VALUE SOURCE
tank custom:costcenter  1234  <span class="nb">local</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要删除自定义属性，请使用 <code>zfs inherit</code> 命令并加上 <code>-r</code> 选项。如果自定义属性在任何父数据集中都没有定义，这个选项将删除它（但池的历史记录仍然会记录这个更改）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs inherit -r custom:costcenter tank</span>
<span class="c"># zfs get custom:costcenter tank</span>
NAME    PROPERTY           VALUE              SOURCE
tank    custom:costcenter  -                  -
<span class="c"># zfs get all tank | grep custom:costcenter</span>
<span class="c">#</span></code></pre>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-set-share">22.4.4.1. 获取和设置共享属性<a class="anchor" href="#zfs-zfs-set-share"></a></h4>
<div class="paragraph">
<p>两个常用且有用的数据集属性是 NFS 和 SMB 共享选项。设置这些选项可以定义 ZFS 在网络上共享数据集的方式和方式。目前， FreeBSD 仅支持设置 NFS 共享。要获取共享的当前状态，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get sharenfs mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharenfs  on       <span class="nb">local</span>
<span class="c"># zfs get sharesmb mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharesmb  off      <span class="nb">local</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要启用数据集的共享，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c">#  zfs set sharenfs=on mypool/usr/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>设置通过 NFS 共享数据集的其他选项，例如 <code>-alldirs</code> 、 <code>-maproot</code> 和 <code>-network</code> 。要在通过 NFS 共享的数据集上设置选项，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c">#  zfs set sharenfs=&#34;-alldirs,-maproot=root,-network=192.168.1.0/24&#34; mypool/usr/home</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-snapshot">22.4.5. 管理快照<a class="anchor" href="#zfs-zfs-snapshot"></a></h3>
<div class="paragraph">
<p><a href="#zfs-term-snapshot ">快照 </a> 是 ZFS 最强大的功能之一。快照提供了数据集的只读、时间点的副本。通过写时复制（ COW ）， ZFS 通过在磁盘上保留旧版本的数据来快速创建快照。如果没有快照存在，当数据被重写或删除时， ZFS 会回收空间以供将来使用。快照通过记录当前数据集与先前版本之间的差异来保留磁盘空间。允许在整个数据集上进行快照，而不是在单个文件或目录上进行快照。数据集的快照复制其中包含的所有内容。这包括文件系统属性、文件、目录、权限等。快照在创建时不占用额外的空间，但随着它们引用的块的变化而消耗空间。使用 <code>-r</code> 进行递归快照会在数据集及其子数据集上创建具有相同名称的快照，提供文件系统的一致时刻快照。当应用程序在相关数据集上有文件或相互依赖时，这可能很重要。如果没有快照，备份将具有来自不同时间点的文件副本。</p>
</div>
<div class="paragraph">
<p>ZFS 中的快照提供了许多其他具有快照功能的文件系统所缺乏的功能。快照的典型用法是在执行风险操作（如软件安装或系统升级）时，快速备份文件系统的当前状态。如果操作失败，回滚到快照可以将系统恢复到创建快照时的相同状态。如果升级成功，可以删除快照以释放空间。如果没有快照，升级失败通常需要恢复备份，这是繁琐、耗时的，并且可能需要停机时间，期间系统无法使用。回滚到快照是快速的，即使系统在正常运行中，几乎没有停机时间。考虑到从备份中复制数据所需的时间，对于多 TB 存储系统来说，节省的时间是巨大的。快照不能替代对池的完整备份，但提供了一种快速简便的方式来存储特定时间点的数据集副本。</p>
</div>
<div class="sect3">
<h4 id="zfs-zfs-snapshot-creation">22.4.5.1. 创建快照<a class="anchor" href="#zfs-zfs-snapshot-creation"></a></h4>
<div class="paragraph">
<p>要创建快照，请使用 <code>zfs snapshot <em>dataset</em>@<em>snapshotname</em></code> 命令。添加 <code>-r</code> 选项可以递归地创建快照，并在所有子数据集上使用相同的名称。</p>
</div>
<div class="paragraph">
<p>创建整个池的递归快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -t all</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool                                 780M  93.2G   144K  none
mypool/ROOT                            777M  93.2G   144K  none
mypool/ROOT/default                    777M  93.2G   777M  /
mypool/tmp                             176K  93.2G   176K  /tmp
mypool/usr                             616K  93.2G   144K  /usr
mypool/usr/home                        184K  93.2G   184K  /usr/home
mypool/usr/ports                       144K  93.2G   144K  /usr/ports
mypool/usr/src                         144K  93.2G   144K  /usr/src
mypool/var                            1.29M  93.2G   616K  /var
mypool/var/crash                       148K  93.2G   148K  /var/crash
mypool/var/log                         178K  93.2G   178K  /var/log
mypool/var/mail                        144K  93.2G   144K  /var/mail
mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
mypool/var/newname@new_snapshot_name      0      -  87.5K  -
mypool/var/tmp                         152K  93.2G   152K  /var/tmp
<span class="c"># zfs snapshot -r mypool@my_recursive_snapshot</span>
<span class="c"># zfs list -t snapshot</span>
NAME                                        USED  AVAIL  REFER  MOUNTPOINT
mypool@my_recursive_snapshot                   0      -   144K  -
mypool/ROOT@my_recursive_snapshot              0      -   144K  -
mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
mypool/tmp@my_recursive_snapshot               0      -   176K  -
mypool/usr@my_recursive_snapshot               0      -   144K  -
mypool/usr/home@my_recursive_snapshot          0      -   184K  -
mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
mypool/usr/src@my_recursive_snapshot           0      -   144K  -
mypool/var@my_recursive_snapshot               0      -   616K  -
mypool/var/crash@my_recursive_snapshot         0      -   148K  -
mypool/var/log@my_recursive_snapshot           0      -   178K  -
mypool/var/mail@my_recursive_snapshot          0      -   144K  -
mypool/var/newname@new_snapshot_name           0      -  87.5K  -
mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
mypool/var/tmp@my_recursive_snapshot           0      -   152K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>普通的 <code>zfs list</code> 操作不会显示快照。要列出快照，请在 <code>zfs list</code> 后面添加 <code>-t snapshot</code> 。 <code>-t all</code> 可以同时显示文件系统和快照。</p>
</div>
<div class="paragraph">
<p>快照不会直接挂载，因此在“ MOUNTPOINT ”列中不显示路径。 ZFS 在“ AVAIL ”列中不提及可用磁盘空间，因为快照在创建后是只读的。将快照与原始数据集进行比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all mypool/usr/home</span>
NAME                                    USED  AVAIL  REFER  MOUNTPOINT
mypool/usr/home                         184K  93.2G   184K  /usr/home
mypool/usr/home@my_recursive_snapshot      0      -   184K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>同时显示数据集和快照可以展示快照以 COW （写时复制）方式工作的原理。它们保存所做的更改（<em>delta</em>），而不是再次保存完整的文件系统内容。这意味着在进行更改时，快照所占用的空间很小。通过将文件复制到数据集中，然后创建第二个快照，可以更加观察空间使用情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/passwd /var/tmp</span>
<span class="c"># zfs snapshot mypool/var/tmp@after_cp</span>
<span class="c"># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个快照包含了复制操作后数据集的变化。这样可以节省大量的空间。请注意，快照 <code><em>mypool/var/tmp @ my_recursive_snapshot</em></code> 的大小在 <code>USED</code> 列中也发生了变化，以显示它与之后拍摄的快照之间的变化。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-snapshot-diff">22.4.5.2. 比较快照<a class="anchor" href="#zfs-zfs-snapshot-diff"></a></h4>
<div class="paragraph">
<p>ZFS 提供了一个内置命令，用于比较两个快照之间内容的差异。当用户想要查看文件系统随时间变化的方式时，这非常有帮助，尤其是在有很多快照的情况下。例如， <code>zfs diff</code> 命令可以帮助用户找到最新的快照，其中仍然包含了意外删除的文件。对于前一节创建的两个快照，执行此命令将输出如下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -
<span class="c"># zfs diff mypool/var/tmp@my_recursive_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令列出了指定快照（在本例中为 <code><em>mypool/var/tmp @ my_recursive_snapshot</em></code> ）与活动文件系统之间的变化。第一列显示变化类型：</p>
</div>
<table class="tableblock frame-all grid-all stretch informaltable">
<colgroup>
<col style="width: 20%;"/>
<col style="width: 80%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加路径或文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">翻译引擎</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除路径或文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">修改路径或文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重命名路径或文件。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>将输出与表格进行比较，可以清楚地看到 ZFS 在创建快照 <code><em>mypool/var/tmp @ my_recursive_snapshot</em></code> 之后添加了 <span class="filename">passwd</span> 。这也导致了挂载在 <code><em>/var/tmp</em></code> 上的父目录的修改。</p>
</div>
<div class="paragraph">
<p>当使用 ZFS 复制功能将数据集传输到不同的主机进行备份时，比较两个快照是非常有帮助的。</p>
</div>
<div class="paragraph">
<p>通过提供两个数据集的完整数据集名称和快照名称来比较两个快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /var/tmp/passwd /var/tmp/passwd.copy</span>
<span class="c"># zfs snapshot mypool/var/tmp@diff_snapshot</span>
<span class="c"># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd
+       /var/tmp/passwd.copy
<span class="c"># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>备份管理员可以比较从发送主机接收到的两个快照，并确定数据集中的实际更改。有关更多信息，请参阅 <a href="#zfs-zfs-send ">复制 </a> 部分。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-snapshot-rollback">22.4.5.3. 快照回滚<a class="anchor" href="#zfs-zfs-snapshot-rollback"></a></h4>
<div class="paragraph">
<p>当至少有一个快照可用时，随时可以回滚到该快照。大多数情况下，当数据集的当前状态不再存在或者更喜欢旧版本时，会出现这种情况。诸如本地开发测试失败、系统更新失败导致系统功能受阻，或者需要恢复已删除的文件或目录等情况都很常见。要回滚快照，请使用 <code>zfs rollback <em>snapshotname</em></code> 命令。如果存在大量更改，操作将需要很长时间。在此期间，数据集始终保持一致的状态，就像符合 ACID 原则的数据库执行回滚操作一样。这一切都发生在数据集处于活动状态且可访问的情况下，无需停机。一旦快照回滚完成，数据集的状态与快照创建时的状态相同。回滚到快照会丢弃数据集中不属于该快照的所有其他数据。在回滚到以前的快照之前，将当前数据集的状态进行快照是一个好主意，以便稍后需要某些数据。这样，用户可以在快照之间来回切换，而不会丢失仍然有价值的数据。</p>
</div>
<div class="paragraph">
<p>在第一个示例中，由于一个粗心的 <code>rm</code> 操作删除了比预期更多的数据，因此需要回滚一个快照。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         262K  93.2G   120K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class="c"># ls /var/tmp</span>
passwd          passwd.copy     vi.recover
<span class="c"># rm /var/tmp/passwd*</span>
<span class="c"># ls /var/tmp</span>
vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上，用户注意到额外文件被删除了，并希望将它们恢复。 ZFS 提供了一种简单的方法来使用回滚将它们恢复，当定期对重要数据进行快照时。要将文件恢复并从最后一个快照重新开始，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs rollback mypool/var/tmp@diff_snapshot</span>
<span class="c"># ls /var/tmp</span>
passwd          passwd.copy     vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p>回滚操作将数据集恢复到最后一个快照的状态。也可以回滚到之前拍摄的快照之后拍摄的其他快照的状态。在尝试这样做时， ZFS 会发出以下警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt snapshot mypool/var/tmp</span>
AME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class="c"># zfs rollback mypool/var/tmp@my_recursive_snapshot</span>
cannot rollback to <span class="s1">&#39;mypool/var/tmp@my_recursive_snapshot&#39;</span>: more recent snapshots exist
use <span class="s1">&#39;-r&#39;</span> to force deletion of the following snapshots:
mypool/var/tmp@after_cp
mypool/var/tmp@diff_snapshot</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个警告意味着在当前数据集状态和用户想要回滚的快照之间存在快照。要完成回滚操作，请删除这些快照。由于快照是只读的， ZFS 无法跟踪数据集不同状态之间的所有更改。除非用户使用 <code>-r</code> 参数确认这是所需的操作，否则 ZFS 不会删除受影响的快照。如果这是用户的意图，并且理解丢失所有中间快照的后果，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs rollback -r mypool/var/tmp@my_recursive_snapshot</span>
<span class="c"># zfs list -rt snapshot mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
<span class="c"># ls /var/tmp</span>
vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>zfs list -t snapshot</code> 的输出确认了由于 <code>zfs rollback -r</code> 的结果，中间快照已被删除。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-snapshot-snapdir">22.4.5.4. 从快照中恢复单个文件<a class="anchor" href="#zfs-zfs-snapshot-snapdir"></a></h4>
<div class="paragraph">
<p>快照存储在父数据集的隐藏目录下： <span class="filename">.zfs/snapshots/snapshotname</span> 。默认情况下，即使执行标准的 <code>ls -a</code> 命令，这些目录也不会显示出来。尽管目录不可见，但可以像访问普通目录一样访问它。名为 <code>snapdir</code> 的属性控制这些隐藏目录是否在目录列表中显示。将该属性设置为 <code>visible</code> 可以使它们出现在 <code>ls</code> 和其他处理目录内容的命令的输出中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get snapdir mypool/var/tmp</span>
NAME            PROPERTY  VALUE    SOURCE
mypool/var/tmp  snapdir   hidden   default
<span class="c"># ls -a /var/tmp</span>
.               ..              passwd          vi.recover
<span class="c"># zfs set snapdir=visible mypool/var/tmp</span>
<span class="c"># ls -a /var/tmp</span>
.               ..              .zfs            passwd          vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过将文件从快照复制回父数据集，将其恢复到先前的状态。 <span class="filename">.zfs/snapshot</span> 下的目录结构中有一个类似于先前拍摄的快照的目录，以便更容易识别它们。下一个示例显示了如何从隐藏的 <span class="filename">.zfs</span> 目录中复制文件，从包含文件最新版本的快照中恢复文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rm /var/tmp/passwd</span>
<span class="c"># ls -a /var/tmp</span>
.               ..              .zfs            vi.recover
<span class="c"># ls /var/tmp/.zfs/snapshot</span>
after_cp                my_recursive_snapshot
<span class="c"># ls /var/tmp/.zfs/snapshot/after_cp</span>
passwd          vi.recover
<span class="c"># cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>即使将 <code>snapdir</code> 属性设置为隐藏，运行 <code>ls .zfs/snapshot</code> 仍然会列出该目录的内容。管理员决定是否显示这些目录。这是每个数据集的设置。从这个隐藏的 <span class="filename">.zfs/snapshot</span> 复制文件或目录非常简单。尝试反过来操作会导致以下错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/</span>
cp: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system</code></pre>
</div>
</div>
<div class="paragraph">
<p>该错误提醒用户快照是只读的，创建后不能更改。将文件复制到快照目录或从中删除文件都是不允许的，因为这会改变所表示数据集的状态。</p>
</div>
<div class="paragraph">
<p>快照占用的空间取决于父文件系统自快照以来的更改量。快照的 <code>written</code> 属性跟踪快照使用的空间。</p>
</div>
<div class="paragraph">
<p>要销毁快照并回收空间，请使用 <code>zfs destroy <em>dataset</em>@<em>snapshot</em></code> 命令。添加 <code>-r</code> 选项可以递归删除父数据集下具有相同名称的所有快照。在命令中添加 <code>-n -v</code> 选项可以显示要删除的快照列表以及执行实际销毁操作前将回收的空间的估计值。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-clones">22.4.6. 管理克隆实例<a class="anchor" href="#zfs-zfs-clones"></a></h3>
<div class="paragraph">
<p>克隆是快照的副本，更像一个常规数据集。与快照不同，克隆是可写的和可挂载的，并且具有自己的属性。使用 <code>zfs clone</code> 创建克隆后，无法销毁原始快照。要反转克隆和快照之间的子 / 父关系，请使用 <code>zfs promote</code> 。将克隆提升为快照成为克隆的子项，而不是原始父数据集的子项。这将改变 ZFS 对空间的计算方式，但实际上不会改变所消耗的空间量。可以在 ZFS 文件系统层次结构中的任何位置挂载克隆，不仅限于快照的原始位置下方。</p>
</div>
<div class="paragraph">
<p>要展示克隆功能，请使用以下示例数据集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all camino/home/joe</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
camino/home/joe         108K   1.3G    87K  /usr/home/joe
camino/home/joe@plans    21K      -  85.5K  -
camino/home/joe@backup    0K      -    87K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>克隆的典型用途是在进行特定数据集的实验时，保留快照以备不时之需。由于快照是不可更改的，因此需要创建一个可读 / 写的快照克隆。在克隆中获得所需的结果后，将克隆提升为数据集并删除旧的文件系统。严格来说，删除父数据集并非必需，因为克隆和数据集可以共存而不会出现问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs clone camino/home/joe@backup camino/home/joenew</span>
<span class="c"># ls /usr/home/joe*</span>
/usr/home/joe:
backup.txz     plans.txt

/usr/home/joenew:
backup.txz     plans.txt
<span class="c"># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建克隆会使其成为数据集在拍摄快照时的精确副本。现在可以独立地更改克隆与其源数据集之间的连接。两者之间的连接是快照。 ZFS 将此连接记录在属性 <code>origin</code> 中。使用 <code>zfs promote</code> 提升克隆将使其成为独立的数据集。这将删除 <code>origin</code> 属性的值，并断开新独立数据集与快照之间的连接。以下示例说明了这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE                     SOURCE
camino/home/joenew    origin    camino/home/joe@backup    -
<span class="c"># zfs promote camino/home/joenew</span>
<span class="c"># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE   SOURCE
camino/home/joenew    origin    -       -</code></pre>
</div>
</div>
<div class="paragraph">
<p>在进行一些更改后，例如将 <span class="filename">loader.conf</span> 复制到推广的克隆中，旧目录在这种情况下变得过时。相反，推广的克隆可以替代它。为了做到这一点，首先使用 <code>zfs destroy</code> 命令销毁旧数据集，然后使用 <code>zfs rename</code> 命令将克隆重命名为旧数据集的名称（或完全不同的名称）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /boot/defaults/loader.conf /usr/home/joenew</span>
<span class="c"># zfs destroy -f camino/home/joe</span>
<span class="c"># zfs rename camino/home/joenew camino/home/joe</span>
<span class="c"># ls /usr/home/joe</span>
backup.txz     loader.conf     plans.txt
<span class="c"># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe</code></pre>
</div>
</div>
<div class="paragraph">
<p>克隆的快照现在是一个普通的数据集。它包含了原始快照中的所有数据，以及像 <span class="filename">loader.conf</span> 这样添加到其中的文件。在不同的场景中，克隆为 ZFS 用户提供了有用的功能。例如，可以将监狱作为包含不同安装应用程序集的快照。用户可以克隆这些快照，并根据需要添加自己的应用程序。一旦对更改满意，可以将克隆提升为完整的数据集，并将其提供给最终用户，就像使用真实数据集一样。这样可以节省提供这些监狱时的时间和管理开销。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-send">22.4.7. 复制<a class="anchor" href="#zfs-zfs-send"></a></h3>
<div class="paragraph">
<p>将数据存储在一个位置的单个池中会使其暴露于盗窃、自然灾害或人为灾害等风险。定期备份整个池是至关重要的。 ZFS 提供了一个内置的序列化功能，可以将数据的流表示发送到标准输出。使用此功能，可以将这些数据存储在连接到本地系统的另一个池中，也可以将其发送到另一个系统上的网络上。快照是复制的基础（参见 <a href="#zfs-zfs-snapshot ， ZFS 快照 ">[zfs-zfs-snapshot ， ZFS 快照 ]</a> 部分）。用于复制数据的命令是 <code>zfs send</code> 和 <code>zfs receive</code> 。</p>
</div>
<div class="paragraph">
<p>这些示例展示了使用这两个存储池进行 ZFS 复制的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>名为_mypool_的池是主要的池，数据的写入和读取在此池中定期进行。在主要池不可用时，使用第二个备用池_backup_。请注意， ZFS 不会自动执行此故障转移，而是需要系统管理员在需要时手动执行。使用快照提供一致的文件系统版本进行复制。在创建_mypool_的快照后，通过复制快照将其复制到_backup_池中。这不包括自最近快照以来所做的更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot mypool@backup1</span>
<span class="c"># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@backup1             0      -  43.6M  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在有了一个快照，使用 <code>zfs send</code> 命令创建一个表示快照内容的流。将这个流存储为文件，或者在另一个存储池中接收它。将流写入标准输出，但要将其重定向到文件或管道，否则会出现错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs send mypool@backup1</span>
Error: Stream can not be written to a terminal.
You must redirect standard output.</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>zfs send</code> 命令备份数据集时，将其重定向到位于已挂载的备份池上的文件。确保备份池有足够的空间来容纳发送的快照的大小，这指的是快照中包含的数据，而不是与上一个快照的更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs send mypool@backup1 &gt; /backup/backup1</span>
<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>zfs send</code> 命令将名为_backup1_的快照中的所有数据传输到名为_backup_的存储池中。要自动创建和发送这些快照，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 任务。</p>
</div>
<div class="paragraph">
<p>ZFS 可以将备份存储为实时文件系统，而不是存储为归档文件，从而可以直接访问备份数据。要访问这些流中包含的实际数据，可以使用 <code>zfs receive</code> 将流转换回文件和目录。下面的示例结合了 <code>zfs send</code> 和 <code>zfs receive</code> ，使用管道将数据从一个存储池复制到另一个存储池。在传输完成后，可以直接在接收存储池上使用数据。只有将数据集复制到空数据集才是可能的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot mypool@replica1</span>
<span class="c"># zfs send -v mypool@replica1 | zfs receive backup/mypool</span>
send from @ to mypool@replica1 estimated size is 50.1M
total estimated size is 50.1M
TIME        SENT   SNAPSHOT

<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="zfs-send-incremental">22.4.7.1. 增量备份<a class="anchor" href="#zfs-send-incremental"></a></h4>
<div class="paragraph">
<p><code>zfs send</code> 还可以确定两个快照之间的差异，并发送两者之间的个别差异。这样可以节省磁盘空间和传输时间。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot mypool@replica2</span>
<span class="c"># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@replica1         5.72M      -  43.6M  -
mypool@replica2             0      -  44.1M  -
<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个名为_replica2_的第二个快照。这个第二个快照包含了从现在到上一个快照_replica1_之间对文件系统所做的更改。使用 <code>zfs send -i</code> 命令，并指定快照对，可以生成一个增量复制流，其中包含了更改的数据。如果接收端已经存在初始快照，则此操作将成功。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool</span>
send from @replica1 to mypool@replica2 estimated size is 5.02M
total estimated size is 5.02M
TIME        SENT   SNAPSHOT

<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT
backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -

<span class="c"># zfs list</span>
NAME                         USED  AVAIL  REFER  MOUNTPOINT
backup                      55.4M   240G   152K  /backup
backup/mypool               55.3M   240G  55.2M  /backup/mypool
mypool                      55.6M  11.6G  55.0M  /mypool

<span class="c"># zfs list -t snapshot</span>
NAME                                         USED  AVAIL  REFER  MOUNTPOINT
backup/mypool@replica1                       104K      -  50.2M  -
backup/mypool@replica2                          0      -  55.2M  -
mypool@replica1                             29.9K      -  50.0M  -
mypool@replica2                                 0      -  55.0M  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>增量流复制了变化的数据，而不是整个_replica1_。仅发送差异所需的传输时间更短，并且通过不每次复制整个池来节省磁盘空间。这在通过慢速网络或按传输字节计费的网络上进行复制时非常有用。</p>
</div>
<div class="paragraph">
<p>一个新的文件系统，<em>backup/mypool</em>，可用于存储来自池_mypool_的文件和数据。使用 <code>-p</code> 参数可以复制数据集的属性，包括压缩设置、配额和挂载点。使用 <code>-R</code> 参数可以复制数据集的所有子数据集以及它们的属性。自动化发送和接收操作可以在第二个池中创建定期备份。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-send-ssh">22.4.7.2. 通过 SSH 发送加密备份<a class="anchor" href="#zfs-send-ssh"></a></h4>
<div class="paragraph">
<p>在计算机领域，备份是一项重要的任务，以确保数据的安全性和可恢复性。然而，由于备份文件可能包含敏感信息，因此在传输过程中需要采取额外的安全措施。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>SSH （ Secure Shell ）是一种加密的网络协议，常用于远程登录和文件传输。通过使用 SSH ，可以确保备份文件在传输过程中的机密性和完整性。</pre>
</div>
</div>
<div class="paragraph">
<p>为了发送加密备份，首先需要在目标服务器上设置 SSH 服务。然后，使用备份软件将文件打包并加密。接下来，通过 SSH 连接到目标服务器，并将加密的备份文件传输到目标服务器上的指定位置。</p>
</div>
<div class="paragraph">
<p>在传输过程中， SSH 会自动加密数据，并使用公钥加密技术进行身份验证。这样，即使在传输过程中被截获，攻击者也无法解密备份文件。</p>
</div>
<div class="paragraph">
<p>通过使用 SSH 发送加密备份，可以确保备份文件的安全性，防止敏感信息被未经授权的人访问。这是一种可靠且常用的方法，用于保护数据的完整性和保密性。</p>
</div>
<div class="paragraph">
<p>通过网络发送流是保持远程备份的好方法，但它也有一个缺点。通过网络链路发送的数据没有加密，允许任何人在不知情的情况下拦截和转换流为数据。当将流发送到远程主机时，这是不可取的。使用 SSH 来安全地加密通过网络连接发送的数据。由于 ZFS 需要将流重定向到标准输出，所以通过 SSH 进行管道传输很容易。为了在传输和远程系统上保持文件系统的内容加密，考虑使用 PEFS （ <a href="https://wiki.freebsd.org/PEFS" class="bare">https://wiki.freebsd.org/PEFS</a> ）。</p>
</div>
<div class="paragraph">
<p>首先，更改一些设置并采取安全预防措施。这描述了执行 <code>zfs send</code> 操作所需的必要步骤；有关 SSH 的更多信息，请参见 <a href="../security/#openssh">OpenSSH</a> 。</p>
</div>
<div class="paragraph">
<p>将配置更改如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 SSH 密钥在发送和接收主机之间实现无密码 SSH 访问</p>
</li>
<li>
<p>ZFS 需要 <code>root</code> 用户的权限来发送和接收流。这需要以 <code>root</code> 用户身份登录到接收系统。</p>
</li>
<li>
<p>出于安全原因，默认情况下禁止 <code>root</code> 用户登录。</p>
</li>
<li>
<p>使用 <a href="#zfs-zfs-allow ">ZFS 委派 </a> 系统，允许每个系统上的非 <code>root</code> 用户执行相应的发送和接收操作。在发送系统上：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs allow -u someuser send,snapshot mypool</span></code></pre>
</div>
</div>
</li>
<li>
<p>要挂载池，非特权用户必须拥有该目录的所有权，并且普通用户需要有挂载文件系统的权限。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在接收系统上：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1
<span class="c"># echo vfs.usermount=1 &gt;&gt; /etc/sysctl.conf</span>
<span class="c"># zfs create recvpool/backup</span>
<span class="c"># zfs allow -u someuser create,mount,receive recvpool/backup</span>
<span class="c"># chown someuser /recvpool/backup</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>非特权用户现在可以接收和挂载数据集，并将_home_数据集复制到远程系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>zfs snapshot -r mypool/home@monday
<span class="gp">% </span>zfs send -R mypool/home@monday | ssh someuser@backuphost zfs recv -dvu recvpool/backup</code></pre>
</div>
</div>
<div class="paragraph">
<p>在池_mypool_上创建一个名为_monday_的文件系统数据集_home_的递归快照。然后， <code>zfs send -R</code> 命令将数据集、所有子数据集、快照、克隆和设置包含在流中。通过 SSH 将输出导向等待的远程主机_backuphost_上的 <code>zfs receive</code> 命令。使用 IP 地址或完全限定域名是良好的实践。接收机将数据写入_recvpool_池上的_backup_数据集。在 <code>zfs recv</code> 命令中添加 <code>-d</code> 选项会使用快照的名称覆盖接收端池的名称。 <code>-u</code> 选项会导致接收端上的文件系统不挂载。使用 <code>-v</code> 选项可以显示有关传输的更多详细信息，包括经过的时间和传输的数据量。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-quota">22.4.8. 数据集、用户和组配额<a class="anchor" href="#zfs-zfs-quota"></a></h3>
<div class="paragraph">
<p>使用 <a href="#zfs-term-quota ，数据集配额 ">[zfs-term-quota ，数据集配额 ]</a> 来限制特定数据集消耗的空间量。 <a href="#zfs-term-refquota ，引用配额 ">[zfs-term-refquota ，引用配额 ]</a> 的工作方式类似，但是计算的是数据集本身使用的空间，不包括快照和子数据集。同样地，使用 <a href="#zfs-term-userquota ，用户配额 ">[zfs-term-userquota ，用户配额 ]</a> 和 <a href="#zfs-term-groupquota ，组配额 ">[zfs-term-groupquota ，组配额 ]</a> 来防止用户或组使用完池或数据集中的所有空间。</p>
</div>
<div class="paragraph">
<p>以下示例假设用户已经存在于系统中。在将用户添加到系统之前，请确保首先创建他们的主目录数据集，并将 <code>mountpoint</code> 设置为 <code>/home/<em>bob</em></code> 。然后，创建用户并将主目录指向数据集的 <code>mountpoint</code> 位置。这将正确设置所有者和组权限，而不会遮盖可能存在的任何预先存在的主目录路径。</p>
</div>
<div class="paragraph">
<p>为了对 <span class="filename">storage/home/bob</span> 强制执行一个 10 GB 的数据集配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set quota=10G storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了强制限制 <span class="filename">storage/home/bob</span> 的引用配额为 10 GB ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set refquota=10G storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要移除 <span class="filename">storage/home/bob</span> 的 10 GB 配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set quota=none storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通用格式为 <code>userquota @<em>user</em>=<em>size</em></code> ，用户的名称必须符合以下格式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POSIX 兼容的名称，例如_joe_。</p>
</li>
<li>
<p>POSIX 数值 ID ，例如_789_。</p>
</li>
<li>
<p>SID 名称，例如_joe.bloggs @ example.com_。</p>
</li>
<li>
<p>SID 是一个数字 ID ，例如_S-1-123-456-789_。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，要为名为_joe_的用户强制执行 50 GB 的用户配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set userquota@joe=50G</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要移除任何配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set userquota@joe=none</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>zfs get all</code> 命令不会显示用户配额属性。非 <code>root</code> 用户除非被授予 <code>userquota</code> 权限，否则无法查看其他用户的配额。拥有此权限的用户可以查看和设置所有人的配额。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>设置群组配额的一般格式为： <code>groupquota @<em>group</em>=<em>size</em></code> 。</p>
</div>
<div class="paragraph">
<p>要将组_firstgroup_的配额设置为 50 GB ，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set groupquota@firstgroup=50G</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要删除组_firstgroup_的配额，或确保未设置配额，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set groupquota@firstgroup=none</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与用户配额属性一样，非 <code>root</code> 用户可以查看与他们所属的组相关联的配额。具有 <code>groupquota</code> 特权或 <code>root</code> 权限的用户可以查看和设置所有组的所有配额。</p>
</div>
<div class="paragraph">
<p>要显示文件系统或快照中每个用户使用的空间量以及任何配额，请使用 <code>zfs userspace</code> 。要获取组信息，请使用 <code>zfs groupspace</code> 。有关支持的选项或如何仅显示特定选项的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=1&amp;format=html">zfs(1)</a> 。</p>
</div>
<div class="paragraph">
<p>特权用户和 <code>root</code> 用户可以使用以下命令列出 <code>storage/home/bob</code> 目录的配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get quota storage/home/bob</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-reservation">22.4.9. 预订<a class="anchor" href="#zfs-zfs-reservation"></a></h3>
<div class="paragraph">
<p><a href="#zfs-term-reservation ">预留空间 </a> 保证了数据集上始终可用的一定量空间。预留的空间将不会对其他数据集可用。这个有用的功能确保了重要数据集或日志文件的可用的空闲空间。</p>
</div>
<div class="paragraph">
<p><code>reservation</code> 属性的一般格式是 <code>reservation =<em>size</em></code> ，因此要在 <span class="filename">storage/home/bob</span> 上设置 10 GB 的预留空间，可以使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set reservation=10G storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>取消任何预订：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set reservation=none storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的原则适用于设置 <code>refreservation</code> 属性以设置 <a href="#zfs-term-refreservation ">参考保留 </a> ，其一般格式为 <code>refreservation =<em>size</em></code> 。</p>
</div>
<div class="paragraph">
<p>该命令显示位于 <span class="filename">storage/home/bob</span> 目录下的任何预留或重新预留。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get reservation storage/home/bob</span>
<span class="c"># zfs get refreservation storage/home/bob</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-compression">22.4.10. 压缩<a class="anchor" href="#zfs-zfs-compression"></a></h3>
<div class="paragraph">
<p>ZFS 提供透明压缩功能。在块级别压缩数据可以节省空间，同时提高磁盘吞吐量。如果数据压缩率为 25% ，压缩后的数据写入磁盘的速度与未压缩版本相同，从而实现了 125% 的有效写入速度。压缩也可以作为 <a href="#zfs-zfs-deduplication ">去重 </a> 的一个很好的替代方案，因为它不需要额外的内存。</p>
</div>
<div class="paragraph">
<p>ZFS 提供了不同的压缩算法，每种算法都有不同的权衡。在 ZFS v5000 中引入的 LZ4 压缩算法可以在不牺牲性能的情况下对整个池进行压缩。 LZ4 的最大优势是“提前中止”功能。如果 LZ4 在数据的头部部分无法达到至少 12.5% 的压缩率， ZFS 会以未压缩的方式写入该块，以避免浪费 CPU 周期尝试压缩已经压缩或无法压缩的数据。有关 ZFS 中可用的不同压缩算法的详细信息，请参阅术语部分中的“压缩”条目。</p>
</div>
<div class="paragraph">
<p>管理员可以通过数据集属性查看压缩的有效性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get used,compressratio,compression,logicalused mypool/compressed_dataset</span>
NAME        PROPERTY          VALUE     SOURCE
mypool/compressed_dataset  used              449G      -
mypool/compressed_dataset  compressratio     1.11x     -
mypool/compressed_dataset  compression       lz4       <span class="nb">local
</span>mypool/compressed_dataset  logicalused       496G      -</code></pre>
</div>
</div>
<div class="paragraph">
<p>该数据集使用了 449 GB 的空间（使用的属性）。如果不进行压缩，它将占用 496 GB 的空间（逻辑使用的属性）。这导致了 1.11:1 的压缩比率。</p>
</div>
<div class="paragraph">
<p>当与 <a href="#zfs-term-userquota ">用户配额 </a> 结合使用时，压缩可能会产生意想不到的副作用。用户配额限制了用户在数据集上实际消耗的空间（在压缩之后）。如果一个用户的配额是 10GB ，并写入了 10GB 的可压缩数据，他们仍然可以存储更多的数据。如果他们稍后更新一个文件，比如一个数据库，其中包含更多或更少可压缩的数据，可用空间的数量将会改变。这可能导致一个奇怪的情况，即用户没有增加实际数据量（ <code>logicalused</code> 属性），但压缩的变化导致他们达到了配额限制。</p>
</div>
<div class="paragraph">
<p>压缩可能会与备份产生类似的意外交互作用。配额通常用于限制数据存储，以确保有足够的备份空间可用。由于配额不考虑压缩，因此 ZFS 可能会写入比未压缩备份所能容纳的更多数据。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-compression-zstd">22.4.11. Zstandard 压缩<a class="anchor" href="#zfs-zfs-compression-zstd"></a></h3>
<div class="paragraph">
<p>OpenZFS 2.0 增加了一种新的压缩算法。 Zstandard （ Zstd ）提供比默认的 LZ4 更高的压缩比，同时比替代方案 gzip 速度更快。 OpenZFS 2.0 可以通过 FreeBSD 12.1-RELEASE 的 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/openzfs/">sysutils/openzfs</a> 包获得，并且自 FreeBSD 13.0-RELEASE 以来已成为默认选项。</p>
</div>
<div class="paragraph">
<p>Zstd 提供了多种压缩级别，可以对性能和压缩比进行细粒度控制。 Zstd 的一个主要优势是解压速度与压缩级别无关。对于只写入一次但经常读取的数据， Zstd 允许使用最高的压缩级别而不会影响读取性能。</p>
</div>
<div class="paragraph">
<p>即使进行频繁的数据更新，启用压缩通常也能提供更高的性能。其中最大的优势之一来自于压缩的 ARC 功能。 ZFS 的自适应替换缓存（ ARC ）将数据的压缩版本缓存在 RAM 中，每次需要时进行解压缩。这使得相同数量的 RAM 能够存储更多的数据和元数据，从而增加了缓存命中率。</p>
</div>
<div class="paragraph">
<p>ZFS 提供 19 个级别的 Zstd 压缩，每个级别都可以在更慢的压缩速度下提供更多的空间节省。默认级别是 <code>zstd-3</code> ，比 LZ4 提供更好的压缩效果，但速度不会慢太多。级别超过 10 需要大量的内存来压缩每个块，内存小于 16GB 的系统不应使用这些级别。 ZFS 还使用了一系列的 Zstd_fast_级别，它们的压缩速度更快，但支持的压缩比较低。 ZFS 支持 <code>zstd-fast-1</code> 到 <code>zstd-fast-10</code> ，以及以 10 为增量的 <code>zstd-fast-20</code> 到 <code>zstd-fast-100</code> ，还有 <code>zstd-fast-500</code> 和 <code>zstd-fast-1000</code> ，它们提供最小的压缩效果，但具有高性能。</p>
</div>
<div class="paragraph">
<p>如果 ZFS 无法获取所需的内存来使用 Zstd 压缩块，它将退回到存储未压缩的块。除非在内存受限的系统上使用 Zstd 的最高级别，否则这种情况不太可能发生。 ZFS 通过 <code>kstat.zfs.misc.zstd.compress_alloc_fail</code> 统计自加载 ZFS 模块以来发生此情况的次数。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-deduplication">22.4.12. 去重<a class="anchor" href="#zfs-zfs-deduplication"></a></h3>
<div class="paragraph">
<p>当启用时， <a href="#zfs-term-deduplication ">去重 </a> 使用每个块的校验和来检测重复块。当一个新块是现有块的副本时， ZFS 会写入一个对现有数据的新引用，而不是整个重复块。如果数据包含大量重复的文件或重复的信息，则可以实现巨大的空间节省。警告：去重需要大量的内存，并且启用压缩可以在不增加额外成本的情况下提供大部分的空间节省。</p>
</div>
<div class="paragraph">
<p>要激活去重功能，请在目标池上设置 <code>dedup</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set dedup=on pool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>去重只会影响写入池中的新数据。仅仅激活此选项不会对已经写入池中的数据进行去重。一个刚刚激活去重属性的池子将会像这个例子一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool list</span>
NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DEDUP</code> 列显示了池的实际重复消除率。 <code>1.00x</code> 的值表示数据尚未进行重复消除。下面的示例将一些系统二进制文件复制了三次，分别放入在上述创建的重复消除池中的不同目录中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># for d in dir1 dir2 dir3; do</span>
<span class="gp">&gt; </span>mkdir <span class="nv">$d</span> <span class="o">&amp;&amp;</span> cp -R /usr/bin <span class="nv">$d</span> &amp;
<span class="gp">&gt; </span><span class="k">done</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要观察冗余数据的去重，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool list</span>
NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DEDUP</code> 列显示了一个 <code>3.00x</code> 的因子。检测和去重数据的副本使用了三分之一的空间。节省空间的潜力是巨大的，但需要足够的内存来跟踪去重块的成本。</p>
</div>
<div class="paragraph">
<p>当池中的数据不冗余时，去重并不总是有益的。 ZFS 可以通过在现有池上模拟去重来显示潜在的节省空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zdb -S pool</span>
Simulated DDT histogram:

bucket              allocated                       referenced
______   ______________________________   ______________________________
refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
------   ------   -----   -----   -----   ------   -----   -----   -----
     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
   128        2   9.50K      2K      2K      419   2.11M    438K    438K
   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
 Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

dedup <span class="o">=</span> 1.05, compress <span class="o">=</span> 1.11, copies <span class="o">=</span> 1.00, dedup <span class="k">*</span> compress / copies <span class="o">=</span> 1.16</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>zdb -S</code> 完成分析池之后，它会显示激活去重将实现的空间减少比例。在这种情况下， <code>1.16</code> 是一个主要由压缩提供的较低的节省空间比例。在此池上激活去重将不会节省任何空间，并且不值得为启用去重所需的内存量。使用公式 <em>ratio = dedup * compress / copies</em>，系统管理员可以规划存储分配，决定工作负载是否包含足够的重复块来证明内存需求的合理性。如果数据可以合理压缩，空间节省可能会很好。良好的做法是首先启用压缩，因为压缩还可以大大提高性能。在节省可观且有足够可用内存用于 <a href="#zfs-term-deduplication ">DDT</a> 的情况下启用去重。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-jail">22.4.13. ZFS 和 Jails<a class="anchor" href="#zfs-zfs-jail"></a></h3>
<div class="paragraph">
<p>使用 <code>zfs jail</code> 命令和相应的 <code>jailed</code> 属性将一个 ZFS 数据集委派给一个 <a href="../jails/#jails">监狱</a> 。 <code>zfs jail <em>jailid</em></code> 命令将数据集附加到指定的监狱， <code>zfs unjail</code> 命令将其分离。要在监狱内控制数据集，需要设置 <code>jailed</code> 属性。由于被监禁的数据集可能具有会危及主机安全的挂载点， ZFS 禁止在主机上挂载被监禁的数据集。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-zfs-allow">22.5. 委派管理<a class="anchor" href="#zfs-zfs-allow"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>一个全面的权限委派系统允许非特权用户执行 ZFS 管理功能。例如，如果每个用户的主目录是一个数据集，用户需要有权限创建和销毁其主目录的快照。执行备份的用户可以获得使用复制功能的权限。 ZFS 允许一个使用统计脚本仅以访问所有用户的空间使用数据的方式运行。还可以委派委派权限的能力。权限委派对于每个子命令和大多数属性都是可能的。</p>
</div>
<div class="sect2">
<h3 id="zfs-zfs-allow-create">22.5.1. 委托数据集创建<a class="anchor" href="#zfs-zfs-allow-create"></a></h3>
<div class="paragraph">
<p><code>zfs allow <em>someuser</em> create <em>mydataset</em></code> 给予指定用户在选定的父数据集下创建子数据集的权限。但需要注意的是，创建新数据集需要挂载它。这要求设置 FreeBSD 的 <code>vfs.usermount</code> 系统控制变量为 <code>1</code> ，以允许非 root 用户挂载文件系统。另外，为了防止滥用，非 root 用户必须拥有挂载点来进行文件系统的挂载。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-allow-allow">22.5.2. 委派权限委派<a class="anchor" href="#zfs-zfs-allow-allow"></a></h3>
<div class="paragraph">
<p><code>zfs allow <em>someuser</em> allow <em>mydataset</em></code> 命令会赋予指定用户在目标数据集及其子数据集上分配其拥有的任何权限给其他用户的能力。如果一个用户拥有 <code>snapshot</code> 权限和 <code>allow</code> 权限，那么该用户可以将 <code>snapshot</code> 权限授予其他用户。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-advanced">22.6. 高级主题<a class="anchor" href="#zfs-advanced"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="zfs-advanced-tuning">22.6.1. 调优<a class="anchor" href="#zfs-advanced-tuning"></a></h3>
<div class="paragraph">
<p>调整可调节参数以使 ZFS 在不同的工作负载下表现最佳。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="zfs-advanced-tuning-arc_max"></a> <code><em>vfs.zfs.arc.max</em></code> 从 13.x 开始（ 12.x 为 <code>vfs.zfs.arc_max</code> ） - <a href="#zfs-term-arc ">ARC</a> 的上限大小。默认值为所有 RAM 减去 1 GB ，或所有 RAM 的 5/8 ，以较大者为准。如果系统运行其他可能需要内存的守护程序或进程，请使用较低的值。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 在运行时调整此值，并在 <span class="filename">/boot/loader.conf</span> 或 <span class="filename">/etc/sysctl.conf</span> 中设置。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-arc_meta_limit"></a> <code><em>vfs.zfs.arc.meta_limit</em></code> 从 13.x 版本开始（ 12.x 版本为 <code>vfs.zfs.arc_meta_limit</code> ） - 限制用于存储元数据的 <a href="#zfs-term-arc ">ARC</a> 的数量。默认值为 <code>vfs.zfs.arc.max</code> 的四分之一。如果工作负载涉及大量文件和目录的操作，或者频繁的元数据操作，增加此值将提高性能，但会减少适应于 <a href="#zfs-term-arc ">ARC</a> 的文件数据量。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 在 <span class="filename">/boot/loader.conf</span> 或 <span class="filename">/etc/sysctl.conf</span> 中在运行时调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-arc_min"></a> <code><em>vfs.zfs.arc.min</em></code> 从 13.x 开始（ 12.x 为 <code>vfs.zfs.arc_min</code> ） - 降低 <a href="#zfs-term-arc ">ARC</a> 的大小。默认值为 <code>vfs.zfs.arc.meta_limit</code> 的一半。调整此值以防止其他应用程序将整个 <a href="#zfs-term-arc ">ARC</a> 压力过大。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 在运行时调整此值，并在 <span class="filename">/boot/loader.conf</span> 或 <span class="filename">/etc/sysctl.conf</span> 中进行调整。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-vdev-cache-size"></a> <code><em>vfs.zfs.vdev.cache.size</em></code> - 在池中的每个设备上预留的用作缓存的内存的预分配量。使用的总内存量将是此值乘以设备数量。在引导时和 <span class="filename">/boot/loader.conf</span> 中设置此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-min-auto-ashift"></a> <code><em>vfs.zfs.min_auto_ashift</em></code> - 在创建池时自动使用的较低的 <code>ashift</code> （扇区大小）。该值是 2 的幂。默认值为 <code>9</code> 表示 <code>2 ^ 9 = 512</code> ，即 512 字节的扇区大小。为了避免写放大并获得最佳性能，将此值设置为池中设备使用的最大扇区大小。</p>
<div class="paragraph">
<p>普通硬盘的扇区大小为 4 KB 。在这些硬盘上使用默认的 <code>ashift</code> 值 <code>9</code> 会导致写放大。一个 4 KB 的写入数据实际上会被分成八个 512 字节的写入操作。在创建存储池时， ZFS 会尝试从所有设备中读取原生扇区大小，但是具有 4 KB 扇区的硬盘会报告它们的扇区大小为 512 字节，以保证兼容性。在创建存储池之前，将 <code>vfs.zfs.min_auto_ashift</code> 设置为 <code>12</code> （ <code>2 ^ 12 = 4096</code> ）可以强制 ZFS 在这些硬盘上使用 4 KB 块以获得最佳性能。</p>
</div>
<div class="paragraph">
<p>对于计划进行磁盘升级的存储池来说，强制使用 4 KB 块也是有用的。未来的磁盘使用 4 KB 扇区，并且在创建存储池后无法更改 <code>ashift</code> 值。</p>
</div>
<div class="paragraph">
<p>在某些特定情况下，较小的 512 字节块大小可能更可取。当与用于数据库或作为虚拟机存储的 512 字节磁盘一起使用时，小规模随机读取时的数据传输量较少。这可以在使用较小的 ZFS 记录大小时提供更好的性能。</p>
</div>
</li>
<li>
<p><a id="zfs-advanced-tuning-prefetch_disable"></a> <code><em>vfs.zfs.prefetch_disable</em></code> - 禁用预读取。值为 <code>0</code> 表示启用，值为 <code>1</code> 表示禁用。默认值为 <code>0</code> ，除非系统内存小于 4 GB 。预读取通过读取比请求的块更大的块到 <a href="#zfs-term-arc ">ARC</a> 中，希望很快需要这些数据。如果工作负载有大量的随机读取，禁用预读取可能会通过减少不必要的读取来提高性能。可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-vdev-trim_on_init"></a> <code><em>vfs.zfs.vdev.trim_on_init</em></code> - 控制是否在将新设备添加到池中时对其运行 <code>TRIM</code> 命令。这可以确保 SSD 的最佳性能和寿命，但会花费额外的时间。如果设备已经进行了安全擦除，则禁用此设置将使新设备的添加更快。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-vdev-max_pending"></a> <code><em>vfs.zfs.vdev.max_pending</em></code> - 限制每个设备的待处理 I/O 请求的数量。较高的值将保持设备命令队列满，并可能提供更高的吞吐量。较低的值将减少延迟。您可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-top_maxinflight"></a> <code><em>vfs.zfs.top_maxinflight</em></code> - 每个顶级 <a href="#zfs-term-vdev ">vdev</a> 的未完成 I/O 的上限。限制命令队列的深度以防止高延迟。该限制是针对每个顶级 vdev 的，意味着该限制独立应用于每个 <a href="#zfs-term-vdev-mirror ">mirror</a> 、 <a href="#zfs-term-vdev-raidz ">RAID-Z</a> 或其他 vdev 。可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-l2arc_write_max"></a> <code><em>vfs.zfs.l2arc_write_max</em></code> - 限制每秒写入 <a href="#zfs-term-l2arc ">L2ARC</a> 的数据量。通过限制写入设备的数据量，此可调整参数可以延长固态硬盘（ SSD ）的使用寿命。您可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-l2arc_write_boost"></a> <code><em>vfs.zfs.l2arc_write_boost</em></code> - 将此可调整值添加到 <a href="#zfs-advanced-tuning-l2arc_write_max "><code>vfs.zfs.l2arc_write_max</code></a> 中，并增加对 SSD 的写入速度，直到从 <a href="#zfs-term-l2arc ">L2ARC</a> 中驱逐第一个块。这个&#34;Turbo Warmup Phase&#34;可以减少重启后空的 <a href="#zfs-term-l2arc ">L2ARC</a> 带来的性能损失。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-scrub_delay"></a><code><em>vfs.zfs.scrub_delay</em></code> - 在进行 <a href="#zfs-term-scrub "><code>scrub</code></a> 时，每个 I/O 之间的延迟时间。为了确保 <code>scrub</code> 不会干扰池的正常操作，如果有其他 I/O 正在进行， <code>scrub</code> 会在每个命令之间进行延迟。该值控制了 <code>scrub</code> 生成的总 IOPS （每秒 I/O 数）的限制。设置的粒度由 <code>kern.hz</code> 的值确定，默认为每秒 1000 个滴答。更改此设置会导致不同的有效 IOPS 限制。默认值为 <code>4</code> ，因此限制为： 1000 个滴答 / 秒 ÷ 4 = 250 IOPS 。使用值为_20_将得到限制： 1000 个滴答 / 秒 ÷ 20 = 50 IOPS 。池上的最近活动限制了 <code>scrub</code> 的速度，由 <a href="#zfs-advanced-tuning-scan_idle "><code>vfs.zfs.scan_idle</code></a> 确定。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-resilver_delay"></a> <code><em>vfs.zfs.resilver_delay</em></code> - 在 <a href="#zfs-term-resilver ">resilver</a> 过程中，每个 I/O 之间插入的延迟时间，以毫秒为单位。为了确保 resilver 不会干扰池的正常操作，如果有其他 I/O 正在进行， resilver 将在每个命令之间延迟。该值控制由 resilver 生成的总 IOPS （每秒 I/O 数）的限制。 ZFS 通过 <code>kern.hz</code> 的值确定设置的粒度，默认为每秒 1000 个滴答。更改此设置会导致不同的有效 IOPS 限制。默认值为 2 ，结果为： 1000 个滴答 / 秒 ÷ 2 = 500 IOPS 。如果另一个设备故障可能导致池发生故障，从而导致数据丢失，则将池恢复到 <a href="#zfs-term-online ">Online</a> 状态可能更为重要。值为 0 将使 resilver 操作与其他操作具有相同的优先级，加快修复过程。池上的其他最近活动会限制 resilver 的速度，由 <a href="#zfs-advanced-tuning-scan_idle "><code>vfs.zfs.scan_idle</code></a> 确定。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-scan_idle"></a> <code><em>vfs.zfs.scan_idle</em></code> - 距离上次操作的毫秒数，用于判断池是否处于空闲状态。当池处于空闲状态时， ZFS 会禁用对 <a href="#zfs-term-scrub "><code>scrub</code></a> 和 <a href="#zfs-term-resilver ">resilver</a> 的速率限制。您可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><code><em>vfs.zfs.txg.timeout</em></code> - 两个 <a href="#zfs-term-txg ">事务组 </a> 之间的最长时间间隔，以秒为单位。当前事务组将数据写入池中，并且如果自上一个事务组以来经过了这么长时间，则会启动一个新的事务组。如果写入的数据足够多，事务组可能会提前触发。默认值为 5 秒。增大该值可能会通过延迟异步写入来提高读取性能，但这可能会导致写入事务组时性能不均衡。可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="zfs-advanced-i386">22.6.2. i386 上的 ZFS<a class="anchor" href="#zfs-advanced-i386"></a></h3>
<div class="paragraph">
<p>ZFS 提供的一些功能对内存要求较高，可能需要在内存有限的系统上进行调整以达到最佳效率。</p>
</div>
<div class="sect3">
<h4 id="_内存">22.6.2.1. 内存<a class="anchor" href="#_内存"></a></h4>
<div class="paragraph">
<p>作为一个较低的值，总系统内存应至少为 1GB 。推荐的 RAM 数量取决于存储池的大小和 ZFS 使用的功能。一个经验法则是每 1TB 存储空间需要 1GB 的 RAM 。如果使用去重功能，一个经验法则是每 1TB 存储空间需要 5GB 的 RAM 用于去重。虽然一些用户在较少的 RAM 下使用 ZFS ，但在负载较重的系统下可能会因内存耗尽而发生崩溃。对于 RAM 低于推荐要求的系统，可能需要进一步调整 ZFS 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_内核配置">22.6.2.2. 内核配置<a class="anchor" href="#_内核配置"></a></h4>
<div class="paragraph">
<p>由于 i386™ 平台的地址空间限制， i386™ 架构上的 ZFS 用户必须将此选项添加到自定义内核配置文件中，重新构建内核并重新启动：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options        KVA_PAGES=512</pre>
</div>
</div>
<div class="paragraph">
<p>这将扩展内核地址空间，允许 <code>vm.kvm_size</code> 可调参数超过 1 GB 的限制，或者超过 PAE 的 2 GB 限制。为了找到最合适的选项值，将所需的地址空间以兆字节为单位除以四。在这个例子中，为 2 GB 选择 <code>512</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_加载器可调参数">22.6.2.3. 加载器可调参数<a class="anchor" href="#_加载器可调参数"></a></h4>
<div class="paragraph">
<p>在所有 FreeBSD 架构上增加了 <span class="filename">kmem</span> 地址空间。一个具有 1 GB 物理内存的测试系统通过将这些选项添加到 <span class="filename">/boot/loader.conf</span> 并重新启动来受益。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vm.kmem_size=&#34;330M&#34;
vm.kmem_size_max=&#34;330M&#34;
vfs.zfs.arc.max=&#34;40M&#34;
vfs.zfs.vdev.cache.size=&#34;5M&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>有关 ZFS 相关调优的更详细建议列表，请参阅 <a href="https://wiki.freebsd.org/ZFSTuningGuide" class="bare">https://wiki.freebsd.org/ZFSTuningGuide</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-links">22.7. 进一步资源<a class="anchor" href="#zfs-links"></a></h2>
<div class="sectionbody">
<div class="ulist">
<ul>
<li>
<p>[OpenZFS](<a href="https://openzfs.org/" class="bare">https://openzfs.org/</a>)</p>
</li>
<li>
<p><a href="https://wiki.freebsd.org/ZFSTuningGuide">FreeBSD Wiki - ZFS 调优</a></p>
</li>
<li>
<p>[Calomel 博客 - ZFS Raidz 性能、容量和完整性]</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs-term">22.8. ZFS 功能和术语<a class="anchor" href="#zfs-term"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>ZFS 不仅仅是一个文件系统，它在根本上是不同的。 ZFS 将文件系统和卷管理器的角色结合在一起，使新的存储设备能够添加到活动系统中，并且新的空间可以立即在该池中的现有文件系统上使用。通过结合传统上分开的角色， ZFS 能够克服以前阻止 RAID 组能够增长的限制。<em>vdev_是池中的顶级设备，可以是简单的磁盘或者是镜像或 RAID-Z 阵列等 RAID 转换。 ZFS 文件系统（称为_datasets</em>）每个都可以访问整个池的合并空闲空间。池中使用的块会减少每个文件系统可用的空间。这种方法避免了广泛分区中常见的问题，即空闲空间在分区之间变得碎片化。</p>
</div>
<table class="tableblock frame-all grid-all stretch informaltable">
<colgroup>
<col style="width: 10%;"/>
<col style="width: 90%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-pool"></a> 池</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储池是 ZFS 的最基本构建块。一个存储池由一个或多个 vdev 组成， vdev 是存储数据的底层设备。然后使用存储池来创建一个或多个文件系统（数据集）或块设备（卷）。
这些数据集和卷共享剩余的自由空间。每个存储池都有一个唯一的名称和 GUID 来进行标识。存储池上的 ZFS 版本号决定了可用的功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-vdev"></a>vdev 类型</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>一个池由一个或多个 vdev 组成，它们本身是一个单独的磁盘或一组磁盘，转换为 RAID 。当使用大量的 vdev 时， ZFS 会将数据分散在 vdev 上，以提高性能和最大化可用空间。所有的 vdev 都必须至少 128MB 大小。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="zfs-term-vdev-disk"></a> <em>磁盘</em> - 最基本的 vdev 类型是标准块设备。这可以是整个磁盘（如 <span class="filename">/dev/ada0</span> 或 <span class="filename">/dev/da0</span> ）或一个分区（ <span class="filename">/dev/ada0p3</span> ）。在 FreeBSD 上，使用分区而不是整个磁盘不会有性能损失。这与 Solaris 文档的建议不同。</p>
<div class="literalblock">
<div class="content">
<pre>[CAUTION]</pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>强烈不建议将整个磁盘作为可引导池的一部分，因为这可能导致池无法引导。
同样，您不应将整个磁盘用作镜像或 RAID-Z vdev 的一部分。
在引导时可靠地确定未分区磁盘的大小是不可能的，也没有地方放置引导代码。</p>
</div>
</div>
</div>
</li>
<li>
<p><a id="zfs-term-vdev-file"></a> <em>文件</em> - 普通文件可以组成 ZFS 池，这对于测试和实验很有用。在 <code>zpool create</code> 中，使用文件的完整路径作为设备路径。</p>
</li>
<li>
<p><a id="zfs-term-vdev-mirror"></a> <em>镜像</em> - 创建镜像时，使用 <code>mirror</code> 关键字后跟镜像的成员设备列表。镜像由两个或更多设备组成，将所有数据写入所有成员设备。镜像 vdev 将保存与其最小成员相同的数据量。镜像 vdev 可以承受除一个成员外的所有成员故障而不丢失任何数据。</p>
<div class="literalblock">
<div class="content">
<pre>[NOTE]</pre>
</div>
</div>
<div class="exampleblock">
<div class="content">
<div class="paragraph">
<p>要随时将常规单磁盘 vdev 升级为镜像 vdev ，请使用 <code>zpool <a href="#zfs-zpool-attach ">attach</a></code> 。</p>
</div>
</div>
</div>
</li>
<li>
<p><a id="zfs-term-vdev-raidz"></a> <em>RAID-Z</em> - ZFS 使用 RAID-Z ，这是标准 RAID-5 的变种，提供更好的奇偶校验分布，并消除了“ RAID-5 写洞”，即在意外重启后数据和奇偶校验信息变得不一致的问题。 ZFS 支持三个级别的 RAID-Z ，它们在提供不同的冗余级别的同时降低可用存储级别。 ZFS 使用基于阵列中奇偶校验设备数量和可以故障的磁盘数量的 RAID-Z1 到 RAID-Z3 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在一个由四个 1TB 磁盘组成的 RAID-Z1 配置中，可用存储空间为 3TB ，并且池仍能在一个故障磁盘的降级模式下运行。如果在替换和重新同步故障磁盘之前另一个磁盘离线，将导致丢失所有池数据。</p>
</div>
<div class="paragraph">
<p>在一个由八个 1TB 磁盘组成的 RAID-Z3 配置中，该卷将提供 5TB 的可用空间，并且仍能在三个故障磁盘的情况下运行。 Sun™ 建议在单个 vdev 中不要使用超过九个磁盘。如果更多的磁盘组成配置，则建议将它们分成单独的 vdev ，并将池数据分布在它们之间。</p>
</div>
<div class="paragraph">
<p>由每个包含 8 个磁盘的 RAID-Z2 vdev 组成的配置将创建类似于 RAID-60 阵列的东西。 RAID-Z 组的存储容量约为最小磁盘大小乘以非奇偶校验磁盘数量。 RAID-Z1 中的四个 1TB 磁盘的有效大小约为 3TB ，而 RAID-Z3 中的八个 1TB 磁盘阵列将提供 5TB 的可用空间。
 * <a id="zfs-term-vdev-spare"></a> <em>热备</em> - ZFS 有一种特殊的伪 vdev 类型，用于跟踪可用的热备。请注意，已安装的热备不会自动部署；请使用 <code>zfs replace</code> 手动配置它们以替换故障设备。
 * <a id="zfs-term-vdev-log"></a> <em>日志</em> - ZFS 日志设备，也称为 ZFS 意图日志（ <a href="#zfs-term-zil ">ZIL</a> ），将意图日志从常规池设备移动到专用设备，通常是 SSD 。拥有专用的日志设备可以提高具有大量同步写入（如数据库）的应用程序的性能。日志设备的镜像是可能的，但不支持 RAID-Z 。如果使用大量日志设备，写入将在它们之间进行负载平衡。
 * <a id="zfs-term-vdev-cache"></a> <em>缓存</em> - 向池添加缓存 vdev 将将缓存的存储添加到 <a href="#zfs-term-l2arc ">L2ARC</a> 中。镜像缓存设备是不可能的。由于缓存设备仅存储现有数据的新副本，不存在数据丢失的风险。</p>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-txg"></a> 事务组 (TXG)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务组是 ZFS 将块更改分组并写入池的方式。事务组是 ZFS 用来确保一致性的原子单位。 ZFS 为每个事务组分配一个唯一的 64 位连续标识符。同时可以有最多三个活动事务组，分别处于以下三种状态之一：</p>
<p class="tableblock"> * <em>打开</em> - 新的事务组开始时处于打开状态并接受新的写入。始终有一个处于打开状态的事务组，但如果达到限制，事务组可能会拒绝新的写入。一旦打开的事务组达到限制，或达到了 <a href="#zfs-advanced-tuning-txg-timeout "><code>vfs.zfs.txg.timeout</code></a> ，事务组将进入下一个状态。
 * <em>静默</em> - 一个短暂的状态，允许所有待处理的操作完成，而不会阻塞新的打开事务组的创建。一旦组中的所有事务完成，事务组将进入最终状态。
 * <em>同步</em> - 将事务组中的所有数据写入稳定存储。这个过程将进一步改变其他数据，如元数据和空间映射， ZFS 也会将其写入稳定存储。同步过程涉及多个步骤。首先是所有更改的数据块；接下来是元数据，可能需要多次通过才能完成。由于为数据块分配空间会生成新的元数据，因此同步状态无法完成，直到完成一个不使用任何新空间的步骤。同步状态也是_synctasks_完成的地方。 Synctasks 是完成超级块更改的创建或销毁快照和数据集等管理操作。一旦同步状态完成，处于静默状态的事务组将进入同步状态。所有管理功能，如 <a href="#zfs-term-snapshot "><code>snapshot</code></a> ，都作为事务组的一部分进行写入。 ZFS 将创建的 synctask 添加到打开的事务组中，并尽快将该组推进到同步状态，以减少管理命令的延迟。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">自适应替换缓存（ ARC ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 使用自适应替换缓存（ ARC ），而不是更传统的最近最少使用（ LRU ）缓存。 LRU 缓存是一个简单的缓存项列表，按照对象最近使用的时间排序，将新项添加到列表的头部。当缓存已满时，从列表的尾部逐出项以为更活跃的对象腾出空间。 ARC 由四个列表组成：最近最常使用（ MRU ）对象和最频繁使用（ MFU ）对象，以及每个列表的幽灵列表。这些幽灵列表跟踪被逐出的对象，以防止将它们重新添加到缓存中。这通过避免具有偶尔使用历史的对象来提高缓存命中率。同时使用 MRU 和 MFU 的另一个优点是，扫描整个文件系统将逐出 MRU 或 LRU 缓存中的所有数据，以便为这些新访问的内容腾出空间。在 ZFS 中，还有一个跟踪最常使用对象的 MFU ，并保留最常访问块的缓存。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-l2arc"></a>L2ARC 是 ZFS 文件系统中的一个重要组件。它是一种用于缓存热数据的高速读取缓存设备。 L2ARC 可以提高读取性能，减少磁盘 I/O 操作，从而加快文件系统的响应速度。它通常使用高速存储介质，如 SSD 来存储数据。 L2ARC 的工作原理是将最常访问的数据块缓存到高速存储设备中，以便在后续的读取操作中快速获取。通过使用 L2ARC ， ZFS 可以更好地利用系统的内存和存储资源，提供更高效的数据访问和处理能力。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L2ARC 是 ZFS 缓存系统的第二级。 RAM 存储主要的 ARC 。由于可用的 RAM 数量通常有限， ZFS 还可以使用缓存 vdevs 。由于与传统的旋转硬盘相比，固态硬盘（ SSD ）具有更高的速度和更低的延迟，因此通常将其用作缓存设备。 L2ARC 是完全可选的，但拥有一个 L2ARC 将提高从 SSD 读取缓存文件的速度，而不必从常规磁盘读取。 L2ARC 还可以加速去重，因为不适合 RAM 但适合 L2ARC 的去重表（ DDT ）比必须从磁盘读取的 DDT 快得多。对缓存设备添加的数据速率限制可以防止额外的写入过早磨损 SSD 。在缓存填满之前（为了腾出空间而驱逐的第一个块），写入 L2ARC 的限制为写入限制和增加限制的总和，之后限制为写入限制。一对 sysctl 值控制这些速率限制。 vfs.zfs.l2arc_write_max 控制每秒写入缓存的字节数，而 vfs.zfs.l2arc_write_boost 在“ Turbo Warmup Phase ”（写入增强）期间增加了这个限制。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-zil"></a>ZIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZIL 通过使用比主存储池中使用的存储设备（如 SSD ）更快的设备来加速同步事务。当应用程序请求同步写入（保证数据存储到磁盘而不仅仅是缓存以供以后写入时），将数据写入更快的 ZIL 存储，然后稍后将其刷新到常规磁盘上，大大降低了延迟并提高了性能。像数据库这样的同步工作负载将从 ZIL 中受益。而常规的异步写入（如复制文件）则根本不会使用 ZIL 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-cow"></a> 写时复制</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与传统的文件系统不同， ZFS 在写入数据时不会直接覆盖旧数据，而是写入一个不同的块。完成写入后，元数据会更新以指向新的位置。当发生截断写入（系统崩溃或断电导致文件写入中断）时，文件的完整原始内容仍然可用，而 ZFS 会丢弃不完整的写入。这也意味着 ZFS 在意外关闭后不需要进行 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 操作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-dataset"></a> 数据集</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据集（<em>Dataset</em>）是 ZFS 文件系统、卷、快照或克隆的通用术语。每个数据集都有一个唯一的名称，格式为_poolname/path @ snapshot_。池的根也是一个数据集。子数据集具有层次结构的名称，类似于目录。例如，<em>mypool/home</em>，即 home 数据集，是 mypool 的子数据集，并从其继承属性。通过创建_mypool/home/user_，可以进一步扩展此结构。这个孙子数据集将从父级和祖父级继承属性。在子数据集上设置属性以覆盖从父级和祖父级继承的默认值。可以将数据集及其子数据集的管理委托给其他用户。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-filesystem"></a> 文件系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 数据集通常用作文件系统。与大多数其他文件系统一样， ZFS 文件系统会挂载到系统目录层次结构的某个位置，并包含具有权限、标志和其他元数据的文件和目录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-volume"></a> 卷</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 还可以创建卷，它们会显示为磁盘设备。卷具有与数据集相似的许多功能，包括写时复制、快照、克隆和校验和。卷对于在 ZFS 上运行其他文件系统格式（如 UFS 虚拟化）或导出 iSCSI 扩展非常有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-snapshot"></a> 快照</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 的 <a href="#zfs-term-cow ">写时复制 </a> （ COW ）设计允许几乎瞬间创建具有任意名称的一致性快照。在对数据集进行快照或对包含所有子数据集的父数据集进行递归快照之后，新数据将进入新的块，但不会将旧块回收为可用空间。快照包含原始文件系统版本，活动文件系统包含自快照以来所做的任何更改，而不使用其他空间。写入活动文件系统的新数据使用新的块来存储这些数据。随着块在活动文件系统中不再使用，快照将增长，但仅在快照中使用。将这些快照以只读方式挂载可以恢复先前的文件版本。可以将活动文件系统回滚到特定快照的 <a href="#zfs-zfs-snapshot ">回滚 </a> 是可能的，从而撤消在快照之后进行的任何更改。池中的每个块都有一个引用计数器，用于跟踪使用该块的快照、克隆、数据集或卷。随着文件和快照被删除，引用计数减少，当不再引用块时，回收可用空间。使用 <a href="#zfs-zfs-snapshot ">保留 </a> 标记快照将导致任何试图销毁它的尝试返回 <code>EBUSY</code> 错误。每个快照可以具有唯一名称的保留。 <a href="#zfs-zfs-snapshot ">释放 </a> 命令会移除保留，以便可以删除快照。快照、克隆和回滚适用于卷，但独立挂载不适用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-clone"></a> 克隆</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">克隆快照也是可能的。克隆是快照的可写版本，允许文件系统分叉为一个新的数据集。与快照一样，克隆最初不占用新的空间。当新数据写入克隆时，使用新的块，克隆的大小增长。当在克隆的文件系统或卷中覆盖块时，先前块的引用计数减少。删除克隆所依赖的快照是不可能的，因为克隆依赖于它。快照是父级，克隆是子级。克隆可以被“提升”，反转这种依赖关系，使克隆成为父级，先前的父级成为子级。此操作不需要新的空间。由于父级和子级使用的空间相互转换，可能会影响现有的配额和预留空间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-checksum"></a> 校验和</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个块也都有校验和。所使用的校验算法是每个数据集的属性，参见 <a href="#zfs-zfs-set "><code>set</code></a> 。在读取时，每个块的校验和会被透明地验证，这使得 ZFS 能够检测到静默损坏。如果读取的数据与预期的校验和不匹配， ZFS 将尝试从任何可用的冗余中恢复数据，例如镜像或 RAID-Z 。可以使用 <a href="#zfs-term-scrub "><code>scrub</code></a> 触发对所有校验和的验证。校验算法包括：</p>
<p class="tableblock"> * <code>fletcher2</code>
 * <code>fletcher4</code>
 * <code>sha256</code>
 <code>fletcher</code> 算法更快，但 <code>sha256</code> 是一种强大的加密哈希算法，具有更低的碰撞几率，但性能稍有损失。可以禁用校验和，但强烈不建议这样做。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-compression"></a> 压缩</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个数据集都有一个压缩属性，默认为关闭状态。将此属性设置为可用的压缩算法。这将导致对写入数据集的所有新数据进行压缩。除了减少所使用的空间外，读写吞吐量通常也会增加，因为需要读取或写入的块较少。</p>
<p class="tableblock"> <a id="zfs-term-compression-lz4"></a>
 * <em>LZ4</em> - 在 ZFS 池版本 5000 （特征标志）中添加， LZ4 现在是推荐的压缩算法。当处理可压缩数据时， LZ4 的工作速度比 LZJB 快约 50 ％，处理不可压缩数据时，速度快三倍以上。 LZ4 的解压速度也比 LZJB 快约 80 ％。在现代 CPU 上， LZ4 通常可以以超过 500 MB/s 的速度进行压缩，并以超过 1.5 GB/s 的速度进行解压缩（每个单独的 CPU 核心）。</p>
<p class="tableblock"> <a id="zfs-term-compression-lzjb"></a>
 * <em>LZJB</em> - 默认的压缩算法。由 Jeff Bonwick （ ZFS 的原始创建者之一）创建。与 GZIP 相比， LZJB 提供了较好的压缩效果，并且 CPU 开销较小。在将来，默认的压缩算法将更改为 LZ4 。</p>
<p class="tableblock"> <a id="zfs-term-compression-gzip"></a>
 * <em>GZIP</em> - ZFS 中提供的一种流压缩算法。使用 GZIP 的主要优势之一是其可配置的压缩级别。在设置 <code>compress</code> 属性时，管理员可以选择压缩级别，从最低级别的 <code>gzip1</code> 到最高级别的 <code>gzip9</code> 。这使管理员可以控制以多少 CPU 时间来换取节省的磁盘空间。</p>
<p class="tableblock"> <a id="zfs-term-compression-zle"></a>
 * <em>ZLE</em> - 零长度编码是一种特殊的压缩算法，仅压缩连续的零。当数据集包含大块的零时，这种压缩算法非常有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-copies"></a> 副本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>copies</code> 属性设置为大于 1 的值时， ZFS 会在 <a href="#zfs-term-filesystem ">文件系统 </a> 或 <a href="#zfs-term-volume ">卷 </a> 中维护每个块的副本。在重要的数据集上设置此属性可以提供额外的冗余，以便从中恢复不匹配其校验和的块。在没有冗余的存储池中，副本功能是唯一的冗余形式。副本功能可以从单个坏扇区或其他形式的轻微损坏中恢复，但它不能保护存储池免受整个磁盘的丢失。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-deduplication"></a> 去重</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在写入数据时，校验和可以检测重复的数据块。通过去重，现有相同块的引用计数增加，节省存储空间。 ZFS 在内存中保留一个去重表（ DDT ）来检测重复的数据块。该表包含一系列唯一的校验和、这些块的位置和引用计数。在写入新数据时， ZFS 计算校验和并将其与列表进行比较。当找到匹配项时，它使用现有的数据块。使用 SHA256 校验和算法进行去重提供了安全的加密哈希。去重是可调整的。如果 <code>dedup</code> 设置为 <code>on</code> ，那么匹配的校验和意味着数据是相同的。将 <code>dedup</code> 设置为 <code>verify</code> ， ZFS 对数据执行逐字节的检查，确保它们实际上是相同的。如果数据不相同， ZFS 将记录哈希冲突并将这两个块分别存储。由于 DDT 必须存储每个唯一块的哈希，它会消耗大量的内存。一个经验法则是每 1TB 去重数据需要 5-6GB 的 RAM ）。在无法实际拥有足够的 RAM 来将整个 DDT 保留在内存中的情况下，性能将大大降低，因为 DDT 必须在写入每个新块之前从磁盘读取。去重可以使用 L2ARC 来存储 DDT ，提供了快速系统内存和较慢磁盘之间的折中方案。考虑使用压缩代替，压缩通常可以提供几乎相同的空间节省效果，而不需要增加内存使用量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-scrub"></a>Scrub 是 ZFS 文件系统中的一个重要操作。它用于检查和修复存储池中的数据完整性问题。 Scrub 操作会扫描存储池中的所有数据块，并与其校验和进行比较，以检测任何损坏或错误的数据。如果发现问题， Scrub 操作会尝试修复或恢复数据。 Scrub 操作可以定期执行，以确保数据的持久性和可靠性。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 类似的一致性检查不同， ZFS 使用 <code>scrub</code> 命令。 <code>scrub</code> 命令会读取存储在池中的所有数据块，并将它们的校验和与元数据中存储的已知良好校验和进行验证。定期检查池中存储的所有数据可以确保在需要之前恢复任何损坏的块。在非正常关闭后不需要进行 scrub ，但良好的做法是至少每三个月进行一次。 ZFS 在正常使用过程中会验证每个块的校验和，但 scrub 会确保对即使很少使用的块进行静默损坏检查。 ZFS 在归档存储情况下提高了数据安全性。通过调整 <code>scrub</code> 的相对优先级，可以使用 <a href="#zfs-advanced-tuning-scrub_delay "><code>vfs.zfs.scrub_delay</code></a> 来防止 scrub 影响池上其他工作负载的性能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-quota"></a> 数据集配额</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 提供了快速准确的数据集、用户和组空间账户，以及配额和空间预留。这使得管理员可以对空间分配进行精细控制，并允许为关键文件系统预留空间。</p>
<p class="tableblock"> ZFS 支持不同类型的配额：数据集配额、引用配额（ refquota ）、用户配额和组配额。</p>
<p class="tableblock">配额限制了数据集及其后代的总大小，包括数据集的快照、子数据集和这些数据集的快照。</p>
<p class="tableblock"> [NOTE]
====
卷不支持配额，因为 <code>volsize</code> 属性充当隐式配额。
====</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-refquota"></a> 参考配额</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">引用配额限制了数据集可以消耗的空间量，通过强制执行一个硬限制。这个硬限制包括数据集本身引用的空间，但不包括后代使用的空间，比如文件系统或快照。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-userquota"></a> 用户配额</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户配额对于限制指定用户使用的空间量非常有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-groupquota"></a> 组配额</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">群组配额限制了指定群组可以使用的空间量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-reservation"></a> 数据集预留空间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reservation</code> 属性使得可以为特定数据集及其子数据集保证一定的空间量。这意味着在 <span class="filename">storage/home/bob</span> 上设置 10 GB 的保留空间，可以防止其他数据集使用完所有的空闲空间，至少为该数据集保留 10 GB 的空间。与常规的 <a href="#zfs-term-refreservation "><code>refreservation</code></a> 不同，快照和子数据集使用的空间不计入保留空间。例如，如果对 <span class="filename">storage/home/bob</span> 进行快照，除了 <code>refreservation</code> 的空间量之外，必须存在足够的磁盘空间才能成功进行操作。主数据集的子数据集不计入 <code>refreservation</code> 的空间量，因此不会侵占设置的空间。</p>
<p class="tableblock">任何类型的保留空间在以下情况下非常有用：在新系统中规划和测试磁盘空间分配的适用性，或确保文件系统上有足够的空间用于音频日志或系统恢复程序和文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-refreservation"></a> 参考保留</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refreservation</code> 属性使得可以为特定数据集的使用保证一定的空间，但不包括其子数据集。这意味着在 <span class="filename">storage/home/bob</span> 上设置 10GB 的保留空间，如果另一个数据集尝试使用空闲空间，至少要保留 10GB 的空间给该数据集。与常规的 <a href="#zfs-term-reservation ">reservation</a> 不同，快照和子数据集使用的空间不计入保留空间。例如，如果对 <span class="filename">storage/home/bob</span> 进行快照，除了 <code>refreservation</code> 的空间之外，必须存在足够的磁盘空间才能成功进行操作。主数据集的子数据集不计入 <code>refreservation</code> 的空间，因此不会侵占设置的空间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-resilver"></a> 重建</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当替换一个故障的磁盘时， ZFS 必须用丢失的数据填充新的磁盘。_重建_是使用分布在剩余驱动器上的奇偶校验信息来计算并将丢失的数据写入新驱动器的过程。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-online"></a> 在线</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处于“在线”状态的池或 vdev 具有其成员设备连接并完全运行。处于“在线”状态的个别设备正在正常运行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-offline"></a> 离线</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果存在足够的冗余以避免使存储池或虚拟设备进入“故障”状态，管理员会将单个设备设置为“离线”状态。管理员可以选择将磁盘设置为离线状态，以便准备更换它，或者为了更容易识别。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-degraded"></a> 降级</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处于“降级”状态的池或 vdev 有一个或多个磁盘消失或失败。池仍然可用，但如果其他设备失败，池可能变得无法恢复。重新连接丢失的设备或替换失败的磁盘将在重新连接或新设备完成“ Resilver ”过程后将池恢复到“在线”状态。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-faulted"></a> 故障</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处于“故障”状态的池或 vdev 不再可操作。无法访问数据。当缺失或故障设备的数量超过 vdev 中的冗余级别时，池或 vdev 进入“故障”状态。如果重新连接缺失的设备，池将返回到“在线”状态。冗余不足以弥补故障磁盘数量会导致池内容丢失，并需要从备份中恢复。</p></td>
</tr>
</tbody>
</table>
</div>
</div>

    </div>
    
    <hr />
    <div class="last-modified">
      <p><strong>Last modified on</strong>: December 25, 2023 by <a href="https://cgit.freebsd.org/doc/commit/?id=aafdd0e" target="_blank">fiercex</a></p>
    </div>
    
    <div class="buttons">
      
      <div class="prev">
        <i class="fa fa-angle-left" aria-hidden="true" title="Prev"></i>
        <div class="container">
          
            <a href=https://free.bsd-doc.org/zh-cn-auto/books/handbook/geom class="direction">Prev</a>
          
        </div>
      </div>
      
      <div class="home">
        <i class="fa fa-home" aria-hidden="true" title="Home"></i>
        <div class="container">
          
            <a href="../" class="direction">Home</a>
          
        </div>
      </div>
      
      <div class="next">
        <div class="container">
          
            <a href=https://free.bsd-doc.org/zh-cn-auto/books/handbook/filesystems  class="direction">Next</a>
          
        </div>
        <i class="fa fa-angle-right" aria-hidden="true" title="Next"></i>
      </div>
      
    </div>
    <label class="hidden book-menu-overlay" for="menu-control"></label>
  </div>
  <aside class="toc">
    <div class="toc-content">
      <h3>Table of Contents</h3>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#zfs-differences">22.1. ZFS 有何不同之处</a></li>
    <li><a href="#zfs-quickstart">22.2. 快速入门指南</a></li>
    <li><a href="#zfs-zpool">22.3. <code>zpool</code> 管理</a></li>
    <li><a href="#zfs-zfs">22.4. <code>zfs</code> 管理</a></li>
    <li><a href="#zfs-zfs-allow">22.5. 委派管理</a></li>
    <li><a href="#zfs-advanced">22.6. 高级主题</a></li>
    <li><a href="#zfs-links">22.7. 进一步资源</a></li>
    <li><a href="#zfs-term">22.8. ZFS 功能和术语</a></li>
  </ul>
</nav>
      <hr />
      
    </div>
  </aside>
  <a class="to-top" href="#top">
    <i class="fa fa-arrow-circle-up" aria-hidden="true"></i>
  </a>
</main>

    <footer>
  <div class="footer-container">
    <section class="logo-column">
          <img src="https://free.bsd-doc.org/images/FreeBSD-colors.svg" width="160" height="50" alt="FreeBSD logo" />
        <div class="options-container">
          
            <div class="language-container">
              <a id="languages" href="https://free.bsd-doc.org/zh-cn-auto/languages">
                
                <img src="https://free.bsd-doc.org/images/language.png" class="language-image" alt="Choose language">
                <span>简体中文-自动翻译</span>
              </a>
            </div>
          
          <div class="theme-container">
            <select id="theme-chooser">
	      <option value="theme-system">System</option>
              <option value="theme-light">Light</option>
              <option value="theme-dark">Dark</option>
              <option value="theme-high-contrast">High contrast</option>
            </select>
          </div>
        </div>
      </section>
      
      <section class="copyright-column">
        <p>&copy; 1994-2023 The FreeBSD Project. All rights reserved</p>
        <span>Made with <span class="heart">♥</span> by the FreeBSD Community</span>
      </section>
  </div>
</footer>

  </body>
</html>
