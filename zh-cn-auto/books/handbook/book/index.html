<!DOCTYPE html>
<html class="theme-light" lang="zh-cn-auto">
  <head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content="一个不断发展的、全面的 FreeBSD 用户资源"/>
  <meta name="keywords" content="91, 34, 70, 114, 101, 101, 66, 83, 68, 32, 72, 97, 110, 100, 98, 111, 111, 107, 34, 44, 32, 34, 72, 97, 110, 100, 98, 111, 111, 107, 34, 93"/>
  <meta name="copyright" content="1995-2024 The FreeBSD Foundation" />
  <link rel="canonical" href="https://free.bsd-doc.org/zh-cn-auto/books/handbook/book/" />

  <title>FreeBSD 手册 |  FreeBSD 中文文档</title>

  <meta name="theme-color" content="#790000">
  <meta name="color-scheme" content="system light dark high-contrast">

    <link rel="shortcut icon" href="https://free.bsd-doc.org/favicon.ico">
    <link rel="stylesheet" href="/styles/main.min.css">
    <link rel="stylesheet" href="https://free.bsd-doc.org/css/font-awesome-min.css">
    <script defer src="/js/theme-chooser.min.js"></script>
    <script defer src="/js/copy-clipboard.min.js"></script>
    <script defer src="/js/search.min.js"></script>

  
  
    
    <meta property="og:title" content="FreeBSD 手册" />
    <meta property="og:description" content="一个不断发展的、全面的 FreeBSD 用户资源" />
    <meta property="og:type" content="website"/>
    <meta property="og:image" content="https://free.bsd-doc.orgfavicon.ico"/>
    <meta property="og:image:alt" content="FreeBSD Logo">
    <meta property="og:locale" content="zh-cn-auto" />
    <meta property="og:url" content="https://free.bsd-doc.org/zh-cn-auto/books/handbook/book/" />
    <meta property="og:site_name" content="FreeBSD 中文文档" />
    <script type="application/ld+json">
      {
        "@context": "http://schema.org",
        "@type": "Article",
        "url": "https:\/\/free.bsd-doc.org\/zh-cn-auto\/books\/handbook\/book\/",
        "name": "FreeBSD 中文文档",
        "headline": "FreeBSD 中文文档",
        "description": "FreeBSD 中文文档"
      }
    </script>
    

  
</head>


  <body>
    <header>
  <div class="header-container">
    <div class="logo-menu-bars-container">
      <a href="https://free.bsd-doc.org" class="logo">
        <img src="https://free.bsd-doc.org/images/FreeBSD-monochromatic.svg" width="160" height="50" alt="FreeBSD logo" />
      </a>
      <label class="menu-bars" for="menu-bars">
        <i class="fa fa-bars" aria-hidden="true"></i>
      </label>
    </div>
    <input id="menu-bars" type="checkbox" />
    
    <div class="search-donate-container">
      
      <div class="donate">
        <a href="https://github.com/fierceX/freebsd-doc-cn" target="_blank">
          <span class="heart">♥</span>
          GitHub
        </a>
      </div>
    </div>
  </div>
</header>

    
<input type="checkbox" class="hidden toggle" id="menu-control">
<main class="main-wrapper-book">
  <a id="top"></a>
  
  <div class="book">
    
    <h1 class="title">FreeBSD 手册</h1>
    
    
      <div class="admonitionblock note">
        <p>
          <i class="fa fa-exclamation-circle" aria-hidden="true"></i>
          如果发现翻译错误，请直接 <a href="https://github.com/fierceX/freebsd-doc-cn/pulls" target="_blank">发起PR修改</a>。
        </p>
      </div>
    
    
      <div class="copyright">
        Copyright © 1995-2023 The FreeBSD Documentation Project
      </div>
    
    
      <div class="legalnotice">
  <a id="trademarks"></a>
  <details>
    <summary>trademarks</summary>
    

    
      <p>FreeBSD 是 FreeBSD 基金会的注册商标</p>
    

    

    

    
      <p>IBM、 AIX、 OS/2、 PowerPC、 PS/2、 S/390 以及 ThinkPad 是国际商用机器公司在美国和其他国家的注册商标或商标。</p>
    

    
      <p>IEEE, POSIX, 和 802 是 Institute of Electrical and Electronics Engineers, Inc. 在美国的注册商标。</p>
    

    
      <p>Red Hat, RPM, 是 Red Hat, Inc. 在美国和其他国家的注册商标。</p>
    

    
      <p>3Com 和 HomeConnect 是 3Com Corporation 的注册商标。</p>
    

    

    
      <p>Adobe、 Acrobat、 Acrobat Reader、 Flash， 以及 PostScript 是 Adobe Systems Incorporated 在美国和/或其他国家的商标或注册商标。</p>
    

    
      <p>Apple, AirPort, FireWire, iMac, iPhone, iPad, Mac, Macintosh, Mac OS, Quicktime, 以及 TrueType 是 Apple Inc. 在美国以及其他国家的注册商标。</p>
    

    

    

    

    
      <p>Intel, Celeron, Centrino, Core, EtherExpress, i386, i486, Itanium, Pentium, 和 Xeon 是 Intel Corporation 及其分支机构在美国和其他国家的商标或注册商标。</p>
    

    
      <p>Linux 是 Linus Torvalds 的注册商标。</p>
    

    
      <p>Microsoft, IntelliMouse, MS-DOS, Outlook, Windows, Windows Media, 和 Windows NT 是 Microsoft Corporation 在美国和/或其他国家的商标或注册商标。</p>
    

    

    

    
      <p>Motif, OSF/1, 和 UNIX 是 The Open Group 在美国和其他国家的注册商标； IT DialTone 和 The Open Group 是其商标。</p>
    

    

    

    
      <p>Sun、 Sun Microsystems、 Java、 Java Virtual Machine、 JDK、 JRE、 JSP、 JVM、 Netra、 OpenJDK、 Solaris、 StarOffice、 SunOS 以及 VirtualBox 是 Sun Microsystems, Inc. 在美国和其他国家的商标或注册商标。</p>
    

    

    

    
      <p>RealNetworks, RealPlayer, 和 RealAudio 是 RealNetworks, Inc. 的注册商标。</p>
    

    
      <p>Oracle 是 Oracle Corporation 的注册商标。</p>
    

    
      <p>3ware 是 3ware Inc 的注册商标。</p>
    

    
      <p>ARM 是 ARM Limited. 的注册商标。</p>
    

    
      <p>Adaptec 是 Adaptec, Inc. 的注册商标。</p>
    

    
      <p>Android 是 Google Inc 的注册商标。</p>
    

    
      <p>Heidelberg、 Helvetica、 Palatino 以及 Times Roman 是 Heidelberger Druckmaschinen AG 在美国和其他国家的商标或注册商标。</p>
    

    
      <p>Intuit 和 Quicken 是 Intuit Inc., 或其子公司在美国和其他国家的商标或注册商标。</p>
    

    
      <p>LSI Logic, AcceleRAID, eXtremeRAID, MegaRAID 和 Mylex 是 LSI Logic Corp 的商标或注册商标。</p>
    

    
      <p>MATLAB 是 The MathWorks, Inc. 的注册商标。</p>
    

    
      <p>SpeedTouch 是 Thomson 的商标。</p>
    

    
      <p>VMware 是 VMware, Inc. 的商标</p>
    

    
      <p>Mathematica 是 Wolfram Research, Inc 的注册商标。</p>
    

    
      <p>Ogg Vorbis 和 Xiph.Org 是 Xiph.Org 的商标。</p>
    

    
      <p>XFree86 是 The XFree86 Project, Inc 的商标。.</p>
    

    

    
      <p>许多制造商和经销商使用一些称为商标的图案或文字设计来彰显自己的产品。 本文档中出现的， 为 FreeBSD Project 所知晓的商标，后面将以 “™” 或 “®” 符号来标注。</p>
    
  </details>
</div>


    
    <div class="toc-mobile">
      <h3>Table of Contents</h3>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#book-preface">前言</a>
      <ul>
        <li><a href="#preface-audience">预期读者</a></li>
        <li><a href="#preface-changes-from4">第四版</a></li>
        <li><a href="#preface-changes-from3">第三版</a></li>
        <li><a href="#preface-changes-from2">第二版（2004 年）</a></li>
        <li><a href="#preface-changes">第一版（2001 年）</a></li>
        <li><a href="#preface-overview">本书的组织结构</a></li>
        <li><a href="#preface-conv">本书中使用的约定</a></li>
        <li><a href="#preface-acknowledgements">致谢</a></li>
      </ul>
    </li>
    <li><a href="#getting-started">Part I: 入门指南</a>
      <ul>
        <li><a href="#introduction">Chapter 1. 介绍</a></li>
        <li><a href="#bsdinstall">Chapter 2. 安装 FreeBSD</a></li>
        <li><a href="#basics">Chapter 3. FreeBSD 基础知识</a></li>
        <li><a href="#ports">Chapter 4. 安装应用程序：软件包和 Ports</a></li>
        <li><a href="#x11">Chapter 5. X Window System （X  Window系统）</a></li>
        <li><a href="#wayland">Chapter 6. 在 FreeBSD 上的 Wayland</a></li>
        <li><a href="#network">Chapter 7. 网络</a></li>
      </ul>
    </li>
    <li><a href="#common-tasks">Part II: 常见任务</a>
      <ul>
        <li><a href="#desktop">Chapter 8. 桌面环境</a></li>
        <li><a href="#multimedia">Chapter 9. 多媒体</a></li>
        <li><a href="#kernelconfig">Chapter 10. 配置 FreeBSD 内核</a></li>
        <li><a href="#printing">Chapter 11. 打印</a></li>
        <li><a href="#linuxemu">Chapter 12. Linux 二进制兼容性</a></li>
        <li><a href="#wine">Chapter 13. WINE 是一个允许在 Linux 和其他类 Unix 操作系统上运行 Windows 应用程序的兼容层。它通过实现 Windows API 的替代实现来实现这一功能。 WINE 的名称是“ Wine Is Not an Emulator ”的缩写，这意味着它不是一个真正的模拟器，而是通过将 Windows API 调用转换为对底层操作系统的调用来实现兼容性。 WINE 对于那些需要在 Linux 环境中运行 Windows 应用程序的用户来说是非常有用的。</a></li>
      </ul>
    </li>
    <li><a href="#system-administration">Part III: 系统管理</a>
      <ul>
        <li><a href="#config-tuning">Chapter 14. 配置、服务、日志和电源管理</a></li>
        <li><a href="#boot">Chapter 15. FreeBSD 的引导过程</a></li>
        <li><a href="#security">Chapter 16. 安全</a></li>
        <li><a href="#jails">Chapter 17. Jails 和容器</a></li>
        <li><a href="#mac">Chapter 18. 强制访问控制</a></li>
        <li><a href="#audit">Chapter 19. 安全事件审计</a></li>
        <li><a href="#disks">Chapter 20. 存储</a></li>
        <li><a href="#geom">Chapter 21. GEOM ：模块化磁盘转换框架</a></li>
        <li><a href="#zfs">Chapter 22. Z 文件系统（ZFS）</a></li>
        <li><a href="#filesystems">Chapter 23. 其他文件系统</a></li>
        <li><a href="#virtualization">Chapter 24. 虚拟化</a></li>
        <li><a href="#l10n">Chapter 25. 本地化 - i18n/L10n 的使用和设置</a></li>
        <li><a href="#updating-upgrading">Chapter 26. 更新和升级 FreeBSD</a></li>
        <li><a href="#dtrace">Chapter 27. DTrace 是一种动态跟踪工具，用于在操作系统和应用程序中收集和分析性能数据。它最初是由 Sun Microsystems 开发的，现在已经成为许多操作系统的标准特性，包括 Solaris 、 FreeBSD 和 Mac OS X 。 DTrace 可以帮助开发人员和系统管理员识别和解决性能问题，优化代码和系统配置，并提供深入的可视化和分析功能。它使用一种称为 D 语言的特殊语法来编写跟踪脚本，并提供了丰富的系统调用和内核事件的跟踪功能。 DTrace 是一个强大而灵活的工具，被广泛用于调试和优化各种类型的软件和系统。</a></li>
        <li><a href="#usb-device-mode">Chapter 28. USB 设备模式 /USB OTG</a></li>
      </ul>
    </li>
    <li><a href="#network-communication">Part IV: 网络通信</a>
      <ul>
        <li><a href="#serialcomms">Chapter 29. 串行通信</a></li>
        <li><a href="#ppp-and-slip">Chapter 30. PPP</a></li>
        <li><a href="#mail">Chapter 31. 电子邮件</a></li>
        <li><a href="#network-servers">Chapter 32. 网络服务器</a></li>
        <li><a href="#firewalls">Chapter 33. 防火墙</a></li>
        <li><a href="#advanced-networking">Chapter 34. 高级网络</a></li>
      </ul>
    </li>
    <li><a href="#appendices">Part V: 附录</a>
      <ul>
        <li><a href="#_获取_freebsd">附录 A: 获取 FreeBSD</a></li>
        <li><a href="#bibliography">附录 B: 参考文献</a></li>
        <li><a href="#eresources">附录 C: 互联网资源</a></li>
        <li><a href="#pgpkeys">附录 D: OpenPGP 密钥</a></li>
        <li><a href="#freebsd-glossary">FreeBSD 词汇表</a></li>
        <li><a href="#colophon">后记</a></li>
      </ul>
    </li>
  </ul>
</nav>
    </div>
    
      
      <div>
        [ <a href="../">Split HTML</a> / Single HTML ]
      </div>
      
      
    
    <div class="book-content">
      <div id="preamble">
<div class="sectionbody">
<div class="paragraph abstract-title">
<p>摘要</p>
</div>
<div class="paragraph">
<p>欢迎来到 FreeBSD ！本手册涵盖了 <em>FreeBSD 14.0-RELEASE, 13.2-RELEASE</em> 和 _FreeBSD 12.4-RELEASE_的安装和日常使用。本书是许多人持续工作的结果。某些部分可能已过时。有兴趣帮助更新和扩展本文档的人应该发送电子邮件至 {freebsd-doc}。</p>
</div>
<div class="paragraph">
<p>这本书的最新版本可以从 <a href="https://www.FreeBSD.org/">FreeBSD 网站</a> 获取。以前的版本可以从 <a href="https://docs.FreeBSD.org/doc/">https://docs.FreeBSD.org/doc/</a> 获取。该书可以从 <a href="https://download.freebsd.org/doc/">FreeBSD 下载服务器</a> 或众多 <a href="./mirrors#mirrors">镜像站点</a> 之一以多种格式和压缩选项下载。可以在手册和其他文档上进行搜索，链接在 <a href="https://www.FreeBSD.org/search/">搜索页面</a> 上。</p>
</div>
<hr/>

</div>
</div>
<div class="sect1">
<h2 id="book-preface">前言<a class="anchor" href="#book-preface"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="preface-audience">预期读者<a class="anchor" href="#preface-audience"></a></h3>
<div class="paragraph">
<p>FreeBSD 新手会发现本书的第一部分指导用户完成 FreeBSD 安装过程，并轻松地介绍了 UNIX® 的概念和约定。阅读这一部分只需要有探索的愿望，以及接受新概念的能力。</p>
</div>
<div class="paragraph">
<p>一旦你走到这一步，手册的第二部分，也是更大的部分，是一个对 FreeBSD 系统管理员感兴趣的各种主题的全面参考。其中一些章节可能会建议你先阅读一些内容，在每个章节的简介中会有注明。</p>
</div>
<div class="paragraph">
<p>有关更多信息来源的列表，请参见 <a href="./#bibliography">参考文献</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="preface-changes-from4">第四版<a class="anchor" href="#preface-changes-from4"></a></h3>
<div class="paragraph">
<p>当前版本的手册代表了一个工作组的累积努力，该工作组一直在审查和更新所有手册内容。以下是自第四版手册以来的主要更新。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>手册已从 <a href="https://docbook.org/">Docbook</a> 转换为 <a href="https://gohugo.io/">Hugo</a> 和 <a href="https://asciidoctor.org/">AsciiDoctor</a>。</p>
</li>
<li>
<p><a href="https://docs.FreeBSD.org">FreeBSD 文档门户</a> 已创建。</p>
</li>
<li>
<p>添加了 <a href="./#wayland">Wayland</a>，其中包含在 FreeBSD 下安装和配置 Wayland 的信息。</p>
</li>
<li>
<p><a href="./#bibliography">参考文献</a> 已经进行了广泛的更新。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="preface-changes-from3">第三版<a class="anchor" href="#preface-changes-from3"></a></h3>
<div class="paragraph">
<p>当前在线版本的手册代表了过去 10 年来数百名贡献者的累积努力。以下是自 2004 年出版第三版两卷本以来的一些重大变化：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加了 <a href="./#wine">WINE</a>，关于如何在 FreeBSD 上运行 Windows® 应用程序的信息。</p>
</li>
<li>
<p><a href="./#dtrace">DTrace</a> 添加了有关功能强大的 DTrace 性能分析工具的信息。</p>
</li>
<li>
<p><a href="./#filesystems">其他文件系统</a> 添加了有关 FreeBSD 中非本地文件系统的信息，如 Sun™ 的 ZFS。</p>
</li>
<li>
<p><a href="./#audit">安全事件审计</a> 增加了关于 FreeBSD 中新的审计功能的信息，并解释了其用途。</p>
</li>
<li>
<p><a href="./#virtualization">虚拟化</a> 添加了有关在虚拟化软件上安装 FreeBSD 的信息。的信息。</p>
</li>
<li>
<p><a href="./#bsdinstall">安装 FreeBSD</a> 新增了使用新安装程序 bsdinstall 安装 FreeBSD 的内容。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="preface-changes-from2">第二版（2004 年）<a class="anchor" href="#preface-changes-from2"></a></h3>
<div class="paragraph">
<p>第三版是 FreeBSD 文档项目专注成员超过两年工作的巅峰之作。印刷版的规模增长到了需要分为两卷出版的程度。以下是这个新版中的主要变化：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="./#config-tuning">配置和调优</a> 增加了关于 ACPI 电源和资源管理、<code>cron</code> 系统实用程序以及更多内核调优选项的新信息。</p>
</li>
<li>
<p><a href="./#security">Security</a> 增加了关于虚拟私有网络（VPN）、文件系统访问控制列表（ACLs）和安全公告的新信息。</p>
</li>
<li>
<p><a href="./#mac">Mandatory Access Control</a> 是本版本的新章节。它解释了 MAC 是什么，以及如何使用这种机制来保护 FreeBSD 系统。</p>
</li>
<li>
<p><a href="./#disks">Storage</a> 增加了关于 USB 存储设备、文件系统快照、文件系统配额、文件和网络支持的文件系统以及加密磁盘分区的新信息。</p>
</li>
<li>
<p>向 <a href="./#ppp-and-slip">PPP</a> 添加了故障排除部分。</p>
</li>
<li>
<p><a href="./#mail">电子邮件</a> 扩展了关于使用替代传输代理、SMTP 身份验证、UUCP、fetchmail、procmail 和其他高级主题的新信息。</p>
</li>
<li>
<p><a href="./#network-servers">网络服务器</a> 在本版中是全新的。本章包括有关设置 Apache HTTP 服务器、ftpd 以及使用 Samba 为 Microsoft® Windows® 客户端设置服务器的信息。为了改善呈现效果，一些来自 <a href="./#advanced-networking">高级网络</a> 的部分内容被移至此处。</p>
</li>
<li>
<p><a href="./#advanced-networking">高级网络</a> 增加了关于在 FreeBSD 上使用蓝牙设备、设置无线网络和异步传输模式（ATM）网络的新信息。</p>
</li>
<li>
<p>添加术语表，以提供一个集中的位置，用于定义整本书中使用的技术术语。</p>
</li>
<li>
<p>对本书中的表格和图表进行了一些美观的改进。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="preface-changes">第一版（2001 年）<a class="anchor" href="#preface-changes"></a></h3>
<div class="paragraph">
<p>第二版是 FreeBSD 文档项目专注成员两年多工作的巅峰之作。以下是本版的主要变化：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>添加完整索引。</p>
</li>
<li>
<p>所有的 ASCII 图形都已被替换为图形化的图表。</p>
</li>
<li>
<p>每个章节都添加了一个标准的简介，以便快速概述该章节包含的信息以及读者应该了解的内容。</p>
</li>
<li>
<p>内容已经在逻辑上重新组织成三个部分：“入门指南”，“系统管理”和“附录”。</p>
</li>
<li>
<p>对 <a href="./#basics">FreeBSD 基础知识</a> 进行了扩展，包含了关于进程、守护进程和信号的额外信息。</p>
</li>
<li>
<p>对 <a href="./#ports">安装应用程序：软件包和端口</a> 进行了扩展，包含了关于二进制包管理的额外信息。</p>
</li>
<li>
<p><a href="./#x11">X Window 系统</a> 章节完全重写，重点是使用现代桌面技术，如 KDE 和 GNOME 在 XFree86™ 4.X 上。</p>
</li>
<li>
<p>对 <a href="./#boot">FreeBSD 引导过程</a> 进行了扩展。</p>
</li>
<li>
<p><a href="./#disks">存储</a> 一章是由原本分为&#34;磁盘&#34;和&#34;备份&#34;两个章节合并而成的。我们认为将这些主题作为一个单独的章节呈现更容易理解。同时，还添加了一个关于 RAID （硬件和软件）的部分。</p>
</li>
<li>
<p><a href="./#serialcomms">Serial Communications</a> 章节完全重新组织和更新，适用于 FreeBSD 4.X/5.X 。</p>
</li>
<li>
<p><a href="./#ppp-and-slip">PPP</a> 章节进行了重大更新。</p>
</li>
<li>
<p><a href="./#advanced-networking">高级网络</a> 中添加了许多新的部分。</p>
</li>
<li>
<p>对 <a href="./#mail">电子邮件</a> 进行扩展，包括更多关于配置 sendmail 的信息。</p>
</li>
<li>
<p>对 <a href="./#linuxemu">Linux® 二进制兼容性</a> 进行了扩展，包括了安装 Oracle® 和 SAP® R/3® 的信息。</p>
</li>
<li>
<p>本第二版涵盖了以下新主题：</p>
<div class="ulist">
<ul>
<li>
<p><a href="./#config-tuning">配置和调优</a>。</p>
</li>
<li>
<p><a href="./#multimedia">多媒体</a>。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="preface-overview">本书的组织结构<a class="anchor" href="#preface-overview"></a></h3>
<div class="paragraph">
<p>本书分为五个逻辑上独立的部分。第一部分是 <em>入门</em>，介绍了 FreeBSD 的安装和基本使用。预计读者会按照章节的顺序阅读，可能会跳过熟悉的主题章节。第二部分是 <em>常见任务</em>，介绍了 FreeBSD 的一些常用功能。这部分以及后续的部分可以按任意顺序阅读。每个章节都以简洁的摘要开始，描述了章节内容和读者所需的基础知识。这样可以让读者随意跳转到感兴趣的章节。第三部分是 <em>系统管理</em>，介绍了管理主题。第四部分是 <em>网络通信</em>，介绍了网络和服务器主题。第五部分包含参考信息的附录。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><em><a href="./#introduction">Introduction</a></em></dt>
<dd>
<p>本文向新用户介绍 FreeBSD 。它描述了 FreeBSD 项目的历史、目标和开发模型。</p>
</dd>
<dt class="hdlist1"><em><a href="./#bsdinstall">安装 FreeBSD</a></em></dt>
<dd>
<p>使用 bsdinstall，引导用户完成 FreeBSD 9._x_及更高版本的完整安装过程。</p>
</dd>
<dt class="hdlist1"><em><a href="./#basics">FreeBSD 基础知识</a></em></dt>
<dd>
<p>介绍了 FreeBSD 操作系统的基本命令和功能。如果您熟悉 Linux® 或其他 UNIX® 的变种，那么您可能可以跳过本章。</p>
</dd>
<dt class="hdlist1"><em><a href="./#ports">安装应用程序：软件包和 Ports</a></em></dt>
<dd>
<p>本文介绍了使用 FreeBSD 创新的“Ports Collection”和标准二进制软件包安装第三方软件的方法。</p>
</dd>
<dt class="hdlist1"><em><a href="./#x11">X Window 系统</a></em></dt>
<dd>
<p>描述了 X Window System 的一般情况，特别是在 FreeBSD 上使用 X11 的情况。还描述了常见的桌面环境，如 KDE 和 GNOME。</p>
</dd>
<dt class="hdlist1"><em><a href="./#wayland">Wayland</a></em></dt>
<dd>
<p>描述了 Wayland 显示服务器的一般情况，特别是在 FreeBSD 上使用 Wayland 的情况。还描述了常见的合成器，如 Wayfire、Hikari 和 Sway。</p>
</dd>
<dt class="hdlist1"><em><a href="./#desktop">桌面应用程序</a></em></dt>
<dd>
<p>列举了一些常见的桌面应用程序，如网络浏览器和办公套件，并描述了如何在 FreeBSD 上安装它们。</p>
</dd>
<dt class="hdlist1"><em><a href="./#multimedia">多媒体</a></em></dt>
<dd>
<p>展示了如何为您的系统设置音频和视频播放支持。还介绍了一些示例音频和视频应用程序。</p>
</dd>
<dt class="hdlist1"><em><a href="./#kernelconfig">配置 FreeBSD 内核</a></em></dt>
<dd>
<p>解释了为什么您可能需要配置一个新的内核，并提供了详细的配置、构建和安装自定义内核的指令。</p>
</dd>
<dt class="hdlist1"><em><a href="./#printing">打印</a></em></dt>
<dd>
<p>描述了在 FreeBSD 上管理打印机的方法，包括有关横幅页面、打印机计费和初始设置的信息。</p>
</dd>
<dt class="hdlist1"><em><a href="./#linuxemu">Linux® 二进制兼容性</a></em></dt>
<dd>
<p>描述了 FreeBSD 的 Linux® 兼容功能。还提供了许多流行的 Linux® 应用程序（如 Oracle® 和 Mathematica®）的详细安装说明。</p>
</dd>
<dt class="hdlist1"><em><a href="./#wine">WINE</a></em></dt>
<dd>
<p>描述了 WINE 并提供了详细的安装说明。还描述了 WINE 的操作方式，如何安装 GUI 助手，如何在 FreeBSD 上运行 Windows® 应用程序，并提供其他提示和解决方案。</p>
</dd>
<dt class="hdlist1"><em><a href="./#config-tuning">配置和调优</a></em></dt>
<dd>
<p>描述了系统管理员可以调整 FreeBSD 系统以获得最佳性能的参数。还描述了在 FreeBSD 中使用的各种配置文件以及它们的位置。</p>
</dd>
<dt class="hdlist1"><em><a href="./#boot">FreeBSD 引导过程</a></em></dt>
<dd>
<p>描述了 FreeBSD 的启动过程，并解释了如何通过配置选项来控制这个过程。</p>
</dd>
<dt class="hdlist1"><em><a href="./#security">安全</a></em></dt>
<dd>
<p>描述了许多不同的工具，可用于帮助保护您的 FreeBSD 系统的安全性，包括 Kerberos、IPsec 和 OpenSSH。</p>
</dd>
<dt class="hdlist1"><em><a href="./#jails">Jails</a></em></dt>
<dd>
<p>描述了 FreeBSD 中的 jails 框架以及 jails 相对于传统的 chroot 支持的改进。</p>
</dd>
<dt class="hdlist1"><em><a href="./#mac">强制访问控制</a></em></dt>
<dd>
<p>解释了强制访问控制（Mandatory Access Control,MAC）是什么，以及如何使用这种机制来保护 FreeBSD 系统。</p>
</dd>
<dt class="hdlist1"><em><a href="./#audit">安全事件审计</a></em></dt>
<dd>
<p>描述了什么是 FreeBSD 事件审计，如何安装、配置以及如何检查或监控审计日志。</p>
</dd>
<dt class="hdlist1"><em><a href="./#disks">存储</a></em></dt>
<dd>
<p>描述了如何使用 FreeBSD 管理存储介质和文件系统。这包括物理磁盘、RAID 阵列、光盘和磁带介质、内存支持的磁盘和网络文件系统。</p>
</dd>
<dt class="hdlist1"><em><a href="./#geom">GEOM：模块化磁盘转换框架</a></em></dt>
<dd>
<p>描述了 FreeBSD 中的 GEOM 框架是什么以及如何配置各种支持的 RAID 级别。</p>
</dd>
<dt class="hdlist1"><em><a href="./#zfs">OpenZFS 存储平台</a></em></dt>
<dd>
<p>描述了 OpenZFS 存储平台，并提供了一个快速入门指南，以及关于在 FreeBSD 下运行 OpenZFS 的高级主题的信息。</p>
</dd>
<dt class="hdlist1"><em><a href="./#filesystems">其他文件系统</a></em></dt>
<dd>
<p>研究了 FreeBSD 对非本地文件系统（如 ext2、 ext3 和 ext4）的支持。</p>
</dd>
<dt class="hdlist1"><em><a href="./#virtualization">虚拟化</a></em></dt>
<dd>
<p>描述了虚拟化系统提供的功能以及如何在 FreeBSD 上使用它们。</p>
</dd>
<dt class="hdlist1"><em><a href="./#l10n">本地化 - i18n/L10n 的使用和设置</a></em></dt>
<dd>
<p>描述了如何在非英语语言环境中使用 FreeBSD。涵盖了系统和应用程序级别的本地化。</p>
</dd>
<dt class="hdlist1"><em><a href="./#updating-upgrading">更新和升级 FreeBSD</a></em></dt>
<dd>
<p>解释了 FreeBSD-STABLE、FreeBSD-CURRENT 和 FreeBSD 发布版之间的区别。描述了哪些用户会从跟踪开发系统中受益，并概述了该过程。介绍了用户可以采取的方法来更新系统到最新的安全发布版。</p>
</dd>
<dt class="hdlist1"><em><a href="./#dtrace">DTrace</a></em></dt>
<dd>
<p>描述了如何在 FreeBSD 上配置和使用 Sun™ 的 DTrace 工具。通过进行实时系统分析，动态跟踪可帮助定位性能问题。</p>
</dd>
<dt class="hdlist1"><em><a href="./#usb-device-mode">USB 设备模式/USB OTG</a></em></dt>
<dd>
<p>解释了在 FreeBSD 上使用 USB 设备模式和 USB On The Go（USB OTG）的方法。</p>
</dd>
<dt class="hdlist1"><em><a href="./#ppp-and-slip">PPP</a></em></dt>
<dd>
<p>描述了如何在 FreeBSD 中使用 PPP 连接到远程系统。</p>
</dd>
<dt class="hdlist1"><em><a href="./#mail">电子邮件</a></em></dt>
<dd>
<p>解释了电子邮件服务器的不同组件，并深入探讨了最流行的邮件服务器软件 sendmail 的简单配置主题。</p>
</dd>
<dt class="hdlist1"><em><a href="./#network-servers">网络服务器</a></em></dt>
<dd>
<p>提供详细的说明和示例配置文件，以将您的 FreeBSD 机器设置为网络文件系统服务器、域名服务器、网络信息系统服务器或时间同步服务器。</p>
</dd>
<dt class="hdlist1"><em><a href="./#firewalls">Firewalls</a></em></dt>
<dd>
<p>解释了基于软件的防火墙背后的哲学，并提供有关可用于 FreeBSD 的不同防火墙的配置的详细信息。</p>
</dd>
<dt class="hdlist1"><em><a href="./#advanced-networking">高级网络</a></em></dt>
<dd>
<p>描述了许多网络主题，包括在局域网上与其他计算机共享互联网连接、高级路由主题、无线网络、蓝牙®、ATM、IPv6 等等。</p>
</dd>
<dt class="hdlist1"><em><a href="./#mirrors">获取 FreeBSD</a></em></dt>
<dd>
<p>列出了获取 FreeBSD 光盘或 DVD 的不同来源，以及允许您下载和安装 FreeBSD 的互联网上的不同网站。</p>
</dd>
<dt class="hdlist1"><em><a href="./#bibliography">参考文献</a></em></dt>
<dd>
<p>这本书涉及了许多不同的主题，可能会让你渴望更详细的解释。参考书目列出了文本中引用的许多优秀书籍。</p>
</dd>
<dt class="hdlist1"><em><a href="./#eresources">互联网资源</a></em></dt>
<dd>
<p>描述了许多可供 FreeBSD 用户发布问题和参与有关 FreeBSD 的技术讨论的论坛。</p>
</dd>
<dt class="hdlist1"><em><a href="./#pgpkeys">OpenPGP 密钥</a></em></dt>
<dd>
<p>列出了几位 FreeBSD 开发者的 PGP 指纹。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="preface-conv">本书中使用的约定<a class="anchor" href="#preface-conv"></a></h3>
<div class="paragraph">
<p>为了提供一致且易于阅读的文本，本书遵循了几个约定。</p>
</div>
<div class="sect3">
<h4 id="preface-conv-typographic">排版约定<a class="anchor" href="#preface-conv-typographic"></a></h4>
<div class="dlist">
<dl>
<dt class="hdlist1"><em>斜体</em></dt>
<dd>
<p>斜体字用于文件名、URL、强调的文本以及技术术语的首次使用。</p>
</dd>
<dt class="hdlist1"><code>等宽</code></dt>
<dd>
<p>错误消息、命令、环境变量、端口名称、主机名、用户名、组名、设备名、变量和代码片段使用 <code>等宽字体</code>。</p>
</dd>
<dt class="hdlist1">粗体</dt>
<dd>
<p>应用程序、命令和按键使用 <strong>粗体</strong> 字体。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="preface-conv-commands">用户输入<a class="anchor" href="#preface-conv-commands"></a></h4>
<div class="paragraph">
<p>键以 <strong>粗体</strong> 显示，以突出显示与其他文本的区别。同时输入的键组合以 <code>+</code> 符号分隔键，例如：</p>
</div>
<div class="paragraph">
<p><span class="keyseq"><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd></span></p>
</div>
<div class="paragraph">
<p>意思是用户应该同时按下 <kbd>Ctrl</kbd>、<kbd>Alt</kbd> 和 <kbd>Del</kbd> 键。</p>
</div>
<div class="paragraph">
<p>需要按顺序输入的键将用逗号分隔，例如：</p>
</div>
<div class="paragraph">
<p><span class="keyseq"><kbd>Ctrl</kbd>+<kbd>X</kbd></span>，<span class="keyseq"><kbd>Ctrl</kbd>+<kbd>S</kbd></span></p>
</div>
<div class="paragraph">
<p>这意味着用户需要同时按下键盘上的 <kbd>Ctrl</kbd> 和 <kbd>X</kbd> 键，然后再同时按下键盘上的 <kbd>Ctrl</kbd> 和 <kbd>S</kbd> 键。</p>
</div>
</div>
<div class="sect3">
<h4 id="preface-conv-examples">示例<a class="anchor" href="#preface-conv-examples"></a></h4>
<div class="paragraph">
<p>以 <span class="filename">C:\&gt;</span> 开头的示例表示一个 MS-DOS® 命令。除非另有说明，这些命令可以在现代 Microsoft® Windows® 环境中的 &#34;Command Prompt&#34; 窗口中执行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">C:\&gt; </span>tools<span class="se">\f</span>dimage floppies<span class="se">\k</span>ern.flp A:</code></pre>
</div>
</div>
<div class="paragraph">
<p>以 # 开头的示例表示在 FreeBSD 中必须以超级用户身份调用的命令。您可以登录为 <code>root</code> 来输入命令，或者登录为您的普通帐户并使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 来获取超级用户权限。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=kern.flp of=/dev/fd0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>以 % 开头的示例表示应从普通用户帐户调用的命令。除非另有说明，设置环境变量和其他 shell 命令使用 C-shell 语法。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>top</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="preface-acknowledgements">致谢<a class="anchor" href="#preface-acknowledgements"></a></h3>
<div class="paragraph">
<p>你手中的这本书代表了全球数百人的努力。无论他们是纠正错别字还是提交完整的章节，所有的贡献都是有用的。</p>
</div>
<div class="paragraph">
<p>几家公司通过支付作者全职工作、出版费用等方式支持了本文档的开发。特别是 BSDi（后来被 Wind River Systems 收购）支付了 FreeBSD 文档项目的成员全职工作，以改进这本书，直到 2000 年 3 月第一版印刷版的出版（ISBN 1-57176-241-8）。随后， <a href="http://www.windriver.com">Wind River Systems</a> 支付了几位额外的作者，改进了印刷输出基础设施，并为文本添加了额外的章节。这项工作最终在 2001 年 11 月出版了第二版印刷版（ISBN 1-57176-303-1）。在 2003 年至 2004 年期间， <a href="http://www.freebsdmall.com">FreeBSD Mall,Inc</a> 支付了几位贡献者，改进了手册，为第三版印刷版做准备。第三版印刷版被分为两卷。两卷都已出版，分别是 The FreeBSD Handbook 3rd Edition Volume 1: User Guide（ISBN 1-57176-327-9）和The FreeBSD Handbook 3rd Edition Volume 2: Administrators Guide（ISBN 1-57176-328-7）。</p>
</div>
</div>
</div>
</div>
<h1 id="getting-started" class="sect0">Part I: 入门指南<a class="anchor" href="#getting-started"></a></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>本手册的这部分是为那些对FreeBSD新手用户和管理员准备的。这些章节包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>介绍 FreeBSD。</p>
</li>
<li>
<p>引导读者完成安装过程。</p>
</li>
<li>
<p>教授 UNIX® 的基础知识和基本原理。</p>
</li>
<li>
<p>展示如何安装适用于 FreeBSD 的丰富第三方应用程序。</p>
</li>
<li>
<p>介绍 UNIX® 窗口系统 X，并详细说明如何配置一个能提高用户生产力的桌面环境。</p>
</li>
<li>
<p>介绍 Wayland，一种新的 UNIX® 显示服务器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>文本中的正向引用数量被尽量减少，以便这一部分可以从头到尾地阅读，最大程度地减少翻页。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="introduction">Chapter 1. 介绍<a class="anchor" href="#introduction"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="introduction-synopsis">1.1. 简介<a class="anchor" href="#introduction-synopsis"></a></h3>
<div class="paragraph">
<p>感谢你对 FreeBSD 有所兴趣！ 下面这一章涉及到了 FreeBSD 项目的各个方面，例如它的历史、目标、开发模式等等。</p>
</div>
<div class="paragraph">
<p>阅读本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FreeBSD 与其他计算机操作系统的关系。</p>
</li>
<li>
<p>FreeBSD 项目的历史。</p>
</li>
<li>
<p>FreeBSD 项目的目标。</p>
</li>
<li>
<p>FreeBSD 开源开发模型的基础知识。</p>
</li>
<li>
<p>当然，还有一个问题： FreeBSD 这个名字的由来。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="nutshell">1.2. 欢迎来到 FreeBSD ！<a class="anchor" href="#nutshell"></a></h3>
<div class="paragraph">
<p>FreeBSD 是一个开源的、符合标准的类 Unix 操作系统，适用于 x86（32 位和 64 位）、ARM、AArch64、RISC-V、POWER 和 PowerPC 计算机。它提供了现在被视为理所当然的所有功能，如抢占式多任务处理、内存保护、虚拟内存、多用户设施、 SMP 支持、各种语言和框架的开源开发工具，以及以 X Window System、KDE 或 GNOME 为中心的桌面功能。它的特点有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>自由开源许可证（ Liberal Open Source license ）</em> 赋予您自由修改和扩展其源代码的权利，并将其纳入开源项目和闭源产品中，而不会施加典型的强制共享许可证所具有的限制，同时避免潜在的许可证不兼容问题。</p>
</li>
<li>
<p><em>强大的 TCP/IP 网络</em> - FreeBSD 采用行业标准协议，具有越来越高的性能和可扩展性。这使得它在服务器和路由 / 防火墙角色中都能很好地匹配 - 实际上，许多公司和供应商正是出于这个目的使用它。</p>
</li>
<li>
<p><em>完全集成的 OpenZFS 支持</em>，包括 root-on-ZFS 、 ZFS 引导环境、故障管理、管理委派、支持 jails 、 FreeBSD 特定文档和系统安装程序支持。</p>
</li>
<li>
<p><em>广泛的安全功能</em>，从强制访问控制框架到 Capsicum 能力和沙盒机制。</p>
</li>
<li>
<p><em>超过30 , 000 个预构建软件包</em> 支持所有架构，以及 Ports Collection ，使得构建自己定制的软件包变得容易。</p>
</li>
<li>
<p><em>文档</em> - 除了手册和涵盖从系统管理到内核内部的各种主题的不同作者的书籍之外，还有 <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> 页面，不仅适用于用户空间的守护进程、实用程序和配置文件，还适用于内核驱动程序 API （第 9 节）和单个驱动程序（第 4 节）。</p>
</li>
<li>
<p><em>简单而一致的存储库结构和构建系统</em> - FreeBSD 使用一个存储库来管理所有组件，包括内核和用户空间。这个特点，加上统一且易于定制的构建系统以及经过深思熟虑的开发流程，使得将 FreeBSD 与自己产品的构建基础设施集成变得容易。</p>
</li>
<li>
<p><em>秉承 Unix 哲学</em>，更倾向于可组合性，而不是硬编码行为的单体化“一体化”守护程序。</p>
</li>
<li>
<p><em>与 Linux 的二进制兼容性</em>，使得在不需要虚拟化的情况下可以运行许多 Linux 二进制文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FreeBSD 基于加利福尼亚大学伯克利分校计算机系统研究组（ CSRG ）的 4.4BSD-Lite 发布版，并延续了 BSD 系统开发的卓越传统。除了 CSRG 提供的出色工作外， FreeBSD 项目还投入了数千小时的工作，扩展了功能并对系统进行了精细调整，以在实际负载情况下实现最大性能和可靠性。 FreeBSD 提供与其他开源和商业产品相当的性能和可靠性，同时结合了其他地方无法获得的尖端功能。</p>
</div>
<div class="sect3">
<h4 id="os-overview">1.2.1. FreeBSD 可以做什么？<a class="anchor" href="#os-overview"></a></h4>
<div class="paragraph">
<p>FreeBSD 的应用范围几乎只受你的想象力限制。从软件开发到工厂自动化，从库存控制到远程卫星天线的方位校正；如果可以用商业 UNIX® 产品完成，那么很有可能你也可以用 FreeBSD 来实现！ FreeBSD 还受益于全球研究中心和大学开发的成千上万个高质量应用程序，通常可以以很低的或者零成本获得。</p>
</div>
<div class="paragraph">
<p>由于 FreeBSD 本身的源代码是免费提供的，因此该系统可以根据特定应用或项目的需求进行几乎无与伦比的定制，而这在大多数主要商业供应商的操作系统中通常是不可能的。以下是一些人们目前正在使用 FreeBSD 的应用程序的示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>互联网服务</em>：FreeBSD 内置的强大的 TCP/IP 网络使其成为各种互联网服务的理想平台，例如：</p>
<div class="ulist">
<ul>
<li>
<p>Web 服务器</p>
</li>
<li>
<p>IPv4 和 IPv6 路由</p>
</li>
<li>
<p>防火墙和 NAT （&#34;IP 伪装&#34;）网关</p>
</li>
<li>
<p>FTP 服务器</p>
</li>
<li>
<p>电子邮件服务器</p>
</li>
<li>
<p>存储服务器</p>
</li>
<li>
<p>虚拟化服务器</p>
</li>
<li>
<p>还有更多 …​</p>
</li>
</ul>
</div>
</li>
<li>
<p><em>教育：</em> 你是计算机科学或相关工程领域的学生吗？没有比 FreeBSD 提供的亲身实践、深入了解操作系统、计算机架构和网络更好的学习方式了。还有一些免费的 CAD 、数学和图形设计软件包，对于那些主要关注计算机用于完成其他工作的人来说，它们也非常有用！</p>
</li>
<li>
<p><em>研究：</em> 由于整个系统的源代码可用， FreeBSD 是操作系统以及计算机科学其他领域研究的优秀平台。 FreeBSD 的自由可用性也使得远程团队能够在想法或共享开发上进行合作，而无需担心特殊许可协议或在公开论坛上讨论的限制。</p>
</li>
<li>
<p><em>网络：</em> 需要一个新的路由器吗？一个域名服务器（ DNS ）？一个防火墙来阻止人们进入您的内部网络？ FreeBSD 可以轻松地将闲置在角落的个人电脑转变为具有复杂数据包过滤功能的高级路由器。</p>
</li>
<li>
<p><em>嵌入式：</em> FreeBSD 是构建嵌入式系统的优秀平台。它支持 ARM 、 AArch64 和 PowerPC 平台，配备强大的网络堆栈、尖端功能和宽松的 <a href="{faq}#bsd-license-restrictions">BSD 许可证</a>，使 FreeBSD 成为构建嵌入式路由器、防火墙和其他设备的理想基础。</p>
</li>
<li>
<p><em>桌面：</em> FreeBSD 是一个使用免费的 X11 服务器和 Wayland 显示服务器的廉价桌面解决方案的不错选择。 FreeBSD 提供了许多开源桌面环境的选择，包括标准的 GNOME 和 KDE 图形用户界面。 FreeBSD 甚至可以从中央服务器“无盘启动”，使得个人工作站更加便宜和易于管理。</p>
</li>
<li>
<p><em>软件开发：</em> 基本的 FreeBSD 系统配备了一套完整的开发工具，包括完整的 C/C ++编译器和调试器套件。通过端口和软件包集合，还可以支持许多其他编程语言。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FreeBSD 可以免费下载，也可以通过 CD-ROM 或 DVD 获取。有关获取 FreeBSD 的更多信息，请参阅 <a href="./#mirrors">Obtaining FreeBSD</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="introduction-nutshell-users">1.2.2. 谁使用 FreeBSD ？<a class="anchor" href="#introduction-nutshell-users"></a></h4>
<div class="paragraph">
<p>FreeBSD 以其 Web 服务器功能而闻名。可以在 FreeBSD 基金会的网站上找到一份 <a href="https://freebsdfoundation.org/about-us/testimonials/">基于 FreeBSD 的产品和服务的公司的 testimonials 列表</a> 。维基百科还维护着一个 <a href="https://en.wikipedia.org/wiki/List_of_products_based_on_FreeBSD">基于 FreeBSD 的产品列表</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="history">1.3. 关于 FreeBSD 项目<a class="anchor" href="#history"></a></h3>
<div class="paragraph">
<p>下面的部分提供了关于项目的一些背景信息，包括简要历史、项目目标以及项目 <a href="{dev-model}#development model">开发模型</a>。</p>
</div>
<div class="sect3">
<h4 id="intro-history">1.3.1. FreeBSD 的简要历史<a class="anchor" href="#intro-history"></a></h4>
<div class="paragraph">
<p>FreeBSD 项目诞生于 1993 年初，部分是由非官方的 386BSDPatchkit 的最后三位协调员 Nate Williams 、 Rod Grimes 和 Jordan Hubbard 共同构思而成。</p>
</div>
<div class="paragraph">
<p>最初的目标是生成 386BSD 的中间快照，以解决一些无法通过补丁机制解决的问题。该项目的早期工作标题是 386BSD 0.5 或 386BSD Interim ，以此为参考。</p>
</div>
<div class="paragraph">
<p>386BSD 是 Bill Jolitz 的操作系统，到那时为止，它已经遭受了将近一年的严重忽视。随着每一天过去，补丁包变得越来越不舒服，他们决定通过提供这个临时的“清理”快照来帮助 Bill 。然而，当 Bill Jolitz 突然决定撤回对该项目的支持，并没有明确表示将采取什么替代措施时，这些计划被粗暴地中止了。</p>
</div>
<div class="paragraph">
<p>即使没有 Bill 的支持，三人组仍然认为目标仍然值得追求，因此他们采用了 David Greenman 提出的“ FreeBSD ”这个名字。在与系统当前用户咨询后，确定了最初的目标。一旦清楚该项目可能成为现实， Jordan 便联系了 Walnut Creek CDROM ，以改善 FreeBSD 的发行渠道，以便那些没有便捷访问互联网的人。 Walnut Creek CDROM 不仅支持在光盘上分发 FreeBSD ，还提供了一台用于开发工作的机器和快速的互联网连接。如果没有 Walnut Creek CDROM 对当时一个完全未知的项目的几乎前所未有的信任， FreeBSD 很可能不会像今天这样迅速取得如此大的进展。</p>
</div>
<div class="paragraph">
<p>第一张 CD-ROM （以及整个网络范围内的）发行版是 FreeBSD 1.0 ，于 1993 年 12 月发布。它基于来自加州大学伯克利分校的 4.3BSD-Lite （“Net/2”）磁带，同时还借鉴了 386BSD 和自由软件基金会提供的许多组件。作为首次发布，它取得了相当不错的成功，并在 1994 年 5 月发布了备受好评的 FreeBSD 1.1 版本。</p>
</div>
<div class="paragraph">
<p>在这个时候，Novell 和加州大学伯克利分校（ U.C. Berkeley ）就有关伯克利 Net/2 磁带的法律地位的长期诉讼达成了意外的和解。和解的条件是 U.C. Berkeley 承认 Net/2 的三个文件是“受限制”的代码，必须予以删除，因为它们是诺维尔的财产，而 Novell 则是之前从 AT&amp;T 收购的。作为回报，伯克利获得了 Novell 的“祝福”，即当 4.4BSD-Lite 版本最终发布时，将被宣布为无限制的，并强烈鼓励所有现有的 Net/2 用户切换过来。这包括 FreeBSD ，该项目被给予截止到 1994 年 7 月底停止发布基于 Net/2 的产品的时间。根据协议的条款，该项目在最后期限之前被允许发布最后一个版本，即 FreeBSD 1.1.5.1 。</p>
</div>
<div class="paragraph">
<p>FreeBSD 随后开始了一项艰巨的任务，从一个全新且相当不完整的 4.4BSD-Lite 代码库中重新塑造自己。虽然只有与 System V 共享内存和信号量相关的三个文件被删除，但在 BSD 发行版中进行了许多其他的更改和错误修复，因此将所有 FreeBSD 的开发工作合并到 4.4BSD-Lite 中是一项巨大的任务。该项目直到 1994 年 11 月才完成了这一过渡，并在 12 月向世界发布了 FreeBSD 2.0 版本。尽管在某种程度上仍然存在一些问题，但这个版本取得了重大的成功，并在 1995 年 6 月发布了更稳定、更易安装的 FreeBSD 2.0.5 版本。</p>
</div>
<div class="paragraph">
<p>从那时起，FreeBSD 发布了一系列版本，每次都会在前一版本的稳定性、速度和功能集上进行改进。</p>
</div>
<div class="paragraph">
<p>目前，长期发展项目仍在15.0-CURRENT (main) 分支中进行，并且随着工作的进行，15.0 的快照版本将持续从 <a href="https://download.freebsd.org/snapshots/">快照服务器</a> 发布。</p>
</div>
</div>
<div class="sect3">
<h4 id="goals">1.3.2. FreeBSD 项目的目标<a class="anchor" href="#goals"></a></h4>
<div class="paragraph">
<p>FreeBSD 项目的目标是提供可用于任何目的且无附加条件的软件。我们中的许多人在代码（和项目）上投入了大量资源，偶尔获得一些财务补偿并不介意，但我们绝对不会坚持要求。我们相信我们的首要任务是向任何人提供代码，无论出于何种目的，以便代码得到最广泛的使用并提供最广泛的利益。我们认为这是自由软件的最基本目标之一，我们对此表示热情支持。</p>
</div>
<div class="paragraph">
<p>我们源代码树中受 GNU 通用公共许可证（ GPL ）或库通用公共许可证（ LGPL ）约束的代码，附带了稍微更多的限制，尽管至少是在强制访问方面，而不是通常的相反情况。由于商业使用 GPL 软件可能出现的额外复杂性，我们更喜欢在合理的情况下选择以更宽松的 BSD 许可证提交的软件。</p>
</div>
</div>
<div class="sect3">
<h4 id="development">1.3.3. FreeBSD 开发模型<a class="anchor" href="#development"></a></h4>
<div class="paragraph">
<p>FreeBSD 的开发是一个<a href="{dev-model}#very open and flexible process">非常开放和灵活的过程</a>，从世界各地成千上万的人的贡献中构建而成，这一点可以从我们的 <a href="{contributors}#list of contributors">贡献者列表</a> 中看出来。 FreeBSD 的开发基础设施允许这些成千上万的贡献者在互联网上进行合作。我们一直在寻找新的志愿者，有兴趣更深入参与的人应该参考有关 <a href="{contributing}#Contributing to FreeBSD">贡献 FreeBSD</a> 的文章。</p>
</div>
<div class="paragraph">
<p>无论是独立工作还是密切合作，以下是关于 FreeBSD 项目及其开发过程的一些有用信息：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Git 仓库 <a id="development-cvs-repository"></a></dt>
<dd>
<p>多年来， FreeBSD 的中央源代码树由免费可用的源代码控制工具 <a href="https://www.nongnu.org/cvs/">CVS</a> （ Concurrent Versions System ）维护。 2008 年 6 月，该项目转而使用 <a href="https://subversion.apache.org/">SVN</a> （ Subversion ）。由于源代码树的迅速扩展和已存储的历史记录量， CVS 所施加的技术限制变得明显，因此这次转换被认为是必要的。文档项目和 Ports 集合存储库也分别于 2012 年 5 月和 2012 年 7 月从 CVS 迁移到了 SVN 。 2020 年 12 月，该项目将源代码和文档存储库迁移到了 <a href="https://git-scm.com/">Git</a> ，而 Ports 集合则在 2021 年 4 月跟随。有关获取 FreeBSD <code>src/</code> 存储库的更多信息，请参阅 <a href="./#synching">Obtaining the Source</a> 部分，有关获取 FreeBSD Ports 集合的详细信息，请参阅 <a href="./#ports-using">Using the Ports Collection</a> 。</p>
</dd>
<dt class="hdlist1">贡献者列表 <a id="development-committers"></a></dt>
<dd>
<p><em>committers</em> 是那些具有对 Git 仓库的 <em>push</em> 访问权限的人，他们被授权对 FreeBSD 源代码进行修改（术语“committer”来自于 <code>commit</code> ，这是用于将新更改引入仓库的源代码控制命令）。任何人都可以提交一个 bug 到 <a href="https://bugs.FreeBSD.org/submit/">Bug Database</a> 。在提交 bug 报告之前，可以使用 FreeBSD 邮件列表、 IRC 频道或论坛来帮助验证一个问题是否真的是一个 bug 。</p>
</dd>
<dt class="hdlist1">FreeBSD 核心团队 <a id="development-core"></a></dt>
<dd>
<p>如果 FreeBSD 项目是一家公司，那么 <em>FreeBSD 核心团队</em> 将相当于董事会。核心团队的主要任务是确保整个项目处于良好状态并朝着正确的方向发展。邀请专注和负责任的开发人员加入我们的提交者团队是核心团队的职责之一，招募新的核心团队成员也是核心团队的职责之一。当前的核心团队是在 2022 年 5 月从提交者候选人中选举产生的。选举每 2 年举行一次。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>和大多数开发者一样， FreeBSD 核心团队的大多数成员在 FreeBSD 开发方面也是志愿者，并且没有从项目中获得经济利益，所以“承诺”也不应被误解为“有保证的支持”。上面提到的“董事会”类比并不十分准确，更适合说这些人是在违背自己更好判断的情况下选择了 FreeBSD 而放弃了自己的生活！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1">FreeBSD 基金会 <a id="开发基金会"></a></dt>
<dd>
<p><a href="https://freebsdfoundation.org/">FreeBSD 基金会</a> 是一个位于美国的 501(c)(3) 非营利组织，致力于支持和推广全球的 FreeBSD 项目和社区。基金会通过项目拨款资助软件开发，并提供员工立即响应紧急问题并实施新的特性和功能。基金会购买硬件以改善和维护 FreeBSD 基础设施，并资助人员提高测试覆盖率、持续集成和自动化。基金会通过在世界各地的技术会议和活动上推广 FreeBSD 来支持 FreeBSD 。基金会还提供研讨会、教育材料和演示，以吸引更多的 FreeBSD 用户和贡献者。基金会还代表 FreeBSD 项目执行合同、许可协议和其他需要认可法律实体的法律安排。</p>
</dd>
<dt class="hdlist1">外部贡献者</dt>
<dd>
<p>最后，但绝对不是最不重要的，最大的开发者群体是用户自己，他们几乎一直向我们提供反馈和错误修复。与 FreeBSD 基本系统的开发保持联系的主要方式是订阅 {freebsd-hackers} ，在这里讨论这些事情。对于移植第三方应用程序，可以使用 {freebsd-ports} 。对于文档，可以使用 {freebsd-doc} 。有关各种 FreeBSD 邮件列表的更多信息，请参见 <a href="./#eresources">互联网资源</a>。</p>
<div class="paragraph">
<p><a href="{contributors}#The FreeBSD Contributors List">The FreeBSD 贡献者列表</a> 是一个长期而不断增长的列表，为什么不通过 <a href="{contributing}#contributing something back to FreeBSD">为 FreeBSD 做出贡献</a> 加入其中呢？提供代码并不是唯一的方式！</p>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>总之，我们的开发模型是以一组松散的同心圆组织起来的。中心化模型是为了方便 FreeBSD 的用户，他们可以通过追踪一个中央代码库来获得便利，而不是为了排斥潜在的贡献者！我们的愿望是提供一个稳定的操作系统，配备一套大量的一致的应用程序，用户可以轻松安装和使用 - 这个模型在实现这一目标方面非常成功。</p>
</div>
<div class="paragraph">
<p>我们对那些希望加入我们成为 FreeBSD 开发者的人只有一个要求，那就是拥有与现有成员一样对其持续成功的奉献精神！</p>
</div>
</div>
<div class="sect3">
<h4 id="third-party-programs">1.3.4. 第三方程序<a class="anchor" href="#third-party-programs"></a></h4>
<div class="paragraph">
<p>除了基本发行版之外， FreeBSD 还提供了一个可移植软件集合，其中包含数千个常见的程序。ports 列表涵盖了从 HTTP 服务器到游戏、编程语言、编辑器等几乎所有领域的程序。大约有 36000 个 ports；整个 Ports 集合需要大约 3 GB 的空间。要编译一个 ports，只需切换到您想要安装的程序的目录，输入 <code>make install</code>，然后让系统完成剩下的工作。每个构建的 ports 都会动态地检索完整的原始发行版，因此您只需要足够的磁盘空间来构建所需的 ports。</p>
</div>
<div class="paragraph">
<p>几乎每个 ports 也都提供了预编译的“软件包”，不希望从源代码编译自己的 ports 的用户可以使用简单的命令（ <code>pkg install</code> ）进行安装。有关软件包和 ports 的更多信息，请参阅 <a href="./#ports">安装应用程序：软件包和 ports</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_附加文档">1.3.5. 附加文档<a class="anchor" href="#_附加文档"></a></h4>
<div class="paragraph">
<p>所有支持的 FreeBSD 版本在安装程序中提供了一个选项，在初始系统设置期间可以安装附加文档到 <span class="filename">/usr/local/share/doc/freebsd</span>。文档也可以在之后使用软件包进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install en-freebsd-doc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于本地化版本，请将“en”替换为所选语言的语言前缀。请注意，一些本地化版本可能已过时，可能包含不再正确或相关的信息。您可以使用以下 URL 在 Web 浏览器中查看本地安装的手册：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">FreeBSD 手册</dt>
<dd>
<p><code>/usr/local/share/doc/freebsd/en/books/handbook/handbook_en.pdf</code></p>
</dd>
<dt class="hdlist1">FreeBSD 常见问题解答</dt>
<dd>
<p><code>/usr/local/share/doc/freebsd/en/books/faq/faq_en.pdf</code></p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>您可以随时在 <a href="https://docs.FreeBSD.org/">文档门户</a> 找到最新的文档。</p>
</div>
<div class="paragraph">
<p>所有商标均为其各自所有者的财产。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bsdinstall">Chapter 2. 安装 FreeBSD<a class="anchor" href="#bsdinstall"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="bsdinstall-synopsis">2.1. 简介<a class="anchor" href="#bsdinstall-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 支持多种架构，包括 amd64 、 ARM® 、 RISC-V® 和 PowerPC® 。根据不同的架构和平台，可以 <a href="https://www.freebsd.org/where/">下载</a> 不同的镜像来安装或直接运行 FreeBSD 。</p>
</div>
<div class="paragraph">
<p>镜像类型有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>虚拟机磁盘镜像，例如 <code>qcow2</code>、<code>vmdk</code>、<code>vhd</code> 和原始设备镜像。这些不是安装镜像，而是已经预装了 FreeBSD 并准备好进行后安装任务的镜像。虚拟机镜像在云环境中也被广泛使用。</p>
</li>
<li>
<p>SD 卡镜像，用于树莓派等嵌入式系统。这些文件必须解压缩并以原始镜像的形式写入 SD 卡，主板将从 SD 卡启动。</p>
</li>
<li>
<p>安装镜像用于从 ISO 或 USB 设备引导，以在常见的台式机、笔记本电脑或服务器系统上安装 FreeBSD 到驱动器。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本章的其余部分描述了第三种情况，解释了如何使用名为 bsdinstall 的基于文本的安装程序安装 FreeBSD 。安装程序与此处显示的内容可能存在细微差异，因此请将本章作为一份通用指南，而不是一组字面指令。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何获取 FreeBSD 镜像并创建 FreeBSD 安装介质。</p>
</li>
<li>
<p>如何启动 bsdinstall 。</p>
</li>
<li>
<p>bsdinstall 将会询问的问题，它们的含义以及如何回答。</p>
</li>
<li>
<p>如何排除安装失败的问题。</p>
</li>
<li>
<p>在进行安装之前，如何访问 FreeBSD 的活动版本。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bsdinstall-hardware">2.2. 最低硬件要求<a class="anchor" href="#bsdinstall-hardware"></a></h3>
<div class="paragraph">
<p>安装 FreeBSD 的硬件要求因架构和版本而异。支持 FreeBSD 发布的硬件架构和设备可以在 <a href="https://www.FreeBSD.org/releases/">FreeBSD 发布信息</a> 页面上找到。<a href="https://www.FreeBSD.org/where/">FreeBSD 下载页面</a> 还提供了选择不同架构的正确镜像的建议。</p>
</div>
</div>
<div class="sect2">
<h3 id="bsdinstall-pre">2.3. 安装前的任务<a class="anchor" href="#bsdinstall-pre"></a></h3>
<div class="paragraph">
<p>一旦确定系统满足安装 FreeBSD 的最低硬件要求，就应该下载安装文件并准备安装介质。在此之前，请通过验证以下清单中的项目，确保系统已准备好进行安装：</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>备份重要数据</strong></p>
<div class="paragraph">
<p>在安装任何操作系统之前， <strong>一定要</strong> 首先备份所有重要数据。不要将备份存储在正在安装的系统上。而是将数据保存到可移动的磁盘，如 USB 驱动器、网络上的另一个系统或在线备份服务中。在开始安装之前，测试备份以确保它包含所有所需的文件。一旦安装程序格式化了系统的磁盘，该磁盘上存储的所有数据都将丢失。</p>
</div>
</li>
<li>
<p><strong>决定在哪里安装 FreeBSD</strong></p>
<div class="paragraph">
<p>如果只安装 FreeBSD 作为唯一的操作系统，可以跳过这一步。但如果 FreeBSD 将与其他操作系统共享磁盘，则需要决定哪个磁盘或分区将用于 FreeBSD 。</p>
</div>
<div class="paragraph">
<p>在 i386 和 amd64 架构中，可以使用两种分区方案将磁盘分成多个分区。传统的 <em>主引导记录（MBR）</em> 保存了一个包含最多四个 <em>主分区</em> 的分区表。出于历史原因，FreeBSD 将这些主分区称为 <em>slices</em>。其中一个主分区可以成为包含多个 <em>逻辑分区</em> 的 <em>扩展分区</em>。 <em>GUID 分区表（GPT）</em> 是一种较新且更简单的磁盘分区方法。常见的 GPT 实现允许每个磁盘最多有 128 个分区，消除了逻辑分区的需要。</p>
</div>
<div class="paragraph">
<p>FreeBSD 引导加载程序需要一个主分区或 GPT 分区。如果所有的主分区或 GPT 分区已经被使用，就必须释放一个分区给 FreeBSD 使用。为了在不删除现有数据的情况下创建一个分区，可以使用分区调整工具来缩小一个现有分区，并使用释放出的空间创建一个新的分区。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://en.wikipedia.org/wiki/List_of_disk_partitioning_software">磁盘分区软件维基百科条目</a> 中列出了各种免费和商业的分区调整工具。<a href="https://gparted.org/livecd.php">GParted Live</a> 是一个免费的 Live CD，其中包含了 GParted 分区编辑器。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当正确使用时，磁盘收缩工具可以安全地为创建新分区腾出空间。由于选择错误分区的可能性存在，一定要在修改磁盘分区之前备份任何重要数据并验证备份的完整性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>包含不同操作系统的磁盘分区使得在一台计算机上安装多个操作系统成为可能。另一种选择是使用虚拟化技术，它允许多个操作系统同时运行，而无需修改任何磁盘分区。</p>
</div>
</li>
<li>
<p><strong>收集网络信息</strong></p>
<div class="paragraph">
<p>一些 FreeBSD 安装方法需要网络连接才能下载安装文件。在任何安装之后，安装程序将提供设置系统网络接口的选项。</p>
</div>
<div class="paragraph">
<p>如果网络有 DHCP 服务器，可以使用它来提供自动网络配置。如果没有 DHCP 可用，必须从本地网络管理员或互联网服务提供商获取系统的以下网络信息：</p>
</div>
<div id="bsdinstall-collect-network-information" class="paragraph">
<p>所需网络信息</p>
</div>
<div class="olist loweralpha">
<ol class="loweralpha" type="a">
<li>
<p>IP 地址</p>
</li>
<li>
<p>子网掩码</p>
</li>
<li>
<p>默认网关的 IP 地址</p>
</li>
<li>
<p>网络的域名</p>
</li>
<li>
<p>网络的 DNS 服务器的 IP 地址</p>
</li>
</ol>
</div>
</li>
<li>
<p><strong>检查 FreeBSD 勘误表</strong></p>
<div class="paragraph">
<p>尽管 FreeBSD 项目努力确保每个 FreeBSD 版本尽可能稳定，但偶尔会出现一些错误。在非常罕见的情况下，这些错误会影响安装过程。当这些问题被发现并修复时，它们会在每个版本的 FreeBSD 勘误页面中进行记录。在安装之前，请检查勘误页面，以确保没有可能影响安装的问题。</p>
</div>
<div class="paragraph">
<p>所有发布版本的信息和勘误表都可以在 <a href="https://www.FreeBSD.org/releases/">FreeBSD Release Information</a> 页面上找到。</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-installation-media">2.3.1. 准备安装介质<a class="anchor" href="#bsdinstall-installation-media"></a></h4>
<div class="paragraph">
<p>FreeBSD 安装程序不是可以在另一个操作系统中运行的应用程序。相反，您需要下载一个 FreeBSD 安装文件，将其刻录到与其文件类型和大小（CD、DVD 或 USB）相关联的介质上，并从插入的介质启动系统以进行安装。</p>
</div>
<div class="paragraph">
<p>FreeBSD 安装文件可以在 <a href="https://www.FreeBSD.org/where/">FreeBSD 下载页面</a> 上找到。每个安装文件的名称包括 FreeBSD 的发布版本、架构和文件类型。</p>
</div>
<div class="paragraph">
<p>安装文件有多种格式可供选择，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xz&amp;sektion=1&amp;format=html">xz(1)</a> 进行压缩或者不压缩。这些格式根据计算机架构和媒体类型而有所不同。</p>
</div>
<div class="paragraph">
<p>安装文件类型：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code><strong>-bootonly.iso</strong></code>：这是最小的安装文件，只包含安装程序。在安装过程中需要一个可用的互联网连接，因为安装程序将下载完成 FreeBSD 安装所需的文件。这个文件应该被刻录到光盘介质上。</p>
</li>
<li>
<p><code><strong>-disc1.iso</strong></code>：这个文件包含了安装 FreeBSD 所需的所有文件，包括其源代码和 Ports 集合。这个文件应该被刻录到光盘介质上。</p>
</li>
<li>
<p><code><strong>-dvd1.iso</strong></code> ：该文件包含安装 FreeBSD 所需的所有文件，包括其源代码和 Ports 集合。它还包含一组流行的二进制软件包，用于安装窗口管理器和一些应用程序，以便可以在没有连接到互联网的情况下从介质上安装完整的系统。该文件应该被刻录到光盘介质上。</p>
</li>
<li>
<p><code><strong>-memstick.img</strong></code>：该文件包含安装 FreeBSD 所需的所有文件，包括其源代码和 Ports 集合。按照 <a href="#bsdinstall-usb">将镜像文件写入 USB</a> 中所示的方法将该文件写入 USB 存储设备。</p>
</li>
<li>
<p><code><strong>-mini-memstick.img</strong></code>：与 <code><strong>-bootonly.iso</strong></code> 类似，不包含安装文件，但会在需要时进行下载。在安装过程中需要一个可用的互联网连接。请按照 <a href="#bsdinstall-usb">将镜像文件写入 USB</a> 中所示的方式将其写入 USB 存储设备。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在下载镜像文件后，从相同目录下载至少一个 <em>checksum</em> 文件。有两个 <em>checksum</em> 文件可用，分别以发布版本号和架构名称命名。例如：<code>CHECKSUM.SHA256-FreeBSD-13.1-RELEASE-amd64</code> 和 <code>CHECKSUM.SHA512-FreeBSD-13.1-RELEASE-amd64</code>。</p>
</div>
<div class="paragraph">
<p>在下载其中一个文件（或两个文件）之后，计算镜像文件的 <em>校验和（checksum）</em> 并将其与 <em>checksum</em> 文件中显示的 <em>校验和</em> 进行比较。请注意，您需要将计算出的 <em>校验和</em> 与正确的文件进行比较，因为它们对应于两种不同的算法： SHA256 和 SHA512。 FreeBSD 提供了可以用于计算 <em>校验和</em> 的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256&amp;sektion=1&amp;format=html">sha256(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=sha512&amp;sektion=1&amp;format=html">sha512(1)</a>。其他操作系统也有类似的程序。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，可以通过执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=sha256sum&amp;sektion=1&amp;format=html">sha256sum(1)</a>（和 <a href="https://man.freebsd.org/cgi/man.cgi?query=sha512sum&amp;sektion=1&amp;format=html">sha512sum(1)</a>）来自动验证 <em>校验和</em>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sha256sum -c CHECKSUM.SHA256-FreeBSD-13.1-RELEASE-amd64 FreeBSD-13.1-RELEASE-amd64-dvd1.iso
FreeBSD-13.1-RELEASE-amd64-dvd1.iso: OK</code></pre>
</div>
</div>
<div class="paragraph">
<p>校验和必须完全匹配。如果校验和不匹配，则图像文件损坏，必须重新下载。</p>
</div>
<div class="sect4">
<h5 id="bsdinstall-usb">2.3.1.1. 将镜像文件写入 USB<a class="anchor" href="#bsdinstall-usb"></a></h5>
<div class="paragraph">
<p><code>*memstick.img</code> 文件是一个内存棒的完整内容的 <code>镜像</code>。它不能作为文件复制到目标设备上。有几个应用程序可用于将 <code>*.img</code> 写入 USB 内存棒。本节介绍其中两个实用程序。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在继续之前，请备份 U 盘上的任何重要数据。此操作将擦除 U 盘上的现有数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="bsdinstall-usb-dd" class="exampleblock procedure">
<div class="content">
<div class="paragraph">
<p><strong>步骤 使用 <code>dd</code> 命令写入镜像</strong><br/></p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这个例子使用 <code>/dev/da0</code> 作为目标设备，镜像将被写入其中。请 <strong>非常小心</strong> 确保使用正确的设备，因为这个命令会破坏指定目标设备上的现有数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>命令行实用程序可在 BSD、Linux® 和 Mac OS® 系统上使用。要使用 <code>dd</code> 烧录镜像，请插入 USB 闪存并确定其设备名称。然后，指定下载的安装文件的名称和 USB 闪存的设备名称。此示例将 amd64 安装镜像烧录到现有的 FreeBSD 系统上的第一个 USB 设备。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=FreeBSD-13.1-RELEASE-amd64-memstick.img of=/dev/da0 bs=1M conv=sync</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果此命令失败，请验证 USB 存储设备是否挂载，并且设备名称是磁盘而不是分区。</p>
</div>
<div class="paragraph">
<p>某些操作系统可能需要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 命令来运行此命令。<a href="https://man.freebsd.org/cgi/man.cgi?query=dd&amp;sektion=1&amp;format=html">dd(1)</a> 的语法在不同的平台上略有不同；例如，Mac OS® 需要使用小写的 <code>bs = 1m</code>。像 Linux® 这样的系统可能会缓冲写入操作。要强制完成所有写入操作，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sync&amp;sektion=8&amp;format=html">sync(8)</a> 命令。</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>步骤。使用 Windows® 写入镜像 *<br/></p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请务必提供正确的驱动器字母，因为指定驱动器上的现有数据将被覆盖和销毁。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><strong>获取 Windows® 的图像写入器</strong></p>
<div class="paragraph">
<p>Image Writer for Windows® 是一个免费的应用程序，可以正确地将图像文件写入存储卡。从 <a href="https://sourceforge.net/projects/win32diskimager/">win32diskimager 主页</a> 下载并将其解压到一个文件夹中。</p>
</div>
</li>
<li>
<p><strong>使用 Writing the Image 写入镜像</strong></p>
<div class="paragraph">
<p>双击 Win32DiskImager 图标启动程序。确保在 <code>Device</code> 下显示的驱动器字母是存储器的驱动器。点击文件夹图标并选择要写入存储器的镜像。点击 <b class="button">Save</b> 接受镜像文件名。确认一切正确，并且存储器上没有其他窗口中打开的文件夹。当一切准备就绪时，点击 <b class="button">Write</b> 将镜像文件写入存储器。</p>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bsdinstall-start">2.4. 开始安装<a class="anchor" href="#bsdinstall-start"></a></h3>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，在以下消息之前，安装程序不会对磁盘进行任何更改：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Your changes will now be written to disk. If you
have chosen to overwrite existing data, it will
be PERMANENTLY ERASED. Are you sure you want to
commit your changes?</pre>
</div>
</div>
<div class="paragraph">
<p>在出现此警告之前，可以随时退出安装。如果担心某些配置不正确，只需在此之前关闭计算机，系统磁盘将不会进行任何更改。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本节描述了如何从使用 <a href="#bsdinstall-installation-media">准备安装介质</a> 中的说明准备的安装介质引导系统。使用可启动的 USB 闪存驱动器时，在打开计算机之前插入 USB 闪存驱动器。从 CD 或 DVD 引导时，应在第一时间打开计算机并插入介质。如何配置系统以从插入的介质引导取决于体系结构。</p>
</div>
<div class="sect3">
<h4 id="bsdinstall-view-probe">2.4.1. FreeBSD 启动菜单<a class="anchor" href="#bsdinstall-view-probe"></a></h4>
<div class="paragraph">
<p>一旦系统从安装介质启动，将显示类似以下的菜单：</p>
</div>
<div id="bsdinstall-newboot-loader-menu" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-newboot-loader-menu.png" alt="FreeBSD 引导加载程序菜单"/>
</div>
<div class="title">图 1. FreeBSD 引导加载程序菜单</div>
</div>
<div class="paragraph">
<p>默认情况下，菜单将在启动 FreeBSD 安装程序之前等待十秒钟以等待用户输入，或者如果 FreeBSD 已经安装，则在启动 FreeBSD 之前等待十秒钟。要暂停启动计时器以查看选择项，请按下空格键。要选择一个选项，请按下其突出显示的数字、字符或键。以下选项可用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>启动多用户模式（Boot Multi User）</code>：这将继续 FreeBSD 的启动过程。如果启动计时器已经暂停，请按下 <kbd>1</kbd>、大写或小写的 <kbd>B</kbd> 或 <kbd>Enter</kbd> 键。</p>
</li>
<li>
<p><code>单用户启动（Boot Single User）</code>: 这种模式可以用于修复已有的 FreeBSD 安装，如 <a href="./#boot-singleuser">”单用户模式“</a> 中所述。按下键盘上的 <kbd>2</kbd> 或大写或小写的 <kbd>S</kbd> 进入此模式。</p>
</li>
<li>
<p><code>进入加载器提示符（Escape to loader prompt）</code>: 这将使系统启动到一个包含有限数量低级命令的修复提示符。该提示符在 <a href="./#boot-loader">“Stage Three”</a> 中有描述。按下 <kbd>3</kbd> 或 <kbd>Esc</kbd> 键进入该提示符。</p>
</li>
<li>
<p><code>Reboot</code>：重新启动系统。</p>
</li>
<li>
<p><code>Cons</code>: 允许通过 <code>视频（video）</code>、<code>串口（serial）</code>、<code>双串口（串口为主）</code> 或 <code>双视频（视频为主）</code> 继续安装。</p>
</li>
<li>
<p><code>Kernel</code>: 加载一个不同的内核。</p>
</li>
<li>
<p><code>引导选项（Boot Options）</code> ：打开菜单，该菜单在 <a href="#bsdinstall-boot-options-menu">FreeBSD 启动选项菜单</a> 中显示并描述。</p>
</li>
</ul>
</div>
<div id="bsdinstall-boot-options-menu" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-boot-options-menu.png" alt="显示支持的不同启动选项的菜单"/>
</div>
<div class="title">图 2. FreeBSD 启动选项菜单</div>
</div>
<div class="paragraph">
<p>启动选项菜单分为两个部分。第一部分可以用于返回主启动菜单或将任何切换选项重置为默认值。</p>
</div>
<div class="paragraph">
<p>下一节用于通过按下选项的突出显示的数字或字符来切换可用选项的状态为 <code>On</code> 或 <code>Off</code>。系统将始终使用这些选项的设置进行引导，直到它们被修改。可以使用此菜单切换多个选项的状态。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ACPI 支持（ACPI Support）</code>: 如果系统在启动过程中出现卡死的情况，请尝试将此选项切换为 <code>Off</code>。</p>
</li>
<li>
<p><code>安全模式（Safe Mode）</code>：如果系统在启动时即使将 <code>ACPI Support</code> 设置为 <code>Off</code> 仍然出现卡顿的情况，请尝试将此选项设置为 <code>On</code>。</p>
</li>
<li>
<p><code>单用户模式（Single User）</code>：将此选项切换为 <code>On</code>，以修复现有的 FreeBSD 安装，如 <a href="./#boot-singleuser">“单用户模式”</a> 中所述。一旦问题解决，将其设置为 <code>Off</code>。</p>
</li>
<li>
<p><code>Verbose</code>：将此选项切换为 <code>On</code> 以在启动过程中显示更详细的消息。在排除硬件问题时，这可能会很有用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在进行所需的选择后，按下 <kbd>1</kbd> 或 <kbd>Backspace</kbd> 返回到主引导菜单，然后按下 <kbd>Enter</kbd> 继续引导进入 FreeBSD。FreeBSD 将执行其硬件设备探测和加载安装程序时，一系列引导消息将出现。引导完成后，将显示在 <a href="#bsdinstall-choose-mode">欢迎菜单</a> 中显示的欢迎菜单。</p>
</div>
<div id="bsdinstall-choose-mode" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-choose-mode.png" alt="FreeBSD 安装欢迎菜单"/>
</div>
<div class="title">图 3. 欢迎菜单</div>
</div>
<div class="paragraph">
<p>按下 <kbd>Enter</kbd> 键选择默认的 <b class="button">Install</b> 按钮进入安装程序。本章的其余部分将描述如何使用此安装程序。否则，使用右箭头、左箭头或带颜色的字母选择所需的菜单项。<b class="button">Shell</b> 可用于访问 FreeBSD shell，以便在安装之前使用命令行实用程序准备磁盘。<b class="button">Live CD</b> 选项可用于在安装之前尝试 FreeBSD。有关 live 版本的详细信息，请参阅 <a href="#using-live-cd">使用 Live CD</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要查看启动消息，包括硬件设备探测，请按下大写或小写的 <kbd>S</kbd>，然后按下 <kbd>Enter</kbd> 以访问 shell。在 shell 提示符下，键入 <code>more /var/run/dmesg.boot</code>，使用空格键滚动浏览消息。完成后，键入 <code>exit</code> 返回欢迎菜单。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="using-bsdinstall">2.5. 使用 bsdinstall<a class="anchor" href="#using-bsdinstall"></a></h3>
<div class="paragraph">
<p>本节展示了 bsdinstall 菜单的顺序以及在系统安装之前将要询问的信息类型。使用箭头键来突出显示菜单选项，然后使用 <kbd>Space</kbd> 来选择或取消选择该菜单项。完成后，按下 <kbd>Enter</kbd> 保存选择并进入下一个屏幕。</p>
</div>
<div class="sect3">
<h4 id="bsdinstall-keymap">2.5.1. 选择键映射菜单<a class="anchor" href="#bsdinstall-keymap"></a></h4>
<div class="paragraph">
<p>在开始过程之前， bsdinstall 将加载键盘映射文件，如 <a href="#bsdinstall-keymap-loading">按键映射加载中</a> 所示。</p>
</div>
<div id="bsdinstall-keymap-loading" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-loading.png" alt="键位映射加载中"/>
</div>
<div class="title">图 4. 按键映射加载中</div>
</div>
<div class="paragraph">
<p>在加载了键位映射之后， bsdinstall 会显示如 <a href="#bsdinstall-keymap-10">按键映射选择菜单</a> 所示的菜单。使用上下箭头选择最接近系统连接的键盘映射的键位映射。按下 <kbd>Enter</kbd> 保存选择。</p>
</div>
<div id="bsdinstall-keymap-10" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-10.png" alt="显示所有支持的键盘的按键映射选择菜单"/>
</div>
<div class="title">图 5. 按键映射选择菜单</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>按下 <kbd>Esc</kbd> 将退出此菜单并使用默认键映射。如果键映射的选择不明确，<span class="guimenuitem">United States of America ISO-8859-1</span> 也是一个安全的选项。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此外，在选择不同的键盘映射时，用户可以在继续之前尝试并确保它是正确的，如 <a href="#bsdinstall-keymap-testing">按键映射测试菜单</a> 所示。</p>
</div>
<div id="bsdinstall-keymap-testing" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-keymap-testing.png" alt="按键映射测试菜单"/>
</div>
<div class="title">图 6. 按键映射测试菜单</div>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-hostname">2.5.2. 设置主机名<a class="anchor" href="#bsdinstall-hostname"></a></h4>
<div class="paragraph">
<p>下一个 bsdinstall 菜单用于设置新安装系统的主机名。</p>
</div>
<div id="bsdinstall-config-hostname" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-config-hostname.png" alt="设置主机名"/>
</div>
<div class="title">图 7. 设置主机名</div>
</div>
<div class="paragraph">
<p>输入一个在网络中唯一的主机名。它应该是一个完全合格的主机名，例如 <code>machine3.example.com</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-components">2.5.3. 选择要安装的组件<a class="anchor" href="#bsdinstall-components"></a></h4>
<div class="paragraph">
<p>接下来， bsdinstall 将提示选择要安装的可选组件。</p>
</div>
<div id="bsdinstall-config-components" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-config-components.png" alt="可以安装的不同组件。示例：base-dbg" width="lib32" height="ports"/>
</div>
<div class="title">图 8. 选择要安装的组件</div>
</div>
<div class="paragraph">
<p>决定安装哪些组件将主要取决于系统的预期用途和可用的磁盘空间。 FreeBSD 内核和用户空间，统称为“基本系统”，始终会被安装。根据架构的不同，其中一些组件可能不会出现：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>base-dbg</code> - 基本工具，如 cat 和 ls 等，其中包含启用了调试符号的工具。</p>
</li>
<li>
<p><code>kernel-dbg</code> - 启用了调试符号的内核和模块。</p>
</li>
<li>
<p><code>lib32-dbg</code> - 在启用调试符号的 64 位 FreeBSD 版本上运行 32 位应用程序的兼容库。</p>
</li>
<li>
<p><code>lib32</code> - 在 64 位版本的 FreeBSD 上运行 32 位应用程序的兼容性库。</p>
</li>
<li>
<p><code>ports</code> - FreeBSD Ports Collection 是一组文件，用于自动下载、编译和安装第三方软件包。 <a href="./#ports">安装应用程序：软件包和 Ports</a> 讨论了如何使用 Ports Collection。</p>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>安装程序不会检查磁盘空间是否足够。只有在有足够的硬盘空间时才选择此选项。 FreeBSD Ports 集合大约占用 3 GB 的磁盘空间。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p><code>src</code> - 包含 FreeBSD 内核和用户空间的完整源代码。虽然大多数应用程序不需要它，但在构建设备驱动程序、内核模块或从 Ports Collection 中构建某些应用程序时可能需要它。它还用于开发 FreeBSD 本身。完整的源代码树需要 1 GB 的磁盘空间，重新编译整个 FreeBSD 系统需要额外的 5 GB 空间。</p>
</li>
<li>
<p><code>tests</code> - FreeBSD 测试套件。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-netinstall">2.5.4. 从网络安装<a class="anchor" href="#bsdinstall-netinstall"></a></h4>
<div class="paragraph">
<p>在 <a href="#bsdinstall-netinstall-notify">从网络安装</a> 中显示的菜单只会在从 <code>-bootonly.iso</code> 或 <code>-mini-memstick.img</code> 进行安装时出现，因为这种安装介质不保存安装文件的副本。由于安装文件必须通过网络连接获取，所以该菜单表示必须先配置网络接口。如果在过程的任何步骤中显示了该菜单，请记住按照 <a href="#bsdinstall-config-network-dev">配置网络接口</a> 中的说明进行操作。</p>
</div>
<div id="bsdinstall-netinstall-notify" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-files.png" alt="表示某些组件未找到，并将使用网络进行下载。"/>
</div>
<div class="title">图 9. 从网络安装</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bsdinstall-partitioning">2.6. 分配磁盘空间<a class="anchor" href="#bsdinstall-partitioning"></a></h3>
<div class="paragraph">
<p>下一个菜单用于确定分配磁盘空间的方法。</p>
</div>
<div id="bsdinstall-zfs-partmenu" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-partmenu.png" alt="显示不同的分区选项。示例：Manual" width="Shell" height="etc."/>
</div>
<div class="title">图 10. 分区选择</div>
</div>
<div class="paragraph">
<p>bsdinstall 为用户提供了四种分配磁盘空间的方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Auto (ZFS)</code> 分区创建一个基于 ZFS 的系统，可选择支持 GELI 加密用于 <em>引导环境</em>。</p>
</li>
<li>
<p><code>Auto (UFS)</code> 分区是使用 <code>UFS</code> 文件系统自动设置磁盘分区的功能。</p>
</li>
<li>
<p><code>Manual</code> 分区允许高级用户通过菜单选项创建自定义分区。</p>
</li>
<li>
<p><code>Shell</code> 打开一个 shell 提示符，高级用户可以使用命令行工具（如 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=fdisk&amp;sektion=8&amp;format=html">fdisk(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>）创建自定义分区。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节描述了在布置磁盘分区时需要考虑的事项。然后演示了如何使用不同的分区方法。</p>
</div>
<div class="sect3">
<h4 id="configtuning-initial">2.6.1. 设计分区布局<a class="anchor" href="#configtuning-initial"></a></h4>
<div class="paragraph">
<p>文件系统的默认分区布局包括一个用于整个系统的文件系统。当使用 <code>UFS</code> 时，如果您有足够的磁盘空间或多个磁盘，考虑使用多个文件系统可能是值得的。在布置文件系统时，请记住硬盘从外部轨道到内部传输数据速度更快。因此，较小且访问频率较高的文件系统应该靠近驱动器的外部，而像 <code>/usr</code> 这样的较大分区应该放置在磁盘的内部部分。按照类似的顺序创建分区是一个好主意： <code>/</code> 、交换空间、<code>/var</code> 和 <code>/usr</code>。</p>
</div>
<div class="paragraph">
<p><code>/var</code> 分区的大小反映了预期机器的使用情况。该分区用于存储邮箱、日志文件和打印机队列。根据用户数量和日志文件保留时间的长短，邮箱和日志文件的大小可能会出乎意料地增长。通常情况下，大多数用户在 <code>/var</code> 分区中很少需要超过 1GB 的可用磁盘空间。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有时，在 <code>/var/tmp</code> 目录下需要大量的磁盘空间。当安装新软件时，打包工具会在 <code>/var/tmp</code> 目录下提取软件包的临时副本。如果 <code>/var/tmp</code> 目录下的磁盘空间不足，安装大型软件包（如 Firefox 或 LibreOffice ）可能会变得棘手。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>/usr</code> 分区存放着许多支持系统的文件，包括 FreeBSD Ports Collection 和系统源代码。建议为这个分区提供至少 2GB 的空间。此外，请注意，默认情况下，用户的家目录位于 <code>/usr/home</code> ，但也可以放在另一个分区上。默认情况下， <code>/home</code> 是指向 <code>/usr/home</code> 的符号链接。</p>
</div>
<div class="paragraph">
<p>在选择分区大小时，请考虑空间需求。在一个分区中空间不足，而另一个分区几乎未使用可能会带来麻烦。</p>
</div>
<div class="paragraph">
<p>作为一个经验法则，交换分区的大小应该是物理内存（RAM）的两倍左右。具有较小内存的系统（对于较大内存配置来说更少）可能在有更多交换空间时性能更好。配置过少的交换空间可能导致虚拟内存页面扫描代码的低效，并且如果添加更多内存后可能会引发问题。</p>
</div>
<div class="paragraph">
<p>在具有多个 SCSI 磁盘或多个在不同控制器上运行的 IDE 磁盘的较大系统上，建议在每个驱动器上配置交换空间，最多四个驱动器。交换分区的大小应该大致相同。内核可以处理任意大小，但内部数据结构会按照最大交换分区的 4 倍进行扩展。保持交换分区的大小接近相同，可以让内核以最佳方式在不同磁盘间条带化交换空间。较大的交换大小可能会引发有关总配置交换的内核警告消息。通过增加用于跟踪交换分配的内存量来提高限制，如警告消息所指示的那样。在被迫重新启动之前，从失控的程序中恢复可能更容易。</p>
</div>
<div class="paragraph">
<p>通过正确地分区系统，较小的写入密集分区引入的碎片不会波及到主要读取分区。将写入负载较重的分区保持在磁盘边缘附近，将提高在这些分区中发生的 I/O 性能。虽然可能需要较大分区的 I/O 性能，但将它们更靠近磁盘边缘不会比将 <code>/var</code> 移动到边缘带来显著的性能改善。</p>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-part-guided">2.6.2. 使用 UFS 进行引导分区<a class="anchor" href="#bsdinstall-part-guided"></a></h4>
<div class="paragraph">
<p>当选择此方法时，菜单将显示可用的磁盘。如果连接了多个磁盘，请选择要安装 FreeBSD 的磁盘。</p>
</div>
<div id="bsdinstall-part-guided-disk" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-part-guided-disk.png" alt="显示可以安装 FreeBSD 的磁盘列表"/>
</div>
<div class="title">图 11. 从多个磁盘中进行选择</div>
</div>
<div class="paragraph">
<p>选择磁盘后，下一个菜单会提示选择是将整个磁盘安装，还是使用可用空间创建分区。如果选择 <b class="button">Entire Disk</b> ，将自动创建一个填满整个磁盘的通用分区布局。选择 <b class="button">Partition</b> 将从磁盘上未使用的空间创建一个分区布局。</p>
</div>
<div id="bsdinstall-part-entire-part" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-part-entire-part.png" alt="菜单询问用户是否想要使用磁盘上的所有可用空间，还是想要进行分区。"/>
</div>
<div class="title">图 12. 选择整个磁盘或分区</div>
</div>
<div class="paragraph">
<p>选择 <b class="button">Entire Disk</b> 选项后，bsdinstall 会显示一个对话框，指示将擦除磁盘。</p>
</div>
<div id="bsdinstall-ufs-warning" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-ufs-warning.png" alt="菜单提示用户所有磁盘上的数据将被删除，并要求确认。"/>
</div>
<div class="title">图 13. 确认</div>
</div>
<div class="paragraph">
<p>下一个菜单显示了可用的分区方案类型列表。对于 amd64 计算机来说， GPT 通常是最合适的选择。不兼容 GPT 的旧计算机应该使用 MBR。其他分区方案通常用于不常见或较旧的计算机。有关更多信息，请参阅 <a href="#partition-schemes">分区方案</a> 。</p>
</div>
<div id="bsdinstall-ufs-scheme" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png" alt="菜单显示用户存在的不同类型的分区，并要求选择其中之一"/>
</div>
<div class="title">图 14. 选择分区方案</div>
</div>
<div class="paragraph">
<p>在创建分区布局之后，请进行审核以确保它满足安装的需求。选择 <b class="button">Revert</b> 将重置分区为其原始值。按下 <b class="button">Auto</b> 将重新创建自动的 FreeBSD 分区。分区也可以手动创建、修改或删除。当分区设置正确时，请选择 <b class="button">Finish</b> 继续进行安装。</p>
</div>
<div id="bsdinstall-part-review" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-part-review.png" alt="显示已创建分区的菜单"/>
</div>
<div class="title">图 15. 审查已创建的分区</div>
</div>
<div class="paragraph">
<p>一旦磁盘配置完成，下一个菜单提供了在选择的驱动器格式化之前进行更改的最后机会。如果需要进行更改，请选择 <b class="button">返回</b> 返回到主分区菜单。 <b class="button">还原和退出</b> 退出安装程序，不对驱动器进行任何更改。否则，选择 <b class="button">提交</b> 开始安装过程。</p>
</div>
<div id="bsdinstall-ufs-final-confirmation" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-final-confirmation.png" alt="菜单向用户指示所有更改将被写入磁盘，并告知如果用户决定继续，现有数据将被永久删除。"/>
</div>
<div class="title">图 16. 最终确认</div>
</div>
<div class="paragraph">
<p>要继续安装过程，请转到 <a href="#bsdinstall-fetching-distribution">获取分发文件</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-part-manual">2.6.3. 手动分区<a class="anchor" href="#bsdinstall-part-manual"></a></h4>
<div class="paragraph">
<p>选择此方法将打开分区编辑器：</p>
</div>
<div id="bsdinstall-part-manual-create" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-create.png" alt="显示分区编辑器的菜单。"/>
</div>
<div class="title">图 17. 手动创建分区</div>
</div>
<div class="paragraph">
<p>高亮显示安装驱动器（在此示例中为 <code>ada0</code>），然后选择 <b class="button">Create</b> 以显示可用分区方案的菜单：</p>
</div>
<div id="bsdinstall-part-manual-partscheme" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-partscheme.png" alt="菜单显示了不同类型的分区方案"/>
</div>
<div class="title">图 18. 手动创建分区</div>
</div>
<div class="paragraph">
<p>GPT 通常是 amd64 计算机的最合适选择。不兼容 GPT 的旧计算机应使用 MBR。其他分区方案通常用于不常见或较旧的计算机。</p>
</div>
<table id="partition-schemes" class="tableblock frame-none grid-all stretch">
<caption class="title">表 1. 分区方案</caption>
<colgroup>
<col style="width: 25%;"/>
<col/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">缩写</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">APM</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apple Partition Map，由 PowerPC® 使用。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">BSD</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有 MBR 的 BSD 标签，有时被称为 <em>危险专用模式</em>，因为非 BSD 磁盘工具可能无法识别它。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">GPT</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/GUID_Partition_Table">GUID 分区表</a> 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">MBR</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://en.wikipedia.org/wiki/Master_boot_record">主引导记录</a> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在选择和创建分区方案之后，再次选择 <b class="button">Create</b> 来创建分区。使用 <kbd>Tab</kbd> 键将焦点放在字段上（在循环通过 <b class="button">&lt;OK&gt;</b> 、 <b class="button">&lt;Options&gt;</b> 和 <b class="button">&lt;Cancel&gt;</b> 之后）。</p>
</div>
<div id="bsdinstall-part-manual-addpart" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-part-manual-addpart.png" alt="请求类型菜单" width="size" height="mountpoint and label for the new partition."/>
</div>
<div class="title">图 19. 手动创建分区</div>
</div>
<div class="paragraph">
<p>标准的 FreeBSD GPT 安装至少使用三个分区，其中包括 UFS 或 ZFS 之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>freebsd-boot</code> 或 <code>efi</code> - 存放着 FreeBSD 的引导代码。</p>
</li>
<li>
<p><code>freebsd-ufs</code> - 一个 FreeBSD UFS 文件系统。</p>
</li>
<li>
<p><code>freebsd-zfs</code> - 一个 FreeBSD 的 ZFS 文件系统。有关 ZFS 的更多信息，请参阅 <a href="./#zfs">Z 文件系统（ZFS）</a> 。</p>
</li>
<li>
<p><code>freebsd-swap</code> - FreeBSD 交换空间。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>，了解可用的 GPT 分区类型的描述。</p>
</div>
<div class="paragraph">
<p>可以创建多个文件系统分区。有些人喜欢传统的布局，将 <code>/</code>、<code>/var</code>、<code>/tmp</code> 和 <code>/usr</code> 分别放在不同的分区中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，在具有足够内存的系统上，可以将 <code>/tmp</code> 作为基于内存的文件系统（<a href="https://man.freebsd.org/cgi/man.cgi?query=tmpfs&amp;sektion=5&amp;format=html">tmpfs(5)</a>）添加。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请参考 <a href="#bsdinstall-part-manual-splitfs">创建传统的分割文件系统分区</a> 中的示例。</p>
</div>
<div class="paragraph">
<p><code>Size</code> 可以使用常见的缩写进行输入：<em>K</em> 表示千字节，<em>M</em> 表示兆字节，<em>G</em> 表示吉字节。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>正确的扇区对齐可以提供最佳性能，将分区大小设置为 4K 字节的倍数有助于确保在具有 512 字节或 4K 字节扇区的驱动器上进行对齐。通常，使用 1M 或 1G 的倍数作为分区大小是确保每个分区从 4K 的倍数开始的最简单方法。有一个例外：由于当前引导代码的限制，<em>freebsd-boot</em> 分区的大小不应超过 512K 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果分区将包含文件系统，则需要一个 <code>Mountpoint</code> 。如果只创建一个 UFS 分区，则挂载点应为 <code>/</code>。</p>
</div>
<div class="paragraph">
<p><code>Label</code> 是分区的名称。如果驱动器连接到不同的控制器或端口，驱动器名称或编号可能会发生变化，但分区标签不会改变。在像 <code>/etc/fstab</code> 这样的文件中使用标签而不是驱动器名称和分区编号，可以使系统更容忍硬件变化。当连接了磁盘时，GPT 标签会出现在 <code>/dev/gpt/</code> 中。其他分区方案具有不同的标签功能，它们的标签会出现在 <code>/dev/</code> 中的不同目录中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在每个分区上使用唯一的标签，以避免相同标签引起的冲突。可以在标签中添加计算机名称、用途或位置的几个字母。例如，对于名为 <code>lab</code> 的计算机上的 UFS 根分区，可以使用 <code>labroot</code> 或 <code>rootfslab</code> 作为标签。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="bsdinstall-part-manual-splitfs" class="exampleblock">
<div class="title">例 1. 创建传统的分割文件系统分区</div>
<div class="content">
<div class="paragraph">
<p>对于传统的分区布局，其中 <code>/</code>、<code>/var</code>、<code>/tmp</code> 和 <code>/usr</code> 目录是各自独立的文件系统，创建一个 GPT 分区方案，然后按照所示创建分区。所示的分区大小适用于 20G 目标磁盘。如果目标磁盘上有更多的空间，可以考虑使用更大的交换空间或 <code>/var</code> 分区。这里显示的标签以 <code>ex</code> 为前缀，表示&#34;示例&#34;，但读者应根据上述说明使用其他唯一的标签值。</p>
</div>
<div class="paragraph">
<p>默认情况下，FreeBSD 的 <code>gptboot</code> 期望第一个 UFS 分区是 <code>/</code> 分区。</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">分区类型</th>
<th class="tableblock halign-left valign-top">大小</th>
<th class="tableblock halign-left valign-top">挂载点</th>
<th class="tableblock halign-left valign-top">标签</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>freebsd-boot</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>512K</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>freebsd-ufs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2G</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exrootfs</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>freebsd-swap</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>4G</code></p></td>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">`</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>freebsd-ufs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2G</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/var</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exvarfs</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>freebsd-ufs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>1G</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/tmp</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>extmpfs</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>freebsd-ufs</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接受默认选项（使用磁盘的剩余空间）。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>exusrfs</code></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="paragraph">
<p>在创建自定义分区后，选择 <b class="button">Finish</b> 继续安装并转到 <a href="#bsdinstall-fetching-distribution">获取分发文件</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-part-zfs">2.6.4. 使用 Root-on-ZFS 进行引导分区<a class="anchor" href="#bsdinstall-part-zfs"></a></h4>
<div class="paragraph">
<p>这种分区模式只适用于整个磁盘，并且会擦除整个磁盘的内容。主要的 ZFS 配置菜单提供了一些选项来控制池的创建。</p>
</div>
<div id="bsdinstall-zfs-menu" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-menu.png" alt="显示配置 ZFS 池的不同选项的菜单"/>
</div>
<div class="title">图 20. ZFS 分区菜单</div>
</div>
<div class="paragraph">
<p>这是该菜单中选项的摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>安装（Install）</code> - 使用所选选项继续安装。</p>
</li>
<li>
<p>` 池类型及磁盘（Pool Type/Disks）` - 配置 <code>池类型</code> 和组成池的磁盘。自动 ZFS 安装程序目前只支持创建单个顶级 vdev，除非是 stripe 模式。要创建更复杂的池，请使用 <a href="#bsdinstall-part-shell">Shell 模式分区</a> 中的说明来创建池。</p>
</li>
<li>
<p><code>重新扫描设备（Rescan Devices）</code> - 重新填充可用磁盘列表。</p>
</li>
<li>
<p><code>磁盘信息（Disk Info）</code> - 此菜单可用于检查每个磁盘，包括其分区表和其他各种信息，如设备型号和序列号（如果可用）。</p>
</li>
<li>
<p><code>池名称（Pool Name）</code> - 设置池的名称。默认名称为 <em>zroot</em>。</p>
</li>
<li>
<p><code>强制使用 4K 扇区（Force 4K Sectors）？</code> - 强制使用 4K 扇区。默认情况下，安装程序将自动创建与 4K 边界对齐的分区，并强制 ZFS 使用 4K 扇区。即使是 512 字节扇区的磁盘，这也是安全的，并且还有一个额外的好处，即确保在将来可以将 4K 扇区磁盘添加到在 512 字节磁盘上创建的池中，无论是作为额外的存储空间还是作为替换失败的磁盘。按下 <kbd>Enter</kbd> 键选择是否激活它。</p>
</li>
<li>
<p><code>加密磁盘（Encrypt Disks）？</code> - 加密磁盘允许用户使用 GELI 对磁盘进行加密。有关磁盘加密的更多信息，请参阅 <a href="./#disks-encrypting-geli">“使用 geli 进行磁盘加密”</a>。按下 <kbd>Enter</kbd> 键选择是否激活它。</p>
</li>
<li>
<p><code>分区方案（Partition Scheme）</code> - 选择分区方案。在大多数情况下，GPT 是推荐的选项。按下 <kbd>Enter</kbd> 键来在不同选项之间进行选择。</p>
</li>
<li>
<p><code>交换空间大小（Swap Size）</code> - 设置交换空间的大小。</p>
</li>
<li>
<p><code>镜像交换分区（Mirror Swap）？</code> - 是否在磁盘之间进行交换分区的镜像。请注意，启用镜像交换分区将会破坏崩溃转储。按下 <kbd>Enter</kbd> 键来激活或不激活。</p>
</li>
<li>
<p><code>加密交换空间（Encrypt Swap）？</code> - 是否加密交换空间。这将在每次系统启动时使用临时密钥加密交换空间，并在重新启动时丢弃它。按下 <kbd>Enter</kbd> 键选择是否激活。有关加密交换空间的更多信息，请参阅 <a href="./#swap-encrypting">“加密交换空间”</a> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>选择 <kbd>T</kbd> 来配置 <code>池类型</code> 和组成池的磁盘。</p>
</div>
<div id="bsdinstall-zfs-vdev_type" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_type.png" alt="请求虚拟设备类型的菜单。例如：stripe" width="mirror" height="raidz1"/>
</div>
<div class="title">图 21. ZFS 池类型</div>
</div>
<div class="paragraph">
<p>这是一个关于此菜单中可选择的 <code>池类型</code> 的摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>stripe</code> - 条带化提供了最大的存储空间，但没有冗余。如果只有一个磁盘故障，池中的数据将无法恢复。</p>
</li>
<li>
<p><code>镜像（mirror）</code> - 镜像将所有数据完整地存储在每个磁盘上。镜像提供良好的读取性能，因为数据可以并行从所有磁盘中读取。写入性能较慢，因为数据必须写入池中的所有磁盘。允许除一个磁盘外的所有磁盘故障。此选项至少需要两个磁盘。</p>
</li>
<li>
<p><code>raid10</code> - 镜像条带化。提供最佳性能，但存储空间最少。此选项至少需要偶数个磁盘和至少四个磁盘。</p>
</li>
<li>
<p><code>raidz1</code> - 单冗余 RAID 。允许同时故障一个磁盘。此选项至少需要三个磁盘。</p>
</li>
<li>
<p><code>raidz2</code> - 双冗余 RAID 。允许同时故障两个磁盘。此选项至少需要四个磁盘。</p>
</li>
<li>
<p><code>raidz3</code> - 三重冗余 RAID 。允许同时故障三个磁盘。此选项至少需要五个磁盘。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一旦选择了 <code>池类型</code>，将显示可用磁盘列表，并提示用户选择一个或多个磁盘来组成池。然后，将验证配置以确保选择了足够的磁盘。如果验证失败，请选择 <b class="button">&lt;Change Selection&gt;</b> 返回到磁盘列表，或选择 <b class="button">&lt;Back&gt;</b> 更改 <code>池类型</code>。</p>
</div>
<div id="bsdinstall-zfs-disk_select" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_select.png" alt="菜单请求添加多少个磁盘到池中"/>
</div>
<div class="title">图 22. 磁盘选择</div>
</div>
<div id="bsdinstall-zfs-vdev_invalid" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-vdev_invalid.png" alt="菜单指示未选择足够的磁盘。"/>
</div>
<div class="title">图 23. 无效选择</div>
</div>
<div class="paragraph">
<p>如果列表中缺少一个或多个磁盘，或者在启动安装程序后附加了磁盘，请选择 <b class="button">- Rescan Devices</b> 以重新填充可用磁盘列表。</p>
</div>
<div id="bsdinstall-zfs-rescan-devices" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-rescan-devices.png" alt="设备重新扫描"/>
</div>
<div class="title">图 24. 重新扫描设备</div>
</div>
<div class="paragraph">
<p>为了避免意外擦除错误的磁盘，可以使用 <b class="button">- Disk Info</b> 菜单来检查每个磁盘，包括其分区表和其他各种信息，如设备型号和序列号（如果有）。</p>
</div>
<div id="bsdinstall-zfs-disk_info" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-disk_info.png" alt="显示分区信息的菜单。"/>
</div>
<div class="title">图 25. 分析磁盘</div>
</div>
<div class="paragraph">
<p>选择 <kbd>N</kbd> 来配置 <code>池名称</code>。输入所需的名称，然后选择 <b class="button">&lt;OK&gt;</b> 来确认，或选择 <b class="button">&lt;Cancel&gt;</b> 返回主菜单并保留默认名称。</p>
</div>
<div id="bsdinstall-zfs-pool-name" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-pool-name.png" alt="请求输入池的名称的菜单。"/>
</div>
<div class="title">图 26. 池名称</div>
</div>
<div class="paragraph">
<p>选择 <kbd>S</kbd> 来设置交换空间的大小。输入所需的交换空间大小，然后选择 <b class="button">&lt;OK&gt;</b> 来确认设置，或选择 <b class="button">&lt;Cancel&gt;</b> 返回主菜单并使用默认大小。</p>
</div>
<div id="bsdinstall-zfs-swap-amount" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-swap-amount.png" alt="请求交换内存的数量的菜单"/>
</div>
<div class="title">图 27. 交换空间大小</div>
</div>
<div class="paragraph">
<p>一旦所有选项都设置为所需的值，选择菜单顶部的 <b class="button">&gt;&gt;&gt; Install</b> 选项。然后安装程序会在销毁所选驱动器的内容以创建 ZFS 池之前，提供最后一次取消的机会。</p>
</div>
<div id="bsdinstall-zfs-warning" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-warning.png" alt="菜单提示用户数据将会丢失。"/>
</div>
<div class="title">图 28. 最后机会</div>
</div>
<div class="paragraph">
<p>如果启用了 GELI 磁盘加密，安装程序将会两次提示输入用于加密磁盘的密码短语。然后，加密的初始化过程开始。</p>
</div>
<div id="bsdinstall-zfs-geli_password" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-geli_password.png" alt="要求输入密码以加密设备的菜单。"/>
</div>
<div class="title">图 29. 磁盘加密密码</div>
</div>
<div id="bsdinstall-zfs-init-encription" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-zfs-init-encription.png" alt="菜单显示加密正在初始化。"/>
</div>
<div class="title">图 30. 初始化加密</div>
</div>
<div class="paragraph">
<p>安装然后正常进行。要继续安装，请转到 <a href="#bsdinstall-fetching-distribution">获取分发文件</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-part-shell">2.6.5. Shell 模式分区<a class="anchor" href="#bsdinstall-part-shell"></a></h4>
<div class="paragraph">
<p>在创建高级安装时，bsdinstall 分区菜单可能无法提供所需的灵活性水平。高级用户可以从分区菜单中选择 <b class="button">Shell</b> 选项，以手动分区驱动器，创建文件系统，填充 <code>/tmp/bsdinstall_etc/fstab</code> ，并将文件系统挂载到 <code>/mnt</code> 下。完成后，输入 <code>exit</code> 返回到 bsdinstall 并继续安装。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bsdinstall-fetching-distribution">2.7. 获取分发文件<a class="anchor" href="#bsdinstall-fetching-distribution"></a></h3>
<div class="paragraph">
<p>安装时间将根据所选择的发行版、安装介质和计算机速度而有所不同。一系列的消息将指示安装的进度。</p>
</div>
<div class="paragraph">
<p>首先，安装程序会格式化所选磁盘并初始化分区。接下来，在选择了 <code>仅引导媒体</code> 或 <code>迷你内存棒</code> 的情况下，它会下载所选组件：</p>
</div>
<div id="bsdinstall-distfile-fetching" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-fetching.png" alt="菜单显示了不同组件的下载。"/>
</div>
<div class="title">图 31. 获取分发文件</div>
</div>
<div class="paragraph">
<p>接下来，将验证分发文件的完整性，以确保在下载过程中没有损坏或在安装介质中读取错误：</p>
</div>
<div id="bsdinstall-distfile-verify" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-verifying.png" alt="显示不同组件的验证菜单。"/>
</div>
<div class="title">图 32. 验证分发文件</div>
</div>
<div class="paragraph">
<p>最后，验证过的分发文件被解压到磁盘上：</p>
</div>
<div id="bsdinstall-distfile-extract" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-distfile-extracting.png" alt="菜单显示了不同组件的提取过程。"/>
</div>
<div class="title">图 33. 提取分发文件</div>
</div>
<div class="paragraph">
<p>一旦提取了所有请求的分发文件， bsdinstall 将显示第一个安装后配置屏幕。下一节将介绍可用的后配置选项。</p>
</div>
</div>
<div class="sect2">
<h3 id="bsdinstall-post">2.8. 网络接口，账户，时区，服务和加固<a class="anchor" href="#bsdinstall-post"></a></h3>
<div class="sect3">
<h4 id="bsdinstall-post-root">2.8.1. 设置 <code>root</code> 密码<a class="anchor" href="#bsdinstall-post-root"></a></h4>
<div class="paragraph">
<p>首先，必须设置 <code>root</code> 密码。在输入密码时，屏幕上不会显示正在输入的字符。为了防止输入错误，密码必须输入两次。</p>
</div>
<div id="bsdinstall-post-set-root-passwd" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-post-root-passwd.png" alt="显示要求输入 root 用户密码的菜单。"/>
</div>
<div class="title">图 34. 设置 <code>root</code> 密码</div>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-config-network-dev">2.8.2. 配置网络接口<a class="anchor" href="#bsdinstall-config-network-dev"></a></h4>
<div class="paragraph">
<p>接下来，将显示计算机上找到的网络接口列表。请选择要配置的接口。</p>
</div>
<div id="bsdinstall-configure-net-interface" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface.png" alt="显示不同网络接口以进行配置的菜单。"/>
</div>
<div class="title">图 35. 选择一个网络接口</div>
</div>
<div class="paragraph">
<p>如果选择了以太网接口，安装程序将直接跳转到 <a href="#bsdinstall-configure-net-ipv4">选择 IPv4 网络</a> 中显示的菜单。如果选择了无线网络接口，系统将会扫描无线接入点：</p>
</div>
<div id="bsdinstall-wireless-scan" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-scan.png" alt="显示无线网络扫描的菜单。"/>
</div>
<div class="title">图 36. 扫描无线接入点</div>
</div>
<div class="paragraph">
<p>无线网络通过服务集标识符（SSID）进行识别，每个网络都有一个短而独特的名称。扫描期间找到的 SSID 将列出，然后是该网络可用的加密类型的描述。如果所需的 SSID 在列表中未出现，请选择 <b class="button">Rescan</b> 进行再次扫描。如果所需的网络仍未出现，请检查天线连接是否有问题，或尝试将计算机移动到接入点附近。每次更改后都要重新扫描。</p>
</div>
<div id="bsdinstall-wireless-accesspoints" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-accesspoints.png" alt="显示可连接的不同无线网络的菜单。"/>
</div>
<div class="title">图 37. 选择无线网络</div>
</div>
<div class="paragraph">
<p>接下来，请输入连接到所选无线网络的加密信息。强烈建议使用 WPA2 加密，而不是较旧的加密类型，如 WEP ，因为 WEP 提供的安全性很低。如果网络使用 WPA2，请输入密码，也称为预共享密钥（PSK）。出于安全原因，输入框中键入的字符将显示为星号。</p>
</div>
<div id="bsdinstall-wireless-wpa2" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-wireless-wpa2setup.png" alt="请求无线网络密码的菜单。"/>
</div>
<div class="title">图 38. WPA2 设置</div>
</div>
<div class="paragraph">
<p>接下来，选择是否在以太网或无线接口上配置 IPv4 地址：</p>
</div>
<div id="bsdinstall-configure-net-ipv4" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4.png" alt="菜单指示是否要为所选接口配置 IPv4 。"/>
</div>
<div class="title">图 39. 选择 IPv4 网络</div>
</div>
<div class="paragraph">
<p>IPv4 配置有两种方法。如果网络提供了 DHCP 服务器，DHCP 将自动正确配置网络接口，并且应该使用 DHCP。否则，需要手动输入地址信息作为静态配置。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请不要输入随机的网络信息，因为它不会起作用。如果没有 DHCP 服务器可用，请向网络管理员或互联网服务提供商获取 <a href="#bsdinstall-collect-network-information">所需网络信息</a> 中列出的信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果有 DHCP 服务器可用，请在下一个菜单中选择 <b class="button">Yes</b> 以自动配置网络接口。安装程序将会暂停一分钟左右，以便找到 DHCP 服务器并获取系统的地址信息。</p>
</div>
<div id="bsdinstall-net-ipv4-dhcp" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-dhcp.png" alt="菜单指示是否要为所选接口配置 DHCP 。"/>
</div>
<div class="title">图 40. 选择 IPv4 DHCP 配置</div>
</div>
<div class="paragraph">
<p>如果没有可用的 DHCP 服务器，请选择 <b class="button">No</b>，并在此菜单中输入以下寻址信息：</p>
</div>
<div id="bsdinstall-net-ipv4-static" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv4-static.png" alt="请求配置 IPv4 网络的菜单。"/>
</div>
<div class="title">图 41. IPv4 静态配置</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IP 地址（IP Address）</code> - 分配给此计算机的 IPv4 地址。该地址必须是唯一的，并且在本地网络上没有被其他设备使用。</p>
</li>
<li>
<p><code>子网掩码（Subnet Mask）</code> - 网络的子网掩码。</p>
</li>
<li>
<p><code>默认路由器（Default Router）</code> - 网络的默认网关的 IP 地址。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>下一个屏幕将询问是否应该为 IPv6 配置接口。如果 IPv6 可用且需要，请选择 <b class="button">Yes</b> 来选择它。</p>
</div>
<div id="bsdinstall-net-ipv6" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6.png" alt="菜单指示是否要为所选接口配置 IPv6 。"/>
</div>
<div class="title">图 42. 选择 IPv6 网络</div>
</div>
<div class="paragraph">
<p>IPv6 还有两种配置方法。无状态地址自动配置（SLAAC）将自动从本地路由器请求正确的配置信息。有关更多信息，请参阅 <a href="http://tools.ietf.org/html/rfc4862">rfc4862</a>。静态配置需要手动输入网络信息。</p>
</div>
<div class="paragraph">
<p>如果有 IPv6 路由器可用，请在下一个菜单中选择 <b class="button">Yes</b> 以自动配置网络接口。安装程序将会暂停一分钟左右，以查找路由器并获取系统的寻址信息。</p>
</div>
<div id="bsdinstall-net-ipv6-slaac" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-slaac.png" alt="菜单指示是否要为所选接口配置 SLAAC 。"/>
</div>
<div class="title">图 43. 选择 IPv6 SLAAC 配置</div>
</div>
<div class="paragraph">
<p>如果没有可用的 IPv6 路由器，请选择 <b class="button">No</b> 并在此菜单中输入以下寻址信息：</p>
</div>
<div id="bsdinstall-net-ipv6-static" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-interface-ipv6-static.png" alt="菜单请求配置 IPv6 网络的数据。"/>
</div>
<div class="title">图 44. IPv6 静态配置</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>IPv6 地址（IPv6 Address）</code> - 分配给此计算机的 IPv6 地址。该地址必须是唯一的，并且在本地网络中没有被其他设备使用。</p>
</li>
<li>
<p><code>默认路由器（Default Router）</code> - 网络的默认网关的 IPv6 地址。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>最后一个网络配置菜单用于配置域名系统（DNS）解析器，该解析器将主机名转换为网络地址，并且可以将网络地址转换为主机名。如果使用 DHCP 或 SLAAC 自动配置网络接口，则 <code>解析器配置（Resolver Configuration）</code> 值可能已经填写。否则，请在 <code>搜索（Search）</code> 字段中输入本地网络的域名。<code>DNS #1</code> 和 <code>DNS #2</code> 是 DNS 服务器的 IPv4 和 / 或 IPv6 地址。至少需要一个 DNS 服务器。</p>
</div>
<div id="bsdinstall-net-dns-config" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-configure-network-ipv4-dns.png" alt="菜单请求数据以配置网络的 DNS 。"/>
</div>
<div class="title">图 45. DNS 配置</div>
</div>
<div class="paragraph">
<p>一旦配置了接口，选择一个位于与安装 FreeBSD 的计算机相同地区的镜像站点。当镜像站点靠近目标计算机时，可以更快地检索文件，从而减少安装时间。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>选择 <code><a href="ftp://ftp.freebsd.org" class="bare">ftp://ftp.freebsd.org</a> (Main Site)</code> 将自动将您路由到最近的镜像站点。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="bsdinstall-netinstall-mirror" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-netinstall-mirrorselect.png" alt="请求网络镜像的菜单。"/>
</div>
<div class="title">图 46. 选择镜像源</div>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-timezone">2.8.3. 设置时区<a class="anchor" href="#bsdinstall-timezone"></a></h4>
<div class="paragraph">
<p>下一系列菜单用于通过选择地理区域、国家和时区来确定正确的本地时间。设置时区允许系统自动校正区域时间变化，如夏令时，并正确执行其他与时区相关的功能。</p>
</div>
<div class="paragraph">
<p>这里展示的示例适用于位于西班牙欧洲大陆时区的机器。根据地理位置的不同，选择项会有所变化。</p>
</div>
<div id="bsdinstall-timezone-region" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-region.png" alt="请求时区地区的菜单。"/>
</div>
<div class="title">图 47. 选择一个地区</div>
</div>
<div class="paragraph">
<p>使用箭头键选择适当的区域，然后按下 <kbd>Enter</kbd> 键。</p>
</div>
<div id="bsdinstall-timezone-country" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-country.png" alt="请求时区国家的菜单。"/>
</div>
<div class="title">图 48. 选择一个国家</div>
</div>
<div class="paragraph">
<p>使用箭头键选择适当的国家，然后按下键盘上的 [Enter] 键。</p>
</div>
<div id="bsdinstall-timezone-zone" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-zone.png" alt="请求时区的菜单。"/>
</div>
<div class="title">图 49. 选择一个时区</div>
</div>
<div class="paragraph">
<p>使用箭头键选择适当的时区，然后按下 <kbd>Enter</kbd> 键确认。</p>
</div>
<div id="bsdinstall-timezone-confirmation" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-confirm.png" alt="菜单请求确认所选时区。"/>
</div>
<div class="title">图 50. 确认时区</div>
</div>
<div class="paragraph">
<p>请确认时区的缩写是否正确。</p>
</div>
<div id="bsdinstall-timezone-date" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-date.png" alt="请求系统日期的菜单。"/>
</div>
<div class="title">图 51. 选择日期</div>
</div>
<div class="paragraph">
<p>使用箭头键选择适当的日期，然后按下 <b class="button">Set Date</b> 。否则，可以通过按下 <b class="button">Skip</b> 来跳过日期选择。</p>
</div>
<div id="bsdinstall-timezone-time" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-timezone-time.png" alt="请求系统时间的菜单。"/>
</div>
<div class="title">图 52. 选择时间</div>
</div>
<div class="paragraph">
<p>使用箭头键选择适当的时间，然后按下 <b class="button">Set Time</b> 。否则，可以通过按下 <b class="button">Skip</b> 来跳过时间选择。</p>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-sysconf">2.8.4. 启用服务<a class="anchor" href="#bsdinstall-sysconf"></a></h4>
<div class="paragraph">
<p>下一个菜单用于配置系统启动时将启动哪些系统服务。所有这些服务都是可选的。只启动系统运行所需的服务。</p>
</div>
<div id="bsdinstall-config-serv" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-config-services.png" alt="显示不同服务的菜单。"/>
</div>
<div class="title">图 53. 选择启用附加服务</div>
</div>
<div class="paragraph">
<p>这里是可以在此菜单中启用的服务的摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>local_unbound</code> - 启用本地 DNS 解析器 unbound 。需要注意的是，这个配置只适用于作为本地缓存转发解析器使用。如果目标是为整个网络设置解析器，请安装 <code>dns/unbound</code> 软件包。</p>
</li>
<li>
<p><code>sshd</code> - 安全 Shell（SSH）守护进程用于通过加密连接远程访问系统。只有在系统需要提供远程登录时才启用此服务。</p>
</li>
<li>
<p><code>moused</code> - 如果希望从命令行系统控制台使用鼠标，请启用此服务。</p>
</li>
<li>
<p><code>ntpdate</code> - 在启动时启用自动时钟同步。请注意，该程序的功能现在已经整合到 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a></code> 守护进程中， <code><a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a></code> 实用程序将很快被弃用。</p>
</li>
<li>
<p><code>ntpd</code> - 自动时钟同步的网络时间协议（NTP）守护进程。如果您希望将系统时钟与远程时间服务器或时间池同步，请启用此服务。</p>
</li>
<li>
<p><code>powerd</code> - 用于系统电源控制和节能的实用程序。</p>
</li>
<li>
<p><code>dumpdev</code> - 崩溃转储在调试系统问题时非常有用，因此鼓励用户启用它们。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-hardening">2.8.5. 启用强化安全选项<a class="anchor" href="#bsdinstall-hardening"></a></h4>
<div class="paragraph">
<p>下一个菜单用于配置启用的安全选项。所有这些选项都是可选的，但建议使用它们。</p>
</div>
<div id="bsdinstall-hardening-options" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-hardening.png" alt="显示不同的加固安全选项的菜单。"/>
</div>
<div class="title">图 54. 选择加固安全选项</div>
</div>
<div class="paragraph">
<p>这里是可以在此菜单中启用的选项摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>hide_uids</code> - 隐藏以其他用户（UID）身份运行的进程。这可以防止非特权用户看到其他用户正在运行的进程。</p>
</li>
<li>
<p><code>hide_gids</code> - 隐藏以其他组（GID）身份运行的进程。这可以防止非特权用户看到来自其他组的运行进程。</p>
</li>
<li>
<p><code>hide_jail</code> - 隐藏在 jail 中运行的进程。这可以防止非特权用户看到在 jail 内部运行的进程。</p>
</li>
<li>
<p><code>read_msgbuf</code> - 禁止非特权用户读取内核消息缓冲区。防止非特权用户使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> 命令查看内核日志缓冲区中的消息。</p>
</li>
<li>
<p><code>proc_debug</code> - 禁用非特权用户的进程调试功能。禁用了各种非特权进程间调试服务，包括一些 procfs 功能，<code>ptrace()</code> 和 <code>ktrace()</code>。请注意，这也会阻止调试工具如 <a href="https://man.freebsd.org/cgi/man.cgi?query=lldb&amp;sektion=1&amp;format=html">lldb(1)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=truss&amp;sektion=1&amp;format=html">truss(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=procstat&amp;sektion=1&amp;format=html">procstat(1)</a>，以及某些脚本语言（如 PHP）中的一些内置调试功能。</p>
</li>
<li>
<p><code>random_pid</code> - 随机化进程的 PID 。</p>
</li>
<li>
<p><code>clear_tmp</code> - 在系统启动时清理 <code>/tmp</code> 目录。</p>
</li>
<li>
<p><code>disable_syslogd</code> - 禁用打开 syslogd 网络套接字。默认情况下，FreeBSD 以安全方式运行 syslogd ，使用 <code>-s</code> 选项。这样可以防止守护进程在 514 端口上监听传入的 UDP 请求。启用此选项后， syslogd 将改为使用 <code>-ss</code> 运行，这将阻止 syslogd 打开任何端口。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 。</p>
</li>
<li>
<p><code>disable_sendmail</code> - 禁用 sendmail 邮件传输代理。</p>
</li>
<li>
<p><code>secure_console</code> - 在进入单用户模式时，使命令提示符要求输入 <code>root</code> 密码。</p>
</li>
<li>
<p><code>disable_ddtrace</code> - DTrace 可以以影响运行中的内核的模式运行。除非显式启用，否则不得使用破坏性操作。在使用 DTrace 时，使用 <code>-w</code> 来启用此选项。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a> 。</p>
</li>
<li>
<p><code>enable_aslr</code> - 启用地址空间布局随机化。有关地址空间布局随机化的更多信息，请参考 <a href="https://en.wikipedia.org/wiki/Address_space_layout_randomization">维基百科文章</a> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-addusers">2.8.6. 添加用户<a class="anchor" href="#bsdinstall-addusers"></a></h4>
<div class="paragraph">
<p>下一个菜单提示您创建至少一个用户帐户。建议使用用户帐户登录系统，而不是使用“ root ”用户。以 <code>root</code> 用户身份登录时，基本上没有限制或保护，可以做任何事情。以普通用户身份登录更安全、更可靠。</p>
</div>
<div class="paragraph">
<p>选择 <b class="button">Yes</b> 来添加新用户。</p>
</div>
<div id="bsdinstall-add-user1" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-adduser1.png" alt="菜单询问用户是否要添加到系统中。"/>
</div>
<div class="title">图 55. 添加用户账户</div>
</div>
<div class="paragraph">
<p>按照提示输入用户账户所需的信息。在 <a href="#bsdinstall-add-user2">输入用户信息</a> 中的示例创建了 <code>asample</code> 用户账户。</p>
</div>
<div id="bsdinstall-add-user2" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-adduser2.png" alt="菜单请求新用户的不同信息。"/>
</div>
<div class="title">图 56. 输入用户信息</div>
</div>
<div class="paragraph">
<p>这是输入信息的摘要：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>用户名（Username）</code> - 用户登录时输入的名称。常见的约定是使用名字的首字母与姓氏结合，只要每个用户名在系统中是唯一的。用户名区分大小写，不应包含任何空格。</p>
</li>
<li>
<p><code>Full name</code> - 用户的全名。可以包含空格，并且用作用户账户的描述。</p>
</li>
<li>
<p><code>Uid</code> - 用户 ID 。通常留空，系统会自动分配一个值。</p>
</li>
<li>
<p><code>登录组（Login group）</code> - 用户所属的组。通常留空以接受默认值。</p>
</li>
<li>
<p>将 <code>用户</code> 邀请加入其他群组（Invite <em>user</em> into other groups）？ - 用户将作为成员添加到其他群组。如果用户需要管理员访问权限，请在此处输入 <code>wheel</code> 。</p>
</li>
<li>
<p><code>登录类（Login class）</code> - 通常留空以使用默认值。</p>
</li>
<li>
<p><code>Shell</code> - 输入列表中的一个值来设置用户的交互式 shell 。有关 shell 的更多信息，请参考 <a href="./#shells">Shells</a> 。</p>
</li>
<li>
<p><code>Home directory</code> - 用户的主目录。通常情况下，默认值是正确的。</p>
</li>
<li>
<p><code>主目录权限（Home directory permissions）</code> - 用户主目录的权限。通常情况下，默认设置是正确的。</p>
</li>
<li>
<p><code>使用基于密码的身份验证（se password-based authentication）？</code> - 通常选择 <code>yes</code>，这样用户在登录时会被提示输入密码。</p>
</li>
<li>
<p><code>使用空密码（Use an empty password）？</code> - 通常情况下，不建议使用空密码，因为空密码或空白密码是不安全的。</p>
</li>
<li>
<p><code>使用随机密码（Use a random password）？</code> - 通常是 <code>no</code>，这样用户可以在下一个提示中设置自己的密码。</p>
</li>
<li>
<p><code>输入密码（Enter password）</code> - 此用户的密码。输入的字符不会显示在屏幕上。</p>
</li>
<li>
<p><code>再次输入密码（Enter password again）</code> - 为了验证，必须再次输入密码。</p>
</li>
<li>
<p><code>创建后锁定账户（Lock out the account after creation）？</code> - 通常是 <code>no</code>，以便用户可以登录。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>输入完所有细节后，会显示一个摘要供审核。如果有错误，请输入 <code>no</code> 进行更正。一切都正确无误后，请输入 <code>yes</code> 创建新用户。</p>
</div>
<div id="bsdinstall-add-user3" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-adduser3.png" alt="菜单显示新用户的信息，并询问是否一切正确。"/>
</div>
<div class="title">图 57. 退出用户和组管理</div>
</div>
<div class="paragraph">
<p>如果还有更多用户需要添加，请用 <code>yes</code> 回答“是否添加另一个用户？”的问题。输入 <code>no</code> 以完成添加用户并继续安装。</p>
</div>
<div class="paragraph">
<p>有关添加用户和用户管理的更多信息，请参阅 <a href="./#users-synopsis">用户和基本帐户管理</a> 一节。</p>
</div>
</div>
<div class="sect3">
<h4 id="bsdinstall-final-conf">2.8.7. 最终配置<a class="anchor" href="#bsdinstall-final-conf"></a></h4>
<div class="paragraph">
<p>在安装和配置完成之后，提供了最后一次修改设置的机会。</p>
</div>
<div id="bsdinstall-final-config" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-finalconfiguration.png" alt="在完成安装之前显示不同选项的菜单。例如：添加用户" width="Time Zone" height="etc."/>
</div>
<div class="title">图 58. 最终配置</div>
</div>
<div class="paragraph">
<p>在完成安装之前，使用此菜单进行任何更改或进行任何额外的配置。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Add User</code> - 在 <a href="#bsdinstall-addusers">添加用户</a> 中描述。</p>
</li>
<li>
<p><code>Root Password</code> - 在 <a href="#bsdinstall-post-root">设置 <code>root</code> 密码</a> 中有详细描述。</p>
</li>
<li>
<p><code>Hostname</code> - 在 <a href="#bsdinstall-hostname">设置主机名</a> 中有详细描述。</p>
</li>
<li>
<p><code>Network</code> - 在 <a href="#bsdinstall-config-network-dev">配置网络接口</a> 中进行了描述。</p>
</li>
<li>
<p><code>Services</code> - 在 <a href="#bsdinstall-sysconf">启用服务</a> 中进行了描述。</p>
</li>
<li>
<p><code>System Hardening</code> - 在 <a href="#bsdinstall-hardening">启用强化安全选项</a> 中进行了描述。</p>
</li>
<li>
<p><code>Time Zone</code> - 在 <a href="#bsdinstall-timezone">设置时区</a> 中描述。</p>
</li>
<li>
<p><code>Handbook</code> - 下载并安装 FreeBSD 手册。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>配置完成后，选择 <b class="button">Exit</b>。</p>
</div>
<div id="bsdinstall-final-modification-shell" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-final-modification-shell.png" alt="菜单显示安装已完成，并询问是否要打开一个 shell 来进行手动更改。"/>
</div>
<div class="title">图 59. 手动配置</div>
</div>
<div class="paragraph">
<p>bsdinstall 将提示进行任何在重启进入新系统之前需要完成的额外配置。选择 <b class="button">Yes</b> 退出到新系统中的 shell ，或选择 <b class="button">No</b> 继续进行安装的最后一步。</p>
</div>
<div id="bsdinstall-final-main" class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/bsdinstall/bsdinstall-mainexit.png" alt="菜单显示安装已完成，并询问是否重新启动系统或访问 Live CD 。"/>
</div>
<div class="title">图 60. 完成安装</div>
</div>
<div class="paragraph">
<p>如果需要进一步配置或特殊设置，请选择 <b class="button">Live CD</b> 以将安装介质引导到 Live CD 模式。</p>
</div>
<div class="paragraph">
<p>如果安装完成，请选择 <b class="button">Reboot</b> 来重新启动计算机并启动新的 FreeBSD 系统。不要忘记移除 FreeBSD 安装介质，否则计算机可能会再次从它启动。</p>
</div>
<div class="paragraph">
<p>FreeBSD 启动时会显示信息性的消息。系统完成启动后，会显示一个登录提示符。在 <code>login:</code> 提示符下，输入在安装过程中添加的用户名。避免使用 <code>root</code> 登录。如需进行管理访问时，参考 <a href="./#users-superuser">超级用户账户</a> 中的说明，了解如何成为超级用户。</p>
</div>
<div class="paragraph">
<p>按下 <kbd>Scroll-Lock</kbd> 键可以查看启动过程中出现的消息，以打开滚动缓冲区。使用 <kbd>PgUp</kbd>、<kbd>PgDn</kbd> 和箭头键可以向后滚动查看消息。完成后，再次按下 <kbd>Scroll-Lock</kbd> 键以解锁显示并返回到控制台。要在系统运行一段时间后查看这些消息，请在命令提示符下输入 <code>less /var/run/dmesg.boot</code>。查看完毕后，按下 <kbd>q</kbd> 键返回到命令行。</p>
</div>
<div class="paragraph">
<p>如果在 <a href="#bsdinstall-config-serv">选择启用附加服务</a> 中启用了 sshd，系统在第一次启动时可能会慢一些，因为系统会生成 SSH 主机密钥。随后的启动将会更快。然后，密钥的指纹将会显示如下示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Generating public/private rsa1 key pair.
Your identification has been saved <span class="k">in</span> /etc/ssh/ssh_host_key.
Your public key has been saved <span class="k">in</span> /etc/ssh/ssh_host_key.pub.
The key fingerprint is:
10:a0:f5:af:93:ae:a3:1a:b2:bb:3c:35:d9:5a:b3:f3 root@machine3.example.com
The key<span class="s1">&#39;s randomart image is:
+--[RSA1 1024]----+
|    o..          |
|   o . .         |
|  .   o          |
|       o         |
|    o   S        |
|   + + o         |
|o . + *          |
|o+ ..+ .         |
|==o..o+E         |
+-----------------+
Generating public/private dsa key pair.
Your identification has been saved in /etc/ssh/ssh_host_dsa_key.
Your public key has been saved in /etc/ssh/ssh_host_dsa_key.pub.
The key fingerprint is:
7e:1c:ce:dc:8a:3a:18:13:5b:34:b5:cf:d9:d1:47:b2 root@machine3.example.com
The key&#39;</span>s randomart image is:
+--[ DSA 1024]----+
|       ..     . .|
|      o  .   . + |
|     . ..   . E .|
|    . .  o o . . |
|     +  S <span class="o">=</span> .    |
|    +  . <span class="o">=</span> o     |
|     +  . <span class="k">*</span> .    |
|    . .  o .     |
|      .o. .      |
+-----------------+
Starting sshd.</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关指纹和 SSH 的更多信息，请参考 <a href="./#openssh">OpenSSH</a> 。</p>
</div>
<div class="paragraph">
<p>默认情况下，FreeBSD 不安装图形化环境。有关安装和配置图形窗口管理器的更多信息，请参考 <a href="./#x11">X Window 系统</a> 。</p>
</div>
<div class="paragraph">
<p>正确关闭 FreeBSD 计算机有助于保护数据和硬件免受损坏。在系统正确关闭之前，请不要关闭电源！如果用户是 <code>wheel</code> 组的成员，请在命令行中输入 <code>su</code> 并输入 <code>root</code> 密码以成为超级用户。然后，输入 <code>shutdown -p now</code>，系统将会干净地关闭，并且如果硬件支持的话，会自动关闭电源。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="bsdinstall-install-trouble">2.9. 故障排除<a class="anchor" href="#bsdinstall-install-trouble"></a></h3>
<div class="paragraph">
<p>本节介绍基本的安装故障排除，例如人们常见的问题。</p>
</div>
<div class="paragraph">
<p>请查看 <a href="https://www.FreeBSD.org/releases/">FreeBSD Release Information</a> 页面上列出的硬件说明，以确保硬件得到支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通过更新各种硬件组件的固件，尤其是主板的固件，可以避免或减轻一些安装问题。主板固件通常被称为 BIOS。大多数主板和计算机制造商都有升级和升级信息的网站。</p>
</div>
<div class="paragraph">
<p>除非有充分的理由，如关键更新，否则制造商通常建议不要升级主板 BIOS。升级过程可能会出错，导致 BIOS 不完整，使计算机无法正常运行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果系统在启动过程中探测硬件时卡住或在安装过程中表现异常，ACPI 可能是罪魁祸首。FreeBSD 在 i386 和 amd64 平台上在启动过程中检测到 ACPI 后会广泛使用系统 ACPI 服务来帮助系统配置。不幸的是，ACPI 驱动程序和系统主板以及 BIOS 固件中仍然存在一些错误。可以通过在第三阶段引导加载程序中设置 <code>hint.acpi.0.disabled</code> 提示来禁用 ACPI。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="nb">set </span>hint.acpi.0.disabled<span class="o">=</span><span class="s2">&#34;1&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>每次系统启动时都会重置这个设置，因此需要将 <code>hint.acpi.0.disabled =&#34;1&#34;</code> 添加到文件 <code>/boot/loader.conf</code> 中。有关引导加载程序的更多信息可以在 <a href="./#boot-synopsis">“Synopsis”</a> 中找到。</p>
</div>
</div>
<div class="sect2">
<h3 id="using-live-cd">2.10. 使用 Live CD<a class="anchor" href="#using-live-cd"></a></h3>
<div class="paragraph">
<p>bsdinstall 的欢迎菜单在 <a href="#bsdinstall-choose-mode">欢迎菜单</a> 中显示，提供了 <b class="button">Live CD</b> 选项。对于那些仍然在犹豫是否选择 FreeBSD 作为他们的操作系统，并且想在安装之前测试一些功能的人来说，这是非常有用的。</p>
</div>
<div class="paragraph">
<p>在使用 <b class="button">Live CD</b> 之前，应注意以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>要访问系统，需要进行身份验证。用户名为 <code>root</code>，密码为空。</p>
</li>
<li>
<p>由于系统直接从安装介质运行，因此性能将明显低于安装在硬盘上的系统。</p>
</li>
<li>
<p>该选项只提供命令提示符，而不提供图形界面。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="basics">Chapter 3. FreeBSD 基础知识<a class="anchor" href="#basics"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="basics-synopsis">3.1. 简介<a class="anchor" href="#basics-synopsis"></a></h3>
<div class="paragraph">
<p>本章介绍了 FreeBSD 操作系统的基本命令和功能。其中很多内容对于任何类 UNIX 操作系统都是相关的。鼓励新的 FreeBSD 用户仔细阅读本章。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何使用和配置虚拟控制台。</p>
</li>
<li>
<p>如何在 FreeBSD 上创建和管理用户和组。</p>
</li>
<li>
<p>UNIX® 文件权限和 FreeBSD 文件标志的工作原理。</p>
</li>
<li>
<p>默认的 FreeBSD 文件系统布局。</p>
</li>
<li>
<p>FreeBSD 磁盘组织。</p>
</li>
<li>
<p>如何挂载和卸载文件系统。</p>
</li>
<li>
<p>进程、守护进程和信号是什么。</p>
</li>
<li>
<p>什么是 shell ，以及如何更改默认的登录环境。</p>
</li>
<li>
<p>如何使用基本文本编辑器。</p>
</li>
<li>
<p>设备和设备节点是什么。</p>
</li>
<li>
<p>如何阅读手册页以获取更多信息。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="consoles">3.2. 虚拟控制台和终端<a class="anchor" href="#consoles"></a></h3>
<div class="paragraph">
<p>除非 FreeBSD 已经配置为在启动时自动启动图形环境，否则系统将启动到一个命令行登录提示符，如下面的示例所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>FreeBSD/amd64 (pc3.example.org) (ttyv0)

login:</pre>
</div>
</div>
<div class="paragraph">
<p>第一行包含了关于系统的一些信息。 <code>amd64</code> 表示 FreeBSD 运行在一个 64 位的 x86 系统上。主机名是 <code>pc3.example.org</code> ，而 <code>ttyv0</code> 表示这是“系统控制台”。第二行是登录提示符。</p>
</div>
<div class="paragraph">
<p>由于 FreeBSD 是一个多用户系统，它需要一种区分不同用户的方式。这通过要求每个用户在访问系统上的程序之前先登录系统来实现。每个用户都有一个唯一的“用户名”和个人的“密码”。</p>
</div>
<div class="paragraph">
<p>要登录系统控制台，请输入在系统安装过程中配置的用户名，如 <a href="./#bsdinstall-addusers">Add Users</a> 中所述，并按下 <kbd>Enter</kbd> 键。然后输入与用户名关联的密码并按下 <kbd>Enter</kbd> 键。出于安全原因，密码不会显示出来。</p>
</div>
<div class="paragraph">
<p>一旦输入正确的密码，将显示当天的消息（ MOTD ），然后显示命令提示符。根据创建用户时选择的 shell 不同，该提示符可能是 <code>#</code> 、 <code>$</code> 或 <code>%</code> 字符。提示符表示用户已成功登录到 FreeBSD 系统控制台，并准备尝试可用的命令。</p>
</div>
<div class="sect3">
<h4 id="consoles-virtual">3.2.1. 虚拟控制台<a class="anchor" href="#consoles-virtual"></a></h4>
<div class="paragraph">
<p>虽然系统控制台可以用于与系统进行交互，但在 FreeBSD 系统的键盘命令行上工作的用户通常会登录到虚拟控制台。这是因为系统消息默认配置为显示在系统控制台上。这些消息会出现在用户正在操作的命令或文件上，使得集中注意力于手头的工作变得困难。</p>
</div>
<div class="paragraph">
<p>默认情况下，FreeBSD 配置了多个虚拟控制台用于输入命令。每个虚拟控制台都有自己的登录提示符和 Shell ，并且可以轻松地在虚拟控制台之间切换。这基本上提供了在图形环境中同时打开多个窗口的命令行等效功能。</p>
</div>
<div class="paragraph">
<p>组合键 <span class="keyseq"><kbd>Alt</kbd>+<kbd>F1</kbd></span> 到 <span class="keyseq"><kbd>Alt</kbd>+<kbd>F8</kbd></span> 已被 FreeBSD 保留用于在虚拟控制台之间切换。使用 <span class="keyseq"><kbd>Alt</kbd>+<kbd>F1</kbd></span> 切换到系统控制台（ <code>ttyv0</code> ），使用 <span class="keyseq"><kbd>Alt</kbd>+<kbd>F2</kbd></span> 访问第一个虚拟控制台（ <code>ttyv1</code> ），使用 <span class="keyseq"><kbd>Alt</kbd>+<kbd>F3</kbd></span> 访问第二个虚拟控制台（ <code>ttyv2</code> ），依此类推。当使用 Xorg 作为图形控制台时，组合键变为 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>F1</kbd></span> 以返回到基于文本的虚拟控制台。</p>
</div>
<div class="paragraph">
<p>当从一个控制台切换到下一个控制台时，FreeBSD 会管理屏幕输出。结果是有多个虚拟屏幕和键盘可以用来键入命令以供 FreeBSD 运行。当用户切换到不同的虚拟控制台时，在一个虚拟控制台中启动的程序不会停止运行</p>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdcontrol&amp;sektion=1&amp;format=html">kbdcontrol(1)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=atkbd&amp;sektion=4&amp;format=html">atkbd(4)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=vt&amp;sektion=4&amp;format=html">vt(4)</a> ，以获取更详细的 FreeBSD 控制台及其键盘驱动程序的技术描述。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，可用的虚拟控制台数量是在 <code>/etc/ttys</code> 文件的这个部分进行配置的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># name    getty                         type  status comments
#
ttyv0   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
# Virtual terminals
ttyv1   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv2   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv3   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv4   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv5   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv6   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv7   &#34;/usr/libexec/getty Pc&#34;         xterm   on  secure
ttyv8   &#34;/usr/X11R6/bin/xdm -nodaemon&#34;  xterm   off secure</pre>
</div>
</div>
<div class="paragraph">
<p>要禁用虚拟控制台，请在表示该虚拟控制台的行的开头放置一个注释符号（ <code>#</code> ）。例如，要将可用虚拟控制台的数量从八个减少到四个，请在表示虚拟控制台 <code>ttyv5</code> 到 <code>ttyv8</code> 的最后四行前面放置一个 <code>#</code> 。 <strong>不要</strong> 注释掉系统控制台 <code>ttyv0</code> 的行。请注意，如果已经安装并配置了 Xorg （如 <a href="./#x11">X Window 系统</a> 中所述），则最后一个虚拟控制台（ <code>ttyv8</code> ）用于访问图形环境。</p>
</div>
<div class="paragraph">
<p>有关此文件中每个列的详细描述以及虚拟控制台的可用选项，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ttys&amp;sektion=5&amp;format=html">ttys(5)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="consoles-singleuser">3.2.2. 单用户模式<a class="anchor" href="#consoles-singleuser"></a></h4>
<div class="paragraph">
<p>FreeBSD 引导菜单提供了一个标有“单用户启动”的选项。如果选择了这个选项，系统将启动到一个称为“单用户模式”的特殊模式。通常情况下，这个模式用于修复无法启动的系统或者在不知道 <code>root</code> 密码时重置密码。在单用户模式下，网络和其他虚拟控制台是不可用的。然而，系统完全支持 <code>root</code> 访问，并且默认情况下不需要 <code>root</code> 密码。因此，需要有对键盘的物理访问权限才能进入该模式，确定谁对键盘有物理访问权是保护 FreeBSD 系统安全时需要考虑的问题</p>
</div>
<div class="paragraph">
<p>控制单用户模式的设置位于 <code>/etc/ttys</code> 文件的这个部分。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># name  getty                           type  status  comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown  off  secure</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，状态被设置为 <code>secure</code>。这意味着对键盘具有物理访问权限的人要么不重要，要么受到物理安全策略的控制。如果将此设置更改为 <code>insecure</code>，则假设环境本身是不安全的，因为任何人都可以访问键盘。当将此行更改为 <code>insecure</code> 时， FreeBSD 将在用户选择进入单用户模式时提示输入 <code>root</code> 密码。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在更改此设置为 <code>insecure</code> 时要小心！如果忘记了 <code>root</code> 密码，仍然可以启动到单用户模式，但对于不熟悉 FreeBSD 启动过程的人来说可能会有困难。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="consoles-vidcontrol">3.2.3. 更改控制台视频模式<a class="anchor" href="#consoles-vidcontrol"></a></h4>
<div class="paragraph">
<p>FreeBSD 控制台的默认视频模式可以调整为 1024x768 、 1280x1024 或其他由图形芯片和显示器支持的尺寸。要使用不同的视频模式，请加载 <code>VESA</code> 模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload vesa</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要确定硬件支持哪些视频模式，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> 。要获取支持的视频模式列表，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># vidcontrol -i mode</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令的输出列出了硬件支持的视频模式。要选择一个新的视频模式，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=vidcontrol&amp;sektion=1&amp;format=html">vidcontrol(1)</a> 作为 <code>root</code> 用户指定该模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># vidcontrol MODE_279</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果新的视频模式可接受，可以通过将其添加到 <code>/etc/rc.conf</code> 来在启动时永久设置。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>allscreens_flags=&#34;MODE_279&#34;</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="users-synopsis">3.3. 用户和基本账户管理<a class="anchor" href="#users-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 允许多个用户同时使用计算机。虽然一次只能有一个用户坐在屏幕前使用键盘，但任意数量的用户可以通过网络登录系统。为了使用系统，每个用户都应该有自己的用户账户。</p>
</div>
<div class="paragraph">
<p>本章描述了：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FreeBSD 系统上的不同类型的用户账户。</p>
</li>
<li>
<p>如何添加、删除和修改用户账户。</p>
</li>
<li>
<p>如何设置限制以控制用户和组可以访问的资源。</p>
</li>
<li>
<p>如何创建组并将用户添加为组的成员。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="users-introduction">3.3.1. 账户类型<a class="anchor" href="#users-introduction"></a></h4>
<div class="paragraph">
<p>由于所有对 FreeBSD 系统的访问都是通过账户实现的，并且所有进程都是由用户运行的，因此用户和账户管理非常重要。</p>
</div>
<div class="paragraph">
<p>有三种主要类型的账户：系统账户、用户账户和超级用户账户。</p>
</div>
<div class="sect4">
<h5 id="users-system">3.3.1.1. 系统账户<a class="anchor" href="#users-system"></a></h5>
<div class="paragraph">
<p>系统账户用于运行诸如 DNS、邮件和 Web 服务器等服务。这样做的原因是出于安全考虑；如果所有服务都以超级用户身份运行，它们就可以无限制地执行操作。</p>
</div>
<div class="paragraph">
<p>系统账户的例子包括 <code>daemon</code>、<code>operator</code>、<code>bind</code>、<code>news</code> 和 <code>www</code>。</p>
</div>
<div class="paragraph">
<p><code>nobody</code> 是一个通用的非特权系统账户。然而，使用 <code>nobody</code> 的服务越多，与该用户相关联的文件和进程也就越多，因此该用户的特权也就越高。</p>
</div>
</div>
<div class="sect4">
<h5 id="users-user">3.3.1.2. 用户账户<a class="anchor" href="#users-user"></a></h5>
<div class="paragraph">
<p>用户账户分配给真实的人，并用于登录和使用系统。每个访问系统的人都应该拥有一个唯一的用户账户。这使管理员能够查明谁在做什么，并防止用户破坏其他用户的设置。</p>
</div>
<div class="paragraph">
<p>每个用户都可以设置自己的环境以适应他们对系统的使用，通过配置他们的默认 shell 、编辑器、键绑定和语言设置。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 系统上，每个用户账户都有与之关联的特定信息：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">User name</dt>
<dd>
<p>用户名称是在 <code>login:</code> 提示处输入的。每个用户必须有一个唯一的用户名。有一些创建有效用户名的规则，这些规则在 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a> 中有详细说明。建议使用由八个或更少个小写字符组成的用户名，以保持与应用程序的向后兼容性。</p>
</dd>
<dt class="hdlist1">Password</dt>
<dd>
<p>每个账户都有一个关联的密码。</p>
</dd>
<dt class="hdlist1">User ID (UID)</dt>
<dd>
<p>用户 ID (UID) 是一个用于在 FreeBSD 系统中唯一标识用户的数字。允许指定用户名的命令将首先将其转换为 UID 。建议使用小于 65535 的 UID ，因为较高的值可能会导致某些软件的兼容性问题。</p>
</dd>
<dt class="hdlist1">Group ID (GID)</dt>
<dd>
<p>组 ID (GID) 是一个用于唯一标识用户所属的主要组的数字。组是一种基于用户的 GID 而不是 UID 来控制对资源访问的机制。这可以显著减小某些配置文件的大小，并允许用户成为多个组的成员。建议使用 65535 或更低的 GID ，因为较高的 GID 可能会破坏某些软件。</p>
</dd>
<dt class="hdlist1">Login class</dt>
<dd>
<p>登录分级是组机制的扩展，为定制系统以适应不同用户提供了额外的灵活性。有关登录类的详细讨论，请参阅 <a href="./#users-limiting">配置登录分级</a> 。</p>
</dd>
<dt class="hdlist1">Password change time</dt>
<dd>
<p>默认情况下，密码不会过期。然而，可以根据每个用户的情况启用密码过期功能，强制一些或所有用户在一定时间后更改他们的密码。</p>
</dd>
<dt class="hdlist1">Account expiration time</dt>
<dd>
<p>默认情况下， FreeBSD 不会使账户过期。当创建需要有限生命周期的账户时，比如学校的学生账户，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 命令指定账户的过期日期。在过期时间到达后，该账户将无法用于登录系统，但账户的目录和文件将保留。</p>
</dd>
<dt class="hdlist1">User’s full name</dt>
<dd>
<p>用户名在 FreeBSD 中唯一标识账户，但不一定反映用户的真实姓名。与注释类似，此信息可以包含空格、大写字符，并且可以超过 8 个字符的长度。</p>
</dd>
<dt class="hdlist1">Home directory</dt>
<dd>
<p>主目录是系统上一个目录的完整路径。这是用户登录时的起始目录。一个常见的约定是将所有用户的主目录放在 <code>/home/username</code> 或 <code>/usr/home/username</code> 下。每个用户在自己的主目录中存储个人文件和子目录。</p>
</dd>
<dt class="hdlist1">User shell</dt>
<dd>
<p>Shell 提供了用户与系统进行交互的默认环境。有许多不同类型的 shell ，有经验的用户会根据自己的偏好进行设置，这些设置可以反映在他们的账户设置中。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="users-superuser">3.3.1.3. 超级用户账户<a class="anchor" href="#users-superuser"></a></h5>
<div class="paragraph">
<p>超级用户账户通常被称为 <code>root</code> ，用于无限制地管理系统。因此，不应将其用于日常任务，如发送和接收邮件、系统的一般探索或编程。</p>
</div>
<div class="paragraph">
<p>与其他用户账户不同，超级用户可以无限制地操作，滥用超级用户账户可能导致灾难性后果。用户账户无法通过错误操作销毁操作系统，因此建议以用户账户登录，并且只在需要额外权限的命令时切换为超级用户。</p>
</div>
<div class="paragraph">
<p>作为超级用户，始终要仔细检查任何发出的命令，因为额外的空格或缺失的字符可能导致无法修复的数据丢失。</p>
</div>
<div class="paragraph">
<p>有几种方法可以获得超级用户权限。虽然可以使用 <code>root</code> 账户登录，但这是极不推荐的。</p>
</div>
<div class="paragraph">
<p>相反，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 命令成为超级用户。如果在运行此命令时指定了 <code>-</code> ，用户还将继承 root 用户的环境。运行此命令的用户必须属于 <code>wheel</code> 组，否则命令将失败。用户还必须知道 <code>root</code> 用户账户的密码。</p>
</div>
<div class="paragraph">
<p>在这个例子中，用户只是为了运行 <code>make install</code> 这个步骤需要超级用户权限，才成为超级用户。一旦命令完成，用户输入 <code>exit</code> 来退出超级用户账户，返回到他们的用户账户的权限。</p>
</div>
<div class="exampleblock">
<div class="title">例 2. 以超级用户身份安装程序</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>configure
<span class="gp">% </span>make
<span class="gp">% </span>su -
Password:
<span class="c"># make install</span>
<span class="c"># exit</span>
%</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>内置的 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 框架适用于单个系统或只有一个系统管理员的小型网络。另一种选择是安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/sudo/">security/sudo</a> 软件包或 port。该软件提供活动日志记录，并允许管理员配置哪些用户可以以超级用户身份运行哪些命令。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="users-modifying">3.3.2. 管理账户<a class="anchor" href="#users-modifying"></a></h4>
<div class="paragraph">
<p>FreeBSD 提供了多种不同的命令来管理用户账户。最常见的命令在 <a href="#users-modifying-utilities">管理用户账户的实用工具</a> 中进行了总结，并附有一些使用示例。有关每个实用程序的更多详细信息和使用示例，请参阅其手册页面。</p>
</div>
<table id="users-modifying-utilities" class="tableblock frame-all grid-all stretch">
<caption class="title">表 2. 管理用户账户的实用工具</caption>
<colgroup>
<col style="width: 25%;"/>
<col/>
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">命令</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">摘要</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于添加新用户的推荐命令行应用程序。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于删除用户的推荐命令行应用程序。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于更改用户数据库信息的灵活工具。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于更改用户密码的命令行工具。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">功能强大而灵活的工具，可对用户账户进行全方位修改。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=bsdconfig&amp;sektion=8&amp;format=html">bsdconfig(8)</a></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">具有账户管理支持的系统配置工具。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="users-adduser">3.3.2.1. 添加用户<a class="anchor" href="#users-adduser"></a></h5>
<div class="paragraph">
<p>添加新用户的推荐程序是 <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> 。当添加新用户时，该程序会自动更新 <code>/etc/passwd</code> 和 <code>/etc/group</code> 文件。它还会为新用户创建一个家目录，并从 <code>/usr/share/skel</code> 目录中复制默认配置文件，并可选择向新用户发送欢迎消息。此实用程序必须以超级用户身份运行。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> 实用程序是交互式的，并且会引导用户完成创建新用户账户的步骤。如在 <a href="#users-modifying-adduser">在 FreeBSD 上添加用户</a> 中所示，可以输入所需信息，或按 <kbd>Return</kbd> 键接受方括号中显示的默认值。在本示例中，用户已被邀请加入 <code>wheel</code> 组，允许他们通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 成为超级用户。完成后，实用程序将提示是否创建另一个用户或退出。</p>
</div>
<div id="users-modifying-adduser" class="exampleblock">
<div class="title">例 3. 在 FreeBSD 上添加用户</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># adduser</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Username: jru
Full name: J. Random User
Uid (Leave empty for default):
Login group [jru]:
Login group is jru. Invite jru into other groups? []: wheel
Login class [default]:
Shell (sh csh tcsh zsh nologin) [sh]: zsh
Home directory [/home/jru]:
Home directory permissions (Leave empty for default):
Use password-based authentication? [yes]:
Use an empty password? (yes/no) [no]:
Use a random password? (yes/no) [no]:
Enter password:
Enter password again:
Lock out the account after creation? [no]:
Username   : jru
Password   : ****
Full Name  : J. Random User
Uid        : 1001
Class      :
Groups     : jru wheel
Home       : /home/jru
Shell      : /usr/local/bin/zsh
Locked     : no
OK? (yes/no): yes
adduser: INFO: Successfully added (jru) to the user database.
Add another user? (yes/no): no
Goodbye!</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于密码在输入时不会显示出来，请在创建用户账户时小心不要输入错误的密码。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="users-rmuser">3.3.2.2. 删除用户<a class="anchor" href="#users-rmuser"></a></h5>
<div class="paragraph">
<p>要完全从系统中删除用户，请以超级用户身份运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> 。该命令执行以下步骤：</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>如果存在用户的 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=1&amp;format=html">crontab(1)</a> 条目，则删除它。</p>
</li>
<li>
<p>删除用户拥有的所有 <a href="https://man.freebsd.org/cgi/man.cgi?query=at&amp;sektion=1&amp;format=html">at(1)</a> 作业。</p>
</li>
<li>
<p>向用户拥有的所有进程发送 SIGKILL 信号。</p>
</li>
<li>
<p>从系统的本地密码文件中删除用户。</p>
</li>
<li>
<p>删除用户的主目录（如果该目录属于该用户），包括处理路径中符号链接指向实际主目录的情况。</p>
</li>
<li>
<p>从 <code>/var/mail</code> 目录中删除属于用户的传入邮件文件。</p>
</li>
<li>
<p>从 <code>/tmp</code>、<code>/var/tmp</code> 和 <code>/var/tmp/vi.recover</code> 中删除用户所有拥有的文件。</p>
</li>
<li>
<p>将用户名从 <code>/etc/group</code> 中所属的所有组中删除。（如果一个组变为空，并且组名与用户名相同，则删除该组；这与 <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> 的每个用户唯一组相对应。）</p>
</li>
<li>
<p>删除用户拥有的所有消息队列、共享内存段和信号量。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=rmuser&amp;sektion=8&amp;format=html">rmuser(8)</a> 不能用于删除超级用户账户，因为这几乎总是意味着大规模破坏的迹象。</p>
</div>
<div class="paragraph">
<p>默认情况下，使用交互模式，如下例所示。</p>
</div>
<div class="exampleblock">
<div class="title">例 4. <code>rmuser</code> 交互式账户删除</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rmuser jru</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Matching password entry:
jru:*:1001:1001::0:0:J. Random User:/home/jru:/usr/local/bin/zsh
Is this the entry you wish to remove? y
Remove user&#39;s home directory (/home/jru)? y
Removing user (jru): mailspool home passwd.</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="users-chpass">3.3.2.3. 更改用户信息<a class="anchor" href="#users-chpass"></a></h5>
<div class="paragraph">
<p>任何用户都可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 命令来更改其默认 shell 和与其用户账户关联的个人信息。超级用户可以使用此实用程序来更改任何用户的其他账户信息。</p>
</div>
<div class="paragraph">
<p>当没有传递任何选项时，除了可选的用户名外， <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 会显示一个包含用户信息的编辑器。当用户从编辑器退出时，用户数据库将会更新为新的信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>该实用程序在退出编辑器时会提示用户输入密码，除非以超级用户身份运行该实用程序。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在 <a href="#users-modifying-chpass-su">以超级用户身份使用 <code>chpass</code> 命令</a> 中，超级用户输入了 <code>chpass jru</code> ，现在正在查看可以更改该用户的字段。如果 <code>jru</code> 运行此命令，只有最后六个字段将被显示并可供编辑。这在 <a href="#users-modifying-chpass-ru">以普通用户身份使用 <code>chpass</code> 命令</a> 中显示。</p>
</div>
<div id="users-modifying-chpass-su" class="exampleblock">
<div class="title">例 5. 以超级用户身份使用 <code>chpass</code> 命令</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chpass</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Changing user database information for jru.
Login: jru
Password: *
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class:
Home directory: /home/jru
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</pre>
</div>
</div>
</div>
</div>
<div id="users-modifying-chpass-ru" class="exampleblock">
<div class="title">例 6. 以普通用户身份使用 <code>chpass</code> 命令</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c">#Changing user database information for jru.</span>
Shell: /usr/local/bin/zsh
Full Name: J. Random User
Office Location:
Office Phone:
Home Phone:
Other information:</code></pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>命令 <a href="https://man.freebsd.org/cgi/man.cgi?query=chfn&amp;sektion=1&amp;format=html">chfn(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a> 是指向 <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 的链接，同样 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchpass&amp;sektion=1&amp;format=html">ypchpass(1)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchfn&amp;sektion=1&amp;format=html">ypchfn(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypchsh&amp;sektion=1&amp;format=html">ypchsh(1)</a> 也是。由于 NIS 支持是自动的，所以在命令之前指定 <code>yp</code> 是不必要的。如何配置 NIS 在 <a href="./#network-servers">网络服务器</a> 中有介绍。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="users-passwd">3.3.2.4. 更改用户密码<a class="anchor" href="#users-passwd"></a></h5>
<div class="paragraph">
<p>任何用户都可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 轻松更改他们的密码。为了防止意外或未经授权的更改，在设置新密码之前，该命令会提示用户输入原始密码：</p>
</div>
<div class="exampleblock">
<div class="title">例 7. 更改密码</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>passwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Changing local password for jru.
Old password:
New password:
Retype new password:
passwd: updating the database...
passwd: done</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>超级用户可以通过在运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 时指定用户名来更改任何用户的密码。当以超级用户身份运行此实用程序时，它不会提示用户输入当前密码。这允许在用户无法记住原始密码时更改密码。</p>
</div>
<div class="exampleblock">
<div class="title">例 8. 以超级用户身份更改另一个用户的密码</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># passwd jru</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Changing local password for jru.
New password:
Retype new password:
passwd: updating the database...
passwd: done</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与 <a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 一样， <a href="https://man.freebsd.org/cgi/man.cgi?query=yppasswd&amp;sektion=1&amp;format=html">yppasswd(1)</a> 是指向 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 的链接，因此 NIS 可以与任一命令一起使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="users-pw">3.3.2.5. 创建、删除、修改和显示系统用户和组<a class="anchor" href="#users-pw"></a></h5>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 实用程序可以创建、删除、修改和显示用户和组。它作为系统用户和组文件的前端工具。 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 具有一套非常强大的命令行选项，使其适用于在 shell 脚本中使用，但新用户可能会发现它比本节中介绍的其他命令更复杂。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="users-groups">3.3.3. 管理群组<a class="anchor" href="#users-groups"></a></h4>
<div class="paragraph">
<p>组是一个用户列表。组由组名称和 GID 标识。在 FreeBSD 中，内核使用进程的 UID 和其所属的组列表来确定该进程被允许做什么。大多数情况下，用户或进程的 GID 通常表示列表中的第一个组。</p>
</div>
<div class="paragraph">
<p>组名到 GID 的映射在 <code>/etc/group</code> 中列出。这是一个纯文本文件，包含四个由冒号分隔的字段。第一个字段是组名，第二个字段是加密密码，第三个字段是 GID ，第四个字段是逗号分隔的成员列表。有关语法的更完整描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a> 。</p>
</div>
<div class="paragraph">
<p>超级用户可以使用文本编辑器修改 <code>/etc/group</code> 文件，尽管使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=vigr&amp;sektion=8&amp;format=html">vigr(8)</a> 编辑组文件更为推荐，因为它可以捕捉一些常见的错误。另外，也可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 来添加和编辑组。例如，要添加一个名为 <code>teamtwo</code> 的组，并确认它是否存在：</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在使用操作员组时必须小心，因为可能会授予意外的类似超级用户的访问权限，包括但不限于关闭、重启以及访问组中 <code>/dev</code> 中的所有项目。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock">
<div class="title">例 9. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 添加一个组</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupadd teamtwo</span>
<span class="c"># pw groupshow teamtwo</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>teamtwo:*:1100:</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，<code>1100</code> 是 <code>teamtwo</code> 的 GID 。目前，<code>teamtwo</code> 没有成员。这个命令将会把 <code>jru</code> 添加为 <code>teamtwo</code> 的成员。</p>
</div>
<div class="exampleblock">
<div class="title">例 10. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 将用户账户添加到新组中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupmod teamtwo -M jru</span>
<span class="c"># pw groupshow teamtwo</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>teamtwo:*:1100:jru</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>-M</code> 参数后面是一个逗号分隔的用户列表，用于将这些用户添加到一个新的（空的）组中，或者替换现有组的成员。对于用户来说，这个组成员身份与密码文件中列出的用户的主组不同，而且是额外的。这意味着当使用 <code>groupshow</code> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 一起查看用户时，用户不会显示为组成员，但是当使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> 或类似的工具查询信息时，用户会显示为组成员。当使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 将用户添加到组时，它只操作 <code>/etc/group</code> 文件，并不尝试从 <code>/etc/passwd</code> 中读取额外的数据。</p>
</div>
<div class="exampleblock">
<div class="title">例 11. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 添加新成员到一个组中</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupmod teamtwo -m db</span>
<span class="c"># pw groupshow teamtwo</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>teamtwo:*:1100:jru,db</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中， <code>-m</code> 参数后面是一个逗号分隔的用户列表，这些用户将被添加到该组中。与前一个例子不同的是，这些用户会被追加到该组中，而不会替换掉组中已有的用户。</p>
</div>
<div class="exampleblock">
<div class="title">例 12. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=id&amp;sektion=1&amp;format=html">id(1)</a> 来确定组成员身份</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>id jru</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>uid=1001(jru) gid=1001(jru) groups=1001(jru), 1100(teamtwo)</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，<code>jru</code> 是 <code>jru</code> 和 <code>teamtwo</code> 组的成员。</p>
</div>
<div class="paragraph">
<p>有关此命令和 <code>/etc/group</code> 文件的格式的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=group&amp;sektion=5&amp;format=html">group(5)</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="permissions">3.4. 权限<a class="anchor" href="#permissions"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 中，每个文件和目录都有一组关联的权限，并且有几个实用程序可用于查看和修改这些权限。要确保用户能够访问所需的文件，并且不能不正当地访问操作系统使用的文件或其他用户拥有的文件，就必须了解权限的工作原理。</p>
</div>
<div class="paragraph">
<p>本节讨论了在 FreeBSD 中使用的传统 UNIX® 权限。要进行更精细的文件系统访问控制，请参考 <a href="./#fs-acl">访问控制列表</a> 。</p>
</div>
<div class="paragraph">
<p>在 UNIX® 中，基本权限使用三种类型的访问进行分配：读取、写入和执行。这些访问类型用于确定文件的所有者、组和其他人（其他所有人）对文件的访问。读取、写入和执行权限可以用字母 <code>r</code>、<code>w</code> 和 <code>x</code> 表示。它们也可以表示为二进制数字，因为每个权限都是打开或关闭的（<code>0</code>）。当表示为数字时，顺序总是按照 <code>rwx</code> 读取，其中 <code>r</code> 的打开值为 <code>4</code> ， <code>w</code> 的打开值为 <code>2</code> ， <code>x</code> 的打开值为 <code>1</code> 。</p>
</div>
<div class="paragraph">
<p>表 4.1 总结了可能的数字和字母组合。在阅读“目录列表”列时，使用 <code>-</code> 表示权限关闭。</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 3. UNIX® 权限</caption>
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">值</th>
<th class="tableblock halign-left valign-top">权限</th>
<th class="tableblock halign-left valign-top">目录列表</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁止读取，禁止写入，禁止执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>---</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁止读取，禁止写入，可执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>--x</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁止读取，可写入，禁止执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-w-</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁止读取，可写入，可执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-wx</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可读取，禁止写入，禁止执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>r--</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可读取，禁止写入，可执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>r-x</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可读取、可写入，禁止执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rw-</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">可读取，可写入，可执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>rwx</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用 <code>-l</code> 参数与 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a></code> 一起，可以查看一个包含有关文件所有者、组和其他人权限的列的长目录列表。例如，在任意目录中使用 <code>ls -l</code> 可能会显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ls -l</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>total 530
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 myfile
-rw-r--r--  1 root  wheel     512 Sep  5 12:31 otherfile
-rw-r--r--  1 root  wheel    7680 Sep  5 12:31 email.txt</pre>
</div>
</div>
<div class="paragraph">
<p>关注 <code>myfile</code> 这一行，第一个（最左边的）字符表示该文件是普通文件、目录、特殊字符设备、套接字还是其他特殊伪文件设备。在这个例子中， <code>-</code> 表示普通文件。接下来的三个字符 <code>rw-</code> 表示文件所有者的权限。再接下来的三个字符 <code>r--</code> 表示文件所属组的权限。最后三个字符 <code>r--</code> 表示其他用户的权限。破折号表示权限被关闭。在这个例子中，权限被设置为文件所有者可以读写文件，文件所属组可以读取文件，其他用户只能读取文件。根据上面的表格，该文件的权限将是 <code>644</code> ，其中每个数字代表文件权限的三个部分。</p>
</div>
<div class="paragraph">
<p>系统如何控制设备的权限？ FreeBSD 将大多数硬件设备视为程序可以打开、读取和写入数据的文件。这些特殊设备文件存储在 <code>/dev/</code> 目录中。</p>
</div>
<div class="paragraph">
<p>目录也被视为文件。它们具有读取、写入和执行权限。目录的可执行位与文件的可执行位略有不同。当一个目录被标记为可执行时，意味着可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cd&amp;sektion=1&amp;format=html">cd(1)</a> 命令进入该目录。这也意味着可以访问该目录中的文件，但受文件本身权限的限制。</p>
</div>
<div class="paragraph">
<p>为了执行目录列表，必须在目录上设置读取权限。为了删除一个已知文件名的文件，必须对包含该文件的目录具有写入和执行权限。</p>
</div>
<div class="paragraph">
<p>还有更多的权限位，但它们主要用于特殊情况，比如 setuid 二进制文件和粘滞目录。有关文件权限及如何设置它们的更多信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 。</p>
</div>
<div class="sect3">
<h4 id="_符号权限">3.4.1. 符号权限<a class="anchor" href="#_符号权限"></a></h4>
<div class="paragraph">
<p>符号权限使用字符而不是八进制值来为文件或目录分配权限。符号权限使用以下语法： (用户) (动作) (权限) ，可用的值如下：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">参数</th>
<th class="tableblock halign-left valign-top">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（用户）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">u</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（用户）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">g</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">组所有者</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（用户）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">o</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其他</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（用户）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">a</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有（&#34;全部&#34;）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（动作）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加权限</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（动作）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除权限</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（动作）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">=</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指定权限</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（权限）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">r</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（权限）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">w</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">写</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（权限）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（权限）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">t</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">粘性位</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">（权限）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">s</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置用户 ID 或组 ID</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这些值与 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 一起使用，但使用字母而不是数字。例如，以下命令将阻止与 <em>FILE</em> 关联的组的所有成员以及所有其他用户访问 <em>FILE</em>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>chmod <span class="nv">go</span><span class="o">=</span> FILE</code></pre>
</div>
</div>
<div class="paragraph">
<p>当需要对文件进行多组更改时，可以提供逗号分隔的列表。例如，以下命令会移除文件 <em>FILE</em> 的组和 &#34;world&#34; 的写权限，并为所有人添加执行权限：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>chmod go-w,a+x FILE</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_freebsd_文件标志">3.4.2. FreeBSD 文件标志<a class="anchor" href="#_freebsd_文件标志"></a></h4>
<div class="paragraph">
<p>除了文件权限之外，FreeBSD 还支持使用“文件标志”。这些标志为文件提供了额外的安全性和控制，但不适用于目录。通过文件标志，即使是 <code>root</code> 也可以被阻止删除或更改文件。</p>
</div>
<div class="paragraph">
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 命令可以修改文件标志。例如，要在文件 <code>file1</code> 上启用系统不可删除标志，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chflags sunlink file1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要禁用系统不可删除标志，请在 <code>sunlink</code> 前面加上 &#34;no&#34; ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chflags nosunlink file1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要查看文件的标志，可以使用 <code>-lo</code> 与 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 一起使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls -lo file1</span></code></pre>
</div>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>-rw-r--r--  1 trhodes  trhodes  sunlnk 0 Mar  1 05:54 file1</pre>
</div>
</div>
<div class="paragraph">
<p>只有 <code>root</code> 用户才能添加或删除一些文件标志。在其他情况下，文件所有者可以设置其文件标志。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=2&amp;format=html">chflags(2)</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_setuid_setgid_和_sticky_权限">3.4.3. setuid 、setgid 和 sticky 权限<a class="anchor" href="#_setuid_setgid_和_sticky_权限"></a></h4>
<div class="paragraph">
<p>除了已经讨论过的权限之外，还有三个其他特定的设置，所有管理员都应该了解。它们是 <code>setuid</code>、<code>setgid</code> 和 <code>sticky</code> 权限。</p>
</div>
<div class="paragraph">
<p>这些设置对于某些 UNIX® 操作非常重要，因为它们提供了通常不授予普通用户的功能。要理解它们，必须注意实际用户 ID 和有效用户 ID 之间的区别。</p>
</div>
<div class="paragraph">
<p>真实用户 ID 是拥有或启动进程的 UID 。有效 UID 是进程运行的用户 ID 。例如，当用户更改密码时， <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 以真实用户 ID 运行。然而，为了更新密码数据库，该命令以 <code>root</code> 用户的有效 ID 运行。这使得用户可以在不看到 <code>权限被拒绝</code> 错误的情况下更改密码。</p>
</div>
<div class="paragraph">
<p>可以通过为用户添加 <code>s</code> 权限来以符号方式添加 setuid 权限，示例如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod u+s suidexample.sh</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在下面的示例中，也可以通过在权限集前加上数字四（4）来设置 setuid 权限：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 4755 suidexample.sh</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>suidexample.sh</code> 的权限现在如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>-rwsr-xr-x   1 trhodes  trhodes    63 Aug 29 06:36 suidexample.sh</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，现在文件所有者的权限集中包含了一个 <code>s</code>，取代了可执行位。这允许使用需要提升权限的实用程序，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>nosuid</code> 选项是 <code>mount[8]</code> 命令中的一个选项，它会导致这些二进制文件在不通知用户的情况下静默失败。然而，这个选项并不完全可靠，因为一个 <code>nosuid</code> 包装器可能会绕过它。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要实时查看此内容，请打开两个终端。在其中一个终端上，以普通用户身份输入 <code>passwd</code> 。在等待新密码时，检查进程表并查看 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 的用户信息。</p>
</div>
<div class="paragraph">
<p>在终端 A 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Changing <span class="nb">local </span>password <span class="k">for </span>trhodes
Old Password:</code></pre>
</div>
</div>
<div class="paragraph">
<p>在终端 B 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ps aux | grep passwd</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">trhodes  5232  0.0  0.2  3420  1608   0  R+    2:10AM   0:00.00 grep passwd
root     5211  0.0  0.2  3620  1724   2  I+    2:09AM   0:00.01 passwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>尽管 <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=1&amp;format=html">passwd(1)</a> 以普通用户身份运行，但它使用的是 <code>root</code> 的有效 UID 。</p>
</div>
<div class="paragraph">
<p><code>setgid</code> 权限与 <code>setuid</code> 权限执行相同的功能，只是它改变的是组的设置。当一个应用程序或实用工具以此设置运行时，它将根据拥有文件的组而不是启动进程的用户被授予权限。</p>
</div>
<div class="paragraph">
<p>要在文件上以符号方式设置 <code>setgid</code> 权限，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 命令为组添加 <code>s</code> 权限。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod g+s sgidexample.sh</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，给 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 命令提供一个前缀的数字 2 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 2755 sgidexample.sh</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在下面的清单中，请注意 <code>s</code> 现在位于用于组权限设置的字段中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">-rwxr-sr-x   1 trhodes  trhodes    44 Aug 31 01:49 sgidexample.sh</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在这些示例中，尽管所讨论的 shell 脚本是一个可执行文件，但它不会以不同的 EUID 或有效用户 ID 运行。这是因为 shell 脚本可能无法访问 <a href="https://man.freebsd.org/cgi/man.cgi?query=setuid&amp;sektion=2&amp;format=html">setuid(2)</a> 系统调用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>setuid</code> 和 <code>setgid</code> 权限位可能会降低系统安全性，因为它们允许提升权限。而第三个特殊权限位，即 <code>sticky bit</code> ，可以增强系统的安全性。</p>
</div>
<div class="paragraph">
<p>当目录上设置了 <code>粘着位（sticky bit）</code> 时，只允许文件所有者删除文件。这对于防止非文件所有者在公共目录（如 <code>/tmp</code>）中删除文件非常有用。要使用此权限，请将 <code>t</code> 模式添加到文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod +t /tmp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，将权限集以数字 1 作为前缀：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 1777 /tmp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>sticky bit</code> 权限将显示为权限集的最后一个字符 <code>t</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls -al / | grep tmp</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">drwxrwxrwt  10 root  wheel         512 Aug 31 01:49 tmp</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dirstructure">3.5. 目录结构<a class="anchor" href="#dirstructure"></a></h3>
<div class="paragraph">
<p>FreeBSD 目录层次结构对于全面了解系统至关重要。最重要的目录是根目录或者“/”。这个目录是在启动时首先挂载的，它包含了准备操作系统进行多用户操作所需的基本系统。根目录还包含其他文件系统的挂载点，在切换到多用户操作时会挂载这些文件系统。</p>
</div>
<div class="paragraph">
<p>挂载点是一个目录，可以将额外的文件系统嵌入到父文件系统（通常是根文件系统）上。这在 <a href="#disk-organization">磁盘组织</a> 中有进一步描述。标准的挂载点包括 <code>/usr/</code>、<code>/var/</code>、<code>/tmp/</code>、<code>/mnt/</code> 和 <code>/cdrom/</code> 。这些目录通常在 <code>/etc/fstab</code> 中引用。这个文件是一个包含各种文件系统和挂载点的表格，并由系统读取。除非它们的条目包含 <code>noauto</code>，否则 <code>/etc/fstab</code> 中的大多数文件系统会在启动时自动从脚本 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 挂载。详细信息可以在 <a href="#disks-fstab">fstab 文件</a> 中找到。</p>
</div>
<div class="paragraph">
<p>文件系统层次结构的完整描述可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> 中找到。下表提供了最常见目录的简要概述。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col/>
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">目录</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件系统的根目录。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/bin/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">单用户和多用户环境的基本用户实用程序。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/boot/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作系统引导过程中使用的程序和配置文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/boot/defaults/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认的启动配置文件。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/dev/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">由 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> 管理的设备特殊文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/etc/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统配置文件和脚本。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/etc/defaults/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认系统配置文件。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/etc/periodic/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 每天、每周和每月运行的脚本。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/lib/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>/bin</code> 和 <code>/sbin</code> 目录中的二进制文件所需的关键系统库。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/libexec/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">关键系统文件</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/media/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含用作可移动介质（如 CD、USB 驱动器和软盘）的挂载点的子目录。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/mnt/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">空目录通常被系统管理员用作临时挂载点。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/net/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">自动挂载的 NFS 共享；请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a> 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/proc/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">进程文件系统。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=procfs&amp;sektion=5&amp;format=html">procfs(5)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_procfs&amp;sektion=8&amp;format=html">mount_procfs(8)</a> 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/rescue/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用于紧急恢复的静态链接程序，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=rescue&amp;sektion=8&amp;format=html">rescue(8)</a> 中所述。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/root/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>root</code> 账户的主目录。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/sbin/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">单用户和多用户环境的基本系统程序和管理工具。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/tmp/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">通常在系统重新启动后不会保留的临时文件。基于内存的文件系统通常会挂载在 <code>/tmp</code> 目录下。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 中与 tmpmfs 相关的变量或在 <code>/etc/fstab</code> 中添加条目来自动化此过程；有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">大多数用户工具和应用程序。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/bin/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">常用工具、编程工具和应用程序。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/include/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">标准的 C 头文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/lib/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">库文件</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/libdata/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">杂项实用数据文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/libexec/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统守护进程和由其他程序执行的系统实用工具。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/local/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地可执行文件和库。也被用作 FreeBSD ports 框架的默认目的地。在 <code>/usr/local</code> 中，应使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> 为 <code>/usr</code> 预设的一般布局。man 目录例外，它直接位于 <code>/usr/local</code> 而不是 <code>/usr/local/share</code> 下，而 ports 文档位于 <code>share/doc/port</code> 中。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/ports/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">FreeBSD Ports 集合（可选）。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/sbin/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统守护进程和由用户执行的系统实用程序。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/share/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">与体系结构无关的文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/usr/src/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD 或本地源文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">多用途日志、临时、暂存和溢出文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/log/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">杂项系统日志文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>/var/tmp/</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">通常在系统重启后保留的临时文件。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect2">
<h3 id="disk-organization">3.6. 磁盘组织<a class="anchor" href="#disk-organization"></a></h3>
<div class="paragraph">
<p>FreeBSD 使用的最小组织单位是文件名。文件名区分大小写，这意味着 <code>readme.txt</code> 和 <code>README.TXT</code> 是两个不同的文件。 FreeBSD 不使用文件的扩展名来确定文件是程序、文档还是其他形式的数据。</p>
</div>
<div class="paragraph">
<p>文件存储在目录中。一个目录可以不包含任何文件，也可以包含数百个文件。一个目录还可以包含其他目录，从而允许在彼此之间建立目录层次结构以组织数据。</p>
</div>
<div class="paragraph">
<p>文件和目录的引用是通过给出文件或目录名称，后跟一个斜杠 <code>/</code> ，再跟上其他必要的目录名称来完成的。例如，如果目录 <code>foo</code> 包含一个目录 <code>bar</code>，该目录又包含文件 <code>readme.txt</code> ，那么文件的完整名称，或者路径，就是 <code>foo/bar/readme.txt</code>。请注意，这与 Windows® 不同，Windows 使用反斜杠 <code>\</code> 来分隔文件和目录名称。 FreeBSD 在路径中不使用驱动器号或其他驱动器名称。例如，在 FreeBSD 上，不会输入 <code>c:\foo\bar\readme.txt</code>。</p>
</div>
<div class="sect3">
<h4 id="disks-file-systems">3.6.1. 文件系统<a class="anchor" href="#disks-file-systems"></a></h4>
<div class="paragraph">
<p>目录和文件存储在文件系统中。每个文件系统在最顶层都包含一个目录，称为该文件系统的根目录。这个根目录可以包含其他目录。一个文件系统被指定为根文件系统或 <code>/</code> 。其他所有文件系统都被挂载在根文件系统下。无论 FreeBSD 系统上有多少个磁盘，每个目录都看起来是同一个磁盘的一部分。</p>
</div>
<div class="paragraph">
<p>考虑三个文件系统，分别称为 <code>A</code>、<code>B</code> 和 <code>C</code>。每个文件系统都有一个根目录，其中包含两个其他目录，分别称为 <code>A1</code>、<code>A2</code> （同样也有 <code>B1</code>、<code>B2</code> 和 <code>C1</code>、<code>C2</code>）。</p>
</div>
<div class="paragraph">
<p>将 <code>A</code> 称为根文件系统。如果使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 命令查看该目录的内容，将显示两个子目录，<code>A1</code> 和 <code>A2</code>。目录树如下所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/basics/example-dir1.png" alt="带有根目录和两个子目录的目录树" width="A1 and A2"/>
</div>
</div>
<div class="paragraph">
<p>一个文件系统必须被挂载到另一个文件系统的目录上。当将文件系统 <code>B</code> 挂载到目录 <code>A1</code> 上时，<code>B</code> 的根目录将替换 <code>A1</code>，并且 <code>B</code> 中的目录会相应地显示出来：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/basics/example-dir2.png" alt="带有根目录和两个子目录的目录树" width="A1 and A2. And more subdirectories" height="B1 and B2 hanging from A1"/>
</div>
</div>
<div class="paragraph">
<p>任何位于 <code>B1</code> 或 <code>B2</code> 目录中的文件可以通过路径 <code>/A1/B1</code> 或 <code>/A1/B2</code> 访问。任何位于 <code>/A1</code> 中的文件都被临时隐藏了。如果从 <code>A</code> 卸载 <code>B</code>，它们将重新出现。</p>
</div>
<div class="paragraph">
<p>如果 <code>B</code> 被安装在 <code>A2</code> 上，那么图表将如下所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/basics/example-dir3.png" alt="带有根目录和两个子目录的目录树" width="A1 and A2. And more subdirectories" height="B1 and B2 hanging from A2"/>
</div>
</div>
<div class="paragraph">
<p>路径分别为 <code>/A2/B1</code> 和 <code>/A2/B2</code>。</p>
</div>
<div class="paragraph">
<p>文件系统可以相互叠加挂载。继续上一个例子，<code>C</code> 文件系统可以被挂载在 <code>B</code> 文件系统中的 <code>B1</code> 目录上方，形成以下的安排：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/basics/example-dir4.png" alt="一个复杂的目录树。根目录下有不同的子目录。"/>
</div>
</div>
<div class="paragraph">
<p>或者 <code>C</code> 可以直接挂载到 <code>A</code> 文件系统下的 <code>A1</code> 目录中：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/basics/example-dir5.png" alt="一个复杂的目录树。根目录下有不同的子目录。"/>
</div>
</div>
<div class="paragraph">
<p>完全可以只有一个大的根文件系统，而不需要创建其他文件系统。这种方法有一些缺点和一个优点。</p>
</div>
<div class="ulist">
<div class="title">多个文件系统的好处</div>
<ul>
<li>
<p>不同的文件系统可以有不同的挂载选项。例如，根文件系统可以以只读方式挂载，这样用户就无法意外删除或编辑关键文件。将可由用户写入的文件系统（如 <code>/home</code>）与其他文件系统分离，可以将它们挂载为 <em>nosuid</em> 。此选项可以防止文件系统上存储的可执行文件的_ suid_/<em>guid</em> 位生效，从而可能提高安全性。</p>
</li>
<li>
<p>FreeBSD 会根据文件系统的使用情况自动优化文件的布局。因此，包含许多频繁写入的小文件的文件系统将与包含较少且较大的文件的文件系统有所不同的优化方式。如果只有一个大文件系统，这种优化将失效。</p>
</li>
<li>
<p>如果断电，FreeBSD 的文件系统是健壮的。然而，在关键时刻断电仍然可能损坏文件系统的结构。通过将数据分散在多个文件系统上，系统更有可能重新启动，从而更容易根据需要进行备份恢复。</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">单一文件系统的好处</div>
<ul>
<li>
<p>文件系统是固定大小的。如果在安装 FreeBSD 时创建了一个文件系统并指定了特定的大小，您可能会发现以后需要扩大分区的大小。这不容易实现，需要先备份数据，然后使用新的大小重新创建文件系统，最后恢复备份的数据。</p>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>FreeBSD 具有 <a href="https://man.freebsd.org/cgi/man.cgi?query=growfs&amp;sektion=8&amp;format=html">growfs(8)</a> 命令，可以在运行时增加文件系统的大小，从而消除了这一限制。文件系统只能扩展到所在分区的可用空间中。如果分区后面有空间，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 来扩展分区。如果分区是虚拟磁盘上的最后一个分区，并且磁盘被扩展了，那么可以扩展该分区。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="disks-partitions">3.6.2. 磁盘分区<a class="anchor" href="#disks-partitions"></a></h4>
<div class="paragraph">
<p>文件系统包含在 <em>分区</em> 中。使用多种分区方案将磁盘划分为分区；参见 <a href="#bsdinstall-part-manual">手动分区</a>。较新的方案是 GPT ；旧的基于 BIOS 的计算机使用 MBR。GPT 支持将磁盘划分为具有大小、偏移和类型的分区。它支持大量的分区和分区类型，并且在可能的情况下推荐使用。GPT 分区使用磁盘名称加后缀，后缀为 <code>p1</code> 表示第一个分区，<code>p2</code> 表示第二个分区，依此类推。然而，MBR 仅支持少量的分区。在 FreeBSD 中，MBR 分区被称为 <code>slices</code>。 Slices 可以用于不同的操作系统。 FreeBSD slices 使用 BSD 标签进行分区细分（参见 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a>）。</p>
</div>
<div class="paragraph">
<p>Slice 号码遵循设备名称，以 <code>s</code> 为前缀，从 1 开始。因此，“da0<em>s1</em>”是第一个 SCSI 驱动器上的第一个 slice。一个磁盘上只能有四个物理 slice，但是在适当类型的物理切片内可以有逻辑 slice。这些扩展 slice 从 5 开始编号，因此“ada0<em>s5</em>”是第一个 SATA 磁盘上的第一个扩展 slice。这些设备由希望占用一个 slice 的文件系统使用。</p>
</div>
<div class="paragraph">
<p>每个 GPT 或 BSD 分区只能包含一个文件系统，这意味着文件系统通常通过其在文件系统层次结构中的典型挂载点或它们所包含的分区的名称来描述。</p>
</div>
<div class="paragraph">
<p>FreeBSD 还使用磁盘空间作为 <em>交换空间</em> 来提供 <em>虚拟内存</em>。这使得您的计算机可以表现得好像它拥有比实际更多的内存。当 FreeBSD 内存不足时，它将一些当前未使用的数据移动到交换空间，并在需要时将其移回（将其他数据移出）。这被称为 <em>分页</em>。</p>
</div>
<div class="paragraph">
<p>一些 BSD 分区与特定的约定相关联。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 25%;"/>
<col/>
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">分区</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">惯例</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>a</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">通常包含根文件系统。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>b</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">通常包含交换空间。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>c</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">通常与包含的 slice 大小相同。这样可以使需要在整个 slice 上工作的实用程序（例如坏块扫描器）能够在 <code>c</code> 分区上工作。通常不会在此分区上创建文件系统。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>d</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">分区 <code>d</code> 曾经有一个特殊的含义，但现在已经消失了，<code>d</code> 可以像任何普通分区一样工作。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>Slices 和“危险专用”物理驱动器包含 BSD 分区，这些分区用字母 <code>a</code> 到 <code>h</code> 表示。这个字母被附加到设备名称上，所以“ da0<em>a</em>”是第一个 <code>da</code> 驱动器上的 <code>a</code> 分区，该驱动器是“危险专用”的。“ada1s3<em>e</em>”是第二个 SATA 磁盘驱动器的第三个 slice 中的第五个分区。</p>
</div>
<div class="paragraph">
<p>最后，系统上的每个磁盘都有一个标识。磁盘名称以表示磁盘类型的代码开头，然后是一个数字，表示它是第几个磁盘。与分区和切片不同，磁盘编号从 0 开始。常见的代码列在 <a href="#disks-naming">磁盘设备名称</a> 中。</p>
</div>
<div class="paragraph">
<p>在引用 slice 中的分区时，请包括磁盘名称、<code>s</code> 、切片编号，然后是分区字母。示例见 <a href="#basics-disk-slice-part">示例磁盘、Slice 和分区名称</a> 。 GPT 分区包括磁盘名称、<code>p</code>，然后是分区编号。</p>
</div>
<div class="paragraph">
<p><a href="#basics-concept-disk-model">磁盘的概念模型</a> 展示了使用 MBR 分区的磁盘布局的概念模型。</p>
</div>
<div class="paragraph">
<p>在安装 FreeBSD 时，如果使用 MBR，请配置磁盘 slice，并在 slice 内创建用于 FreeBSD 的分区。如果使用 GPT ，请为每个文件系统配置分区。无论哪种情况，都要在每个分区中创建文件系统或交换空间，并决定每个文件系统将被挂载到哪里。有关操作分区的信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 。</p>
</div>
<table id="disks-naming" class="tableblock frame-none grid-all stretch">
<caption class="title">表 4. 磁盘设备名称</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">驱动类型</th>
<th class="tableblock halign-left valign-top">驱动设备名称</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SATA 和 IDE 硬盘</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ada</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCSI 硬盘和 USB 存储设备</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>da</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NVMe 存储</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvd</code> or <code>nda</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SATA 和 IDE CD-ROM 驱动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cd</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCSI CD-ROM 驱动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cd</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">软盘驱动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fd</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCSI 磁带驱动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>sa</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">RAID 驱动器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">例如，Adaptec® AdvancedRAID 的 <code>aacd</code>、Mylex® 的 <code>mlxd</code> 和 <code>mlyd</code>、AMI MegaRAID® 的 <code>amrd</code>、Compaq Smart RAID 的 <code>idad</code>、3ware® RAID 的 <code>twed</code>。</p></td>
</tr>
</tbody>
</table>
<div class="exampleblock">
<div class="content">
<table id="basics-disk-slice-part" class="tableblock frame-none grid-all stretch informaltable">
<caption class="title">表 5. 示例磁盘、Slice 和分区名称</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">意义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ada0s1a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第一个 SATA 磁盘（<code>ada0</code>）上的第一个 slice（<code>s1</code>）上第一个分区（<code>a</code>）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>da1s2e</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">第二个 SCSI 磁盘（<code>da1</code>）上第二个 slice（<code>s2</code>）上的第五个分区（<code>e</code>）。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div id="basics-concept-disk-model" class="exampleblock">
<div class="title">例 13. 磁盘的概念模型</div>
<div class="content">
<div class="paragraph">
<p>这个图示展示了 FreeBSD 对系统上连接的第一个 SATA 硬盘的视图。假设该硬盘的容量为 250GB ，包含一个 80GB 的分区和一个 170GB 的分区（MS-DOS® 分区）。第一个分区包含一个 Windows® NTFS 文件系统，即 <code>C:</code>，而第二个分区包含一个 FreeBSD 安装。这个示例的 FreeBSD 安装有四个数据分区和一个交换分区。</p>
</div>
<div class="paragraph">
<p>四个分区分别持有一个文件系统。分区 <code>a</code> 用于根文件系统，<code>d</code> 用于 <code>/var/</code>，<code>e</code> 用于 <code>/tmp/</code>，<code>f</code> 用于 <code>/usr/</code>。分区字母 <code>c</code> 指的是整个 slice，因此不用于普通分区。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/basics/disk-layout.png" alt="Windows 和 FreeBSD 之间共享驱动器的布局"/>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mount-unmount">3.7. 挂载和卸载文件系统<a class="anchor" href="#mount-unmount"></a></h3>
<div class="paragraph">
<p>文件系统最好被视为一棵树，以 <code>/</code> 作为根节点。根目录中的 <code>/dev</code>、<code>/usr</code> 和其他目录是分支，它们可能有自己的分支，比如 <code>/usr/local</code> 等等。</p>
</div>
<div class="paragraph">
<p>将一些目录放在单独的文件系统上有各种原因。<code>/var</code> 包含了 <code>log/</code>、<code>spool/</code> 以及各种类型的临时文件，因此可能会被填满。填满根文件系统是不明智的，所以将 <code>/var</code> 与 <code>/</code> 分离通常是可取的。</p>
</div>
<div class="paragraph">
<p>将某些目录树包含在其他文件系统中的另一个常见原因是它们将被放置在单独的物理磁盘上，或者是单独的虚拟磁盘，例如网络文件系统挂载，如 <a href="./#network-nfs">“网络文件系统（ NFS ）”</a> 描述的，或者 CDROM 驱动器。</p>
</div>
<div class="sect3">
<h4 id="disks-fstab">3.7.1. fstab 文件<a class="anchor" href="#disks-fstab"></a></h4>
<div class="paragraph">
<p>在引导过程中（<a href="./#boot">FreeBSD 引导过程</a>），除了包含 <code>noauto</code> 条目的条目外，<code>/etc/fstab</code> 中列出的文件系统会自动挂载。该文件以以下格式包含条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device       /mount-point fstype     options      dumpfreq     passno</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>device</code></dt>
<dd>
<p>如 <a href="#disks-naming">磁盘设备名称</a> 中所解释的，现有设备名称。</p>
</dd>
<dt class="hdlist1"><code>mount-point</code></dt>
<dd>
<p>一个现有的目录，用于挂载文件系统。</p>
</dd>
<dt class="hdlist1"><code>fstype</code></dt>
<dd>
<p>传递给 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 的文件系统类型。默认的 FreeBSD 文件系统是 <code>ufs</code>。</p>
</dd>
<dt class="hdlist1"><code>options</code></dt>
<dd>
<p>可以选择 <code>rw</code> 表示读写文件系统，或者 <code>ro</code> 表示只读文件系统，后面可以添加其他可能需要的选项。常见的选项是 <code>noauto</code> ，用于在启动序列期间通常不挂载的文件系统。其他选项可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 中找到。</p>
</dd>
<dt class="hdlist1"><code>dumpfreq</code></dt>
<dd>
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 使用此字段来确定哪些文件系统需要进行备份。如果该字段缺失，则默认为零值。</p>
</dd>
<dt class="hdlist1"><code>passno</code></dt>
<dd>
<p>确定在重新启动后，<a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 应该按照什么顺序检查 UFS 文件系统。应该跳过的文件系统应该将其 <code>passno</code> 设置为零。根文件系统需要在其他所有文件系统之前进行检查，并且其 <code>passno</code> 应该设置为一。其他文件系统的 <code>passno</code> 应该设置为大于一的值。如果有多个文件系统具有相同的 <code>passno</code>，<a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 将尝试在可能的情况下并行检查文件系统。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 以获取有关 <code>/etc/fstab</code> 格式及其选项的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="disks-mount">3.7.2. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a><a class="anchor" href="#disks-mount"></a></h4>
<div class="paragraph">
<p>文件系统使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 进行挂载。最基本的语法如下：</p>
</div>
<div class="exampleblock">
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount device mountpoint</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>在 <code>/etc/fstab</code> 中列出的文件系统也可以通过提供挂载点来挂载。</p>
</div>
<div class="paragraph">
<p>该命令提供了许多选项，这些选项在 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 中有描述。最常用的选项包括：</p>
</div>
<div class="dlist">
<div class="title">挂载选项</div>
<dl>
<dt class="hdlist1"><code>-a</code></dt>
<dd>
<p>挂载 <code>/etc/fstab</code> 中列出的所有文件系统，除了那些标记为“noauto”、被 <code>-t</code> 标志排除的文件系统，以及已经挂载的文件系统。</p>
</dd>
<dt class="hdlist1"><code>-d</code></dt>
<dd>
<p>执行除实际挂载系统调用之外的所有操作。这个选项与 <code>-v</code> 标志一起使用非常有用，可以确定 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 实际上正在尝试做什么。</p>
</dd>
<dt class="hdlist1"><code>-f</code></dt>
<dd>
<p>强制挂载一个不干净的文件系统（危险操作），或者在将文件系统的挂载状态从读写改为只读时，撤销写访问权限。</p>
</dd>
<dt class="hdlist1"><code>-r</code></dt>
<dd>
<p>将文件系统挂载为只读模式。这与使用 <code>-o ro</code> 参数完全相同。</p>
</dd>
<dt class="hdlist1"><code>-t <em>fstype</em></code></dt>
<dd>
<p>如果包含 <code>-a</code> 选项，则挂载指定的文件系统类型或仅挂载给定类型的文件系统。“ufs”是默认的文件系统类型。</p>
</dd>
<dt class="hdlist1"><code>-u</code></dt>
<dd>
<p>更新文件系统的挂载选项。</p>
</dd>
<dt class="hdlist1"><code>-v</code></dt>
<dd>
<p>提供详细信息。</p>
</dd>
<dt class="hdlist1"><code>-w</code></dt>
<dd>
<p>将文件系统挂载为读写模式。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>可以将以下选项作为逗号分隔的列表传递给 <code>-o</code>：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">nosuid</dt>
<dd>
<p>不要读取文件系统上的 <code>setuid</code> 或 <code>setgid</code> 标志。这也是一个有用的安全选项。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="disks-umount">3.7.3. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a><a class="anchor" href="#disks-umount"></a></h4>
<div class="paragraph">
<p>要卸载文件系统，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=umount&amp;sektion=8&amp;format=html">umount(8)</a> 命令。该命令接受一个参数，可以是挂载点、设备名称、<code>-a</code> 或 <code>-A</code>。</p>
</div>
<div class="paragraph">
<p>所有的表单都可以使用 <code>-f</code> 来强制卸载，并且使用 <code>-v</code> 来显示详细信息。请注意，一般情况下不建议使用 <code>-f</code>，因为它可能会导致计算机崩溃或者损坏文件系统上的数据。</p>
</div>
<div class="paragraph">
<p>要卸载所有已挂载的文件系统，或者只卸载在 <code>-t</code> 后面列出的文件系统类型，请使用 <code>-a</code> 或 <code>-A</code> 选项。请注意，<code>-A</code> 选项不会尝试卸载根文件系统。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="basics-processes">3.8. 进程和守护进程<a class="anchor" href="#basics-processes"></a></h3>
<div class="paragraph">
<p>FreeBSD 是一个多任务操作系统。每个同时运行的程序被称为一个 <em>进程</em>。每个正在运行的命令都会启动至少一个新的进程，并且 FreeBSD 还会运行一些系统进程。</p>
</div>
<div class="paragraph">
<p>每个进程都由一个称为 <em>进程 ID</em>（PID）的数字唯一标识。与文件类似，每个进程都有一个所有者和组，并且所有者和组权限用于确定进程可以打开哪些文件和设备。大多数进程还有一个启动它们的父进程。例如，shell 是一个进程，shell 中启动的任何命令都是一个进程，其父进程是 shell 。例外情况是一个特殊的进程，称为 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>，它始终是在启动时第一个启动的进程，其 PID 始终为 <code>1</code>。</p>
</div>
<div class="paragraph">
<p>有些程序并不是设计成需要连续的用户输入，也不能在第一时间与终端断开连接。例如，Web 服务器响应 Web 请求，而不是用户输入。邮件服务器是另一种这种类型的应用程序。这些类型的程序被称为 <em>守护进程（daemon）</em>。术语 daemon 来自希腊神话，代表着一个既不善良也不邪恶的实体，它在不可见的情况下执行有用的任务。这就是为什么 BSD 吉祥物是一个看起来开心的带着运动鞋和叉子的 daemon。</p>
</div>
<div class="paragraph">
<p>有一个约定，即通常作为守护进程运行的程序的命名方式是以字母&#34;d&#34;结尾的。例如，BIND 是 Berkeley Internet Name Domain 的缩写，但实际执行的程序是 <code>named</code>。Apache Web 服务器程序是 <code>httpd</code> ，线打印机排队守护进程是 <code>lpd</code>。这只是一种命名约定。例如，Sendmail 应用程序的主邮件守护进程是 <code>sendmail</code>，而不是 <code>maild</code>。</p>
</div>
<div class="sect3">
<h4 id="_查看进程">3.8.1. 查看进程<a class="anchor" href="#_查看进程"></a></h4>
<div class="paragraph">
<p>要查看系统上运行的进程，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>。要显示当前正在运行的进程的静态列表，包括它们的进程 ID 、使用的内存量以及启动它们的命令，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 。要显示所有正在运行的进程，并每隔几秒更新一次显示，以便交互式地查看计算机正在做什么，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a>。</p>
</div>
<div class="paragraph">
<p>默认情况下，<a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 只显示正在运行且由用户拥有的命令。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ps</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre> PID TT  STAT    TIME COMMAND
8203  0  Ss   0:00.59 /bin/csh
8895  0  R+   0:00.00 ps</pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 的输出被组织成多列。<code>PID</code> 列显示进程 ID。PID 从 1 开始分配，最大为 99999 ，然后重新从头开始分配。然而，如果 PID 已经被使用，它不会被重新分配。<code>TT</code> 列显示程序所在的 tty，<code>STAT</code> 列显示程序的状态。 <code>TIME</code> 是程序在 CPU 上运行的时间。这通常不是程序启动后经过的时间，因为大多数程序在需要在 CPU 上花费时间之前会花费很多时间等待事件发生。最后，<code>COMMAND</code> 是用于启动程序的命令。</p>
</div>
<div class="paragraph">
<p>有多种不同的选项可用于更改显示的信息。其中最有用的一组是 <code>auxww</code>，其中 <code>a</code> 显示有关所有用户的所有运行进程的信息，<code>u</code> 显示进程所有者的用户名和内存使用情况，<code>x</code> 显示有关守护进程的信息，<code>ww</code> 使 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 显示每个进程的完整命令行，而不是在屏幕上显示过长时截断它。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 的输出类似：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>top</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>last pid:  9609;  load averages:  0.56,  0.45,  0.36              up 0+00:20:03  10:21:46
107 processes: 2 running, 104 sleeping, 1 zombie
CPU:  6.2% user,  0.1% nice,  8.2% system,  0.4% interrupt, 85.1% idle
Mem: 541M Active, 450M Inact, 1333M Wired, 4064K Cache, 1498M Free
ARC: 992M Total, 377M MFU, 589M MRU, 250K Anon, 5280K Header, 21M Other
Swap: 2048M Total, 2048M Free

  PID USERNAME    THR PRI NICE   SIZE    RES STATE   C   TIME   WCPU COMMAND
  557 root          1 -21  r31   136M 42296K select  0   2:20  9.96% Xorg
 8198 dru           2  52    0   449M 82736K select  3   0:08  5.96% kdeinit4
 8311 dru          27  30    0  1150M   187M uwait   1   1:37  0.98% firefox
  431 root          1  20    0 14268K  1728K select  0   0:06  0.98% moused
 9551 dru           1  21    0 16600K  2660K CPU3    3   0:01  0.98% top
 2357 dru           4  37    0   718M   141M select  0   0:21  0.00% kdeinit4
 8705 dru           4  35    0   480M    98M select  2   0:20  0.00% kdeinit4
 8076 dru           6  20    0   552M   113M uwait   0   0:12  0.00% soffice.bin
 2623 root          1  30   10 12088K  1636K select  3   0:09  0.00% powerd
 2338 dru           1  20    0   440M 84532K select  1   0:06  0.00% kwin
 1427 dru           5  22    0   605M 86412K select  1   0:05  0.00% kdeinit4</pre>
</div>
</div>
<div class="paragraph">
<p>输出分为两个部分。标题部分（前五或六行）显示了最后一个运行的进程的 PID ，系统负载平均值（衡量系统繁忙程度的指标），系统运行时间（自上次重启以来的时间）和当前时间。标题中的其他数字与正在运行的进程数量、已使用的内存和交换空间以及系统在不同 CPU 状态下花费的时间有关。如果加载了 ZFS 文件系统模块，<code>ARC</code> 行将显示有多少数据是从内存缓存中读取而不是从磁盘中读取的。</p>
</div>
<div class="paragraph">
<p>在标题下面是一系列列，其中包含与 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 输出类似的信息，例如 PID、用户名、CPU 时间和启动进程的命令。默认情况下，<a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 还会显示进程占用的内存空间。这被分为两列：总大小和常驻大小。总大小是应用程序所需的内存量，常驻大小是它当前实际使用的内存量。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 每两秒自动更新显示。可以使用 <code>-s</code> 指定不同的间隔。</p>
</div>
</div>
<div class="sect3">
<h4 id="basics-daemons">3.8.2. 杀死进程<a class="anchor" href="#basics-daemons"></a></h4>
<div class="paragraph">
<p>与任何正在运行的进程或守护进程进行通信的一种方法是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> 发送一个 <em>信号（signal）</em>。有许多不同的信号；一些具有特定的含义，而其他信号在应用程序的文档中有描述。用户只能向自己拥有的进程发送信号，向他人的进程发送信号将导致权限被拒绝的错误。例外情况是 <code>root</code> 用户，他可以向任何进程发送信号。</p>
</div>
<div class="paragraph">
<p>操作系统也可以向进程发送信号。如果一个应用程序编写得很糟糕，试图访问它不应该访问的内存， FreeBSD 将向该进程发送“分段违规（Segmentation Violation）”信号（<code>SIGSEGV</code>）。如果一个应用程序被编写成使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=alarm&amp;sektion=3&amp;format=html">alarm(3)</a> 系统调用，在经过一段时间后被提醒，它将收到“闹钟（Alarm）”信号（<code>SIGALRM</code>）。</p>
</div>
<div class="paragraph">
<p>有两个信号可以用来停止一个进程：<code>SIGTERM</code> 和 <code>SIGKILL</code>。<code>SIGTERM</code> 是一种礼貌的方式来终止一个进程，因为进程可以读取该信号，关闭可能打开的任何日志文件，并尝试在关闭之前完成正在进行的操作。在某些情况下，如果进程正在执行无法中断的任务，它可能会忽略 <code>SIGTERM</code> 信号。</p>
</div>
<div class="paragraph">
<p><code>SIGKILL</code> 无法被进程忽略。向一个进程发送 <code>SIGKILL</code> 通常会立即停止该进程。<sup class="footnote">[<a id="_footnoteref_1" class="footnote" href="#_footnotedef_1" title="View footnote.">1</a>]</sup> 。</p>
</div>
<div class="paragraph">
<p>其他常用的信号包括 <code>SIGHUP</code>、<code>SIGUSR1</code> 和 <code>SIGUSR2</code>。由于这些是通用的信号，不同的应用程序会有不同的响应。</p>
</div>
<div class="paragraph">
<p>例如，在更改 Web 服务器的配置文件后，需要告诉 Web 服务器重新读取其配置。重新启动 <code>httpd</code> 将导致 Web 服务器短暂的停机时间。相反，发送 <code>SIGHUP</code> 信号给守护进程。请注意，不同的守护进程会有不同的行为，因此请参考守护进程的文档以确定是否使用 <code>SIGHUP</code> 可以达到所需的结果。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在系统上随机杀死一个进程是一个坏主意。特别是，<a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>，PID 1 ，是特殊的。运行 <code>/bin/kill -s KILL 1</code> 是一个快速但不推荐的关闭系统的方法。在按下 <kbd>Return</kbd> 之前，<em>始终</em> 仔细检查 <a href="https://man.freebsd.org/cgi/man.cgi?query=kill&amp;sektion=1&amp;format=html">kill(1)</a> 的参数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="shells">3.9. Shells<a class="anchor" href="#shells"></a></h3>
<div class="paragraph">
<p>一个 <em>shell</em> 提供了一个命令行界面，用于与操作系统进行交互。 Shell 从输入通道接收命令并执行它们。许多 shell 提供了内置函数来帮助处理日常任务，如文件管理、文件通配符、命令行编辑、命令宏和环境变量。 FreeBSD 提供了几个 shell，包括 Bourne shell（<a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a>）和扩展的 C shell（<a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a>）。FreeBSD Ports Collection 中还提供了其他 shell，如 <code>zsh</code> 和 <code>bash</code>。</p>
</div>
<div class="paragraph">
<p>使用的 shell 实际上是个人口味的问题。 C 程序员可能更喜欢类似 C 的 shell ，比如 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> 。 Linux® 用户可能更喜欢 <code>bash</code>。每个 shell 都有独特的特性，可能适用或不适用于用户首选的工作环境，这就是为什么可以选择使用哪个 shell 的原因。</p>
</div>
<div class="paragraph">
<p>一个常见的 shell 功能是文件名补全。当用户输入命令或文件名的前几个字母并按下 <kbd>Tab</kbd> 键时， shell 会自动完成命令或文件名的剩余部分。假设有两个文件名分别为 <code>foobar</code> 和 <code>football</code>。要删除 <code>foobar</code>，用户可以输入 <code>rm foo</code> 并按下 <kbd>Tab</kbd> 键来完成文件名的补全。</p>
</div>
<div class="paragraph">
<p>但是 Shell 只显示 <code>rm foo</code> 。由于 <code>foobar</code> 和 <code>football</code> 都以 <code>foo</code> 开头，它无法完成文件名。一些 Shell 会发出哔哔声或显示所有匹配的选项。用户必须输入更多字符来识别所需的文件名。输入一个 <code>t</code> 并再次按下 <kbd>Tab</kbd> 就足够让 Shell 确定所需的文件名并填充剩下的部分。</p>
</div>
<div class="paragraph">
<p>shell 的另一个特性是使用环境变量。环境变量是存储在 shell 环境中的键值对。任何由 shell 调用的程序都可以读取这个环境，并因此包含了许多程序配置。 <a href="#shell-env-vars">常见的环境变量</a> 提供了常见环境变量及其含义的列表。请注意，环境变量的名称始终为大写。</p>
</div>
<table id="shell-env-vars" class="tableblock frame-all grid-all stretch">
<caption class="title">表 6. 常见的环境变量</caption>
<colgroup>
<col style="width: 25%;"/>
<col/>
</colgroup>
<tbody>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock">变量</p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">描述</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>USER</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前登录用户的名称。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>PATH</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">以冒号分隔的目录列表，用于搜索二进制文件。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>DISPLAY</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果可用，连接到的 Xorg 显示器的网络名称。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>SHELL</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">当前的 Shell 。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>TERM</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户终端的类型名称。用于确定终端的功能。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>TERMCAP</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">终端转义码的数据库条目，用于执行各种终端功能。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>OSTYPE</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">操作系统的类型。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>MACHTYPE</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统的 CPU 架构。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>EDITOR</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户首选的文本编辑器。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>PAGER</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户首选的逐页查看文本的实用工具。</p></td>
</tr>
<tr>
<th class="tableblock halign-left valign-top"><p class="tableblock"><code>MANPATH</code></p></th>
<td class="tableblock halign-left valign-top"><p class="tableblock">以冒号分隔的目录列表，用于搜索手册页。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在不同的 shell 中设置环境变量的方法是不同的。在 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> 中，使用 <code>setenv</code> 来设置环境变量。在 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> 和 <code>bash</code> 中，使用 <code>export</code> 来设置当前的环境变量。以下示例将默认的 <code>EDITOR</code> 设置为 <code>/usr/local/bin/emacs</code>，适用于 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> shell。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>setenv EDITOR /usr/local/bin/emacs</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>bash</code> 的等效命令是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">export </span><span class="nv">EDITOR</span><span class="o">=</span><span class="s2">&#34;/usr/local/bin/emacs&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了展开环境变量以查看其当前设置，在命令行中在其名称前面键入 <code>$</code> 字符。例如，<code>echo $TERM</code> 会显示当前的 <code>$TERM</code> 设置。</p>
</div>
<div class="paragraph">
<p>Shell 将特殊字符，称为元字符，视为数据的特殊表示。最常见的元字符是 <code>*</code> ，它表示文件名中的任意数量的字符。元字符可以用于执行文件名通配符匹配。例如，<code>echo *</code> 等同于 <code>ls</code> ，因为 shell 会将与 <code>*</code> 匹配的所有文件取出，并在命令行上列出它们。</p>
</div>
<div class="paragraph">
<p>为了防止 shell 解释特殊字符，可以通过在特殊字符前加上反斜杠（<code>\</code>）来将其从 shell 中转义。例如， <code>echo $TERM</code> 会打印终端设置，而 <code>echo \$TERM</code> 会直接打印字符串 <code>$TERM</code>。</p>
</div>
<div class="sect3">
<h4 id="changing-shells">3.9.1. 更改 Shell<a class="anchor" href="#changing-shells"></a></h4>
<div class="paragraph">
<p>永久更改默认 shell 的最简单方法是使用 <code>chsh</code> 命令。运行此命令将打开在 <code>EDITOR</code> 环境变量中配置的编辑器，默认设置为 <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>。将 <code>Shell:</code> 行更改为新 shell 的完整路径。</p>
</div>
<div class="paragraph">
<p>或者，使用 <code>chsh -s</code> 命令可以在不打开编辑器的情况下设置指定的 shell。例如，要将 shell 更改为 <code>bash</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>chsh -s /usr/local/bin/bash</code></pre>
</div>
</div>
<div class="paragraph">
<p>在提示符处输入您的密码，然后按下 <kbd>Return</kbd> 键来更改您的 shell。注销并重新登录以开始使用新的 shell。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>新的 shell 必须存在于 <code>/etc/shells</code> 中。如果 shell 是按照 <a href="./#ports">安装应用程序：软件包和 Ports</a> 中描述的方式从 FreeBSD Ports Collection 安装的，则应自动将其添加到此文件中。如果缺少，则使用以下命令添加，将路径替换为 shell 的路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo /usr/local/bin/bash &gt;&gt; /etc/shells</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，重新运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=chsh&amp;sektion=1&amp;format=html">chsh(1)</a>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_高级_shell_技巧">3.9.2. 高级 Shell 技巧<a class="anchor" href="#_高级_shell_技巧"></a></h4>
<div class="paragraph">
<p>UNIX® shell 不仅仅是一个命令解释器，它还是一个强大的工具，允许用户执行命令、重定向输出、重定向输入以及链式组合命令，以提高最终命令的输出。当这种功能与内置命令结合使用时，用户可以获得一个可以最大化效率的环境。</p>
</div>
<div class="paragraph">
<p>Shell 重定向是将命令的输出或输入发送到另一个命令或文件的操作。例如，要将 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 命令的输出捕获到文件中，可以使用重定向操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ls &gt; directory_listing.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>目录内容现在将会列在 <code>directory_listing.txt</code> 中。一些命令可以用来读取输入，比如 <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a> 。要对这个列表进行排序，可以重定向输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sort &lt; directory_listing.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>输入将被排序并显示在屏幕上。要将该输入重定向到另一个文件，可以通过混合方向来重定向 <a href="https://man.freebsd.org/cgi/man.cgi?query=sort&amp;sektion=1&amp;format=html">sort(1)</a> 的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sort &lt; directory_listing.txt &gt; sorted.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>在所有之前的示例中，命令都是使用文件描述符进行重定向。每个 UNIX® 系统都有文件描述符，包括标准输入 (stdin)、标准输出 (stdout) 和标准错误 (stderr)。每个文件描述符都有其用途，其中输入可以是键盘或鼠标，提供输入的设备。输出可以是屏幕或打印机上的纸张。而错误则是用于诊断或错误消息的任何内容。这三个都被视为基于 I/O 的文件描述符，有时也被称为流。</p>
</div>
<div class="paragraph">
<p>通过使用这些描述符， Shell 允许输出和输入在各个命令之间传递，并可以重定向到文件或从文件中读取。另一种重定向的方法是管道操作符。</p>
</div>
<div class="paragraph">
<p>UNIX® 管道操作符“|”允许将一个命令的输出直接传递或定向到另一个程序。基本上，管道允许将一个命令的标准输出作为另一个命令的标准输入传递，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>cat directory_listing.txt | sort | less</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，<code>directory_listing.txt</code> 的内容将被排序，并且输出将传递给 <a href="https://man.freebsd.org/cgi/man.cgi?query=less&amp;sektion=1&amp;format=html">less(1)</a> 。这使得用户可以按照自己的节奏滚动输出，并防止其滚动到屏幕外。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="editors">3.10. 文本编辑器<a class="anchor" href="#editors"></a></h3>
<div class="paragraph">
<p>大多数 FreeBSD 的配置是通过编辑文本文件来完成的，因此熟悉文本编辑器是一个好主意。FreeBSD 自带了一些基本系统的文本编辑器，还有更多的编辑器可以在 Ports Collection 中找到。</p>
</div>
<div class="paragraph">
<p>一个简单的学习编辑器是 <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a> ，它代表着 easy editor（简易编辑器）。要启动这个编辑器，输入 <code>ee <em>filename</em></code>，其中 <em>filename</em> 是要编辑的文件名。一旦进入编辑器，所有用于操作编辑器功能的命令都列在显示屏的顶部。插入符号（<code>^</code>）代表 <kbd>Ctrl</kbd>，所以 <code>^e</code> 扩展为 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>e</kbd></span>。要离开 <a href="https://man.freebsd.org/cgi/man.cgi?query=ee&amp;sektion=1&amp;format=html">ee(1)</a>，按下 <kbd>Esc</kbd>，然后从主菜单中选择“离开编辑器”选项。如果文件已被修改，编辑器将提示保存任何更改。</p>
</div>
<div class="paragraph">
<p>FreeBSD 还配备了更强大的文本编辑器，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a>，作为基本系统的一部分。其他编辑器，如 <a class="package" href="https://cgit.freebsd.org/ports/tree/editors/emacs/">editors/emacs</a> 和 <a class="package" href="https://cgit.freebsd.org/ports/tree/editors/vim/">editors/vim</a>，是 FreeBSD Ports Collection 的一部分。这些编辑器提供了更多的功能，但学习起来更加复杂。学习使用像 vim 或 Emacs 这样更强大的编辑器可以在长期来看节省更多的时间。</p>
</div>
<div class="paragraph">
<p>许多修改文件或需要输入文本的应用程序会自动打开一个文本编辑器。要更改默认的编辑器，请按照 <a href="#shells">Shells</a> 中描述的方式设置 <code>EDITOR</code> 环境变量。</p>
</div>
</div>
<div class="sect2">
<h3 id="basics-devices">3.11. 设备和设备节点<a class="anchor" href="#basics-devices"></a></h3>
<div class="paragraph">
<p>设备是系统中主要用于硬件相关活动的术语，包括磁盘、打印机、显卡和键盘等。当 FreeBSD 启动时，大部分引导消息都是关于检测到的设备。引导消息的副本保存在 <code>/var/run/dmesg.boot</code> 中。</p>
</div>
<div class="paragraph">
<p>每个设备都有一个设备名称和编号。例如， <code>ada0</code> 表示第一个 SATA 硬盘，而 <code>kbd0</code> 表示键盘。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，大多数设备必须通过称为设备节点的特殊文件进行访问，这些文件位于 <code>/dev</code> 目录中。</p>
</div>
</div>
<div class="sect2">
<h3 id="basics-more-information">3.12. 手册页<a class="anchor" href="#basics-more-information"></a></h3>
<div class="paragraph">
<p>FreeBSD 上最全面的文档是以手册页的形式存在的。系统上几乎每个程序都附带有一个简短的参考手册，解释其基本操作和可用参数。可以使用 <code>man</code> 命令查看这些手册。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>man <span class="nb">command</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <em>command</em> 是要了解的命令的名称。例如，要了解有关 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 的更多信息，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>man ls</code></pre>
</div>
</div>
<div class="paragraph">
<p>手册页被分为不同的章节，代表不同的主题类型。在 FreeBSD 中，有以下几个章节可用：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>用户命令。</p>
</li>
<li>
<p>系统调用和错误编号。</p>
</li>
<li>
<p>C 库中的函数。</p>
</li>
<li>
<p>设备驱动程序。</p>
</li>
<li>
<p>文件格式。</p>
</li>
<li>
<p>游戏和其他娱乐活动。</p>
</li>
<li>
<p>杂项信息。</p>
</li>
<li>
<p>系统维护和操作命令。</p>
</li>
<li>
<p>系统内核接口。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>在某些情况下，同一个主题可能会出现在在线手册的多个部分中。例如，有一个 <code>chmod</code> 用户命令和一个 <code>chmod()</code> 系统调用。要告诉 <a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> 显示哪个部分，需要指定部分号码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>man 1 chmod</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将显示用户命令 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 的手册页面。在书面文档中，对在线手册的特定部分的引用通常放在括号中，因此 <a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=1&amp;format=html">chmod(1)</a> 指的是用户命令，<a href="https://man.freebsd.org/cgi/man.cgi?query=chmod&amp;sektion=2&amp;format=html">chmod(2)</a> 指的是系统调用。</p>
</div>
<div class="paragraph">
<p>如果不知道手册页的名称，请使用 <code>man -k</code> 在手册页描述中搜索关键字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>man -k mail</code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令显示具有关键字“mail”在其描述中的命令列表。这相当于使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=apropos&amp;sektion=1&amp;format=html">apropos(1)</a> 命令。</p>
</div>
<div class="paragraph">
<p>要阅读 <code>/usr/sbin</code> 目录下所有命令的描述，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">cd</span> /usr/sbin
<span class="gp">% </span>man -f <span class="k">*</span> | more</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">cd</span> /usr/sbin
<span class="gp">% </span>whatis <span class="k">*</span> |more</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="basics-info">3.12.1. GNU Info 文件<a class="anchor" href="#basics-info"></a></h4>
<div class="paragraph">
<p>FreeBSD 包含了由自由软件基金会（FSF）制作的多个应用程序和实用工具。除了手册页，这些程序还可能包括称为 <code>info</code> 文件的超文本文档。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a> 命令或者如果安装了 <a class="package" href="https://cgit.freebsd.org/ports/tree/editors/emacs/">editors/emacs</a> ，可以使用 emacs 的 info 模式来查看这些文件。</p>
</div>
<div class="paragraph">
<p>要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=info&amp;sektion=1&amp;format=html">info(1)</a>，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>info</code></pre>
</div>
</div>
<div class="paragraph">
<p>要进行简要介绍，请输入 <code>h</code>。要查看快速命令参考，请输入 <code>?</code>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ports">Chapter 4. 安装应用程序：软件包和 Ports<a class="anchor" href="#ports"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ports-synopsis">4.1. 简介<a class="anchor" href="#ports-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 捆绑了丰富的系统工具作为基本系统的一部分。此外，FreeBSD 还提供了两种互补的技术来安装第三方软件：FreeBSD Ports Collection 用于从源代码安装，而软件包则用于从预编译的二进制文件安装。可以使用任一方法从本地媒体或网络安装软件。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>二进制包和 ports 之间的区别。</p>
</li>
<li>
<p>如何找到已经移植到 FreeBSD 的第三方软件。</p>
</li>
<li>
<p>如何使用 pkg 管理二进制软件包。</p>
</li>
<li>
<p>如何使用 Ports Collection 从源代码构建第三方软件。</p>
</li>
<li>
<p>如何找到应用程序安装后的文件，以进行后续配置。</p>
</li>
<li>
<p>如果软件安装失败，应该怎么办。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ports-overview">4.2. 软件安装概述<a class="anchor" href="#ports-overview"></a></h3>
<div class="paragraph">
<p>FreeBSD 的 <code>ports</code> 是一组文件，旨在自动化从源代码编译应用程序的过程。组成 ports 的文件包含了自动下载、提取、打补丁、编译和安装应用程序所需的所有必要信息。</p>
</div>
<div class="paragraph">
<p>如果软件尚未在 FreeBSD 上进行适配和测试，源代码可能需要进行编辑，以便正确安装和运行。</p>
</div>
<div class="paragraph">
<p>然而，在 <a href="https://www.FreeBSD.org/ports/">36000</a> 上已经有许多第三方应用程序被移植到了 FreeBSD。在可行的情况下，这些应用程序会以预编译的软件包形式提供下载。</p>
</div>
<div class="paragraph">
<p>可以使用 FreeBSD 软件包管理命令来操作软件包。</p>
</div>
<div class="paragraph">
<p>包和 ports 都能理解依赖关系。如果使用包或 ports 来安装一个应用程序，并且所依赖的库尚未安装，那么该库将会自动被先安装。</p>
</div>
<div class="paragraph">
<p>一个 FreeBSD 软件包包含了一个应用程序的预编译副本，以及任何配置文件和文档。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 命令来操作软件包，例如 <code>pkg install</code>。</p>
</div>
<div class="paragraph">
<p>虽然这两种技术相似，但软件包和 ports 各有各的优势。选择符合您安装特定应用程序需求的技术。</p>
</div>
<div class="ulist">
<div class="title">包的好处</div>
<ul>
<li>
<p>通常，压缩的软件包 tarball 比包含应用程序源代码的压缩 tarball 要小。</p>
</li>
<li>
<p>包不需要编译时间。对于大型应用程序，如 Firefox 、KDE Plasma 或 GNOME，在慢速系统上这一点可能很重要。</p>
</li>
<li>
<p>在 FreeBSD 上编译软件的过程中，包不需要任何理解。</p>
</li>
</ul>
</div>
<div class="ulist">
<div class="title">Port 的好处</div>
<ul>
<li>
<p>通常情况下，软件包会使用保守的选项进行编译，因为它们需要在尽可能多的系统上运行。通过从 ports 进行编译，可以更改编译选项。</p>
</li>
<li>
<p>一些应用程序具有与安装的功能相关的编译时选项。例如，NGINX® 可以配置多种不同的内置选项。</p>
<div class="paragraph">
<p>在某些情况下，为了指定特定的设置，同一个应用程序可能会存在多个软件包。例如，NGINX® 有一个 <code>nginx</code> 软件包和一个 <code>nginx-lite</code> 软件包，取决于是否安装了 Xorg。如果一个应用程序有超过一两个不同的编译选项，创建多个软件包将很快变得不可能。</p>
</div>
</li>
<li>
<p>一些软件的许可条件禁止二进制分发。这类软件必须以源代码的形式分发，并由最终用户进行编译。</p>
</li>
<li>
<p>有些人不信任二进制发行版，或者更喜欢阅读源代码以寻找潜在问题。</p>
</li>
<li>
<p>为了应用自定义补丁，需要提供源代码。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要跟踪更新的 ports ，请订阅 {freebsd-ports} 和 {freebsd-ports-bugs} 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在安装应用程序之前，请检查 <a href="https://vuxml.freebsd.org/" class="bare">https://vuxml.freebsd.org/</a> 是否存在相关的安全问题。</p>
</div>
<div class="paragraph">
<p>要对已安装的软件包进行已知漏洞的审计，请运行 <code>pkg audit -F</code>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本章的其余部分将解释如何使用软件包和 ports 在 FreeBSD 上安装和管理第三方软件。</p>
</div>
</div>
<div class="sect2">
<h3 id="ports-finding-applications">4.3. 寻找软件<a class="anchor" href="#ports-finding-applications"></a></h3>
<div class="paragraph">
<p>FreeBSD 的可用应用程序列表不断增长。有多种方法可以找到要安装的软件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FreeBSD 网站维护着一个最新的可搜索的应用程序列表，位于 <a href="https://www.FreeBSD.org/ports/">Ports Portal</a>。可以通过应用程序名称或软件类别来搜索 ports。</p>
</li>
<li>
<p>Dan Langille 维护着 <a href="https://www.freshports.org/">FreshPorts</a>，该网站提供了一个全面的搜索工具，并跟踪 Ports Collection 中应用程序的变化。注册用户可以创建一个定制的监视列表，以便在所监视的 ports 更新时收到自动邮件通知。</p>
</li>
<li>
<p>如果找到一个特定的应用程序变得困难，可以尝试在 <a href="https://sourceforge.net/">SourceForge</a> 或者 <a href="https://github.com/">GitHub</a> 这样的网站上进行搜索，然后再回到 <a href="https://www.FreeBSD.org/ports/">Ports Portal</a> 查看该应用程序是否已经被移植。</p>
</li>
<li>
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 命令在二进制软件包仓库中搜索一个应用程序</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="pkgng-intro">4.4. 使用 pkg 进行二进制包管理<a class="anchor" href="#pkgng-intro"></a></h3>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 提供了一个用于操作软件包的接口：注册、添加、删除和升级软件包。</p>
</div>
<div class="paragraph">
<p>对于只希望使用 FreeBSD 镜像站点提供的预编译二进制包的网站，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 来管理软件包可能已经足够了。</p>
</div>
<div class="paragraph">
<p>然而，对于那些从源代码构建网站的用户，将需要使用单独的 ports 管理工具。</p>
</div>
<div class="paragraph">
<p>由于 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 只能用于二进制软件包，它并不能替代这些工具。这些工具可以用于安装来自二进制软件包和 Ports Collection 的软件，而 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 只能安装二进制软件包。</p>
</div>
<div class="sect3">
<h4 id="pkgng-initial-setup">4.4.1. 开始使用 pkg<a class="anchor" href="#pkgng-initial-setup"></a></h4>
<div class="paragraph">
<p>所有支持的 FreeBSD 版本现在都包含 <code>/usr/sbin/pkg</code>，也被称为 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=7&amp;format=html">pkg(7)</a> 。这是一个小的占位符，只包含安装真正的 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 所需的最小功能。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在引导过程中，需要一个互联网连接才能成功。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 命令行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>The package management tool is not yet installed on your system.
Do you want to fetch and install it now? [y/N]</pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=7&amp;format=html">pkg(7)</a> 将拦截该命令，如果您确认这是您的意图，将下载 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> tarball ，并从中安装 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a>，引导本地软件包数据库，然后继续运行您最初请求的命令。</p>
</div>
<div class="paragraph">
<p>较新版本的 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=7&amp;format=html">pkg(7)</a> 可以理解 <code>pkg -N</code> 作为一种测试，用于检查是否安装了 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a>，而不触发安装操作。相反，pkg bootstrap[-f] 用于安装 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a>（或强制重新安装），而不执行任何其他操作。</p>
</div>
<div class="paragraph">
<p>可以通过查看 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 手册页面或者在运行 <code>pkg</code> 命令时不添加额外参数来获取 pkg 的使用信息。有关其他 pkg 配置选项的描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> 。</p>
</div>
<div class="paragraph">
<p>每个 pkg 命令参数都在特定命令的手册页中有详细说明。</p>
</div>
<div class="paragraph">
<p>例如，要阅读 <code>pkg install</code> 的手册页，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg help install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>本节的其余部分演示了使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 执行的常见二进制包管理任务。每个演示的命令都提供了许多开关来自定义其使用方式。有关详细信息和更多示例，请参阅命令的帮助或 man 页面。</p>
</div>
</div>
<div class="sect3">
<h4 id="quarterly-latest-branch">4.4.2. 季度和最新的 ports 分支<a class="anchor" href="#quarterly-latest-branch"></a></h4>
<div class="paragraph">
<p><code>Quarterly</code> 分支为用户提供了更可预测和稳定的 ports 和软件包安装和升级体验。这主要通过只允许非功能性更新来实现。季度分支旨在接收安全修复（可能是版本更新或提交的回溯）、错误修复和 ports 合规性或框架更改。季度分支在每年的一月、四月、七月和十月的季度初从 HEAD 中切出。分支的命名方式根据它们创建的年份（YYYY）和季度（Q1-4）。例如， 2023 年 1 月创建的季度分支被命名为 2023Q1。而 <code>Latest</code> 分支为用户提供了软件包的最新版本。</p>
</div>
<div class="paragraph">
<p>要将 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 从季度版切换到最新版，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir -p /usr/local/etc/pkg/repos</span>
<span class="c"># echo &#39;FreeBSD: { url: &#34;pkg+http://pkg.FreeBSD.org/${ABI}/latest&#34; }&#39; &gt; /usr/local/etc/pkg/repos/FreeBSD.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后运行以下命令来更新本地软件包仓库目录，以获取最新分支的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg update -f</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkg-configuration">4.4.3. 配置 pkg<a class="anchor" href="#pkg-configuration"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> 是 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 工具使用的系统级配置文件。该文件的默认位置是 <code>/usr/local/etc/pkg.conf</code>。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>FreeBSD 不需要有 <code>pkg.conf</code> 文件。许多安装可以在没有任何 <code>pkg.conf</code> 文件或只有空的 <code>pkg.conf</code> 文件（除了注释行）的情况下正常工作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以&#34;#&#34;开头的行是注释，会被忽略。</p>
</div>
<div class="paragraph">
<p>该文件采用 UCL 格式。有关 <a href="https://man.freebsd.org/cgi/man.cgi?query=libucl&amp;sektion=3&amp;format=html">libucl(3)</a> 语法的更多信息，请访问 <a href="https://github.com/vstakhov/libucl">official UCL website</a> 。</p>
</div>
<div class="paragraph">
<p>识别以下类型的选项 - 布尔型、字符串型和列表型选项。</p>
</div>
<div class="paragraph">
<p>如果在配置文件中指定了以下值之一 - YES 、TRUE 和 ON，则将布尔选项标记为已启用。</p>
</div>
</div>
<div class="sect3">
<h4 id="pkg-search">4.4.4. 搜索软件包<a class="anchor" href="#pkg-search"></a></h4>
<div class="paragraph">
<p>要搜索一个软件包，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-search&amp;sektion=8&amp;format=html">pkg-search(8)</a> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg search nginx</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>modsecurity3-nginx-1.0.3       Instruction detection and prevention engine / nginx Wrapper
nginx-1.22.1_2,3               Robust and small WWW server
nginx-devel-1.23.2_4           Robust and small WWW server
nginx-full-1.22.1_1,3          Robust and small WWW server (full package)
nginx-lite-1.22.1,3            Robust and small WWW server (lite package)
nginx-naxsi-1.22.1,3           Robust and small WWW server (plus NAXSI)
nginx-prometheus-exporter-0.10.0_7 Prometheus exporter for NGINX and NGINX Plus stats
nginx-ultimate-bad-bot-blocker-4.2020.03.2005_1 Nginx bad bot and other things blocker
nginx-vts-exporter-0.10.7_7    Server that scraps NGINX vts stats and export them via HTTP
p5-Nginx-ReadBody-0.07_1       Nginx embeded perl module to read and evaluate a request body
p5-Nginx-Simple-0.07_1         Perl 5 module for easy to use interface for Nginx Perl Module
p5-Test-Nginx-0.30             Testing modules for Nginx C module development
py39-certbot-nginx-2.0.0       NGINX plugin for Certbot
rubygem-passenger-nginx-6.0.15 Modules for running Ruby on Rails and Rack applications</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkg-installing-fetching">4.4.5. 安装和获取软件包<a class="anchor" href="#pkg-installing-fetching"></a></h4>
<div class="paragraph">
<p>要安装一个二进制软件包，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-install&amp;sektion=8&amp;format=html">pkg-install(8)</a> 命令。该命令使用存储库数据来确定要安装的软件的版本以及是否有未安装的依赖项。例如，要安装 curl ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install curl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following 9 package(s) will be affected (of 0 checked):

New packages to be INSTALLED:
        ca_root_nss: 3.83
        curl: 7.86.0
        gettext-runtime: 0.21
        indexinfo: 0.3.1
        libidn2: 2.3.3
        libnghttp2: 1.48.0
        libpsl: 0.21.1_4
        libssh2: 1.10.0.3
        libunistring: 1.0

Number of packages to be installed: 9

The process will require 11 MiB more space.
3 MiB to be downloaded

Proceed with this action? [y/N]</pre>
</div>
</div>
<div class="paragraph">
<p>新的软件包以及作为依赖项安装的任何其他软件包都可以在已安装软件包列表中看到：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg info</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ca_root_nss-3.83               Root certificate bundle from the Mozilla Project
curl-7.86.0                    Command line tool and library for transferring data with URLs
gettext-runtime-0.21.1         GNU gettext runtime libraries and programs
indexinfo-0.3.1                Utility to regenerate the GNU info page index
libidn2-2.3.3                  Implementation of IDNA2008 internationalized domain names
libnghttp2-1.48.0              HTTP/2.0 C Library
libpsl-0.21.1_6                C library to handle the Public Suffix List
libssh2-1.10.0.3               Library implementing the SSH2 protocol
libunistring-1.0               Unicode string library
pkg-1.18.4                     Package manager</pre>
</div>
</div>
<div class="paragraph">
<p>要获取一个软件包并稍后安装它或在另一个地方安装，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-fetch&amp;sektion=8&amp;format=html">pkg-fetch(8)</a>。例如，要下载 <code>nginx-lite</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg fetch -d -o /usr/home/user/packages/ nginx-lite</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-d</code>：用于获取所有的依赖项</p>
</li>
<li>
<p><code>-o</code>：用于指定下载目录</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Updating FreeBSD repository catalogue...
FreeBSD repository is up to date.
All repositories are up to date.
The following packages will be fetched:

New packages to be FETCHED:
        nginx-lite: 1.22.1,3 (342 KiB: 22.20% of the 2 MiB to download)
        pcre: 8.45_3 (1 MiB: 77.80% of the 2 MiB to download)

Number of packages to be fetched: 2

The process will require 2 MiB more space.
2 MiB to be downloaded.

Proceed with fetching packages? [y/N]:</pre>
</div>
</div>
<div class="paragraph">
<p>要安装下载的软件包，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-install&amp;sektion=8&amp;format=html">pkg-install(8)</a> 命令，具体操作如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/home/user/packages/</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install nginx-lite-1.22.1,3.pkg</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkgng-pkg-info">4.4.6. 获取已安装软件包的信息<a class="anchor" href="#pkgng-pkg-info"></a></h4>
<div class="paragraph">
<p>可以通过运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-info&amp;sektion=8&amp;format=html">pkg-info(8)</a> 来查看系统上安装的软件包的信息。当不带任何开关运行时，它将列出所有已安装软件包或指定软件包的版本信息。</p>
</div>
<div class="paragraph">
<p>例如，要查看已安装的 pkg 版本，请运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg info pkg</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pkg-1.19.0
Name           : pkg
Version        : 1.19.0
Installed on   : Sat Dec 17 11:05:28 2022 CET
Origin         : ports-mgmt/pkg
Architecture   : FreeBSD:13:amd64
Prefix         : /usr/local
Categories     : ports-mgmt
Licenses       : BSD2CLAUSE
Maintainer     : pkg@FreeBSD.org
WWW            : https://github.com/freebsd/pkg
Comment        : Package manager
Options        :
        DOCS           : on
Shared Libs provided:
        libpkg.so.4
Annotations    :
        FreeBSD_version: 1301000
        repo_type      : binary
        repository     : FreeBSD
Flat size      : 33.2MiB
Description    :
Package management tool

WWW: https://github.com/freebsd/pkg</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkgng-upgrading">4.4.7. 升级已安装的软件包<a class="anchor" href="#pkgng-upgrading"></a></h4>
<div class="paragraph">
<p>已安装的软件包可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-upgrade&amp;sektion=8&amp;format=html">pkg-upgrade(8)</a> 命令升级到最新版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg upgrade</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令将比较已安装的版本与存储库目录中可用的版本，并从存储库中升级它们。</p>
</div>
</div>
<div class="sect3">
<h4 id="pkgng-auditing">4.4.8. 审核已安装的软件包<a class="anchor" href="#pkgng-auditing"></a></h4>
<div class="paragraph">
<p>第三方应用程序经常会发现软件漏洞。为了解决这个问题，pkg 包含了一个内置的审计机制。要确定系统上安装的软件是否存在已知的漏洞，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-audit&amp;sektion=8&amp;format=html">pkg-audit(8)</a> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg audit -F</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Fetching vuln.xml.xz: 100%  976 KiB 499.5kB/s    00:02
chromium-108.0.5359.98 is vulnerable:
  chromium -- multiple vulnerabilities
  CVE: CVE-2022-4440
  CVE: CVE-2022-4439
  CVE: CVE-2022-4438
  CVE: CVE-2022-4437
  CVE: CVE-2022-4436
  WWW: https://vuxml.FreeBSD.org/freebsd/83eb9374-7b97-11ed-be8f-3065ec8fd3ec.html</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkg-delete">4.4.9. 移除软件包<a class="anchor" href="#pkg-delete"></a></h4>
<div class="paragraph">
<p>不再需要的软件包可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-delete&amp;sektion=8&amp;format=html">pkg-delete(8)</a> 命令进行删除。</p>
</div>
<div class="paragraph">
<p>例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg delete curl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages (of 0 packages in the universe):

Installed packages to be REMOVED:
        curl :7.86.0

Number of packages to be removed: 1

The operation will free 4 MiB.

Proceed with deinstallation packages? [y/N]: y
[1/1] Deinstalling curl-7.86.0...
[1/1] Deleting files for curl-7.86.0: 100%</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkgng-autoremove">4.4.10. 自动删除未使用的软件包<a class="anchor" href="#pkgng-autoremove"></a></h4>
<div class="paragraph">
<p>删除一个软件包可能会留下不再需要的依赖项。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-autoremove&amp;sektion=8&amp;format=html">pkg-autoremove(8)</a> 自动检测和删除作为依赖项安装的不需要的软件包（叶子软件包）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg autoremove</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Checking integrity... done (0 conflicting)
Deinstallation has been requested for the following 1 packages:

Installed packages to be REMOVED:
        ca_root_nss-3.83

Number of packages to be removed: 1

The operation will free 723 KiB.

Proceed with deinstalling packages? [y/N]:</pre>
</div>
</div>
<div class="paragraph">
<p>作为依赖安装的软件包被称为 <em>自动</em> 软件包。非自动软件包，即明确安装而不是作为其他软件包的依赖项安装的软件包，可以使用以下命令列出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg prime-list</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nginx
openvpn
sudo</pre>
</div>
</div>
<div class="paragraph">
<p><code>pkg prime-list</code> 是在 <code>/usr/local/etc/pkg.conf</code> 中声明的一个别名命令。系统中还有许多其他命令可以用来查询软件包数据库。例如，命令 <code>pkg prime-origins</code> 可以用来获取上述列表的源 ports 目录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg prime-origins</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>www/nginx
security/openvpn
security/sudo</pre>
</div>
</div>
<div class="paragraph">
<p>这个列表可以用于使用构建工具（如 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/">ports-mgmt/poudriere</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/synth/">ports-mgmt/synth</a>）重新构建系统上安装的所有软件包。</p>
</div>
<div class="paragraph">
<p>将已安装的软件包标记为自动安装可以使用以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg set -A 1 devel/cmake</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦一个包是一个叶子包并且被标记为自动安装，它将被 <code>pkg autoremove</code> 命令选择删除。</p>
</div>
<div class="paragraph">
<p>将已安装的软件包标记为 <em>非</em> 自动安装可以使用以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg set -A 0 devel/cmake</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkgng-clean">4.4.11. 移除过期的软件包<a class="anchor" href="#pkgng-clean"></a></h4>
<div class="paragraph">
<p>默认情况下，pkg 将二进制软件包存储在由 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg.conf&amp;sektion=5&amp;format=html">pkg.conf(5)</a> 中的 <code>PKG_CACHEDIR</code> 定义的缓存目录中。只保留最新安装的软件包的副本。旧版本的 pkg 会保留所有先前的软件包。要删除这些过时的二进制软件包，请运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过运行以下命令来清除整个缓存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg clean -a</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkg-locking-unlocking">4.4.12. 锁定和解锁软件包<a class="anchor" href="#pkg-locking-unlocking"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-lock&amp;sektion=8&amp;format=html">pkg-lock(8)</a> 用于锁定包，防止重新安装、修改或删除。<a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-unlock&amp;sektion=8&amp;format=html">pkg-unlock(8)</a> 用于解锁指定的包。无论哪种变体，都只对当前已安装的包产生影响。因此，除非安装新包意味着更新已锁定的包，否则无法通过此机制阻止新包的安装。</p>
</div>
<div class="paragraph">
<p>例如，要锁定 <code>nginx-lite</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg lock nginx-lite</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要解锁 <code>nginx-lite</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg unlock nginx-lite</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="pkgng-set">4.4.13. 修改软件包元数据<a class="anchor" href="#pkgng-set"></a></h4>
<div class="paragraph">
<p>FreeBSD Ports Collection 中的软件可能会经历主版本号的更改。为了解决这个问题，pkg 有一个内置命令来更新软件包的来源。这在某些情况下非常有用，例如，如果 <a class="package" href="https://cgit.freebsd.org/ports/tree/lang/python3/">lang/python3</a> 被重命名为 <a class="package" href="https://cgit.freebsd.org/ports/tree/lang/python311/">lang/python311</a> ，那么 <a class="package" href="https://cgit.freebsd.org/ports/tree/lang/python3/">lang/python3</a> 现在可以表示版本 <code>3.11</code>。</p>
</div>
<div class="paragraph">
<p>要更改上面示例的软件包来源，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg set -o lang/python3:lang/python311</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个例子是，要将 <a class="package" href="https://cgit.freebsd.org/ports/tree/lang/ruby31/">lang/ruby31</a> 更新为 <a class="package" href="https://cgit.freebsd.org/ports/tree/lang/ruby32/">lang/ruby32</a>，运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg set -o lang/ruby31:lang/ruby32</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在更改软件包来源时，重要的是重新安装依赖于已修改来源的软件包。要强制重新安装依赖软件包，请运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install -Rf lang/ruby32</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ports-using">4.5. 使用 Ports 集合<a class="anchor" href="#ports-using"></a></h3>
<div class="paragraph">
<p>Ports Collection 是一组 <code>Makefiles</code>、补丁和描述文件。每组这些文件用于在 FreeBSD 上编译和安装单个应用程序，被称为一个 <em>ports</em>。</p>
</div>
<div class="paragraph">
<p>默认情况下，Ports Collection 本身存储在 <code>/usr/ports</code> 的子目录中。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在安装和使用 Ports Collection 之前，请注意通常不建议使用 Ports Collection 与通过 pkg 提供的二进制软件包一起安装软件。 pkg 默认跟踪 ports 树的季度分支发布，而不是 HEAD 。与季度分支发布中的对应 ports 相比， HEAD 中的 ports 的依赖关系可能不同，这可能导致 pkg 安装的依赖关系与 Ports Collection 中的依赖关系发生冲突。如果必须同时使用 Ports Collection 和 pkg ，请确保您的 Ports Collection 和 pkg 位于相同的 ports 树分支发布上。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Ports 集合包含了软件类别的目录。每个类别中都有针对个别应用程序的子目录。每个应用程序子目录包含一组文件，告诉 FreeBSD 如何编译和安装该程序，称为 <em>ports skeleton</em>。每个 ports 骨架包括以下文件和目录：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><strong>Makefile</strong>：包含指定应用程序如何编译以及其组件应安装在何处的语句。</p>
</li>
<li>
<p><strong>distinfo</strong>：包含构建 ports 所需下载的文件的名称和校验和。</p>
</li>
<li>
<p><strong>files/</strong>：这个目录包含了在 FreeBSD 上编译和安装程序所需的补丁文件。这个目录也可能包含其他用于构建 ports 的文件。</p>
</li>
<li>
<p><strong>pkg-descr</strong>：提供程序的更详细描述。</p>
</li>
<li>
<p><strong>pkg-plist</strong>：一个包含所有将由 ports 安装的文件的列表。它还告诉 ports 系统在卸载时要删除哪些文件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一些 ports 包括 <code>pkg-message</code> 或其他文件来处理特殊情况。有关这些文件以及 ports 的更多详细信息，请参考 <a href="{porters-handbook}">FreeBSD Porter’s Handbook</a>。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ports 不包含实际的源代码，也称为 `distfile` 。构建 ports 的提取部分将自动将下载的源代码保存到 `/usr/ports/distfiles`。</pre>
</div>
</div>
<div class="sect3">
<h4 id="ports-using-installation-methods">4.5.1. 安装 Ports 集合<a class="anchor" href="#ports-using-installation-methods"></a></h4>
<div class="paragraph">
<p>在使用 ports 编译应用程序之前，必须先安装 ports 集合。如果在安装 FreeBSD 时没有安装它，请使用以下方法之一进行安装：</p>
</div>
<div id="ports-using-git-method" class="sidebarblock procedure">
<div class="content">
<div class="paragraph">
<p><strong>过程：Git 方法</strong></p>
</div>
<div class="paragraph">
<p>如果需要对 ports 树进行更多的控制，或者需要维护本地更改，或者正在运行 FreeBSD-CURRENT，可以使用 Git 来获取 Ports Collection。有关 Git 的详细描述，请参阅 <a href="{committers-guide}#git-primer">Git Primer</a>。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在使用 Git 检出 ports 树之前，必须先安装 Git 。如果已经存在一个 ports 树的副本，请按照以下方式安装 Git ：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/devel/git</span>
<span class="c"># make install clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 ports 树不可用，或者正在使用 pkg 来管理软件包，可以将 Git 作为一个软件包安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install git</span></code></pre>
</div>
</div>
</li>
<li>
<p>检出 ports 树的 HEAD 分支的副本：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git clone https://git.FreeBSD.org/ports.git /usr/ports</span></code></pre>
</div>
</div>
</li>
<li>
<p>或者，检出一个季度分支的副本：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git clone https://git.FreeBSD.org/ports.git -b 2023Q1 /usr/ports</span></code></pre>
</div>
</div>
</li>
<li>
<p>在初始的 Git 检出之后，根据需要更新 <code>/usr/ports</code>。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git -C /usr/ports pull</span></code></pre>
</div>
</div>
</li>
<li>
<p>根据需要，将 <code>/usr/ports</code> 切换到不同的季度分支：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git -C /usr/ports switch 2023Q1</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_安装_ports">4.5.2. 安装 Ports<a class="anchor" href="#_安装_ports"></a></h4>
<div class="paragraph">
<p>本节提供了使用 Ports Collection 安装或删除软件的基本说明。有关可用的 <code>make</code> 目标和环境变量的详细描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a>。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在编译任何 ports 之前，请确保按照前一节中的描述更新 Ports Collection。由于安装任何第三方软件都可能引入安全漏洞，建议首先在 <a href="https://vuxml.freebsd.org/" class="bare">https://vuxml.freebsd.org/</a> 上检查与该 ports 相关的已知安全问题。或者，在安装新 ports 之前运行 <code>pkg audit -F</code>。此命令可以配置为在每日安全系统检查期间自动执行安全审计和漏洞数据库的更新。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-audit&amp;sektion=8&amp;format=html">pkg-audit(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用 Ports 集合需要一个正常的互联网连接。它还需要超级用户权限。</p>
</div>
<div class="paragraph">
<p>要编译和安装 ports，请切换到要安装的 ports 的目录，然后在提示符下键入 <code>make install</code>。消息将指示进度：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/sysutils/lsof</span>
<span class="c"># make install</span>
<span class="gp">&gt;&gt; </span>lsof_4.88D.freebsd.tar.gz doesn<span class="s1">&#39;t seem to exist in /usr/ports/distfiles/.
&gt;&gt; Attempting to fetch from ftp://lsof.itap.purdue.edu/pub/tools/unix/lsof/.
===&gt;  Extracting for lsof-4.88
...
[extraction output snipped]
...
&gt;&gt; Checksum OK for lsof_4.88D.freebsd.tar.gz.
===&gt;  Patching for lsof-4.88.d,8
===&gt;  Applying FreeBSD patches for lsof-4.88.d,8
===&gt;  Configuring for lsof-4.88.d,8
...
[configure output snipped]
...
===&gt;  Building for lsof-4.88.d,8
...
[compilation output snipped]
...

===&gt;  Installing for lsof-4.88.d,8
...
[installation output snipped]
...
===&gt;   Generating temporary packing list
===&gt;   Compressing manual pages for lsof-4.88.d,8
===&gt;   Registering installation for lsof-4.88.d,8
===&gt;  SECURITY NOTE:
      This port has installed the following binaries which execute with
      increased privileges.
/usr/local/sbin/lsof
#</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>lsof</code> 是一个以增加权限运行的程序，因此在安装时会显示一个安全警告。安装完成后，提示符将会返回。</p>
</div>
<div class="paragraph">
<p>一些 shell 会在 <code>PATH</code> 环境变量所列目录中保留一个命令缓存，以加快对这些命令可执行文件的查找操作。使用 <code>tcsh</code> shell 的用户应该输入 <code>rehash</code> 命令，以便可以在不指定完整路径的情况下使用新安装的命令。对于 <code>sh</code> shell，请使用 <code>hash -r</code> 命令。有关更多信息，请参阅 shell 的文档。</p>
</div>
<div class="paragraph">
<p>在安装过程中，会创建一个工作子目录，其中包含编译过程中使用的所有临时文件。删除此目录可以节省磁盘空间，并在以后升级到新版本的 ports 时最大程度地减少问题的可能性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make clean</span>
<span class="gp">===&gt;  </span>Cleaning <span class="k">for </span>lsof-88.d,8
<span class="c">#</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了避免这个额外的步骤，编译 ports 时可以使用 <code>make install clean</code>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_自定义_ports_安装">4.5.2.1. 自定义 ports 安装<a class="anchor" href="#_自定义_ports_安装"></a></h5>
<div class="paragraph">
<p>一些 ports 提供构建选项，可以用于启用或禁用应用程序组件，提供安全选项或允许其他自定义。示例包括 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/firefox/">www/firefox</a> 和 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/gpgme/">security/gpgme</a>。如果该 ports 依赖于具有可配置选项的其他 ports，则默认行为是提示用户从菜单中选择选项，因此可能会多次暂停以进行用户交互。为了避免这种情况，并在一个批处理中进行所有配置，请在 ports 骨架中运行 <code>make config-recursive</code>。然后，运行 <code>make install [clean]</code> 来编译和安装该 ports。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当使用 <code>config-recursive</code> 时，要配置的 ports 列表是通过 <code>all-depends-list</code> 目标收集的。建议运行 <code>make config-recursive</code> 直到所有依赖 ports 选项都被定义，并且 ports 选项屏幕不再出现，以确保所有依赖选项都已配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在构建 ports 后，有几种方法可以重新访问 ports 的构建选项菜单，以添加、删除或更改这些选项。一种方法是进入包含 ports 的目录，然后输入 <code>make config</code> 命令。另一种选择是使用 <code>make showconfig</code> 命令。还可以执行 <code>make rmconfig</code> 命令，该命令将删除所有已选择的选项，并允许您重新开始。所有这些选项以及其他选项都在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ports&amp;sektion=7&amp;format=html">ports(7)</a> 中详细解释。</p>
</div>
<div class="paragraph">
<p>ports 系统使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> 来下载源文件，该工具支持各种环境变量。如果 FreeBSD 系统位于防火墙或 FTP/HTTP 代理后面，可能需要设置 <code>FTP_PASSIVE_MODE</code>、<code>FTP_PROXY</code> 和 <code>FTP_PASSWORD</code> 变量。有关支持的变量的完整列表，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=3&amp;format=html">fetch(3)</a>。</p>
</div>
<div class="paragraph">
<p>对于不能始终连接到互联网的用户，可以在 <code>/usr/ports</code> 目录下运行 <code>make fetch</code> 命令，以获取所有的 distfiles，或者在某个分类目录（例如 <code>/usr/ports/net</code>）或特定的 ports 骨架中运行。请注意，如果一个 ports 有任何依赖项，那么在分类目录或 ports 骨架中运行此命令将不会获取来自其他分类的 ports 的 distfiles。相反，使用 <code>make fetch-recursive</code> 命令也可以获取 ports 的所有依赖项的 distfiles。</p>
</div>
<div class="paragraph">
<p>在极少数情况下，例如当组织拥有本地的 distfiles 仓库时，<code>MASTER_SITES</code> 变量可以用于覆盖 <code>Makefile</code> 中指定的下载位置。在使用时，请指定替代位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/directory</span>
<span class="c"># make MASTER_SITE_OVERRIDE= \</span>
ftp://ftp.organization.org/pub/FreeBSD/ports/distfiles/ fetch</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>WRKDIRPREFIX</code> 和 <code>PREFIX</code> 变量可以覆盖默认的工作目录和目标目录。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make WRKDIRPREFIX=/usr/home/example/ports install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 ports 编译在 <code>/usr/home/example/ports</code> 目录下，并将所有内容安装在 <code>/usr/local</code> 目录下。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make PREFIX=/usr/home/example/local install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 ports 编译在 <code>/usr/ports</code> 中，并将其安装在 <code>/usr/home/example/local</code> 中。并且：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make WRKDIRPREFIX=../ports PREFIX=../local install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将两者合并。</p>
</div>
<div class="paragraph">
<p>这些也可以设置为环境变量。请参考您所使用的 shell 的手册页面，了解如何设置环境变量的指令。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ports-removing">4.5.3. 移除已安装的 ports<a class="anchor" href="#ports-removing"></a></h4>
<div class="paragraph">
<p>使用 <code>pkg delete</code> 命令可以卸载已安装的 ports。有关使用此命令的示例，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg-delete&amp;sektion=8&amp;format=html">pkg-delete(8)</a> 手册页。</p>
</div>
<div class="paragraph">
<p>或者，可以在 ports 的目录中运行 <code>make deinstall</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/sysutils/lsof</span>
<span class="c"># make deinstall</span>
<span class="gp">===&gt;  </span>Deinstalling <span class="k">for </span>sysutils/lsof
<span class="gp">===&gt;   </span>Deinstalling
Deinstallation has been requested <span class="k">for </span>the following 1 packages:

	lsof-4.88.d,8

The deinstallation will free 229 kB
<span class="o">[</span>1/1] Deleting lsof-4.88.d,8... <span class="k">done</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>建议在卸载 ports 之前阅读消息。如果该 ports 有任何依赖于它的应用程序，这些信息将被显示，但卸载将继续进行。在这种情况下，重新安装应用程序可能更好，以防止依赖关系破裂。</p>
</div>
</div>
<div class="sect3">
<h4 id="ports-upgrading">4.5.4. 升级 ports<a class="anchor" href="#ports-upgrading"></a></h4>
<div class="paragraph">
<p>随着时间的推移，Ports Collection 中会有更新版本的软件可用。本节介绍了如何确定可以升级的软件以及如何执行升级操作。</p>
</div>
<div class="paragraph">
<p>要确定已安装的 ports 是否有更新版本可用，请确保安装了最新版本的 ports 树，使用在 <a href="#ports-using-git-method">&#34;Git Method&#34;</a> 中描述的更新命令。以下命令将列出已过时的已安装 ports：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg version -l &#34;&lt;&#34;</span></code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在尝试升级之前，请从文件顶部开始阅读 <code>/usr/ports/UPDATING</code>，直到最接近上次升级 ports 或安装系统的日期。该文件描述了在更新 ports 时用户可能遇到的各种问题和需要执行的额外步骤，包括文件格式更改、配置文件位置更改或与先前版本不兼容的任何问题。请注意任何与需要升级的 ports 匹配的说明，并在执行升级时遵循这些说明。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="ports-upgrading-tools">4.5.4.1. 升级和管理 ports 的工具<a class="anchor" href="#ports-upgrading-tools"></a></h5>
<div class="paragraph">
<p>Ports Collection 包含多个实际执行升级的实用工具。每个工具都有其优点和缺点。</p>
</div>
<div class="paragraph">
<p>从历史上看，大多数安装使用的是 Portmaster 或 Portupgrade 。Synth 是一种较新的替代方案。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>选择哪种工具最适合特定系统是由系统管理员决定的。在使用这些工具之前，建议先备份数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="portmaster">4.5.4.2. 使用 Portmaster 升级 Ports<a class="anchor" href="#portmaster"></a></h5>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/">ports-mgmt/portmaster</a> 是一个非常小的工具，用于升级已安装的 ports。它旨在使用安装在 FreeBSD 基本系统中的工具，而不依赖其他 ports 或数据库。要将此实用程序安装为一个 ports：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/ports-mgmt/portmaster</span>
<span class="c"># make install clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Portmaster 定义了四个 ports 的分类：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Root ports：没有依赖项，也不是任何其他 ports 的依赖项。</p>
</li>
<li>
<p>Trunk ports：没有依赖项，但其他 ports 依赖于它。</p>
</li>
<li>
<p>Branch ports：具有依赖关系，其他 ports 依赖于它。</p>
</li>
<li>
<p>Leaf ports：具有依赖关系，但没有其他 ports 依赖于它。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要列出这些类别并搜索更新：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portmaster -L</span>
<span class="gp">===&gt;&gt;&gt; </span>Root ports <span class="o">(</span>No dependencies, not depended on<span class="o">)</span>
<span class="gp">===&gt;&gt;&gt; </span>ispell-3.2.06_18
<span class="gp">===&gt;&gt;&gt; </span>screen-4.0.3
        <span class="o">===</span>&gt;&gt;&gt; New version available: screen-4.0.3_1
<span class="gp">===&gt;&gt;&gt; </span>tcpflow-0.21_1
<span class="gp">===&gt;&gt;&gt; </span>7 root ports
...
<span class="gp">===&gt;&gt;&gt; </span>Branch ports <span class="o">(</span>Have dependencies, are depended on<span class="o">)</span>
<span class="gp">===&gt;&gt;&gt; </span>apache22-2.2.3
        <span class="o">===</span>&gt;&gt;&gt; New version available: apache22-2.2.8
...
<span class="gp">===&gt;&gt;&gt; </span>Leaf ports <span class="o">(</span>Have dependencies, not depended on<span class="o">)</span>
<span class="gp">===&gt;&gt;&gt; </span>automake-1.9.6_2
<span class="gp">===&gt;&gt;&gt; </span>bash-3.1.17
        <span class="o">===</span>&gt;&gt;&gt; New version available: bash-3.2.33
...
<span class="gp">===&gt;&gt;&gt; </span>32 leaf ports

<span class="gp">===&gt;&gt;&gt; </span>137 total installed ports
        <span class="o">===</span>&gt;&gt;&gt; 83 have new versions available</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个命令用于升级所有过时的 ports：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portmaster -a</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下，Portmaster 在删除现有 ports 之前会创建一个备份包。如果新版本的安装成功，Portmaster 会删除备份。使用 <code>-b</code> 指令可以让 Portmaster 不自动删除备份。添加 <code>-i</code> 可以启动 Portmaster 的交互模式，在升级每个 ports 之前提示确认。还有许多其他选项可用。请阅读 <a href="https://man.freebsd.org/cgi/man.cgi?query=portmaster&amp;sektion=8&amp;format=html">portmaster(8)</a> 的手册页面，了解有关它们使用的详细信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果在升级过程中遇到错误，请在升级和重建所有 ports 时添加 <code>-f</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portmaster -af</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Portmaster 还可以用于在系统上安装新的 ports，在构建和安装新的 ports 之前升级所有依赖项。要使用此功能，请指定 Ports Collection 中 ports 的位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portmaster shells/bash</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/">ports-mgmt/portmaster</a> 的更多信息可以在其 <code>pkg-descr</code> 中找到。</p>
</div>
</div>
<div class="sect4">
<h5 id="portupgrade">4.5.4.3. 使用 Portupgrade 升级 ports<a class="anchor" href="#portupgrade"></a></h5>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/">ports-mgmt/portupgrade</a> 是另一个可以用来升级 ports 的实用工具。它安装了一套可以用来管理 ports 的应用程序。然而，它依赖于 Ruby。要安装该 ports：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/ports-mgmt/portupgrade</span>
<span class="c"># make install clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用此工具进行升级之前，建议使用 <code>pkgdb -F</code> 扫描已安装的 ports 列表，并修复它报告的所有不一致性。</p>
</div>
<div class="paragraph">
<p>要升级系统上安装的所有过时 ports，请使用 <code>portupgrade -a</code>。或者，加入 <code>-i</code> 以便在每次单独升级时要求确认：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portupgrade -ai</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要升级指定的应用程序而不是所有可用的 ports，请使用 <code>portupgrade <em>pkgname</em></code>。非常重要的是要包括 <code>-R</code> 选项，以先升级给定应用程序所需的所有 ports：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portupgrade -R firefox</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果包含了 <code>-P</code> 选项，Portupgrade 会在 <code>PKG_PATH</code> 列出的本地目录中搜索可用的软件包。如果本地没有可用的软件包，它会从远程站点获取软件包。如果无法在本地或远程获取软件包，Portupgrade 将使用 ports。为了完全避免使用 ports，可以指定 <code>-PP</code> 选项。最后一组选项告诉 Portupgrade 如果没有可用的软件包则中止操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portupgrade -PP gnome3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果指定了 <code>-P</code>，只需获取 ports distfiles 或软件包，而不需要构建或安装任何内容，请使用 <code>-F 。有关所有可用开关的更多信息，请参阅 `portupgrade</code> 的手册页。</p>
</div>
<div class="paragraph">
<p>有关 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/portupgrade/">ports-mgmt/portupgrade</a> 的更多信息可以在其 <code>pkg-descr</code> 中找到。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="ports-disk-space">4.5.5. ports 和磁盘空间<a class="anchor" href="#ports-disk-space"></a></h4>
<div class="paragraph">
<p>使用 Ports Collection 会随着时间的推移占用磁盘空间。在构建和安装 ports 之后，在 ports 骨架中运行 <code>make clean</code> 将清理临时的 <code>work</code> 目录。如果使用 Portmaster 安装 ports，它会自动删除此目录，除非指定了 <code>-K</code> 选项。如果安装了 Portupgrade，此命令将删除在本地 Ports Collection 副本中找到的所有 <code>work</code> 目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portsclean -C</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此外，随着时间的推移，过时的源代码分发文件会在 <code>/usr/ports/distfiles</code> 中累积。要使用 Portupgrade 删除所有不再被任何 ports 引用的分发文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portsclean -D</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Portupgrade 可以删除系统上当前未安装任何 ports 引用的所有 distfiles 文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portsclean -DD</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果已安装 Portmaster，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portmaster --clean-distfiles</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，该命令是交互式的，并提示用户确认是否删除 distfile。</p>
</div>
<div class="paragraph">
<p>除了这些命令之外，<a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/pkg_cutleaves/">ports-mgmt/pkg_cutleaves</a> 还可以自动化删除不再需要的已安装 ports 的任务。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ports-poudriere">4.6. 使用 poudriere 构建软件包<a class="anchor" href="#ports-poudriere"></a></h3>
<div class="paragraph">
<p>poudriere 是一个使用 BSD 许可证的实用工具，用于创建和测试 FreeBSD 软件包。它使用 FreeBSD jails 来设置隔离的编译环境。这些 jails 可以用于为与安装它的系统不同的 FreeBSD 版本构建软件包，也可以用于在主机是 amd64 系统的情况下构建 i386 的软件包。一旦软件包构建完成，它们的布局与官方镜像完全相同。这些软件包可以被 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 和其他软件包管理工具使用。</p>
</div>
<div class="paragraph">
<p>poudriere 是使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/">ports-mgmt/poudriere</a> 包或 ports 进行安装的。安装过程中包含一个示例配置文件 <code>/usr/local/etc/poudriere.conf.sample</code>。将此文件复制到 <code>/usr/local/etc/poudriere.conf</code>。编辑复制的文件以适应本地配置。</p>
</div>
<div class="paragraph">
<p>虽然在运行 poudriere 的系统上不需要 <code>ZFS</code>，但它是有益的。当使用 <code>ZFS</code> 时，必须在 <code>/usr/local/etc/poudriere.conf</code> 中指定 <code>ZPOOL</code>，并将 <code>FREEBSD_HOST</code> 设置为附近的镜像。定义 <code>CCACHE_DIR</code> 可以启用 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/devel/ccache/">devel/ccache</a></code> 来缓存编译并减少频繁编译代码的构建时间。将 poudriere 数据集放在挂载在 <code>/poudriere</code> 的隔离树中可能很方便。其他配置值的默认设置是足够的。</p>
</div>
<div class="paragraph">
<p>检测到的处理器核心数量用于定义并行运行的构建数量。请提供足够的虚拟内存，可以是 RAM 或者交换空间。如果虚拟内存耗尽，编译环境将停止并被销毁，导致出现奇怪的错误信息。</p>
</div>
<div class="sect3">
<h4 id="poudriere-initialization">4.6.1. 初始化 Jails 和 Port Trees<a class="anchor" href="#poudriere-initialization"></a></h4>
<div class="paragraph">
<p>配置完成后，初始化 poudriere，以便安装一个包含所需 FreeBSD 树和 ports 树的 jail。使用 <code>-j</code> 指定 jail 的名称，并使用 <code>-v</code> 指定 FreeBSD 版本。在运行 FreeBSD/amd64 的系统上，可以使用 <code>-a</code> 将架构设置为 <code>i386</code> 或 <code>amd64</code>。默认架构为 <code>uname</code> 显示的架构。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># poudriere jail -c -j 13amd64 -v 13.1-RELEASE</span>
<span class="o">[</span>00:00:00] Creating 13amd64 fs at /poudriere/jails/13amd64... <span class="k">done</span>
<span class="o">[</span>00:00:00] Using pre-distributed MANIFEST <span class="k">for </span>FreeBSD 13.1-RELEASE amd64
<span class="o">[</span>00:00:00] Fetching base <span class="k">for </span>FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/base.txz              125 MB 4110 kBps    31s
<span class="o">[</span>00:00:33] Extracting base... <span class="k">done</span>
<span class="o">[</span>00:00:54] Fetching src <span class="k">for </span>FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/src.txz               154 MB 4178 kBps    38s
<span class="o">[</span>00:01:33] Extracting src... <span class="k">done</span>
<span class="o">[</span>00:02:31] Fetching lib32 <span class="k">for </span>FreeBSD 13.1-RELEASE amd64
/poudriere/jails/13amd64/fromftp/lib32.txz              24 MB 3969 kBps    06s
<span class="o">[</span>00:02:38] Extracting lib32... <span class="k">done</span>
<span class="o">[</span>00:02:42] Cleaning up... <span class="k">done</span>
<span class="o">[</span>00:02:42] Recording filesystem state <span class="k">for </span>clean... <span class="k">done</span>
<span class="o">[</span>00:02:42] Upgrading using ftp
/etc/resolv.conf -&gt; /poudriere/jails/13amd64/etc/resolv.conf
Looking up update.FreeBSD.org mirrors... 3 mirrors found.
Fetching public key from update4.freebsd.org... <span class="k">done</span>.
Fetching metadata signature <span class="k">for </span>13.1-RELEASE from update4.freebsd.org... <span class="k">done</span>.
Fetching metadata index... <span class="k">done</span>.
Fetching 2 metadata files... <span class="k">done</span>.
Inspecting system... <span class="k">done</span>.
Preparing to download files... <span class="k">done</span>.
Fetching 124 patches.....10....20....30....40....50....60....70....80....90....100....110....120.. <span class="k">done</span>.
Applying patches... <span class="k">done</span>.
Fetching 6 files... <span class="k">done</span>.
The following files will be added as part of updating to
13.1-RELEASE-p1:
/usr/src/contrib/unbound/.github
/usr/src/contrib/unbound/.github/FUNDING.yml
/usr/src/contrib/unbound/contrib/drop2rpz
/usr/src/contrib/unbound/contrib/unbound_portable.service.in
/usr/src/contrib/unbound/services/rpz.c
/usr/src/contrib/unbound/services/rpz.h
/usr/src/lib/libc/tests/gen/spawnp_enoexec.sh
The following files will be updated as part of updating to
13.1-RELEASE-p1:
<span class="o">[</span>…]
Installing updates...Scanning //usr/share/certs/blacklisted <span class="k">for </span>certificates...
Scanning //usr/share/certs/trusted <span class="k">for </span>certificates...
 <span class="k">done</span>.
13.1-RELEASE-p1
<span class="o">[</span>00:04:06] Recording filesystem state <span class="k">for </span>clean... <span class="k">done</span>
<span class="o">[</span>00:04:07] Jail 13amd64 13.1-RELEASE-p1 amd64 is ready to be used</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># poudriere ports -c -p local -m git+https</span>
<span class="o">[</span>00:00:00] Creating <span class="nb">local </span>fs at /poudriere/ports/local... <span class="k">done</span>
<span class="o">[</span>00:00:00] Checking out the ports tree... <span class="k">done</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在一台计算机上，poudriere 可以使用多个配置，在多个 jail 中，从不同的 ports 树构建 ports。这些组合的自定义配置被称为 <em>集合</em>。在安装了 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere/">ports-mgmt/poudriere</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/poudriere-devel/">ports-mgmt/poudriere-devel</a> 之后，可以查看 <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> 的 CUSTOMIZATION 部分获取详细信息。</p>
</div>
<div class="paragraph">
<p>这里显示的基本配置将一个单独的 jail、 port 和 set 特定的 <code>make.conf</code> 放置在 <code>/usr/local/etc/poudriere.d</code> 目录下。在这个示例中，文件名是通过组合 jail 名称、 port 名称和 set 名称创建的：<code>13amd64-local-workstation-make.conf</code>。系统的 <code>make.conf</code> 和这个新文件在构建时会合并，以创建构建 jail 使用的 <code>make.conf</code> 文件。</p>
</div>
<div class="paragraph">
<p>要构建的软件包应该在 <code>13amd64-local-workstation-pkglist</code> 文件中输入（具有 @FLAVOR 的 <a href="{porters-handbook}flavors">FLAVORS</a> 的 ports 可以定义）。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>editors/emacs
devel/git
devel/php-composer2@php82
ports-mgmt/pkg
...</pre>
</div>
</div>
<div class="paragraph">
<p>已配置指定 ports 的选项和依赖项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># poudriere options -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，构建软件包并创建软件包仓库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># poudriere bulk -j 13amd64 -p local -z workstation -f 13amd64-local-workstation-pkglist</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在运行过程中，按下 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>t</kbd></span> 键可以显示构建的当前状态。poudriere 还会在 <code>/poudriere/logs/bulk/jailname</code> 目录中构建文件，可以与 Web 服务器一起使用以显示构建信息。</p>
</div>
<div class="paragraph">
<p>完成后，新的软件包现在可以从 poudriere 仓库进行安装。</p>
</div>
<div class="paragraph">
<p>有关使用 poudriere 的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=poudriere&amp;sektion=8&amp;format=html">poudriere(8)</a> 和主要网站 <a href="https://github.com/freebsd/poudriere/wiki" class="bare">https://github.com/freebsd/poudriere/wiki</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置_pkg_客户端以使用_poudriere_仓库">4.6.2. 配置 pkg 客户端以使用 poudriere 仓库<a class="anchor" href="#_配置_pkg_客户端以使用_poudriere_仓库"></a></h4>
<div class="paragraph">
<p>虽然可以同时使用自定义仓库和官方仓库，但有时禁用官方仓库是有用的。这可以通过创建一个配置文件来覆盖和禁用官方配置文件来实现。创建 <code>/usr/local/etc/pkg/repos/FreeBSD.conf</code> 文件，其中包含以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>FreeBSD: {
	enabled: no
}</pre>
</div>
</div>
<div class="paragraph">
<p>通常，通过 HTTP 将 poudriere 仓库提供给客户机最为简单。设置一个 web 服务器来提供软件包目录，例如： <code>/usr/local/poudriere/data/packages/13amd64</code>，其中 <code>13amd64</code> 是构建的名称。</p>
</div>
<div class="paragraph">
<p>如果软件包仓库的 URL 是：<code><a href="http://pkg.example.com/13amd64" class="bare">http://pkg.example.com/13amd64</a></code>，那么位于 <code>/usr/local/etc/pkg/repos/custom.conf</code> 的仓库配置文件将如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>custom: {
	url: &#34;http://pkg.example.com/13amd64&#34;,
	enabled: yes,
}</pre>
</div>
</div>
<div class="paragraph">
<p>如果不希望将软件包仓库暴露在互联网上，可以使用 <code>file://</code> 协议直接指向仓库：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>custom: {
	url: &#34;file:///usr/local/poudriere/data/packages/11amd64&#34;,
	enabled: yes,
}</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ports-nextsteps">4.7. 安装后的考虑事项<a class="anchor" href="#ports-nextsteps"></a></h3>
<div class="paragraph">
<p>无论软件是从二进制包还是 ports 安装的，大多数第三方应用程序在安装后都需要进行一定程度的配置。以下命令和位置可用于帮助确定应用程序安装了什么。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>大多数应用程序都会在 <code>/usr/local/etc</code> 目录下安装至少一个默认配置文件。在应用程序有大量配置文件的情况下，会创建一个子目录来存放它们。通常，会安装一些以 <code>.sample</code> 后缀结尾的示例配置文件。应该审查并可能编辑这些配置文件以满足系统的需求。要编辑示例文件，首先将其复制并去掉 <code>.sample</code> 扩展名。</p>
</li>
<li>
<p>提供文档的应用程序会将文档安装到 <code>/usr/local/share/doc</code> 目录下，许多应用程序还会安装手册页。在继续之前，应该先查阅这些文档。</p>
</li>
<li>
<p>一些应用程序运行的服务在启动应用程序之前必须添加到 <code>/etc/rc.conf</code> 中。这些应用程序通常会在 <code>/usr/local/etc/rc.d</code> 中安装一个启动脚本。有关更多信息，请参阅 <a href="./#configtuning-starting-services">启动服务</a>。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根据设计，应用程序在安装时不会运行启动脚本，也不会在卸载或升级时运行停止脚本。这个决定留给了个别系统管理员来决定。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> 的用户应该运行 <code>rehash</code> 命令来重新构建 shell 的 <code>PATH</code> 中已知的二进制文件列表。</p>
</li>
<li>
<p>使用 <code>pkg info</code> 命令来确定应用程序安装了哪些文件、man 页面和二进制文件。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="ports-broken">4.8. 处理损坏的 ports<a class="anchor" href="#ports-broken"></a></h3>
<div class="paragraph">
<p>当 ports 无法构建或安装时，请尝试以下操作：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>搜索一下 <a href="https://www.FreeBSD.org/support/">Problem Report database</a> 中的 ports 是否有待修复的问题报告。如果有的话，实施建议的修复可能会解决这个问题。</p>
</li>
<li>
<p>向 ports 的维护者寻求帮助。在 ports 骨架中键入 <code>make maintainer</code>，或者阅读 ports 的 <code>Makefile</code> 以找到维护者的电子邮件地址。记得在发送给维护者的电子邮件中包含错误之前的输出。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些 ports 不是由个人维护，而是由一个由邮件列表表示的团队维护者维护。其中许多（但不是全部）地址看起来像 <a href="mailto:freebsd-listname@FreeBSD.org">freebsd-listname@FreeBSD.org</a>。在发送电子邮件时，请考虑这一点。</p>
</div>
<div class="paragraph">
<p>特别是，由 <a href="mailto:ports@FreeBSD.org">ports@FreeBSD.org</a> 维护的 ports 不由特定个人维护。相反，任何修复和支持都来自订阅该邮件列表的广大社区。我们始终需要更多的志愿者！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果没有收到邮件回复，请按照 <a href="{problem-reports}#编写 FreeBSD 问题报告">Writing FreeBSD Problem Reports</a> 中的说明，使用 Bugzilla 提交错误报告。</p>
</div>
</li>
<li>
<p>修复它！ <a href="{porters-handbook}">Porter’s Handbook</a> 包含了有关 ports 基础设施的详细信息，以便您可以修复偶尔出现的损坏 ports，甚至提交您自己的 ports！</p>
</li>
<li>
<p>按照 <a href="#pkgng-intro">使用 pkg 进行二进制包管理</a> 中的说明安装软件包，而不是使用 ports。</p>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="x11">Chapter 5. X Window System （X  Window系统）<a class="anchor" href="#x11"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="x11-synopsis">5.1. 简介<a class="anchor" href="#x11-synopsis"></a></h3>
<div class="paragraph">
<p>使用 bsdinstall 安装 FreeBSD 时，不会自动安装图形用户界面。本章介绍了如何安装和配置 Xorg，它提供了用于提供图形环境的开源 X Window 系统。然后，它描述了如何查找和安装桌面环境或窗口管理器。</p>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根据 <a href="./#ports">安装应用程序：软件包和 Ports</a> 中描述的方法，了解如何安装额外的第三方软件。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>X Window 系统的各个组件以及它们之间的相互操作。</p>
</li>
<li>
<p>如何安装和配置 Xorg。</p>
</li>
<li>
<p>如何在 Xorg 中使用 TrueType® 字体。</p>
</li>
<li>
<p>如何设置系统以进行图形登录（XDM）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="x-install">5.2. 安装 Xorg<a class="anchor" href="#x-install"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 上，Xorg 可以作为一个软件包或者端口进行安装。</p>
</div>
<div class="paragraph">
<p>二进制元包可以快速安装，但自定义选项较少：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install xorg</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>任何一种安装方式都会导致完整的 Xorg 系统被安装。</p>
</div>
<div class="paragraph">
<p>当前用户必须是 <code>video</code> 组的成员。要将用户添加到 <code>video</code> 组中，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupmod video -m username</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>适用于有经验的用户的 X 系统的较小版本可在包： x11/xorg-minimal[] 中获得。大多数文档、库和应用程序将不会被安装。某些应用程序需要这些额外的组件才能正常运行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>视频卡、显示器和输入设备会被自动检测，不需要任何手动配置。除非自动配置失败，否则不要创建 <code>xorg.conf</code> 文件或运行 <code>-configure</code> 步骤。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="x-graphic-card-drivers">5.3. 显卡驱动程序<a class="anchor" href="#x-graphic-card-drivers"></a></h3>
<div class="paragraph">
<p>下表显示了 FreeBSD 支持的不同图形卡，应安装的软件包及其对应的模块。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 7. 图形卡套件</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">品牌</th>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">包</th>
<th class="tableblock halign-left valign-top">模块</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Intel®</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">drm-kmod</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>i915kms</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AMD®</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">drm-kmod</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>amdgpu</code> 和 <code>radeonkms</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NVIDIA®</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">专有的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">nvidia-driver</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nvidia</code> 或 <code>nvidia-modeset</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VESA</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xf86-video-vesa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">vesa</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SCFB</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xf86-video-scfb</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">scfb</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VirtualBox®</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">virtualbox-ose-additions</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VirtualBox® OSE 增加了 <code>vboxvideo</code> 驱动程序。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VMware®</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">开源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">xf86-video-vmware</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">vmwgfx</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以使用以下命令来识别系统中安装的图形卡：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>pciconf -lv|grep -B4 VGA</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vgapci0@pci0:0:2:0:     class=0x030000 rev=0x07 hdr=0x00 vendor=0x8086 device=0x2a42 subvendor=0x17aa subdevice=0x20e4
    vendor     = &#39;Intel Corporation&#39;
    device     = &#39;Mobile 4 Series Chipset Integrated Graphics Controller&#39;
    class      = display
    subclass   = VGA</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果显卡不受 Intel®、AMD® 或 NVIDIA® 驱动程序支持，则应使用 VESA 或 SCFB 模块。在 BIOS 模式下启动时必须使用 VESA 模块，在 UEFI 模式下启动时必须使用 SCFB 模块。</p>
</div>
<div class="paragraph">
<p>这个命令可以用来检查启动模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl machdep.bootmethod</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>machdep.bootmethod: BIOS</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="x-configuration-intel">5.3.1. Intel®<a class="anchor" href="#x-configuration-intel"></a></h4>
<div class="paragraph">
<p>Intel® Graphics 指的是与 Intel® CPU 集成在同一芯片上的图形芯片类别。维基百科提供了 <a href="https://en.wikipedia.org/wiki/List_of_Intel_graphics_processing_units">一个关于 Intel HD Graphics 各个世代的变体和命名的良好概述</a> 。</p>
</div>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/">graphics/drm-kmod</a> 包间接提供了一系列用于 Intel® 图形卡的内核模块。可以通过执行以下命令来安装 Intel® 驱动程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install drm-kmod</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将该模块添加到 <code>/etc/rc.conf</code> 文件中，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kld_list+=i915kms</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果注意到高 CPU 使用率或高清视频出现过多的撕裂现象，安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/multimedia/libva-intel-driver/">multimedia/libva-intel-driver</a> 可能会有所帮助。要安装该软件包，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install libva-intel-driver mesa-libs mesa-dri</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="x-configuration-amd">5.3.2. AMD®<a class="anchor" href="#x-configuration-amd"></a></h4>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/">graphics/drm-kmod</a> 包间接提供了一系列用于 AMD® 图形卡的内核模块。根据硬件的代数，可以使用 <code>amdgpu</code> 和 <code>radeonkms</code> 模块。FreeBSD 项目维护了一个 <a href="https://wiki.freebsd.org/Graphics/AMD-GPU-Matrix">AMD 图形支持矩阵</a>，以确定必须使用哪个驱动程序。</p>
</div>
<div class="paragraph">
<p>可以通过执行以下命令来安装 AMD® 驱动程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install drm-kmod</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 HD7000 系列或 Tahiti 显卡，请将模块添加到 <code>/etc/rc.conf</code> 文件中，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kld_list+=amdgpu</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于较旧的图形卡（HD7000 之前或 Tahiti 之前，请将模块添加到 <code>/etc/rc.conf</code> 文件中，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kld_list+=radeonkms</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x-configuration-nvidia">5.3.3. NVIDIA®<a class="anchor" href="#x-configuration-nvidia"></a></h4>
<div class="paragraph">
<p>FreeBSD 支持不同版本的专有 NVIDIA® 驱动程序。使用较新的显卡的用户应安装包： x11/nvidia-driver[]。那些使用较旧显卡的用户需要查看下面支持它们的版本。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 8. 支持的 NVIDIA® 驱动程序版本</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">包</th>
<th class="tableblock halign-left valign-top">支持的硬件</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/nvidia-driver-304</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.nvidia.com/Download/driverResults.aspx/123712/en-us/">支持的硬件</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/nvidia-driver-340</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.nvidia.com/Download/driverResults.aspx/156167/en-us/">支持的硬件</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/nvidia-driver-390</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.nvidia.com/Download/driverResults.aspx/191122/en-us/">支持的硬件</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/nvidia-driver-470</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.nvidia.com/Download/driverResults.aspx/194639/en-us/">支持的硬件</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/nvidia-driver</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.nvidia.com/Download/driverResults.aspx/210651/en-us/">支持的硬件</a></p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>NVIDIA® 图形驱动程序的 304 版本（nvidia-driver-304）不支持 xorg-server 1.20 或更高版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最新的 NVIDIA® 驱动程序可以通过运行以下命令进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install nvidia-driver</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将该模块添加到 <code>/etc/rc.conf</code> 文件中，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kld_list+=nvidia-modeset</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果安装了 x11/nvidia-driver-304 或 x11/nvidia-driver-340 软件包，则必须使用 <code>nvidia</code> 驱动程序。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kld_list+=nvidia</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x-config">5.4. Xorg 配置<a class="anchor" href="#x-config"></a></h3>
<div class="paragraph">
<p>Xorg 支持大多数常见的视频卡、键盘和指针设备。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>视频卡、显示器和输入设备会被自动检测，不需要任何手动配置。除非自动配置失败，否则不要创建 <span class="filename">xorg.conf</span> 文件或运行 <code>Xorg -configure</code> 步骤。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="x-config-files">5.4.1. 配置文件<a class="anchor" href="#x-config-files"></a></h4>
<div class="paragraph">
<p>Xorg 在多个目录中查找配置文件。在 FreeBSD 上，推荐使用目录 <code>/usr/local/etc/X11/</code> 来存放这些文件。使用这个目录可以将应用程序文件与操作系统文件分开。</p>
</div>
</div>
<div class="sect3">
<h4 id="x-config-files-single-or-multi">5.4.2. 单个文件或多个文件<a class="anchor" href="#x-config-files-single-or-multi"></a></h4>
<div class="paragraph">
<p>使用多个文件来配置特定设置比传统的单个 <span class="filename">xorg.conf</span> 文件更容易。这些文件存储在 <span class="filename">/usr/local/etc/X11/xorg.conf.d/</span> 子目录中。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>传统的单一 <span class="filename">xorg.conf</span> 仍然有效，但是与位于 <span class="filename">/usr/local/etc/X11/xorg.conf.d/</span> 子目录中的多个文件相比，既不清晰也不灵活。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="x-config-video-cards">5.4.3. 视频卡<a class="anchor" href="#x-config-video-cards"></a></h4>
<div class="paragraph">
<p>图形卡的驱动程序可以在 <span class="filename">/usr/local/etc/X11/xorg.conf.d/</span> 目录中指定。</p>
</div>
<div class="paragraph">
<p>要在配置文件中配置 Intel® 驱动程序：</p>
</div>
<div id="x-config-video-cards-file-intel" class="exampleblock">
<div class="title">例 14. 在文件中选择 Intel® 视频驱动程序</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/20-intel.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;intel&#34;
EndSection</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在配置文件中配置 AMD® 驱动程序：</p>
</div>
<div id="x-config-video-cards-file-amd" class="exampleblock">
<div class="title">例 15. 在文件中选择 AMD® 视频驱动程序</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/20-radeon.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;radeon&#34;
EndSection</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在配置文件中配置 NVIDIA® 驱动程序：</p>
</div>
<div id="x-config-video-cards-file-nvidia" class="exampleblock">
<div class="title">例 16. 在文件中选择 NVIDIA® 视频驱动程序</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/20-nvidia.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;nvidia&#34;
EndSection</pre>
</div>
</div>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/x11/nvidia-xconfig/">x11/nvidia-xconfig</a> 也可以用来对 NVIDIA 驱动程序中可用的配置选项进行基本控制。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要在配置文件中配置 VESA 驱动程序：</p>
</div>
<div id="x-config-video-cards-file-vesa" class="exampleblock">
<div class="title">例 17. 在文件中选择 VESA 视频驱动程序</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/20-vesa.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;vesa&#34;
EndSection</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要在配置文件中配置 SCFB 驱动程序：</p>
</div>
<div id="x-config-video-cards-file-sfcb" class="exampleblock">
<div class="title">例 18. 在文件中选择 SCFB 视频驱动程序</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/20-scfb.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;scfb&#34;
EndSection</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要配置多个视频卡，可以添加 <code>BusID</code>。执行以下命令可以显示视频卡总线 <code>ID</code> 的列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>pciconf -lv | grep -B3 display</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vgapci0@pci0:0:2:0:     class=0x030000 rev=0x07 hdr=0x00 vendor=0x8086 device=0x2a42 subvendor=0x17aa subdevice=0x20e4
    vendor     = &#39;Intel Corporation&#39;
    device     = &#39;Mobile 4 Series Chipset Integrated Graphics Controller&#39;
    class      = display
--
vgapci1@pci0:0:2:1:     class=0x038000 rev=0x07 hdr=0x00 vendor=0x8086 device=0x2a43 subvendor=0x17aa subdevice=0x20e4
    vendor     = &#39;Intel Corporation&#39;
    device     = &#39;Mobile 4 Series Chipset Integrated Graphics Controller&#39;
    class      = display</pre>
</div>
</div>
<div id="x-config-video-cards-file-multiple" class="exampleblock">
<div class="title">例 19. 在一个文件中选择 Intel® 视频驱动程序和 NVIDIA® 视频驱动程序。</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/20-drivers.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;intel&#34;
	BusID     &#34;pci0:0:2:0&#34;
EndSection

Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver     &#34;nvidia&#34;
	BusID     &#34;pci0:0:2:1&#34;
EndSection</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x-config-monitors">5.4.4. 显示器<a class="anchor" href="#x-config-monitors"></a></h4>
<div class="paragraph">
<p>几乎所有的显示器都支持扩展显示识别数据标准（<code>EDID</code>）。Xorg 使用 <code>EDID</code> 与显示器进行通信，检测支持的分辨率和刷新率，然后选择最合适的设置组合来与该显示器配合使用。</p>
</div>
<div class="paragraph">
<p>可以通过在配置文件中设置所需的分辨率，或在启动 X 服务器后使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 来选择显示器支持的其他分辨率。</p>
</div>
<div class="sect4">
<h5 id="x-config-monitors-xrandr">5.4.4.1. 使用 RandR (Resize and Rotate)<a class="anchor" href="#x-config-monitors-xrandr"></a></h5>
<div class="paragraph">
<p>运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 命令，不带任何参数，可以查看视频输出和检测到的显示器模式列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>xrandr</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Screen 0: minimum 320 x 200, current 2560 x 960, maximum 8192 x 8192
LVDS-1 connected 1280x800+0+0 (normal left inverted right x axis y axis) 261mm x 163mm
   1280x800      59.99*+  59.81    59.91    50.00
   1280x720      59.86    59.74
   1024x768      60.00
   1024x576      59.90    59.82
   960x540       59.63    59.82
   800x600       60.32    56.25
   864x486       59.92    59.57
   640x480       59.94
   720x405       59.51    58.99
   640x360       59.84    59.32
VGA-1 connected primary 1280x960+1280+0 (normal left inverted right x axis y axis) 410mm x 257mm
   1280x1024     75.02    60.02
   1440x900      74.98    60.07
   1280x960      60.00*
   1280x800      74.93    59.81
   1152x864      75.00
   1024x768      75.03    70.07    60.00
   832x624       74.55
   800x600       72.19    75.00    60.32    56.25
   640x480       75.00    72.81    66.67    59.94
   720x400       70.08
HDMI-1 disconnected (normal left inverted right x axis y axis)
DP-1 disconnected (normal left inverted right x axis y axis)
HDMI-2 disconnected (normal left inverted right x axis y axis)
DP-2 disconnected (normal left inverted right x axis y axis)
DP-3 disconnected (normal left inverted right x axis y axis)</pre>
</div>
</div>
<div class="paragraph">
<p>这表明 <code>VGA-1</code> 输出正在用于显示分辨率为 1280x960 像素、刷新率约为 60 Hz 的屏幕。<code>LVDS-1</code> 被用作辅助显示器，显示分辨率为 1280x800 像素、刷新率约为 60 Hz 的屏幕。<code>HDMI-1</code>、<code>HDMI-2</code>、<code>DP-1</code>、<code>DP-2</code> 和 <code>DP-3</code> 连接器上没有连接显示器。</p>
</div>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=xrandr&amp;sektion=1&amp;format=html">xrandr(1)</a> 选择任何其他的显示模式。例如，要切换到 1280x1024 分辨率，刷新率为 60 Hz ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>xrandr --output LVDS-1 --mode 1280x720 --rate 60</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="x-config-monitors-files">5.4.4.2. 使用 Xorg 配置文件<a class="anchor" href="#x-config-monitors-files"></a></h5>
<div class="paragraph">
<p>监视器配置也可以在配置文件中进行设置。</p>
</div>
<div class="paragraph">
<p>在配置文件中设置屏幕分辨率为 1024x768 ：</p>
</div>
<div class="exampleblock">
<div class="title">例 20. 在文件中设置屏幕分辨率</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/10-monitor.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Screen&#34;
	Identifier &#34;Screen0&#34;
	Device     &#34;Card0&#34;
	SubSection &#34;Display&#34;
	Modes      &#34;1024x768&#34;
	EndSubSection
EndSection</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="x-config-input">5.4.5. 输入设备<a class="anchor" href="#x-config-input"></a></h4>
<div class="paragraph">
<p>Xorg 通过 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11/libinput/">x11/libinput</a> 支持绝大部分输入设备。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些桌面环境（如 KDE Plasma）提供了用于设置这些参数的图形界面。在尝试手动配置编辑之前，请检查是否有这样的界面。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div id="x-config-input-keyboard-layout" class="paragraph">
<p>例如，要配置键盘布局：</p>
</div>
<div class="exampleblock">
<div class="title">例 21. 设置键盘布局</div>
<div class="content">
<div class="paragraph">
<p><span class="filename">/usr/local/etc/X11/xorg.conf.d/00-keyboard.conf</span></p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;InputClass&#34;
        Identifier &#34;Keyboard1&#34;
        MatchIsKeyboard &#34;on&#34;
        Option &#34;XkbLayout&#34; &#34;es, fr&#34;
        Option &#34;XkbModel&#34; &#34;pc104&#34;
        Option &#34;XkbVariant&#34; &#34;,qwerty&#34;
        Option &#34;XkbOptions&#34; &#34;grp:win_space_toggle&#34;
EndSection</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="x-fonts">5.5. 在 Xorg 中使用字体<a class="anchor" href="#x-fonts"></a></h3>
<div class="paragraph">
<p>Xorg 默认提供的字体对于典型的桌面出版应用来说并不理想。大号演示字体显示出来会有锯齿状，不够专业，而小号字体几乎完全无法辨认。然而，有几种免费的高质量 Type1 (PostScript®) 字体可供在 Xorg 中方便地使用。</p>
</div>
<div class="sect3">
<h4 id="type1">5.5.1. Type1 字体<a class="anchor" href="#type1"></a></h4>
<div class="paragraph">
<p>URW 字体集合 (<a class="package" href="https://cgit.freebsd.org/ports/tree/x11-fonts/urwfonts/">x11-fonts/urwfonts</a>) 包括标准 Type1 字体 (Times Roman™，Helvetica™，Palatino™ 等）的高质量版本。Freefonts 集合 (<a class="package" href="https://cgit.freebsd.org/ports/tree/x11-fonts/freefonts/">x11-fonts/freefonts</a>) 包括更多字体，但大部分是为图形软件（如 Gimp）使用的，并不完整，不能用作屏幕字体。此外，Xorg 可以配置为轻松使用 TrueType® 字体。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=X&amp;sektion=7&amp;format=html">X(7)</a> 手册页面或 <a href="#truetype">TrueType® 字体</a>。</p>
</div>
<div class="paragraph">
<p>要安装上述的 Type1 字体集合，可以运行以下命令来安装二进制包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install urwfonts</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样，对于 freefont 或其他字体集合也是如此。要让 X 服务器检测这些字体，需要在 X 服务器配置文件 (<span class="filename">/usr/local/etc/X11/xorg.conf.d/90-fonts.conf</span>) 中添加一行适当的内容，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Files&#34;
  FontPath &#34;/usr/local/share/fonts/urwfonts/&#34;
EndSection</pre>
</div>
</div>
<div class="paragraph">
<p>或者，在 X 会话的命令行中运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>xset fp+ /usr/local/share/fonts/urwfonts
<span class="gp">% </span>xset fp rehash</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将起作用，但在 X 会话关闭时将丢失，除非将其添加到启动文件（对于普通的 <code>startx</code> 会话，为 <span class="filename">~/.xinitrc</span>，或者对于通过图形登录管理器（如 XDM）登录的情况，为 <span class="filename">~/.xsession</span>）。第三种方法是使用新的 <span class="filename">/usr/local/etc/fonts/local.conf</span>，如 <a href="#antialias">抗锯齿字体</a> 中所示。</p>
</div>
</div>
<div class="sect3">
<h4 id="truetype">5.5.2. TrueType® 字体<a class="anchor" href="#truetype"></a></h4>
<div class="paragraph">
<p>Xorg 内置了对 TrueType® 字体的渲染支持。有两个不同的模块可以启用这个功能。在这个例子中使用 freetype 模块，因为它与其他字体渲染后端更加一致。要启用 freetype 模块，只需将以下行添加到 <span class="filename">/usr/local/etc/X11/xorg.conf.d/90-fonts.conf</span> 文件的 <code>&#34;Module&#34;</code> 部分。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Load  &#34;freetype&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>现在创建一个用于 TrueType® 字体的目录（例如，<span class="filename">/usr/local/share/fonts/TrueType</span>），并将所有的 TrueType® 字体复制到该目录中。请记住，TrueType® 字体不能直接从 Apple® Mac® 中获取；它们必须以 UNIX®/MS-DOS®/Windows® 格式存在，以供 Xorg 使用。一旦文件被复制到该目录中，使用 mkfontscale 创建一个 <span class="filename">fonts.dir</span> 文件，以便 X 字体渲染器知道这些新文件已经安装。<code>mkfontscale</code> 可以作为一个软件包进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install mkfontscale</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在一个目录中创建 X 字体文件的索引：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/local/share/fonts/TrueType</span>
<span class="c"># mkfontscale</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在将 TrueType® 目录添加到字体路径中。这与 <a href="#type1">Type1 字体</a> 中描述的方式完全相同。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>xset fp+ /usr/local/share/fonts/TrueType
<span class="gp">% </span>xset fp rehash</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在 <span class="filename">xorg.conf</span> 文件中添加一个 <code>FontPath</code> 行。</p>
</div>
<div class="paragraph">
<p>现在，Gimp、LibreOffice 和所有其他 X 应用程序应该能够识别已安装的 TrueType® 字体。现在，在高分辨率显示器上的网页文本中的极小字体以及 LibreOffice 中的极大字体将会看起来更好。</p>
</div>
</div>
<div class="sect3">
<h4 id="antialias">5.5.3. 抗锯齿字体<a class="anchor" href="#antialias"></a></h4>
<div class="paragraph">
<p>在 Xorg 中，所有在 <span class="filename">/usr/local/share/fonts/</span> 和 <span class="filename">~/.fonts/</span> 目录中找到的字体都会自动提供给支持 Xft-aware 的应用程序进行反锯齿处理。大多数最新的应用程序都支持 Xft-aware，包括 KDE、GNOME 和 Firefox。</p>
</div>
<div class="paragraph">
<p>要控制反锯齿的字体或配置反锯齿属性，请创建（或编辑，如果已存在）文件 <span class="filename">/usr/local/etc/fonts/local.conf</span>。可以使用此文件调整 Xft 字体系统的几个高级功能；本节仅描述了一些简单的可能性。有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=fonts-conf&amp;sektion=5&amp;format=html">fonts-conf(5)</a>。</p>
</div>
<div class="paragraph">
<p>这个文件必须是 XML 格式的。请注意大小写，并确保所有标签都正确闭合。文件以通常的 XML 头部开始，接着是 DOCTYPE 定义，然后是 <code>&lt;fontconfig&gt;</code> 标签。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&lt;?xml version=&#34;1.0&#34;?&gt;
      &lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&#34;&gt;
      &lt;fontconfig&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>如前所述，位于 <span class="filename">/usr/local/share/fonts/</span> 和 <span class="filename">~/.fonts/</span> 目录中的所有字体已经可以在支持 Xft-aware 的应用程序中使用。如果要添加一个位于这两个目录树之外的目录，可以在 <span class="filename">/usr/local/etc/fonts/local.conf</span> 文件中添加如下一行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&lt;dir&gt;/path/to/my/fonts&lt;/dir&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>在添加新字体，尤其是新的字体目录后，重新构建字体缓存：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># fc-cache -f</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>抗锯齿会使边界略微模糊，这使得非常小的文本更易读，并消除了大文本上的“阶梯状”效果，但如果应用于普通文本，可能会导致眼部疲劳。要排除小于 14 点字号的字体应用抗锯齿，包括以下几行代码：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>	&lt;match target=&#34;font&#34;&gt;
	    &lt;test name=&#34;size&#34; compare=&#34;less&#34;&gt;
		&lt;double&gt;14&lt;/double&gt;
	    &lt;/test&gt;
	    &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;
		&lt;bool&gt;false&lt;/bool&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;
	&lt;match target=&#34;font&#34;&gt;
	    &lt;test name=&#34;pixelsize&#34; compare=&#34;less&#34; qual=&#34;any&#34;&gt;
		&lt;double&gt;14&lt;/double&gt;
	    &lt;/test&gt;
	    &lt;edit mode=&#34;assign&#34; name=&#34;antialias&#34;&gt;
		&lt;bool&gt;false&lt;/bool&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>对于某些等宽字体，使用反锯齿可能会导致间距不合适。这似乎是 KDE 特别存在的问题。一个可能的解决方法是强制将这些字体的间距设置为 100 。添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	   &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
	       &lt;string&gt;fixed&lt;/string&gt;
	   &lt;/test&gt;
	   &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
	       &lt;string&gt;mono&lt;/string&gt;
	   &lt;/edit&gt;
	&lt;/match&gt;
	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	    &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		&lt;string&gt;console&lt;/string&gt;
	    &lt;/test&gt;
	    &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
		&lt;string&gt;mono&lt;/string&gt;
	    &lt;/edit&gt;
	&lt;/match&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>（这将其他常见的固定字体名称别名为 <code>&#34;mono&#34;</code>），然后添加：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	     &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		 &lt;string&gt;mono&lt;/string&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;spacing&#34; mode=&#34;assign&#34;&gt;
		 &lt;int&gt;100&lt;/int&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>某些字体，比如 Helvetica，在反锯齿处理时可能会出现问题。通常表现为字体在垂直方向上被切割了一半。最糟糕的情况下，可能会导致应用程序崩溃。为了避免这种情况，考虑将以下内容添加到 .local.conf 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>	&lt;match target=&#34;pattern&#34; name=&#34;family&#34;&gt;
	     &lt;test qual=&#34;any&#34; name=&#34;family&#34;&gt;
		 &lt;string&gt;Helvetica&lt;/string&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;family&#34; mode=&#34;assign&#34;&gt;
		 &lt;string&gt;sans-serif&lt;/string&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>在编辑 <span class="filename">local.conf</span> 后，确保用 <code>&lt;/fontconfig&gt;</code> 标签结束文件。如果不这样做，将会忽略所做的更改。</p>
</div>
<div class="paragraph">
<p>用户可以通过创建自己的 <span class="filename">~/.config/fontconfig/fonts.conf</span> 文件来添加个性化设置。该文件使用上述描述的相同的 <code>XML</code> 格式。</p>
</div>
<div class="paragraph">
<p>最后一个要点：对于 LCD 屏幕，可能需要进行亚像素采样。这基本上是将（水平分离的）红色、绿色和蓝色分量分别处理，以提高水平分辨率；结果可能非常显著。要启用此功能，请在 <span class="filename">local.conf</span> 中的某个位置添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>	 &lt;match target=&#34;font&#34;&gt;
	     &lt;test qual=&#34;all&#34; name=&#34;rgba&#34;&gt;
		 &lt;const&gt;unknown&lt;/const&gt;
	     &lt;/test&gt;
	     &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;
		 &lt;const&gt;rgb&lt;/const&gt;
	     &lt;/edit&gt;
	 &lt;/match&gt;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根据显示器的类型，可能需要将 <code>rgb</code> 更改为 <code>bgr</code>、<code>vrgb</code> 或 <code>vbgr</code>：进行实验并查看哪种效果最好。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关在 FreeBSD 上安装和配置字体的更多信息，请阅读文章 <a href="{fonts}">字体和 FreeBSD</a>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="wayland">Chapter 6. 在 FreeBSD 上的 Wayland<a class="anchor" href="#wayland"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="wayland-synopsis">6.1. Wayland 概述<a class="anchor" href="#wayland-synopsis"></a></h3>
<div class="paragraph">
<p>Wayland 是一个新的显示服务器，但它与 Xorg 在几个重要方面有所不同。首先，Wayland 只是一个协议，充当客户端之间的中介，使用不同的机制来消除对 X 服务器的依赖。Xorg 既包括用于运行远程显示的 X11 协议，也包括 X 服务器将接受连接和显示窗口。在 Wayland 下，合成器或窗口管理器提供显示服务器，而不是传统的 X 服务器。</p>
</div>
<div class="paragraph">
<p>由于 Wayland 不是一个 X 服务器，传统的 X 屏幕连接需要使用其他方法，如 VNC 或 RDP 来进行远程桌面管理。其次，Wayland 可以作为一个独立实体来管理客户端和合成器之间的复合通信，而不需要支持 X 协议。</p>
</div>
<div class="paragraph">
<p>Wayland 相对较新，不是所有的软件都已经更新以在没有 <code>Xwayland</code> 支持的情况下本地运行。因为 Wayland 不提供 X 服务器，并且期望合成器提供该支持，尚不支持 Wayland 的 X11 窗口管理器将要求不使用 <code>-rootless</code> 参数启动 <code>Xwayland</code> 。移除 <code>-rootless</code> 参数后，将恢复 X11 窗口管理器的支持。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当前的 NVIDIA® 驱动程序应该能够与大多数 wlroots 合成器配合使用，但可能会有一些不稳定性，并且在此时可能不支持所有功能。我们请求志愿者帮助改进 NVIDIA® DRM 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>目前，许多软件在 Wayland 上可以正常运行，包括 Firefox。还有一些可用的桌面环境，比如 Compiz Fusion 的替代品 Wayfire，以及 i3 窗口管理器的替代品 Sway 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>截至 2021 年 5 月， plasma5-kwin 在 FreeBSD 上支持 Wayland。要在 Wayland 下使用 Plasma，请使用 <code>ck-launch-session</code> 的 <code>startplasma-wayland</code> 参数，并使用以下命令将 dbus 与其绑定：<code>ck-launch-session dbus-run-session startplasma-wayland</code>。这样可以使其正常工作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于合成器来说，必须存在支持 <a href="https://man.freebsd.org/cgi/man.cgi?query=evdev&amp;sektion=4&amp;format=html">evdev(4)</a> 驱动程序的内核才能利用按键绑定功能。这在默认情况下已经内置在 <span class="filename">GENERIC</span> 内核中；然而，如果内核被定制并且去除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=evdev&amp;sektion=4&amp;format=html">evdev(4)</a> 支持，那么就需要加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=evdev&amp;sektion=4&amp;format=html">evdev(4)</a> 模块。此外，使用 <code>Wayland</code> 的用户还需要是 <code>video</code> 组的成员。要快速进行此更改，请使用 <code>pw</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">pw groupmod video -m user</code></pre>
</div>
</div>
<div class="paragraph">
<p>安装 Wayland 很简单；协议本身没有太多的配置。大部分的组合将取决于所选择的合成器。通过现在安装 <code>seatd</code>，可以跳过合成器安装和配置一部分的步骤，因为 <code>seatd</code> 需要提供对某些设备的非 root 访问权限。</p>
</div>
<div class="paragraph">
<p>这里描述的所有合成器都应该与 <a class="package" href="https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/">graphics/drm-kmod</a> 开源驱动程序配合使用；然而，使用专有驱动程序时， NVIDIA® 显卡可能会出现问题。首先安装以下软件包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install wayland seatd</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦协议和支持包被安装，合成器必须创建用户界面。接下来的几节将介绍几种合成器。所有使用 Wayland 的合成器都需要在环境中定义一个运行时目录，可以通过在 Bourne shell 中使用以下命令来实现：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">export </span><span class="nv">XDG_RUNTIME_DIR</span><span class="o">=</span>/var/run/user/<span class="sb">`</span>id -u<span class="sb">`</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>需要注意的是，大多数合成器会在 XDG_RUNTIME_DIR 目录中搜索配置文件。在这里包含的示例中，将使用一个参数来指定一个配置文件在 [.filename]# ~ /.config# 中，以便将临时文件和配置文件分开存放。建议为每个合成器配置一个别名，以加载指定的配置文件。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>据报道，ZFS 用户可能会在某些 Wayland 客户端上遇到问题，因为它们需要在运行时目录中访问 <code>posix_fallocate()</code> 函数。尽管作者无法在他们的 ZFS 系统上重现此问题，但建议的解决方法是不要将 ZFS 用于运行时目录，而是使用 <code>tmpfs</code> 作为 <span class="filename">/var/run</span> 目录。在这种情况下，通过命令 <code>mount -t tmpfs tmpfs /var/run</code> 将 <code>tmpfs</code> 文件系统挂载到 <span class="filename">/var/run</span>，然后通过 <span class="filename">/etc/fstab</span> 使此更改在重新启动后持久化。可以配置 XDG_RUNTIME_DIR 环境变量以使用 <span class="filename">/var/run/user/$UID</span>，避免与 ZFS 可能存在的问题。在查看以下部分的配置示例时，请考虑这种情况。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>seatd 守护进程帮助在合成器中管理非 root 用户对共享系统设备的访问，包括图形卡。对于传统的 X11 管理器，如 Plasma 和 GNOME，不需要使用 <code>seatd</code>，但对于这里讨论的 Wayland 合成器，在启动合成器环境之前，需要在系统上启用并运行它。要立即启用和启动 <code>seatd</code> 守护进程，并在系统初始化时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc seatd_enable=”YES”</span>
<span class="c"># service seatd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>之后，需要安装一个类似于 X11 桌面的合成器 (compositor) 来创建 GUI 环境。这里讨论了三种合成器，包括基本配置选项、设置屏幕锁定以及获取更多信息的建议。</p>
</div>
</div>
<div class="sect2">
<h3 id="wayland-wayfire">6.2. Wayfire 合成器<a class="anchor" href="#wayland-wayfire"></a></h3>
<div class="paragraph">
<p>Wayfire 是一个旨在轻量化和可定制化的合成器。它提供了多种功能，并且还恢复了之前发布的 Compiz Fusion 桌面的一些元素。所有的部分在现代硬件上看起来都很漂亮。要启动和运行 Wayfire，请先安装所需的软件包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install wayfire wf-shell alacritty swaylock-effects swayidle wlogout kanshi mako wlsunset</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>alacritty</code> 软件包提供了一个终端仿真器。然而，并不完全需要它，因为其他终端仿真器如 <code>kitty</code> 和 XFCE-4 <code>Terminal</code> 已经在 Wayfire 合成器下进行了测试和验证。 Wayfire 的配置相对简单；它使用一个文件，应该对其中的任何自定义进行审查。要开始，将示例文件复制到运行时环境配置目录，然后编辑该文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mkdir ~/.config/wayfire
<span class="gp">% </span>cp /usr/local/share/examples/wayfire/wayfire.ini ~/.config/wayfire</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于大多数用户来说，默认设置应该是可以的。在配置文件中，像著名的 <code>cube</code> 这样的项目已经预先配置好了，并且有说明来帮助设置可用的选项。一些值得注意的主要设置包括：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[output]
mode = 1920x1080@60000
position = 0,0
transform = normal
scale = 1.000000</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，从配置文件中，屏幕的输出应该是列表中列出的模式和列表中列出的赫兹。例如，模式应该设置为 <code>widthxheight@refresh_rate</code>。位置将输出放置在指定的像素位置上。默认值对大多数用户来说应该是可以接受的。最后， transform 设置了背景变换， scale 将输出按指定的比例因子进行缩放。这些选项的默认值通常是可以接受的；有关更多信息，请参阅文档。</p>
</div>
<div class="paragraph">
<p>如前所述，Wayland 是一种新的协议，还不是所有的应用程序都能与之兼容。目前，<code>sddm</code> 似乎不支持在 Wayland 中启动和管理合成器。在这些示例中，使用了 <code>swaylock</code> 实用程序。配置文件中包含了运行 <code>swayidle</code> 和 <code>swaylock</code> 来处理屏幕空闲和锁定的选项。</p>
</div>
<div class="paragraph">
<p>当系统处于空闲状态时，可以使用此选项来定义要执行的操作。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>idle = swaylock</pre>
</div>
</div>
<div class="paragraph">
<p>锁定超时是通过以下行进行配置的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[idle]
toggle = &lt;super&gt; KEY_Z
screensaver_timeout = 300
dpms_timeout = 600</pre>
</div>
</div>
<div class="paragraph">
<p>第一个选项将在 300 秒后锁定屏幕，再过 300 秒后，屏幕将通过 <code>dpms_timeout</code> 选项关闭。</p>
</div>
<div class="paragraph">
<p>需要注意的最后一件事是 &lt;super&gt; 键。大多数配置都提到了这个键，它是键盘上的传统 <code>Windows</code> 键。大多数键盘都有这个超级键可用；然而，如果该键不可用，应在此配置文件中重新映射它。例如，要锁定屏幕，请按住超级键，<kbd>shift</kbd> 键，然后按下 <kbd>escape</kbd> 键。除非映射已更改，否则这将执行 swaylock 应用程序。 <code>swaylock</code> 的默认配置将显示一个灰色屏幕；然而，该应用程序可以高度自定义，并且有很好的文档。此外，由于安装的是 swaylock-effects 版本，因此有几个可用的选项，例如模糊效果，可以使用以下命令查看：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>swaylock --effect-blur 7x5</code></pre>
</div>
</div>
<div class="paragraph">
<p>还有一个 <code>--clock</code> 参数，它会在锁屏界面上显示一个带有日期和时间的时钟。当安装了 <code>x11/swaylock-effects</code> 软件包时，会包含一个默认的 <code>pam.d</code> 配置文件。它提供了适用于大多数用户的默认选项。还有更高级的选项可用；有关更多信息，请参阅 PAM 文档。</p>
</div>
<div class="paragraph">
<p>此时，是时候测试 Wayfire 并查看它是否能在系统上启动了。只需输入以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>wayfire -c ~/.config/wayfire/wayfire.ini</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，合成器应该开始运行，并在屏幕顶部显示一个背景图像和一个菜单栏。 Wayfire 将尝试列出已安装的兼容应用程序，并在此下拉菜单中呈现它们；例如，如果安装了 XFCE-4 文件管理器，它将显示在此下拉菜单中。如果特定应用程序与键盘快捷键兼容且足够有价值，可以使用 <span class="filename">wayfire.ini</span> 配置文件将其映射到键盘序列。 Wayfire 还有一个名为 Wayfire Config Manager 的配置工具。它位于下拉菜单栏中，但也可以通过终端发出以下命令来启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>wcm</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过这个应用程序，可以启用、禁用或配置各种 Wayfire 配置选项，包括合成特效。此外，为了提供更用户友好的体验，可以在配置文件中启用背景管理器、面板和停靠应用程序。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>panel = wf-panel
dock = wf-dock
background = wf-background</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通过 <code>wcm</code> 进行的更改将覆盖 <span class="filename">wayfire.ini</span> 配置文件中的自定义更改。强烈建议备份 <span class="filename">wayfire.ini</span> 文件，以便可以恢复任何重要的更改。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>最后，在 <span class="filename">wayfire.ini</span> 中列出的默认启动器是 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11/wf-shell/">x11/wf-shell</a> ，用户可以根据需要替换为其他面板。</p>
</div>
</div>
<div class="sect2">
<h3 id="wayland-hikari">6.3. Hikari 合成器<a class="anchor" href="#wayland-hikari"></a></h3>
<div class="paragraph">
<p>Hikari 合成器使用了几个以提高生产力为中心的概念，例如工作表（sheets）、工作区（workspaces）等等。从这个角度来看，它类似于平铺式窗口管理器。具体来说，合成器从一个单一的工作区开始，类似于虚拟桌面。 Hikari 使用一个单一的工作区或虚拟桌面进行用户交互。工作区由多个视图组成，这些视图是合成器中的工作窗口，分组为工作表或组（groups）。工作表和组都由一组视图组成，即被分组在一起的窗口。在工作表或之间切换时，活动的工作表或组将被统称为工作区。手册将详细介绍每个功能，但在本文档中，只需考虑一个使用单个 工作表的工作区。 Hikari 的安装将包括一个单一的软件包 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11-wm/hikari/">x11-wm/hikari</a> 和一个终端模拟器 <code>alacritty</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install hikari alacritty</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>其他终端，如 <code>kitty</code> 或 Plasma 的 <code>Terminal</code>，在 Wayland 下可以正常工作。用户应该尝试使用他们喜欢的终端编辑器来验证兼容性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Hikari 使用一个配置文件 <span class="filename">hikari.conf</span>，可以放置在 XDG_RUNTIME_DIR 目录中，也可以在启动时使用 <code>-c</code> 参数指定。不需要自动启动配置文件，但是可能会使迁移到这个合成器更容易一些。开始配置是创建 Hikari 配置目录并复制配置文件进行编辑：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mkdir ~/.config/hikari
<span class="gp">% </span>cp /usr/local/etc/hikari/hikari.conf ~/.config/hikari</code></pre>
</div>
</div>
<div class="paragraph">
<p>配置被分解为各种部分，如 ui、outputs、layouts 等等。对于大多数用户来说，默认设置应该可以正常运行；但是还需要进行一些重要的更改。例如，$TERMINAL 变量通常在用户的环境中没有设置。可以更改这个变量或者修改 <span class="filename">hikari.conf</span> 文件以进行读取。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>terminal = &#34;/usr/local/bin/alacritty&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>将使用绑定的按键启动 <code>alacritty</code> 终端。在浏览配置文件时，应注意大写字母用于为用户映射键。例如，用于启动终端的 <kbd>L</kbd> 键 <span class="keyseq"><kbd>L</kbd>+<kbd>Return</kbd></span> 实际上是前面讨论过的超级键或 Windows 徽标键。因此，按住 <kbd>L/super/Windows</kbd> 键并按下 <kbd>Enter</kbd> 键将使用默认配置打开指定的终端仿真器。将其他键映射到应用程序需要创建一个动作定义。为此，动作项应列在动作段中，例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>actions {
  terminal = &#34;/usr/local/bin/alacritty&#34;
  browser = &#34;/usr/local/bin/firefox&#34;
}</pre>
</div>
</div>
<div class="paragraph">
<p>然后，可以将一个动作映射到键盘部分，该部分在绑定部分中定义：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>bindings {
  keyboard {
SNIP
    &#34;L+Return&#34; = action-terminal
    &#34;L+b&#34; = action-browser
SNIP</pre>
</div>
</div>
<div class="paragraph">
<p>在 Hikari 重新启动后，按住 Windows 徽标按钮并在键盘上按下 <kbd>b</kbd> 键将启动网页浏览器。合成器没有菜单栏，建议用户在迁移之前至少设置一个终端仿真器。手册中包含大量的文档，应在进行完整迁移之前阅读。Hikari 的另一个积极方面是，在迁移到合成器时，可以在 Plasma 和 GNOME 桌面环境中启动 Hikari，以便在完全迁移之前进行试用。</p>
</div>
<div class="paragraph">
<p>在 Hikari 中锁定屏幕很容易，因为默认的 <span class="filename">pam.d</span> 配置文件和解锁工具已经与软件包捆绑在一起。锁定屏幕的键绑定是 <kbd>L</kbd>（Windows 徽标键）+ <kbd>Shift</kbd> + <kbd>Backspace</kbd>。需要注意的是，所有未标记为公共的视图将被隐藏。当屏幕锁定时，这些视图将不接受输入，但要注意敏感信息可能可见。对于一些用户来说，可能更容易迁移到其他屏幕锁定工具，比如在本节中讨论的 swaylock-effects。要启动 Hikari，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>hikari -c ~/.config/hikari/hikari.conf</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wayland-sway">6.4. Sway 合成器<a class="anchor" href="#wayland-sway"></a></h3>
<div class="paragraph">
<p>Sway 合成器是一种平铺式合成器，旨在取代 i3 窗口管理器。它应该与用户当前的 i3 配置兼容；但是，新功能可能需要一些额外的设置。在接下来的示例中，假设进行了全新安装，没有迁移任何 i3 配置。要安装 Sway 和有价值的组件，请以 root 用户身份执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install sway swayidle swaylock-effects alacritty dmenu-wayland dmenu</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于一个基本的配置文件，执行以下命令，然后在复制完成后编辑配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mkdir ~/.config/sway
<span class="gp">% </span>cp /usr/local/etc/sway/config ~/.config/sway</code></pre>
</div>
</div>
<div class="paragraph">
<p>基本配置文件有许多默认值，对于大多数用户来说这是可以的。但是还需要进行一些重要的更改，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Logo key. Use Mod1 for Alt.
input * xkb_rules evdev
set $mod Mod4
# Your preferred terminal emulator
set $term alacritty
set $lock swaylock -f -c 000000
output &#34;My Workstation&#34; mode 1366x786@60Hz position 1366 0
output * bg ~/wallpapers/mywallpaper.png stretch
### Idle configuration
exec swayidle -w \
          timeout 300 &#39;swaylock -f -c 000000&#39; \
          timeout 600 &#39;swaymsg &#34;output * dpms off&#34;&#39; resume &#39;swaymsg &#34;output * dpms on&#34;&#39; \
          before-sleep &#39;swaylock -f -c 000000&#39;</pre>
</div>
</div>
<div class="paragraph">
<p>在前面的示例中，加载了 <code>xkb</code> 规则以处理 <a href="https://man.freebsd.org/cgi/man.cgi?query=evdev&amp;sektion=4&amp;format=html">evdev(4)</a> 事件，并将 $mod 键设置为 Windows 徽标键以进行键绑定。接下来，终端仿真器被设置为 <code>alacritty</code>，并定义了一个屏幕锁定命令；稍后会详细介绍。输出关键字、模式、位置、背景壁纸以及 Sway 还被告知将该壁纸拉伸以填满屏幕。最后，设置 <code>swaylock</code> 在 300 秒超时后将屏幕或监视器锁定并进入睡眠模式。在这里还定义了锁定的背景颜色为 000000，即黑色。使用 swaylock-effects，还可以使用 <code>--clock</code> 参数显示时钟。有关更多选项，请参阅手册页。还应该查看 <a href="https://man.freebsd.org/cgi/man.cgi?query=sway-output&amp;sektion=5&amp;format=html">sway-output(5)</a> 手册页；它包含了大量关于自定义输出选项的信息。</p>
</div>
<div class="paragraph">
<p>在 Sway 中，要打开应用程序菜单，请按住 Windows 徽标键（mod 键）并按下 <kbd>d</kbd> 键。可以使用键盘上的箭头键来导航菜单。还有一种方法可以操作栏的布局并添加一个托盘；请阅读 <a href="https://man.freebsd.org/cgi/man.cgi?query=sway-bar&amp;sektion=5&amp;format=html">sway-bar(5)</a> 手册页面获取更多信息。默认配置在右上角添加了日期和时间。在配置文件的 <code>Bar</code> 部分中可以找到一个示例。默认情况下，配置不包括在上面的示例之外锁定屏幕，启用锁定计时器。创建一个锁定键绑定需要在 <code>Key bindings</code> 部分添加以下行：</p>
</div>
<div class="literalblock programlising">
<div class="content">
<pre># Lock the screen manually
bindsym $mod+Shift+Return exec $lock</pre>
</div>
</div>
<div class="paragraph">
<p>现在可以使用按住 Windows 徽标键、按住 Shift 键，最后按下回车键的组合来锁定屏幕。当安装了 Sway，无论是从软件包还是 FreeBSD Ports Collection 安装的，都会安装一个默认的 <span class="filename">pam.d</span> 文件。默认配置对大多数用户来说应该是可接受的，但也提供了更高级的选项。请阅读 PAM 文档以获取更多信息。</p>
</div>
<div class="paragraph">
<p>最后，要退出 Sway 并返回到 shell，请按住 Windows 徽标键和 Shift 键，然后按下键盘上的 [e] 键。会显示一个提示，其中有一个选项可以退出 Sway。在迁移期间，可以通过在诸如 Plasma 之类的 X11 桌面上的终端模拟器中启动 Sway 。这使得在完全迁移到这个合成器之前，测试不同的更改和键绑定变得更加容易。要启动 Sway ，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sway -c ~/.config/sway/config</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wayland-xwayland">6.5. 使用 Xwayland<a class="anchor" href="#wayland-xwayland"></a></h3>
<div class="paragraph">
<p>在安装 Wayland 时，除非 Wayland 是没有构建 X11 支持的，否则应该已经安装了 <code>Xwayland</code> 二进制文件。如果 <span class="filename">/usr/local/bin/Xwayland</span> 文件不存在，请使用以下命令进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install xwayland-devel</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>推荐使用 Xwayland 的开发版本，并且很可能已经随 Wayland 软件包一起安装。每个合成器都有一种启用或禁用此功能的方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一旦安装了 <code>Xwayland</code>，请在所选的合成器中进行配置。对于 Wayfire 来说，在 <span class="filename">wayfire.ini</span> 文件中需要添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>xwayland = true</pre>
</div>
</div>
<div class="paragraph">
<p>对于 Sway 合成器，默认情况下应启用 <code>Xwayland</code>。即便如此，建议在 <span class="filename">~/.config/sway/config</span> 中手动添加以下配置行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>启用 XWayland</pre>
</div>
</div>
<div class="paragraph">
<p>最后，对于 Hikari 来说，不需要进行任何更改。默认情况下，已经内置了对 <code>Xwayland</code> 的支持。要禁用该支持，可以从 ports 集合中重新构建该软件包，并在那时禁用 Xwayland 支持。</p>
</div>
<div class="paragraph">
<p>在进行这些更改后，通过命令行启动合成器，并从键绑定中执行一个终端。在这个终端中，输入 <code>env</code> 命令并搜索 <code>DISPLAY</code> 变量。如果合成器能够正确启动 Xwayland X 服务器，这些环境变量应该类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>env | grep DISPLAY</code></pre>
</div>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>WAYLAND_DISPLAY=wayland-1
DISPLAY=:0</pre>
</div>
</div>
<div class="paragraph">
<p>在这个输出中，有一个默认的 Wayland 显示器和一个为 Xwayland 服务器设置的显示器。验证 <code>Xwayland</code> 是否正常工作的另一种方法是安装和测试一个小包 package:[x11/eyes]，并检查输出。如果 <code>xeyes</code> 应用程序启动并且眼睛跟随鼠标指针移动，那么 Xwayland 正常工作。如果显示了以下错误或类似错误，则在 <code>Xwayland</code> 初始化过程中发生了某些问题，可能需要重新安装：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Error: Cannot open display wayland-0</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Wayland 的一个安全特性是，在没有运行 X 服务器的情况下，没有其他网络监听器。一旦启用了 <code>Xwayland</code>，这个安全特性对系统就不再适用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于一些复合器，比如 Wayfire，<code>Xwayland</code> 可能无法正常启动。因此，<code>env</code> 将显示 <code>DISPLAY</code> 环境变量的以下信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>env | grep DISPLAY</code></pre>
</div>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>DISPLAY=wayland-1
WAYLAND_DISPLAY=wayland-1</pre>
</div>
</div>
<div class="paragraph">
<p>尽管已经安装和配置了 <code>Xwayfire</code>，但 X11 应用程序无法启动，出现显示问题。为了解决这个问题，可以通过以下两种方法验证是否已经存在一个使用 UNIX 套接字的 <code>Xwayland</code> 实例。首先，检查 <code>sockstat</code> 的输出，并搜索 X11-unix:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sockstat | grep x11</code></pre>
</div>
</div>
<div class="paragraph">
<p>应该有类似以下信息的内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>trhodes  Xwayland   2734  8  stream /tmp/.X11-unix/X0
trhodes  Xwayland   2734  9  stream /tmp/.X11-unix/X0
trhodes  Xwayland   2734  10 stream /tmp/.X11-unix/X0
trhodes  Xwayland   2734  27 stream /tmp/.X11-unix/X0_
trhodes  Xwayland   2734  28 stream /tmp/.X11-unix/X0</pre>
</div>
</div>
<div class="paragraph">
<p>这表明存在一个 X11 套接字。可以通过在合成器下运行的终端模拟器中尝试手动执行 <code>Xwayland</code> 来进一步验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>Xwayland</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果已经存在一个 X11 套接字，则应向用户显示以下错误：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>(EE)
Fatal server error:
(EE) Server is already active for display 0
	If this server is no longer running, remove /tmp/.X0-lock
	and start again.
(EE)</pre>
</div>
</div>
<div class="paragraph">
<p>由于存在一个可用的活动 X 显示器，使用显示器零，环境变量设置不正确，要修复这个问题，将 <code>DISPLAY</code> 环境变量更改为 <code>:0</code>，然后尝试再次执行应用程序。以下示例使用 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/mail/claws-mail/">mail/claws-mail</a></code> 作为需要 <code>Xwayland</code> 服务的应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="nb">export </span><span class="nv">DISPLAY</span><span class="o">=</span>:0</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个改变之后，<a class="package" href="https://cgit.freebsd.org/ports/tree/mail/claws-mail/">mail/claws-mail</a> 应用程序现在应该开始使用 <code>Xwayland</code> 并正常工作。</p>
</div>
</div>
<div class="sect2">
<h3 id="wayland-remotedesktop">6.6. 使用 VNC 进行远程桌面访问<a class="anchor" href="#wayland-remotedesktop"></a></h3>
<div class="paragraph">
<p>在本文档中早些时候已经指出， Wayland 不像 Xorg 提供相同的 X 服务器样式访问。相反，用户可以自由选择远程桌面协议，如 RDP 或 VNC。FreeBSD Ports 集合中包括 <code>wayvnc</code>，它将支持基于 wlroots 的合成器，例如在这里讨论的合成器。可以使用以下命令安装此应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install wayvnc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与其他一些软件包不同，<code>wayvnc</code> 不提供配置文件。幸运的是，手册页面记录了重要的选项，并且可以将它们推导成一个简单的配置文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>address=0.0.0.0
enable_auth=true
username=username
password=password
private_key_file=/path/to/key.pem
certificate_file=/path/to/cert.pem</pre>
</div>
</div>
<div class="paragraph">
<p>需要生成密钥文件，并强烈建议使用它们以增加连接的安全性。当调用时，wayvnc 将在 <span class="filename">~/.config/wayvnc/config</span> 中搜索配置文件。可以使用 <code>-C configuration_file</code> 选项在启动服务器时覆盖该文件。因此，要启动 <code>wayvnc</code> 服务器，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>wayvnc -C ~/.config/wayvnc/config</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在撰写本文时，系统初始化时没有 rc.d 脚本来启动 <code>wayvnc</code>。如果需要这个功能，需要创建一个本地启动文件。这可能是对端口维护者的一个功能请求。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="wayland-ly">6.7. Wayland 登录管理器<a class="anchor" href="#wayland-ly"></a></h3>
<div class="paragraph">
<p>虽然存在多个登录管理器，并且正在逐渐迁移到 Wayland，但其中一个选择是 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11/ly/">x11/ly</a> 中的文本用户界面（TUI）管理器。<code>ly</code> 只需要最少的配置，它会在系统初始化时显示一个登录窗口来启动 Sway、Wayfire 等桌面环境。要安装 <code>ly</code>，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install ly</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将会提供一些配置提示，导入步骤是将以下行添加到 <span class="filename">/etc/gettytab</span> 文件中：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Ly:\
  :lo=/usr/local/bin/ly:\
  :al=root:</pre>
</div>
</div>
<div class="paragraph">
<p>然后在 <span class="filename">/etc/ttys</span> 中修改 ttyv1 行，使其与以下行匹配：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>ttyv1 &#34;/usr/libexec/getty Ly&#34; xterm onifexists secure</pre>
</div>
</div>
<div class="paragraph">
<p>系统重新启动后，应该出现登录界面。要配置特定的设置，例如语言和编辑 <span class="filename">/usr/local/etc/ly/config.ini</span> 。至少，这个文件应该有之前在 <span class="filename">/etc/ttys</span> 中指定的终端。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果将 ttyv0 设置为登录终端，可能需要按下 <kbd>alt</kbd> 和 <kbd>F1</kbd> 键才能正确显示登录窗口。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当登录窗口出现时，使用左右箭头可以在不同支持的窗口管理器之间切换。</p>
</div>
</div>
<div class="sect2">
<h3 id="wayland-utilities">6.8. 有用的工具<a class="anchor" href="#wayland-utilities"></a></h3>
<div class="paragraph">
<p>所有合成器都可以使用的一个有用的 Wayland 实用程序是 waybar。虽然 Wayfire 带有一个启动菜单，但一个易于使用和快速的任务栏对于任何合成器或桌面管理器来说都是一个很好的附件。一个快速且易于配置的 Wayland 兼容的任务栏是 waybar。要安装该软件包和一个支持音频控制的实用程序，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install pavucontrol waybar</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建配置目录并复制默认配置文件，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mkdir ~/.config/waybar
<span class="gp">% </span>cp /usr/local/etc/xdg/waybar/config ~/.config/waybar</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>lavalauncher</code> 实用程序为各种应用程序提供了一个启动栏。软件包中没有提供示例配置文件，因此必须执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">mkdir ~/.config/lavalauncher</code></pre>
</div>
</div>
<div class="paragraph">
<p>下面是一个只包含 Firefox 的示例配置文件，并且放置在右侧：</p>
</div>
<div class="literalblock programlising">
<div class="content">
<pre>global-settings {
	watch-config-file = true;
}

bar {
	output            = eDP-1;
	position          = bottom;
	background-colour = &#34;#202020&#34;;

	# Condition for the default configuration set.
	condition-resolution = wider-than-high;

	config {
		position = right;
	}

	button {
		image-path          =     /usr/local/lib/firefox/browser/chrome/icons/default/default48.png;
		command[mouse-left] =     /usr/local/bin/firefox;
	}
	button {
	  image-path           =   /usr/local/share/pixmaps/thunderbird.png;
	  command[mouse-left]  =   /usr/local/bin/thunderbird;
}</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network">Chapter 7. 网络<a class="anchor" href="#network"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="network-synopsis">7.1. 简介<a class="anchor" href="#network-synopsis"></a></h3>
<div class="paragraph">
<p>本章深入探讨了网络配置和性能的主题，展示了 FreeBSD 操作系统强大的网络能力。无论是使用有线网络还是无线网络，本章提供了一个全面的指南，帮助您在 FreeBSD 中配置和优化网络连接。</p>
</div>
<div class="paragraph">
<p>在深入了解细节之前，读者对网络概念如协议、网络接口和寻址有基本的了解是有益的。</p>
</div>
<div class="paragraph">
<p>本章内容包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 FreeBSD 中配置有线网络的能力，包括网络接口设置、寻址和定制选项。</p>
</li>
<li>
<p>在 FreeBSD 中配置无线网络的技能，包括无线网络接口设置、安全协议和故障排除技术。</p>
</li>
<li>
<p>FreeBSD 的网络能力以及其在优秀网络性能方面的声誉。</p>
</li>
<li>
<p>对于 FreeBSD 支持的各种网络服务和协议的理解，包括 DNS、DHCP 等的配置说明。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关如何进行高级网络配置的更多信息，请参阅 <a href="./#advanced-networking">高级网络</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="config-network-setup">7.2. 设置网络<a class="anchor" href="#config-network-setup"></a></h3>
<div class="paragraph">
<p>为 FreeBSD 用户设置有线或无线连接是一个常见的任务。本节将展示如何识别有线和无线网络适配器以及如何配置它们。</p>
</div>
<div class="paragraph">
<p>在开始配置之前，需要了解以下网络数据：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果网络使用 DHCP</p>
</li>
<li>
<p>如果网络没有 DHCP，则使用静态 IP 。</p>
</li>
<li>
<p>子网掩码</p>
</li>
<li>
<p>默认网关的 IP 地址</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>网络连接可能在安装时由 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> 进行配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="config-identify-network-adapter">7.2.1. 识别网络适配器<a class="anchor" href="#config-identify-network-adapter"></a></h4>
<div class="paragraph">
<p>FreeBSD 支持各种有线和无线网络适配器。请查看所使用的 FreeBSD 版本的硬件兼容性列表 <a href="https://www.freebsd.org/releases/">FreeBSD release</a>，以查看网络适配器是否受支持。</p>
</div>
<div class="paragraph">
<p>要获取我们系统使用的网络适配器，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>pciconf -lv | grep -A1 -B3 network</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>em0@pci0:0:25:0:        class=0x020000 rev=0x03 hdr=0x00 vendor=0x8086 device=0x10f5 subvendor=0x17aa subdevice=0x20ee
    vendor     = &#39;Intel Corporation&#39; <i class="conum" data-value="1"></i><b>(1)</b>
    device     = &#39;82567LM Gigabit Network Connection&#39; <i class="conum" data-value="2"></i><b>(2)</b>
    class      = network
    subclass   = ethernet
--
iwn0@pci0:3:0:0:        class=0x028000 rev=0x00 hdr=0x00 vendor=0x8086 device=0x4237 subvendor=0x8086 subdevice=0x1211
    vendor     = &#39;Intel Corporation&#39; <i class="conum" data-value="1"></i><b>(1)</b>
    device     = &#39;PRO/Wireless 5100 AGN [Shiloh] Network Connection&#39; <i class="conum" data-value="2"></i><b>(2)</b>
    class      = networ</pre>
</div>
</div>
<div class="paragraph">
<p>在 &#39;@&#39; 符号之前的文本是控制设备的驱动程序的名称。在这种情况下，它们是 <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=iwn&amp;sektion=4&amp;format=html">iwn(4)</a>。</p>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>显示供应商的名称</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>显示设备的名称</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>只有在 FreeBSD 没有正确检测到网络接口卡时，才需要加载该模块。</p>
</div>
<div class="paragraph">
<p>例如，要加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=alc&amp;sektion=4&amp;format=html">alc(4)</a> 模块，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload if_alc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，要在启动时将驱动程序加载为模块，请将以下行放置在 <span class="filename">/boot/loader.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>if_alc_load=&#34;YES&#34;</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="config-network-connection">7.3. 有线网络<a class="anchor" href="#config-network-connection"></a></h3>
<div class="paragraph">
<p>一旦正确的驱动程序加载完成，需要配置网络适配器。FreeBSD 使用驱动程序名称后跟一个单元号来命名网络接口适配器。单元号表示适配器在引导时被检测到的顺序，或者是稍后被发现的顺序。</p>
</div>
<div class="paragraph">
<p>例如，<code>em0</code> 是系统上使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> 驱动程序的第一个网络接口卡（NIC）。</p>
</div>
<div class="paragraph">
<p>要显示网络接口配置，请输入以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ifconfig</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>em0: flags=8863&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=481249b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,LRO,WOL_MAGIC,VLAN_HWFILTER,NOMAP&gt;
        ether 00:1f:16:0f:27:5a
        inet6 fe80::21f:16ff:fe0f:275a%em0 prefixlen 64 scopeid 0x1
        inet 192.168.1.19 netmask 0xffffff00 broadcast 192.168.1.255
        media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
        status: active
        nd6 options=23&lt;PERFORMNUD,ACCEPT_RTADV,AUTO_LINKLOCAL&gt;
lo0: flags=8049&lt;UP,LOOPBACK,RUNNING,MULTICAST&gt; metric 0 mtu 16384
        options=680003&lt;RXCSUM,TXCSUM,LINKSTATE,RXCSUM_IPV6,TXCSUM_IPV6&gt;
        inet6 ::1 prefixlen 128
        inet6 fe80::1%lo0 prefixlen 64 scopeid 0x2
        inet 127.0.0.1 netmask 0xff000000
        groups: lo
        nd6 options=21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，显示了以下设备：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>em0</code>：以太网接口。</p>
</li>
<li>
<p><code>lo0</code>：回环接口是一种软件环回机制，可用于性能分析、软件测试或本地通信。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=lo&amp;sektion=4&amp;format=html">lo(4)</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个例子显示 <code>em0</code> 已经启动并运行。</p>
</div>
<div class="paragraph">
<p>关键指标包括：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>UP</code> 表示接口已配置并准备就绪。</p>
</li>
<li>
<p>该接口具有一个 IPv4 Internet（<code>inet</code>）地址，<code>192.168.1.19</code>。</p>
</li>
<li>
<p>该接口具有一个 IPv6 Internet（<code>inet6</code>）地址，<code>fe80::21f:16ff:fe0f:275a%em0</code> 。</p>
</li>
<li>
<p>它具有有效的子网掩码（<code>netmask</code>），其中 <code>0xffffff00</code> 与 <code>255.255.255.0</code> 相同。</p>
</li>
<li>
<p>它具有有效的广播地址，<code>192.168.1.255</code>。</p>
</li>
<li>
<p>接口（<code>ether</code>）的 MAC 地址是 <code>00:1f:16:0f:27:5a</code>。</p>
</li>
<li>
<p>物理媒体选择处于自动选择模式（<code>media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)</code>）。</p>
</li>
<li>
<p>链接的状态（<code>status</code>）为 <code>active</code>，表示检测到载波信号。对于 <code>em0</code>，当以太网电缆未插入接口时，<code>status: no carrier</code> 状态是正常的。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 命令的输出结果与下面的输出结果类似，那么说明接口尚未配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>em0: flags=8822&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=481249b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,LRO,WOL_MAGIC,VLAN_HWFILTER,NOMAP&gt;
        ether 00:1f:16:0f:27:5a
        media: Ethernet autoselect
        status: no carrier
        nd6 options=29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</pre>
</div>
</div>
<div class="sect3">
<h4 id="config-static-ip-v4">7.3.1. 配置静态 IPv4 地址<a class="anchor" href="#config-static-ip-v4"></a></h4>
<div class="paragraph">
<p>本节提供了在 FreeBSD 系统上配置静态 IPv4 地址的指南。</p>
</div>
<div class="paragraph">
<p>可以使用命令行的 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 来配置网络接口卡，但是如果不将配置添加到 <span class="filename">/etc/rc.conf</span> 中，配置在重启后将不会保留。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果网络在安装过程中由 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdinstall&amp;sektion=8&amp;format=html">bsdinstall(8)</a> 进行配置，则可能已经存在一些网络接口卡（NIC）的条目。在执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> 之前，请仔细检查 <span class="filename">/etc/rc.conf</span>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以通过执行以下命令来设置 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig em0 inet 192.168.1.150/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使更改在重新启动后保持生效，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_em0=&#34;inet 192.168.1.150 netmask 255.255.255.0&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>执行以下命令添加默认路由器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc defaultrouter=&#34;192.168.1.1&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 DNS 记录添加到 [/etc/resolv.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nameserver 8.8.8.8
nameserver 8.8.4.4</pre>
</div>
</div>
<div class="paragraph">
<p>然后执行以下命令重新启动 <code>netif</code> 和 <code>routing</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service netif restart &amp;&amp; service routing restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 来测试连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ping -c2 www.FreeBSD.org</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>PING web.geo.FreeBSD.org (147.28.184.45): 56 data bytes
64 bytes from 147.28.184.45: icmp_seq=0 ttl=51 time=55.173 ms
64 bytes from 147.28.184.45: icmp_seq=1 ttl=51 time=53.093 ms

--- web.geo.FreeBSD.org ping statistics ---
2 packets transmitted, 2 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 53.093/54.133/55.173/1.040 ms</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="config-dynamic-ip-v4">7.3.2. 配置动态 IPv4 地址<a class="anchor" href="#config-dynamic-ip-v4"></a></h4>
<div class="paragraph">
<p>如果网络有一个 DHCP 服务器，配置网络接口使用 DHCP 非常简单。FreeBSD 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 作为 DHCP 客户端。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 会自动提供 IP 地址、子网掩码和默认路由器。</p>
</div>
<div class="paragraph">
<p>要使接口与 DHCP 配合工作，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_em0=&#34;DHCP&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 可以通过运行以下命令手动使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dhclient em0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>DHCPREQUEST on em0 to 255.255.255.255 port 67
DHCPACK from 192.168.1.1
unknown dhcp option value 0x7d
bound to 192.168.1.19 -- renewal in 43200 seconds.</pre>
</div>
</div>
<div class="paragraph">
<p>通过这种方式可以验证使用 DHCP 进行地址分配是否正常工作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 客户端可以在后台启动。这可能会对依赖于正常工作网络的应用程序造成麻烦，但在许多情况下，它将提供更快的启动速度。</p>
</div>
<div class="paragraph">
<p>要在后台执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a>，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc background_dhclient=&#34;YES&#34;</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后执行以下命令重新启动 <code>netif</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service netif restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 来测试连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ping -c2 www.FreeBSD.org</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>PING web.geo.FreeBSD.org (147.28.184.45): 56 data bytes
64 bytes from 147.28.184.45: icmp_seq=0 ttl=51 time=55.173 ms
64 bytes from 147.28.184.45: icmp_seq=1 ttl=51 time=53.093 ms

--- web.geo.FreeBSD.org ping statistics ---
2 packets transmitted, 2 packets received, 0.0% packet loss
round-trip min/avg/max/stddev = 53.093/54.133/55.173/1.040 ms</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="network-ipv6">7.3.3. IPv6<a class="anchor" href="#network-ipv6"></a></h4>
<div class="paragraph">
<p>IPv6 是广为人知的 IP 协议的新版本，也被称为 IPv4。</p>
</div>
<div class="paragraph">
<p>IPv6 相比 IPv4 提供了几个优势，以及许多新的功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>它的 128 位地址空间允许拥有 340,282,366,920,938,463,463,374,607,431,768,211,456 个地址。这解决了 IPv4 地址短缺和最终的 IPv4 地址耗尽问题。</p>
</li>
<li>
<p>路由器只在其路由表中存储网络聚合地址，从而将路由表的平均空间减少到 8192 个条目。这解决了与 IPv4 相关的可扩展性问题，因为 IPv4 要求每个分配的 IPv4 地址块在互联网路由器之间进行交换，导致它们的路由表变得过大，无法实现高效的路由。</p>
</li>
<li>
<p>地址自动配置 (<a href="http://www.ietf.org/rfc/rfc2462.txt">RFC2462</a>)</p>
</li>
<li>
<p>强制性多播地址。</p>
</li>
<li>
<p>内置 IPsec（IP security）。</p>
</li>
<li>
<p>简化的标题结构。</p>
</li>
<li>
<p>支持移动 IP。</p>
</li>
<li>
<p>IPv6 到 IPv4 的过渡机制。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FreeBSD 包含了 <a href="http://www.kame.net/">KAME 项目</a> IPv6 参考实现，并且提供了使用 IPv6 所需的一切。</p>
</div>
<div class="paragraph">
<p>本节重点介绍如何配置和运行 IPv6。</p>
</div>
<div class="paragraph">
<p>IPv6 地址有三种不同的类型：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">单播</dt>
<dd>
<p>发送到单播地址的数据包到达与该地址相关的接口。</p>
</dd>
<dt class="hdlist1">任播</dt>
<dd>
<p>这些地址在语法上与单播地址无法区分，但它们用于寻址一组接口。发送到任播地址的数据包将到达最近的路由器接口。任播地址只由路由器使用。</p>
</dd>
<dt class="hdlist1">多播</dt>
<dd>
<p>这些地址标识了一组接口。发送到多播地址的数据包将到达属于多播组的所有接口。 IPv4 广播地址通常为 <code>xxx.xxx.xxx.255</code>，在 IPv6 中用多播地址表示。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在阅读 IPv6 地址时，规范形式表示为 <code>x:x:x:x:x:x:x:x</code>，其中每个 <code>x</code> 表示一个 16 位的十六进制值。一个例子是 <code>FEBC:A574:382B:23C1:AA49:4592:4EFE:9982</code>。</p>
</div>
<div class="paragraph">
<p>通常，一个地址会有很长的全零子串。一个 <code>::</code>（双冒号）可以用来替换地址中的一个子串。此外，每个十六进制值前面的最多三个 <code>0</code> 可以省略。例如， <code>fe80::1</code> 对应的规范形式是 <code>fe80:0000:0000:0000:0000:0000:0000:0001</code>。</p>
</div>
<div class="paragraph">
<p>第三种形式是使用众所周知的 IPv4 表示法编写最后 32 位。例如，<code>2002::10.0.0.1</code> 对应于十六进制的规范表示 <code>2002:0000:0000:0000:0000:0000:0a00:0001</code>，而这又等同于 <code>2002::a00:1</code>。</p>
</div>
<div class="paragraph">
<p>要查看 FreeBSD 系统的 IPv6 地址，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>em0: flags=8863&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        options=481249b&lt;RXCSUM,TXCSUM,VLAN_MTU,VLAN_HWTAGGING,VLAN_HWCSUM,LRO,WOL_MAGIC,VLAN_HWFILTER,NOMAP&gt;
        ether 00:1f:16:0f:27:5a
        inet 192.168.1.150 netmask 0xffffff00 broadcast 192.168.1.255
        inet6 fe80::21f:16ff:fe0f:275a%em0 prefixlen 64 scopeid 0x1
        media: Ethernet autoselect (1000baseT &lt;full-duplex&gt;)
        status: active
        nd6 options=23&lt;PERFORMNUD,ACCEPT_RTADV,AUTO_LINKLOCAL&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，<code>em0</code> 接口正在使用 <code>fe80::21f:16ff:fe0f:275a%em0</code>，这是一个自动配置的链路本地地址，它是根据 MAC 地址自动生成的。</p>
</div>
<div class="paragraph">
<p>一些 IPv6 地址是保留地址。保留地址的列表可以在下表中查看：</p>
</div>
<table id="reservedip6" class="tableblock frame-none grid-all stretch">
<caption class="title">表 9. IPv6 保留地址示例</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">IPv6 地址</th>
<th class="tableblock halign-left valign-top">前缀长度（位）</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">未指定的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4 中等同于 <code>0.0.0.0</code> 的地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::1</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">128 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">环回地址</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4 中等同于 <code>127.0.0.1</code> 的地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::00:xx:xx:xx:xx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">96 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">嵌入式 IPv4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">低 32 位是兼容的 IPv4 地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>::ff:xx:xx:xx:xx</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">96 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPv4 映射 IPv6 地址</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">低 32 位是不支持 IPv6 的主机的 IPv4 地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fe80::/10</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">10 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链路本地</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在 IPv4 中，等同于 169.254.0.0/16 的地址。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>fc00::/7</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">唯一本地</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">唯一本地地址用于本地通信，只能在一组合作站点内进行路由。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ff00::</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">多播</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>2000::-3fff::</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3 位</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">全局单播</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有全局单播地址都是从这个地址池中分配的。前 3 位是 <code>001</code>。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>有关 IPv6 地址结构的更多信息，请参考 <a href="http://www.ietf.org/rfc/rfc3513.txt">RFC3513</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="config-static-ip-v6">7.3.4. 配置静态 IPv6 地址<a class="anchor" href="#config-static-ip-v6"></a></h4>
<div class="paragraph">
<p>要将 FreeBSD 系统配置为具有静态 IPv6 地址的 IPv6 客户端，需要设置 IPv6 地址。</p>
</div>
<div class="paragraph">
<p>执行以下命令以满足要求：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_em0_ipv6=&#34;inet6 2001:db8:4672:6565:2026:5043:2d42:5344 prefixlen 64&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要分配一个默认路由器，请执行以下命令指定其地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ipv6_defaultrouter=&#34;2001:db8:4672:6565::1&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="config-dynamic-ip-v6">7.3.5. 配置动态 IPv6 地址<a class="anchor" href="#config-dynamic-ip-v6"></a></h4>
<div class="paragraph">
<p>如果网络有一个 DHCP 服务器，配置网络接口使用 DHCP 非常简单。<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 会自动提供 IP 地址、子网掩码和默认路由器。</p>
</div>
<div class="paragraph">
<p>要使接口与 DHCP 配合工作，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_em0_ipv6=&#34;inet6 accept_rtadv&#34;</span>
<span class="c"># sysrc rtsold_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_路由器通告和主机自动配置">7.3.6. 路由器通告和主机自动配置<a class="anchor" href="#_路由器通告和主机自动配置"></a></h4>
<div class="paragraph">
<p>本节演示了如何在 IPv6 路由器上设置 <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>，以广播 IPv6 网络前缀和默认路由。</p>
</div>
<div class="paragraph">
<p>要启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a>，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc rtadvd_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>指定 IPv6 路由器通告的接口非常重要。例如，要告诉 <a href="https://man.freebsd.org/cgi/man.cgi?query=rtadvd&amp;sektion=8&amp;format=html">rtadvd(8)</a> 使用 <code>em0</code>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc rtadvd_interfaces=&#34;em0&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，按照以下示例创建配置文件 <span class="filename">/etc/rtadvd.conf</span> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>em0:\
	:addrs#1:addr=&#34;2001:db8:1f11:246::&#34;:prefixlen#64:tc=ether:</pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>em0</code> 替换为要使用的接口，将 <code>2001:db8:1f11:246::</code> 替换为分配的前缀。</p>
</div>
<div class="paragraph">
<p>对于一个专用的 <code>/64</code> 子网，不需要做任何其他更改。否则，请将 <code>prefixlen#</code> 更改为正确的值。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ipv6_和_ipv4_地址映射">7.3.7. IPv6 和 IPv4 地址映射<a class="anchor" href="#_ipv6_和_ipv4_地址映射"></a></h4>
<div class="paragraph">
<p>当服务器启用 IPv6 时，可能需要启用 IPv4 映射的 IPv6 地址通信。这个兼容选项允许将 IPv4 地址表示为 IPv6 地址。允许 IPv6 应用程序与 IPv4 相互通信可能会存在安全问题。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，这个选项可能不是必需的，只是为了兼容性而提供的。这个选项将允许仅支持 IPv6 的应用程序在双栈环境中与 IPv4 一起工作。这对于可能不支持仅 IPv6 环境的第三方应用程序非常有用。</p>
</div>
<div class="paragraph">
<p>要启用此功能，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ipv6_ipv4mapping=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-wireless">7.4. 无线网络<a class="anchor" href="#network-wireless"></a></h3>
<div class="paragraph">
<p>大多数无线网络都基于 <a href="https://en.wikipedia.org/wiki/IEEE_802.11">IEEE® 802.11 标准</a>。</p>
</div>
<div class="paragraph">
<p>FreeBSD 支持使用 <a href="https://en.wikipedia.org/wiki/IEEE_802.11a-1999">802.11a</a>，<a href="https://en.wikipedia.org/wiki/IEEE_802.11b-1999">802.11b</a>，<a href="https://en.wikipedia.org/wiki/IEEE_802.11g-2003">802.11g</a> 和 <a href="https://en.wikipedia.org/wiki/IEEE_802.11n-2009">802.11n</a> 网络。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 FreeBSD 上，目前正在开发对 <a href="https://en.wikipedia.org/wiki/IEEE_802.11ac-2013">802.11ac</a> 的支持。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一个基本的无线网络由多个站点组成，这些站点使用广播在 2.4GHz 或 5GHz 频段进行通信，尽管这在不同地区可能有所不同，并且也在不断变化以实现在 2.3GHz 和 4.9GHz 范围内的通信。</p>
</div>
<div class="paragraph">
<p>配置无线网络有三个基本步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>扫描并选择一个接入点</p>
</li>
<li>
<p>验证该站点</p>
</li>
<li>
<p>配置 IP 地址或使用 DHCP。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>下面的部分讨论了每个步骤。</p>
</div>
<div class="sect3">
<h4 id="network-wireless-quick-start">7.4.1. 连接无线网络的快速入门指南<a class="anchor" href="#network-wireless-quick-start"></a></h4>
<div class="paragraph">
<p>将 FreeBSD 连接到现有的无线网络是一种非常常见的情况。</p>
</div>
<div class="paragraph">
<p>该过程显示所需的步骤：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>第一步是从网络管理员那里获取无线网络的 SSID （服务集标识）和 PSK （预共享密钥）。</p>
</li>
<li>
<p>第二步是将此网络添加到 <span class="filename">/etc/wpa_supplicant.conf</span> 的条目中。如果文件不存在，请创建它：</p>
</li>
</ul>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
 ssid=&#34;myssid&#34; <i class="conum" data-value="1"></i><b>(1)</b>
 psk=&#34;mypsk&#34; <i class="conum" data-value="2"></i><b>(2)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>是无线网络的 SSID 。请将其替换为无线网络的名称。 &lt;.&gt; 是无线网络的 PSK 。请将其替换为无线网络的密码。
<div class="ulist">
<ul>
<li>
<p>第三步是添加网络条目以在启动时配置网络：</p>
</li>
</ul>
</div></td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc wlans_iwn0=&#34;wlan0&#34;</span>
<span class="c"># sysrc ifconfig_wlan0=&#34;WPA DHCP&#34;</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>最后一步将是重新启动 <code>netif</code> 服务，执行以下命令：</p>
</li>
</ul>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service netif restart</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="basic-wireless-configuration">7.4.2. 基本无线配置<a class="anchor" href="#basic-wireless-configuration"></a></h4>
<div class="paragraph">
<p>第一步是将无线网络卡配置到一个接口上。要查看系统中有哪些无线网络卡，请参考 <a href="#config-identify-network-adapter">识别网络适配器</a> 部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandevice iwm0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使更改在重新启动后保持生效，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc wlans_iwn0=&#34;wlan0&#34;</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于世界各地的监管情况不同，因此有必要正确设置适用于您所在地区的域名，以获取关于可以使用哪些频道的正确信息。</p>
</div>
<div class="paragraph">
<p>可用的区域定义可以在 <span class="filename">/etc/regdomain.xml</span> 中找到。要在运行时设置数据，请使用 <code>ifconfig</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 regdomain etsi2 country AT</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要持久保存设置，请将其添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc create_args_wlan0=&#34;country AT regdomain etsi2&#34;</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="scan-wireless-networks">7.4.3. 扫描无线网络<a class="anchor" href="#scan-wireless-networks"></a></h4>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 命令扫描可用的无线网络。</p>
</div>
<div class="paragraph">
<p>要列出无线网络，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 up list scan</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>SSID/MESH ID                      BSSID              CHAN RATE    S:N     INT CAPS
FreeBSD                           e8:d1:1b:1b:58:ae    1   54M  -47:-96   100 EP   RSN BSSLOAD HTCAP WPS WME
NetBSD                            d4:b9:2f:35:fe:08    1   54M  -80:-96   100 EP   RSN BSSLOAD HTCAP WPS WME
OpenBSD                           fc:40:09:c6:31:bd   36   54M  -94:-96   100 EPS  VHTPWRENV APCHANREP RSN WPS BSSLOAD HTCAP VHTCAP VHTOPMODE WME
GNU-Linux                         dc:f8:b9:a0:a8:e0   44   54M  -95:-96   100 EP   WPA RSN WPS HTCAP VHTCAP VHTOPMODE WME VHTPWRENV
Windows                           44:48:b9:b3:c3:ff   44   54M  -84:-96   100 EP   BSSLOAD VHTPWRENV HTCAP WME RSN VHTCAP VHTOPMODE WPS
MacOS                             46:48:b9:b3:c3:ff   44   54M  -84:-96   100 EP   BSSLOAD VHTPWRENV HTCAP WME RSN VHTCAP VHTOPMODE WPS</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>SSID/MESH ID 标识网络的名称。</p>
</li>
<li>
<p>BSSID 标识了接入点的 MAC 地址。</p>
</li>
<li>
<p>CAPS 字段标识了每个网络的类型以及在该网络上运行的站点的能力（有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 中 <code>list scan</code> 的定义）。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="wireless-authentication">7.4.4. 连接和认证无线网络<a class="anchor" href="#wireless-authentication"></a></h4>
<div class="paragraph">
<p>一旦从扫描到的网络列表中选择了一个无线网络，就需要进行连接和认证。在绝大多数无线网络中，认证是通过路由器中配置的密码来完成的。其他方案要求在数据流量可以流动之前完成加密握手，可以使用预共享密钥或密钥，也可以使用涉及后端服务（如 RADIUS）的更复杂的方案。</p>
</div>
<div class="sect4">
<h5 id="authenticate-wpa2-wpa-personal">7.4.4.1. 使用 WPA2/WPA/Personal<a class="anchor" href="#authenticate-wpa2-wpa-personal"></a></h5>
<div class="paragraph">
<p>无线网络中的身份验证过程由 <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> 管理。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> 配置将在 <span class="filename">/etc/wpa_supplicant.conf</span> 文件中进行。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a>。</p>
</div>
<div class="paragraph">
<p>一旦完成了对无线网络的扫描，选择了一个网络并获得了密码（PSK），那么这些信息将被添加到文件 <span class="filename">/etc/wpa_supplicant.conf</span> 中，如下所示的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
        scan_ssid=1 <i class="conum" data-value="1"></i><b>(1)</b>
        ssid=&#34;FreeBSD&#34; <i class="conum" data-value="2"></i><b>(2)</b>
        psk=&#34;12345678&#34; <i class="conum" data-value="3"></i><b>(3)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>SSID 扫描技术。只有在网络隐藏时才需要使用此选项。 &lt;.&gt; 网络名称。 &lt;.&gt; 无线网络的密码。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下一步将是在文件 <span class="filename">/etc/rc.conf</span> 中配置无线连接。</p>
</div>
<div class="paragraph">
<p>要使用静态地址，需要执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_wlan0=&#34;inet 192.168.1.20 netmask 255.255.255.0&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用动态地址，需要执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig_wlan0=&#34;WPA DHCP&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后执行以下命令重新启动网络：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service netif restart</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以在 <a href="./#network-advanced-wireless">“无线高级认证”</a> 获取有关如何执行更高级身份验证方法的更多信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="authenticate-open-networks">7.4.4.2. 使用开放网络进行身份验证<a class="anchor" href="#authenticate-open-networks"></a></h5>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当用户连接到没有任何身份验证方式的开放网络时，非常重要的是用户要非常小心。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>完成无线网络扫描并选择无线网络的 SSID 后，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 ssid SSID</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 来获取配置的地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dhclient wlan0</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_同时使用有线和无线连接">7.4.5. 同时使用有线和无线连接<a class="anchor" href="#_同时使用有线和无线连接"></a></h4>
<div class="paragraph">
<p>有线连接提供更好的性能和可靠性，而无线连接提供灵活性和移动性。笔记本电脑用户通常希望在这两种连接类型之间无缝切换。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 上，可以以“故障转移（failover）”的方式将两个甚至更多的网络接口组合在一起。这种配置类型使用一组网络接口中最优先和可用的连接，并且当链路状态发生变化时，操作系统会自动切换。</p>
</div>
<div class="paragraph">
<p>链路聚合和故障转移在 <a href="./#network-aggregation">“链路聚合和故障转移”</a> 中有详细介绍，并且在 <a href="./#networking-lagg-wired-and-wireless">“以太网和无线接口之间的故障转移模式”</a> 中提供了同时使用有线和无线连接的示例。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="hostname">7.5. 主机名<a class="anchor" href="#hostname"></a></h3>
<div class="paragraph">
<p>主机名表示网络上主机的完全限定域名（FQDN）。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果主机没有设置主机名，FreeBSD 将分配值 <code>Amnesiac</code>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="get-hostname">7.5.1. 检查当前主机名<a class="anchor" href="#get-hostname"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> 可以用来检查当前的主机名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">$ </span>hostname</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>freebsdhostname.example.com</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="change-hostname">7.5.2. 更改主机名<a class="anchor" href="#change-hostname"></a></h4>
<div class="paragraph">
<p>要更改主机的主机名并在重新启动后保持不变，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc hostname=&#34;freebsdhostname.example.com&#34;</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dns">7.6. DNS<a class="anchor" href="#dns"></a></h3>
<div class="paragraph">
<p>DNS 可以被理解为一个 <a href="https://en.wikipedia.org/wiki/Telephone_directory">电话簿</a>，其中将 IP 地址与主机名进行互相识别。</p>
</div>
<div class="paragraph">
<p>有三个文件处理 FreeBSD 系统与 DNS 的交互。这三个文件是 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=nsswitch.conf&amp;sektion=5&amp;format=html">nsswitch.conf(5)</a>。</p>
</div>
<div class="paragraph">
<p>除非在 <span class="filename">/etc/nsswitch.conf</span> 文件中另有说明，否则 FreeBSD 将首先查看 <span class="filename">/etc/hosts</span> 文件中的地址，然后再查看 <span class="filename">/etc/resolv.conf</span> 文件中的 DNS 信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=nsswitch.conf&amp;sektion=5&amp;format=html">nsswitch.conf(5)</a> 文件指定了 nsdispatch（名称服务切换调度程序）的操作方式。</p>
</div>
<div class="paragraph">
<p>默认情况下，<span class="filename">/etc/nsswitch.conf</span> 文件的 hosts 部分将如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hosts: files dns</pre>
</div>
</div>
<div class="paragraph">
<p>例如，在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=nscd&amp;sektion=8&amp;format=html">nscd(8)</a> 服务的情况下，可以通过将该行保持如下来更改优先顺序：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hosts: files cache dns</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="local-addresses">7.6.1. 本地地址<a class="anchor" href="#local-addresses"></a></h4>
<div class="paragraph">
<p><span class="filename">/etc/hosts</span> 文件是一个简单的文本数据库，用于提供主机名到 IP 地址的映射。可以将连接到局域网的本地计算机的条目添加到此文件中，以简化命名，而不是设置 DNS 服务器。此外， <span class="filename">/etc/hosts</span> 还可以用于提供互联网名称的本地记录，减少查询外部 DNS 服务器以获取常用名称的需求。</p>
</div>
<div class="paragraph">
<p>例如，在本地环境中有一个名为 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/gitlab-ce/">www/gitlab-ce</a> 的本地实例的情况下，可以将其添加到文件 <span class="filename">/etc/hosts</span> 中，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>192.168.1.150 git.example.com git</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-nameserver">7.6.2. 配置域名服务器<a class="anchor" href="#configuring-nameserver"></a></h4>
<div class="paragraph">
<p>FreeBSD 系统如何访问互联网域名系统（DNS）由 <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> 控制。</p>
</div>
<div class="paragraph">
<p>最常见的条目是 <span class="filename">/etc/resolv.conf</span> ：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>nameserver</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">解析器应查询的名称服务器的 IP 地址。按照列出的顺序查询服务器，最多查询三个。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>search</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">搜索列表用于主机名查找。通常由本地主机名的域确定。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>domain</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">本地域名。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>一个典型的 <span class="filename">/etc/resolv.conf</span> 文件如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>search example.com
nameserver 147.11.1.11
nameserver 147.11.100.30</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>只能使用 <code>search</code> 和 <code>domain</code> 选项中的一个。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在使用 DHCP 时，<a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 通常会使用从 DHCP 服务器接收到的信息重写 .filename#/etc/resolv.conf# 文件。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果进行配置的机器 <strong>不是</strong> DNS 服务器，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=local-unbound&amp;sektion=8&amp;format=html">local-unbound(8)</a> 来提高 DNS 查找性能。</p>
</div>
<div class="paragraph">
<p>要在启动时启用它，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc local_unbound_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=local-unbound&amp;sektion=8&amp;format=html">local-unbound(8)</a> 服务，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service local_unbound start</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="troubleshooting">7.7. 故障排除<a class="anchor" href="#troubleshooting"></a></h3>
<div class="paragraph">
<p>在排除硬件和软件配置问题时，首先检查简单的事情。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网络电缆已插好吗？</p>
</li>
<li>
<p>网络服务是否已正确配置？</p>
</li>
<li>
<p>防火墙配置正确吗？</p>
</li>
<li>
<p>FreeBSD 是否支持该网卡？</p>
</li>
<li>
<p>路由器是否正常工作？</p>
</li>
</ul>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在发送错误报告之前，始终要在 <a href="https://www.freebsd.org/releases/">FreeBSD 发布页面</a> 检查硬件说明 ，将 FreeBSD 版本更新到最新的 STABLE 版本，检查邮件列表存档，并在互联网上进行搜索。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="wired-troubleshooting">7.7.1. 有线网络故障排除<a class="anchor" href="#wired-troubleshooting"></a></h4>
<div class="paragraph">
<p>如果卡可以正常工作，但性能较差，请阅读 <a href="https://man.freebsd.org/cgi/man.cgi?query=tuning&amp;sektion=7&amp;format=html">tuning(7)</a>。此外，请检查网络配置，因为不正确的网络设置可能会导致连接变慢。</p>
</div>
<div class="paragraph">
<p>如果系统无法将数据包路由到目标主机，则会出现“无法到达主机”的消息。如果没有指定默认路由或者电缆未插好，就会发生这种情况。检查 <code>netstat -rn</code> 的输出，并确保存在到目标主机的有效路由。如果不存在有效路由，请阅读 <a href="./#network-routing">“网关和路由”</a>.</p>
</div>
<div class="paragraph">
<p><code>ping: sendto: Permission denied</code> 错误消息通常是由于配置错误的防火墙引起的。如果在 FreeBSD 上启用了防火墙但没有定义规则，那么默认策略是拒绝所有流量，甚至是 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a>。有关更多信息，请参考 <a href="./#firewalls">防火墙</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="wireless-troubleshooting">7.7.2. 无线网络故障排除<a class="anchor" href="#wireless-troubleshooting"></a></h4>
<div class="paragraph">
<p>本节描述了一些步骤，以帮助解决常见的无线网络问题。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果在扫描时未列出访问点，请检查配置是否限制了无线设备的频道范围。</p>
</li>
<li>
<p>如果设备无法与接入点关联，请验证配置是否与接入点上的设置匹配。这包括认证方案和任何安全协议。尽量简化配置。如果使用 WPA2 或 WPA 等安全协议，请将接入点配置为开放认证和无安全性，以查看是否可以传输流量。</p>
</li>
<li>
<p>一旦系统能够与接入点建立关联，可以使用诸如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 之类的工具来诊断网络配置。</p>
</li>
<li>
<p>有许多低级调试工具。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=wlandebug&amp;sektion=8&amp;format=html">wlandebug(8)</a> 在 802.11 协议支持层启用调试消息。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<h1 id="common-tasks" class="sect0">Part II: 常见任务<a class="anchor" href="#common-tasks"></a></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>现在基础知识已经介绍完毕，本书的这一部分将讨论 FreeBSD 的一些常用功能。这些章节包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>介绍流行且实用的桌面应用程序：浏览器、办公工具、文档查看器等等。</p>
</li>
<li>
<p>介绍一些适用于 FreeBSD 的多媒体工具。</p>
</li>
<li>
<p>解释构建自定义 FreeBSD 内核以启用额外功能的过程。</p>
</li>
<li>
<p>详细描述桌面和网络连接打印机设置中的打印系统。</p>
</li>
<li>
<p>展示如何在 FreeBSD 系统上运行 Linux 应用程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>其中一些章节建议先阅读，这在每个章节开头的简介中有注明。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="desktop">Chapter 8. 桌面环境<a class="anchor" href="#desktop"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="desktop-synopsis">8.1. 简介<a class="anchor" href="#desktop-synopsis"></a></h3>
<div class="paragraph">
<p>尽管 FreeBSD 因其性能和稳定性而在服务器领域很受欢迎，但它也非常适合作为日常桌面使用。在 FreeBSD ports 树中有超过 36000 个应用程序可用，可以轻松构建一个定制的桌面环境，可以运行各种各样的桌面应用程序。本章介绍了如何安装流行的桌面环境以及诸如网络浏览器、办公软件、文档查看器和财务软件等桌面应用程序。</p>
</div>
<div class="paragraph">
<p>先决条件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>阅读本章的读者应该已经了解如何在 FreeBSD 上安装 <a href="./#x11 ， X Window System"></a> 或 <a href="./#wayland ， Wayland"></a> 。</p>
</li>
<li>
<p>在本章中，读者被指示安装官方软件包。请参考 <a href="./#ports-using">使用端口集合</a> 部分，以从端口构建定制软件包。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="desktop-environments">8.2. 桌面环境<a class="anchor" href="#desktop-environments"></a></h3>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 系统上安装和配置一些流行的桌面环境。桌面环境可以是一个简单的窗口管理器，也可以是一个完整的桌面应用套件。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 10. 支持的桌面环境</caption>
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KDE Plasma 是一个开源的桌面环境，为 Linux 和其他类 Unix 操作系统提供了一个现代化和可定制的用户界面。它提供了丰富的功能和工具，包括面板、应用程序菜单、任务管理器、文件管理器等，使用户能够方便地管理和使用计算机。 KDE Plasma 还支持各种主题和插件，可以根据个人喜好进行个性化设置。它被广泛用于许多 Linux 发行版中，被认为是一个功能强大且易于使用的桌面环境。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/kde5 是一个指向 X11 和 KDE5 的路径或标签。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GNOME 是一个开源的桌面环境，它提供了一个直观和用户友好的界面，用于在 Linux 和其他类 Unix 操作系统上运行。 GNOME 的目标是提供一个现代化、易于使用和高度可定制的桌面环境，以满足各种用户的需求。 GNOME 还提供了许多应用程序和工具，用于增强用户体验和提高生产力。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/gnome 是一个基于 X Window System 的桌面环境。它是一个开源的项目，旨在提供一个直观、易用和美观的用户界面。 GNOME 桌面环境提供了许多应用程序和工具，包括文件管理器、文本编辑器、终端仿真器等，以满足用户的各种需求。它还支持插件和扩展，可以根据用户的喜好进行个性化定制。 GNOME 桌面环境在 Linux 和其他类 Unix 操作系统上广泛使用，并且有一个活跃的开发社区。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">XFCE 是一个轻量级的桌面环境，它注重速度和资源效率。它提供了一个简洁而直观的用户界面，适用于各种操作系统，包括 Linux 、 BSD 和 Solaris 。 XFCE 提供了许多常用的功能，如窗口管理、面板、应用程序菜单和文件管理器。它还支持自定义和扩展，用户可以根据自己的喜好进行个性化设置。总体而言， XFCE 是一个稳定、可靠且易于使用的桌面环境。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL ， LGPL ， BSD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11-wm/xfce4 是一个 X Window 系统下的窗口管理器，它是一个轻量级的桌面环境，提供了一套简洁而功能丰富的用户界面。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MATE 是一个开源的桌面环境，最初是为 GNOME 2 开发的一个分支。它提供了一个传统的、直观的用户界面，类似于早期的 GNOME 版本。 MATE 桌面环境具有稳定性和可定制性的特点，可以在多种 Linux 发行版上使用。它支持多任务处理、窗口管理、面板、应用程序菜单等常见功能，并提供了许多扩展和插件来增强用户体验。 MATE 桌面环境还提供了一些自带的应用程序，如文件管理器、文本编辑器、终端模拟器等。总之， MATE 是一个功能强大且易于使用的桌面环境，适合那些喜欢传统风格的用户。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 ， LGPL 2.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/mate 是一个基于 X Window System 的桌面环境，它是一个轻量级的、易于使用的桌面环境，特别适合于老旧的计算机或资源有限的设备。它提供了许多常见的桌面功能，如窗口管理、面板、菜单、文件管理器等，并且具有高度的可定制性。 MATE 桌面环境是一个开源项目，它的目标是提供一个传统的、经典的桌面体验，类似于 GNOME 2.x 系列。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">肉桂</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11/cinnamon 是一个基于 X11 窗口系统的桌面环境，它提供了一套直观和易于使用的用户界面，适用于 Linux 操作系统。 Cinnamon 桌面环境具有类似于传统桌面的布局和功能，包括任务栏、应用程序菜单、系统托盘等。它还支持自定义主题和插件，使用户能够根据自己的喜好进行个性化设置。 Cinnamon 是一个轻量级的桌面环境，具有良好的性能和稳定性，适合于各种类型的计算机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LXQt 是一个轻量级的桌面环境，它是 LXDE 和 Razor-qt 两个项目的合并。它使用 Qt 框架和 Openbox 窗口管理器，并提供了一个简洁、快速和易于使用的用户界面。 LXQt 支持多种语言，并且具有可定制性强的特点，可以根据用户的喜好进行个性化设置。它适用于资源有限的系统，如低端计算机和嵌入式设备。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL （ GNU 通用公共许可证）和 LGPL （ GNU 较宽松公共许可证）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">x11-wm/lxqt 是一个基于 X11 窗口管理器的 LXQt 桌面环境。</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="kde-environment">8.2.1. KDE Plasma 是一个开源的桌面环境，为 Linux 和其他类 Unix 操作系统提供了一个现代化和可定制的用户界面。它提供了丰富的功能和工具，包括面板、应用程序菜单、任务管理器、文件管理器等，使用户能够方便地管理和使用计算机。 KDE Plasma 还支持各种主题和插件，可以根据个人喜好进行个性化设置。它被广泛用于许多 Linux 发行版中，被认为是一个功能强大且易于使用的桌面环境。<a class="anchor" href="#kde-environment"></a></h4>
<div class="paragraph">
<p>KDE Plasma 是一个易于使用的桌面环境。该桌面提供了一套应用程序，具有一致的外观和感觉，标准化的菜单和工具栏，键绑定，配色方案，国际化以及集中式、对话框驱动的桌面配置。有关 KDE 的更多信息，请访问链接： <a href="https://kde.org/">KDE 主页</a> 。有关 FreeBSD 特定信息，请参阅链接： <a href="https://freebsd.kde.org/">KDE 上的 FreeBSD 主页</a> 。</p>
</div>
<div class="sect4">
<h5 id="kde-meta-install">8.2.1.1. 安装 KDE Plasma 元包<a class="anchor" href="#kde-meta-install"></a></h5>
<div class="paragraph">
<p>要安装带有 KDE 框架、 Plasma 桌面和应用程序的 KDE Plasma 元包，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install kde5</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kde-minimal-install">8.2.1.2. 最小化的 KDE Plasma 安装<a class="anchor" href="#kde-minimal-install"></a></h5>
<div class="paragraph">
<p>要安装最小化的 KDE Plasma ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install plasma5-plasma</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这个安装非常简洁。必须单独安装 Konsole ，执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install konsole</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="kde-configuration">8.2.1.3. 配置 KDE Plasma<a class="anchor" href="#kde-configuration"></a></h5>
<div class="paragraph">
<p>KDE Plasma 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dbus-daemon&amp;sektion=1&amp;format=html">dbus-daemon(1)</a> 作为消息总线和硬件抽象层。这个应用程序会自动作为 KDE Plasma 的依赖项安装。</p>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 D-BUS 服务以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc dbus_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要增加消息大小，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">sysctl net.local.stream.recvspace<span class="o">=</span>65536
sysctl net.local.stream.sendspace<span class="o">=</span>65536</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="kde-start">8.2.1.4. 启动 KDE Plasma<a class="anchor" href="#kde-start"></a></h5>
<div class="paragraph">
<p>首选的 KDE Plasma 显示管理器是 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11/sddm/">x11/sddm</a> 。要安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11/sddm/">x11/sddm</a> ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install sddm</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 SDDM 服务以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc sddm_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过运行以下命令在 SDDM 中设置键盘语言（例如，对于西班牙语）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc sddm_lang=&#34;es_ES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动 KDE Plasma 的第二种方法是手动调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> 。为了使其工作，需要在~ /.xinitrc 中添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo</span> <span class="s2">&#34;exec ck-launch-session startplasma-x11&#34;</span> &gt; ~/.xinitrc</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gnome-environment">8.2.2. GNOME 是一个开源的桌面环境，它提供了一个直观和用户友好的界面，用于在 Linux 和其他类 Unix 操作系统上运行。 GNOME 的目标是提供一个现代化、易于使用和高度可定制的桌面环境，以满足各种用户的需求。 GNOME 还提供了许多应用程序和工具，用于增强用户体验和提高生产力。<a class="anchor" href="#gnome-environment"></a></h4>
<div class="paragraph">
<p>GNOME 是一个用户友好的桌面环境。它包括一个用于启动应用程序和显示状态的面板，一个桌面，一套工具和应用程序，以及一套使应用程序能够合作并保持一致的约定。</p>
</div>
<div class="sect4">
<h5 id="gnome-meta-install">8.2.2.1. 安装 GNOME 元包<a class="anchor" href="#gnome-meta-install"></a></h5>
<div class="paragraph">
<p>要安装带有 GNOME 桌面和应用程序的 GNOME 元包，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install gnome</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="gnome-minimal-install">8.2.2.2. 最小化的 GNOME 安装<a class="anchor" href="#gnome-minimal-install"></a></h5>
<div class="paragraph">
<p>要安装 GNOME-lite 元包，其中包含了经过精简的 GNOME 桌面，仅包含基本功能，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install gnome-lite</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="gnome-configuration">8.2.2.3. 配置 GNOME<a class="anchor" href="#gnome-configuration"></a></h5>
<div class="paragraph">
<p>GNOME 需要挂载 <code>/proc</code> 。在系统启动时自动挂载此文件系统，请将以下行添加到 <code>/etc/fstab</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
proc                    /proc           procfs  rw              0       0</pre>
</div>
</div>
<div class="paragraph">
<p>GNOME 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dbus-daemon&amp;sektion=1&amp;format=html">dbus-daemon(1)</a> 作为消息总线和硬件抽象的工具。这个应用程序会作为 GNOME 的依赖自动安装。</p>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 D-BUS 服务以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc dbus_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="gnome-start">8.2.2.4. 启动 GNOME<a class="anchor" href="#gnome-start"></a></h5>
<div class="paragraph">
<p>GNOME Display Manager （简称 GDM ）是 GNOME 首选的显示管理器。 GDM 作为 GNOME 软件包的一部分进行安装。</p>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 GDM 以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc gdm_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动 GNOME 的第二种方法是手动调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> 。为了使其工作，需要在 ` ~ /.xinitrc` 中添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo</span> <span class="s2">&#34;exec gnome-session&#34;</span> &gt; ~/.xinitrc</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xfce-environment">8.2.3. XFCE 是一个轻量级的桌面环境，它注重速度和资源效率。它提供了一个简洁而直观的用户界面，适用于各种操作系统，包括 Linux 、 BSD 和 Solaris 。 XFCE 提供了许多常用的功能，如窗口管理、面板、应用程序菜单和文件管理器。它还支持自定义和扩展，用户可以根据自己的喜好进行个性化设置。总体而言， XFCE 是一个稳定、可靠且易于使用的桌面环境。<a class="anchor" href="#xfce-environment"></a></h4>
<div class="paragraph">
<p>XFCE 是一个基于 GTK +的桌面环境，它轻量级并提供了一个简单、高效、易于使用的桌面。它可以完全配置，有一个带有菜单、小部件和应用程序启动器的主面板，提供文件管理器和声音管理器，并且支持主题定制。由于它快速、轻量级和高效，非常适合内存有限的老旧或较慢的计算机。</p>
</div>
<div class="sect4">
<h5 id="xfce-install">8.2.3.1. 安装 XFCE<a class="anchor" href="#xfce-install"></a></h5>
<div class="paragraph">
<p>要安装 XFCE 元包，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install xfce</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xfce-configuration">8.2.3.2. 配置 XFCE<a class="anchor" href="#xfce-configuration"></a></h5>
<div class="paragraph">
<p>XFCE 需要挂载 <code>/proc</code> 。在系统启动时自动挂载此文件系统，请将以下行添加到 <code>/etc/fstab</code> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
proc                    /proc           procfs  rw              0       0</pre>
</div>
</div>
<div class="paragraph">
<p>XFCE 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dbus-daemon&amp;sektion=1&amp;format=html">dbus-daemon(1)</a> 作为消息总线和硬件抽象的工具。这个应用程序会作为 XFCE 的依赖项自动安装。</p>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 D-BUS 以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc dbus_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="xfce-start">8.2.3.3. 启动 XFCE<a class="anchor" href="#xfce-start"></a></h5>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/x11/lightdm/">x11/lightdm</a> 是一个支持不同显示技术的显示管理器，它非常轻量级，内存使用量少，并且性能快速，是一个很好的选择。</p>
</div>
<div class="paragraph">
<p>要安装它，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install lightdm lightdm-gtk-greeter</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 lightdm 以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc lightdm_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动 XFCE 的第二种方法是手动调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> 。为了使其工作，需要在 ` ~ /.xinitrc` 中添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo</span> <span class="s1">&#39;. /usr/local/etc/xdg/xfce4/xinitrc&#39;</span> &gt; ~/.xinitrc</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mate-environment">8.2.4. MATE 是一个开源的桌面环境，最初是为 GNOME 2 开发的一个分支。它提供了一个传统的、直观的用户界面，类似于早期的 GNOME 版本。 MATE 桌面环境具有稳定性和可定制性的特点，可以在多种 Linux 发行版上使用。它支持多任务处理、窗口管理、面板、应用程序菜单等常见功能，并提供了许多扩展和插件来增强用户体验。 MATE 桌面环境还提供了一些自带的应用程序，如文件管理器、文本编辑器、终端模拟器等。总之， MATE 是一个功能强大且易于使用的桌面环境，适合那些喜欢传统风格的用户。<a class="anchor" href="#mate-environment"></a></h4>
<div class="paragraph">
<p>MATE 桌面环境是 GNOME 2 的延续。它使用传统的隐喻，提供直观和吸引人的桌面环境。</p>
</div>
<div class="sect4">
<h5 id="mate-meta-install">8.2.4.1. 安装 MATE 元包<a class="anchor" href="#mate-meta-install"></a></h5>
<div class="paragraph">
<p>要安装包含 MATE 桌面和一些额外应用程序（如文本编辑器、压缩管理器等）的 MATE 元包，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install mate</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mate-minimal-install">8.2.4.2. 最小化的 MATE 安装<a class="anchor" href="#mate-minimal-install"></a></h5>
<div class="paragraph">
<p>要安装 MATE Lite 元包，其中 MATE 桌面被精简为仅包含基本功能，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install mate-base</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mate-configuration">8.2.4.3. 配置 MATE<a class="anchor" href="#mate-configuration"></a></h5>
<div class="paragraph">
<p>MATE 需要挂载 <code>/proc</code> 。在系统启动时自动挂载该文件系统，请将以下行添加到 <code>/etc/fstab</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
proc                    /proc           procfs  rw              0       0</pre>
</div>
</div>
<div class="paragraph">
<p>MATE 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dbus-daemon&amp;sektion=1&amp;format=html">dbus-daemon(1)</a> 作为消息总线和硬件抽象层。这个应用程序会自动作为 MATE 的依赖项安装。在 <code>/etc/rc.conf</code> 中启用 D-BUS 以在系统启动时启动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc dbus_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="mate-start">8.2.4.4. 启动 MATE<a class="anchor" href="#mate-start"></a></h5>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/x11/lightdm/">x11/lightdm</a> 是一个支持不同显示技术的显示管理器，它非常轻量级，内存使用量少，并且性能快速，是一个很好的选择。</p>
</div>
<div class="paragraph">
<p>要安装它，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install lightdm lightdm-gtk-greeter</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 lightdm 以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc lightdm_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动 MATE 的第二种方法是手动调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> 。为了使其工作，需要在 ` ~ /.xinitrc` 中添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo</span> <span class="s2">&#34;exec ck-launch-session mate-session&#34;</span> &gt; ~/.xinitrc</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cinnamon-environment">8.2.5. 肉桂<a class="anchor" href="#cinnamon-environment"></a></h4>
<div class="paragraph">
<p>Cinnamon 是一个 UNIX® 桌面环境，提供先进的创新功能和传统的用户体验。桌面布局类似于 Gnome 2 。底层技术是从 Gnome Shell 分叉出来的。重点是让用户感到宾至如归，并为他们提供易于使用和舒适的桌面体验。</p>
</div>
<div class="sect4">
<h5 id="cinnamon-install">8.2.5.1. 安装 Cinnamon<a class="anchor" href="#cinnamon-install"></a></h5>
<div class="paragraph">
<p>要安装 Cinnamon 软件包，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install cinnamon</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cinnamon-configuration">8.2.5.2. 配置 Cinnamon<a class="anchor" href="#cinnamon-configuration"></a></h5>
<div class="paragraph">
<p>Cinnamon 需要挂载 <code>/proc</code> 。在系统启动时自动挂载该文件系统，请将以下行添加到 <code>/etc/fstab</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
proc                    /proc           procfs  rw              0       0</pre>
</div>
</div>
<div class="paragraph">
<p>Cinnamon 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dbus-daemon&amp;sektion=1&amp;format=html">dbus-daemon(1)</a> 作为消息总线和硬件抽象层。这个应用程序会自动作为 Cinnamon 的依赖项安装。在 <code>/etc/rc.conf</code> 中启用 D-BUS 以在系统启动时启动它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc dbus_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="cinnamon-start">8.2.5.3. 启动 Cinnamon<a class="anchor" href="#cinnamon-start"></a></h5>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/x11/lightdm/">x11/lightdm</a> 是一个支持不同显示技术的显示管理器，它非常轻量级，内存使用量少，并且性能快速，是一个很好的选择。</p>
</div>
<div class="paragraph">
<p>要安装它，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install lightdm lightdm-gtk-greeter</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 lightdm 以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc lightdm_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动 Cinnamon 的第二种方法是手动调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> 。为了使其工作，需要在 ` ~ /.xinitrc` 中添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo</span> <span class="s2">&#34;exec ck-launch-session cinnamon-session&#34;</span> &gt; ~/.xinitrc</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="lxqt-environment">8.2.6. LXQt 是一个轻量级的桌面环境，它是 LXDE 和 Razor-qt 两个项目的合并。它使用 Qt 框架和 Openbox 窗口管理器，并提供了一个简洁、快速和易于使用的用户界面。 LXQt 支持多种语言，并且具有可定制性强的特点，可以根据用户的喜好进行个性化设置。它适用于资源有限的系统，如低端计算机和嵌入式设备。<a class="anchor" href="#lxqt-environment"></a></h4>
<div class="paragraph">
<p>LXQt 是一个基于 Qt 技术的先进、易于使用和快速的桌面环境。它专为那些重视简洁、速度和直观界面的用户量身定制。与大多数桌面环境不同， LXQt 在性能较低的机器上也能良好运行。</p>
</div>
<div class="sect4">
<h5 id="lxqt-install">8.2.6.1. 安装 LXQT<a class="anchor" href="#lxqt-install"></a></h5>
<div class="paragraph">
<p>要安装 LXQT 元包，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install lxqt</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="lxqt-configuration">8.2.6.2. 配置 LXQT<a class="anchor" href="#lxqt-configuration"></a></h5>
<div class="paragraph">
<p>LXQT 需要挂载 <code>/proc</code> 。在系统启动时自动挂载该文件系统，请将以下行添加到 <code>/etc/fstab</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
proc                    /proc           procfs  rw              0       0</pre>
</div>
</div>
<div class="paragraph">
<p>LXQT 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dbus-daemon&amp;sektion=1&amp;format=html">dbus-daemon(1)</a> 作为消息总线和硬件抽象的工具。这个应用程序会自动作为 LXQT 的依赖项进行安装。</p>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 D-BUS 以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc dbus_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="lxqt-start">8.2.6.3. 启动 LXQT<a class="anchor" href="#lxqt-start"></a></h5>
<div class="paragraph">
<p>首选的 LXQT 显示管理器是 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11/sddm/">x11/sddm</a> 。要安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/x11/sddm/">x11/sddm</a> ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install sddm</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 SDDM 服务以在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc sddm_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 SDDM 中，可以通过运行以下命令来设置键盘语言（例如，对于西班牙语）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc sddm_lang=&#34;es_ES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动 LXQT 的第二种方法是手动调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=startx&amp;sektion=1&amp;format=html">startx(1)</a> 。为了使其工作，需要在 ` ~ /.xinitrc` 中添加以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo</span> <span class="s2">&#34;exec ck-launch-session startlxqt&#34;</span> &gt; ~/.xinitrc</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="desktop-browsers">8.3. 浏览器<a class="anchor" href="#desktop-browsers"></a></h3>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 系统上安装和配置一些流行的网络浏览器，从资源消耗较高的完整网络浏览器到资源使用较少的命令行网络浏览器。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 11. 支持的浏览器</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">所需资源</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Firefox 是一款开源的网络浏览器，由 Mozilla 基金会开发和维护。它是一款跨平台的浏览器，可在 Windows 、 macOS 、 Linux 和 Android 等操作系统上运行。 Firefox 以其快速的浏览速度、强大的安全性和丰富的功能而闻名。它支持扩展插件，用户可以根据自己的需求自定义浏览器功能。 Firefox 还注重用户隐私保护，提供了一系列的隐私设置选项，以确保用户的个人信息安全。作为一款开源软件， Firefox 的源代码对开发者开放，任何人都可以参与到其开发和改进中。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPL 2.0 是 Mozilla 公共许可证的第 2 个版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/firefox[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Chromium 是一个开源的网页浏览器项目，由 Google 主导开发。它是 Google Chrome 浏览器的基础，提供了类似的功能和用户界面。 Chromium 的目标是提供一个快速、稳定和安全的浏览器，同时也为开发者提供一个可扩展的平台。它支持多种操作系统，包括 Windows 、 Mac 和 Linux 。 Chromium 的源代码是公开的，任何人都可以查看和修改。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-3 和其他</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/chromium[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">铱浏览器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-3 和其他</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/iridium-browser[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Falkon 是一个开源的跨平台网络浏览器，旨在提供快速、轻量级和用户友好的浏览体验。它基于 QtWebEngine 引擎，具有现代化的用户界面和丰富的功能，包括标签页管理、书签管理、扩展支持等。 Falkon 支持多种操作系统，包括 Windows 、 macOS 和 Linux 。它还提供了一些高级功能，如广告拦截、隐私保护和自定义设置，以满足用户的不同需求。无论是日常浏览网页还是进行在线活动， Falkon 都是一个可靠的选择。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPL 2.0 是 Mozilla 公共许可证的第 2 个版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/falkon-qtonly[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Konqueror 是一款开源的网络浏览器和文件管理器，最初是 KDE 桌面环境的一部分。它是一个功能强大且灵活的应用程序，可以在 Linux 和其他类 Unix 系统上运行。 Konqueror 支持多种网络协议，包括 HTTP 、 FTP 和 SMB 等。它还具有文件管理功能，可以浏览本地文件系统和远程文件系统。 Konqueror 还支持插件和扩展，可以根据用户的需求进行定制。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： x11-fm/konqueror[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">中等的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Gnome Web （ Epiphany ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 3.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/epiphany[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">中等的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">qutebrowser 是一个基于 Python 和 QtWebEngine 的开源网络浏览器。它的设计目标是提供一个快速、轻量级且可定制的浏览器，同时保持简洁和易于使用的界面。 qutebrowser 支持键盘导航和命令行操作，可以通过键盘快捷键来浏览网页、打开链接和执行其他操作。它还支持用户脚本和插件，可以根据个人需求进行扩展和定制。 qutebrowser 是一个适用于计算机爱好者和技术专业人士的浏览器，它提供了丰富的功能和灵活的配置选项。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 3.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/qutebrowser[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">中等的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Dillo</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 3.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/dillo[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">轻盈</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : www/links[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">轻盈</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">w3m 是一个用于终端的文本浏览器。它支持 HTML 、 ASCII 文本和图像的浏览，并且具有一些基本的浏览功能，如超链接导航、书签管理和搜索等。 w3m 是一个轻量级的浏览器，适用于在命令行界面下浏览互联网或本地文件。它在 Linux 和其他类 Unix 系统上广泛使用，并且可以通过命令行或配置文件进行自定义设置。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">麻省理工学院</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： www/w3m[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">轻盈</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="firefox">8.3.1. Firefox 是一款开源的网络浏览器，由 Mozilla 基金会开发和维护。它是一款跨平台的浏览器，可在 Windows 、 macOS 、 Linux 和 Android 等操作系统上运行。 Firefox 以其快速的浏览速度、强大的安全性和丰富的功能而闻名。它支持扩展插件，用户可以根据自己的需求自定义浏览器功能。 Firefox 还注重用户隐私保护，提供了一系列的隐私设置选项，以确保用户的个人信息安全。作为一款开源软件， Firefox 的源代码对开发者开放，任何人都可以参与到其开发和改进中。<a class="anchor" href="#firefox"></a></h4>
<div class="paragraph">
<p>Firefox 是一个开源浏览器，具有符合标准的 HTML 显示引擎、选项卡浏览、弹窗阻止、扩展功能、增强的安全性等特点。 Firefox 基于 Mozilla 代码库开发。</p>
</div>
<div class="paragraph">
<p>要安装最新发布版本的 Firefox 软件包，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install firefox</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要安装 Firefox Extended Support Release (ESR) 版本，执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install firefox-esr</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="chromium">8.3.2. Chromium 是一个开源的网页浏览器项目，由 Google 主导开发。它是 Google Chrome 浏览器的基础，提供了类似的功能和用户界面。 Chromium 的目标是提供一个快速、稳定和安全的浏览器，同时也为开发者提供一个可扩展的平台。它支持多种操作系统，包括 Windows 、 Mac 和 Linux 。 Chromium 的源代码是公开的，任何人都可以查看和修改。<a class="anchor" href="#chromium"></a></h4>
<div class="paragraph">
<p>Chromium 是一个开源的浏览器项目，旨在构建更安全、更快速、更稳定的网络浏览体验。 Chromium 具有标签式浏览、弹窗拦截、扩展等功能。 Chromium 是 Google Chrome 浏览器基于的开源项目。</p>
</div>
<div class="paragraph">
<p>要安装 Chromium ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install chromium</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Chromium 的可执行文件是 [/usr/local/bin/chrome] ，而不是 [/usr/local/bin/chromium] 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="iridium">8.3.3. 铱浏览器<a class="anchor" href="#iridium"></a></h4>
<div class="paragraph">
<p>Iridium 是一个免费、开放和自由的浏览器修改版本，基于 Chromium 代码库，通过增强隐私保护在几个关键领域进行改进。禁止自动传输部分查询、关键词和指标到中央服务，只有在获得同意的情况下才会发生传输。</p>
</div>
<div class="paragraph">
<p>要安装 Iridium ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install iridium-browser</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="falkon">8.3.4. Falkon 是一个开源的跨平台网络浏览器，旨在提供快速、轻量级和用户友好的浏览体验。它基于 QtWebEngine 引擎，具有现代化的用户界面和丰富的功能，包括标签页管理、书签管理、扩展支持等。 Falkon 支持多种操作系统，包括 Windows 、 macOS 和 Linux 。它还提供了一些高级功能，如广告拦截、隐私保护和自定义设置，以满足用户的不同需求。无论是日常浏览网页还是进行在线活动， Falkon 都是一个可靠的选择。<a class="anchor" href="#falkon"></a></h4>
<div class="paragraph">
<p>Falkon 是一个新近推出的非常快速的 QtWebEngine 浏览器。它旨在成为一款轻量级的适用于所有主要平台的网络浏览器。 Falkon 具备您从一个网络浏览器所期望的所有标准功能。它包括书签、历史记录（两者都在侧边栏中）和选项卡。除此之外，您还可以使用内置的 AdBlock 插件屏蔽广告，使用 Click2Flash 屏蔽 Flash 内容，并使用 SSL 管理器编辑本地 CA 证书数据库。</p>
</div>
<div class="paragraph">
<p>要安装 Falkon ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install falkon</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="konqueror">8.3.5. Konqueror 是一款开源的网络浏览器和文件管理器，最初是 KDE 桌面环境的一部分。它是一个功能强大且灵活的应用程序，可以在 Linux 和其他类 Unix 系统上运行。 Konqueror 支持多种网络协议，包括 HTTP 、 FTP 和 SMB 等。它还具有文件管理功能，可以浏览本地文件系统和远程文件系统。 Konqueror 还支持插件和扩展，可以根据用户的需求进行定制。<a class="anchor" href="#konqueror"></a></h4>
<div class="paragraph">
<p>Konqueror 不仅是一个网页浏览器，还是一个文件管理器和多媒体查看器。它支持 WebKit ，这是许多现代浏览器（包括 Chromium ）使用的渲染引擎，同时也支持自己的 KHTML 引擎。</p>
</div>
<div class="paragraph">
<p>要安装 Konqueror ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install konqueror</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gnome-web-epiphany">8.3.6. Gnome Web （ Epiphany ）<a class="anchor" href="#gnome-web-epiphany"></a></h4>
<div class="paragraph">
<p>Gnome Web （ Epiphany ）是一个旨在尽可能轻量和快速的网络浏览器，但牺牲了其他浏览器中的许多功能。</p>
</div>
<div class="paragraph">
<p>要安装 Gnome Web （ Epiphany ），执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install epiphany</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="qutebrowser">8.3.7. qutebrowser 是一个基于 Python 和 QtWebEngine 的开源网络浏览器。它的设计目标是提供一个快速、轻量级且可定制的浏览器，同时保持简洁和易于使用的界面。 qutebrowser 支持键盘导航和命令行操作，可以通过键盘快捷键来浏览网页、打开链接和执行其他操作。它还支持用户脚本和插件，可以根据个人需求进行扩展和定制。 qutebrowser 是一个适用于计算机爱好者和技术专业人士的浏览器，它提供了丰富的功能和灵活的配置选项。<a class="anchor" href="#qutebrowser"></a></h4>
<div class="paragraph">
<p>Qutebrowser 是一个以键盘为重点的浏览器，具有简洁的图形用户界面。它基于 Python 和 PyQt5 ，是一款自由软件，根据 GPL 许可证发布。</p>
</div>
<div class="paragraph">
<p>要安装 qutebrowser ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install qutebrowser</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dillo">8.3.8. Dillo<a class="anchor" href="#dillo"></a></h4>
<div class="paragraph">
<p>Dillo 旨在成为一个跨平台的替代浏览器，它小巧、稳定、开发者友好、易用、快速和可扩展。这个新的实验版本的 Dillo 基于 FLTK 工具包，而不是 GTK1 ，并且已经进行了大量的重写。</p>
</div>
<div class="paragraph">
<p>要安装 Dillo ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install dillo</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="links">8.3.9. 链接<a class="anchor" href="#links"></a></h4>
<div class="paragraph">
<p>一个类似猞猁的网络浏览器，具有文本和图形模式，具有许多功能，如显示表格、菜单等。</p>
</div>
<div class="paragraph">
<p>要安装 Links ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install links</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="w3m">8.3.10. w3m 是一个用于终端的文本浏览器。它支持 HTML 、 ASCII 文本和图像的浏览，并且具有一些基本的浏览功能，如超链接导航、书签管理和搜索等。 w3m 是一个轻量级的浏览器，适用于在命令行界面下浏览互联网或本地文件。它在 Linux 和其他类 Unix 系统上广泛使用，并且可以通过命令行或配置文件进行自定义设置。<a class="anchor" href="#w3m"></a></h4>
<div class="paragraph">
<p>w3m 是一个分页器 / 基于文本的网页浏览器。它与 Lynx 类似，但具有 Lynx 没有的几个功能，如渲染表格和渲染框架。</p>
</div>
<div class="paragraph">
<p>要安装 w3m ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install w3m</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="desktop-development">8.4. 开发工具<a class="anchor" href="#desktop-development"></a></h3>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 系统上安装和配置一些流行的开发工具。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 12. 支持的开发工具</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">所需资源</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Visual Studio Code 是一款由微软开发的免费源代码编辑器。它支持多种编程语言，并提供了丰富的功能和插件，使开发者能够更高效地编写和调试代码。 Visual Studio Code 具有直观的用户界面和强大的编辑功能，可以满足开发者的各种需求。它还支持版本控制系统，如 Git ，以便开发者可以轻松地管理和共享代码。无论是初学者还是专业开发者， Visual Studio Code 都是一个强大而可靠的工具。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">麻省理工学院</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：编辑器 /VS Code[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt Creator 是一个跨平台的集成开发环境（ IDE ），用于开发基于 Qt 框架的应用程序。它提供了一套丰富的工具和功能，包括代码编辑器、调试器、可视化界面设计工具和项目管理工具等。 Qt Creator 支持多种编程语言，如 C ++、 QML 和 JavaScript ，并且可以与其他开发工具和版本控制系统集成。它是 Qt 开发者的首选工具，可以帮助开发者更高效地创建和调试 Qt 应用程序。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">QtGPL 是指 Qt 的开源许可协议，全称为 GNU 通用公共许可证（ GNU General Public License ）。该许可证允许用户自由地使用、修改和分发 Qt 的源代码，但要求任何基于 Qt 的衍生作品也必须以相同的开源许可协议发布。这意味着使用 QtGPL 许可证的开发者需要将他们的代码公开并允许其他人自由地使用和修改它。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： devel/qtcreator[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KDevelop 是一个开源的集成开发环境（ IDE ），用于开发各种编程语言的应用程序。它支持多种编程语言，包括 C ++， Python ， PHP 等。 KDevelop 提供了丰富的功能，如代码自动完成，调试器，版本控制集成等，以帮助开发人员提高开发效率。它还具有可扩展性，可以通过插件来增加额外的功能。 KDevelop 是一个功能强大且易于使用的开发工具，适用于各种项目规模和复杂度。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 或更高版本和 LGPL 2.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： devel/kdevelop[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Eclipse IDE 是一个开发环境，用于编写、调试和部署各种类型的应用程序。它是一个开源的集成开发环境，支持多种编程语言，包括 Java 、 C ++、 Python 等。 Eclipse IDE 提供了丰富的功能和插件，可以帮助开发人员提高效率和代码质量。它还具有强大的调试和测试工具，以及集成的版本控制系统。 Eclipse IDE 是一个非常受欢迎的开发工具，被广泛用于各种软件开发项目。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">EPL 是指英超联赛（ English Premier League ）的缩写。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： java/eclipse[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Vim 是一款功能强大的文本编辑器，广泛用于计算机编程和文本处理。它是 Vi 编辑器的改进版本，具有更多的功能和定制选项。 Vim 支持多种编程语言，并提供了丰富的插件和扩展功能，使用户可以根据自己的需求进行定制和扩展。 Vim 具有高度可配置性和灵活性，可以通过命令行或图形界面进行使用。它被认为是一款高效和强大的编辑器，深受程序员和技术人员的喜爱。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">VIM 是一款功能强大的文本编辑器，广泛用于计算机编程和文本处理。它具有高度可定制性和灵活性，可以通过插件和配置文件进行个性化设置。 VIM 支持多种编程语言和文件格式，并提供了丰富的编辑功能，如语法高亮、代码折叠、自动补全等。它还具有强大的搜索和替换功能，可以快速定位和修改文本。 VIM 采用模式编辑的方式，用户可以在不同的模式之间切换，以便执行不同的操作。它也支持多窗口和分屏功能，方便用户同时编辑多个文件。总之， VIM 是一款非常受程序员和技术人员喜爱的编辑器工具。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包 : 编辑器 /vim[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">轻盈</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Neovim 是一个现代化的文本编辑器，是 Vim 编辑器的一个分支。它旨在提供更好的性能、更好的可扩展性和更好的用户体验。 Neovim 保留了 Vim 的大部分功能和快捷键，同时还引入了一些新的功能和改进。它支持各种编程语言和插件，可以通过配置文件进行个性化设置。 Neovim 是一个开源项目，可以在多个操作系统上运行。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Apache 2.0 是一种开源软件许可证，它是 Apache 软件基金会所采用的许可证之一。它允许用户自由地使用、修改和分发软件，同时保留了原作者的版权和专利权。 Apache 2.0 许可证也被广泛应用于许多开源项目和商业软件中。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：编辑器 /Neovim[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">轻盈</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GNU Emacs 是一款自由开源的文本编辑器，它具有强大的可扩展性和定制性。它最初由 Richard Stallman 开发，旨在提供一个功能丰富且可自定义的编辑环境。 Emacs 支持多种编程语言和文件格式，并提供了许多有用的功能，如语法高亮、自动完成、代码调试等。它还具有强大的文本处理功能，如搜索替换、宏录制和批处理操作。 Emacs 使用 Lisp 作为其扩展语言，使用户能够根据自己的需求定制编辑器的行为。它在计算机领域被广泛使用，并且有一个庞大的用户社区，提供了大量的扩展和插件。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 3.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：编辑器 /emacs[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">轻盈</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="vs-code">8.4.1. Visual Studio Code 是一款由微软开发的免费源代码编辑器。它支持多种编程语言，并提供了丰富的功能和插件，使开发者能够更高效地编写和调试代码。 Visual Studio Code 具有直观的用户界面和强大的编辑功能，可以满足开发者的各种需求。它还支持版本控制系统，如 Git ，以便开发者可以轻松地管理和共享代码。无论是初学者还是专业开发者， Visual Studio Code 都是一个强大而可靠的工具。<a class="anchor" href="#vs-code"></a></h4>
<div class="paragraph">
<p>Visual Studio Code 是一种工具，它将代码编辑器的简洁性与开发人员在核心编辑 - 构建 - 调试循环中所需的功能相结合。它提供全面的编辑和调试支持，可扩展性模型以及与现有工具的轻量级集成。</p>
</div>
<div class="paragraph">
<p>要安装 Visual Studio Code ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install vscode</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="qt-creator">8.4.2. Qt Creator 是一个跨平台的集成开发环境（ IDE ），用于开发基于 Qt 框架的应用程序。它提供了一套丰富的工具和功能，包括代码编辑器、调试器、可视化界面设计工具和项目管理工具等。 Qt Creator 支持多种编程语言，如 C ++、 QML 和 JavaScript ，并且可以与其他开发工具和版本控制系统集成。它是 Qt 开发者的首选工具，可以帮助开发者更高效地创建和调试 Qt 应用程序。<a class="anchor" href="#qt-creator"></a></h4>
<div class="paragraph">
<p>Qt Creator 是一个跨平台的集成开发环境（ IDE ），专为 Qt 开发人员的需求而设计。 Qt Creator 包含的功能有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>支持 C ++、 QML 和 ECMAscript 的代码编辑器；</p>
</li>
<li>
<p>快速代码导航工具；</p>
</li>
<li>
<p>实时代码检查和样式提示；</p>
</li>
<li>
<p>上下文敏感帮助；</p>
</li>
<li>
<p>可视化调试器；</p>
</li>
<li>
<p>集成的 GUI 布局和表单设计工具。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要安装 Qt Creator ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install qtcreator</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kdevelop">8.4.3. KDevelop 是一个开源的集成开发环境（ IDE ），用于开发计算机软件。它支持多种编程语言，包括 C ++， Python ， PHP 等。 KDevelop 提供了丰富的功能，如代码编辑器，调试器，版本控制集成等，以帮助开发人员提高效率和质量。它是一个跨平台的工具，可以在多个操作系统上使用，如 Linux ， Windows 和 macOS 。<a class="anchor" href="#kdevelop"></a></h4>
<div class="paragraph">
<p>开源、功能丰富、可扩展插件的 C/C ++和其他编程语言的集成开发环境。它基于 KDevPlatform 、 KDE 和 Qt 库进行开发，并自 1998 年以来一直在不断发展。</p>
</div>
<div class="paragraph">
<p>要安装 kdevelop ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install kdevelop</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="eclipse">8.4.4. Eclipse IDE 是一个开发环境，用于编写、调试和部署各种类型的应用程序。它是一个开源的集成开发环境，支持多种编程语言，包括 Java 、 C ++、 Python 等。 Eclipse IDE 提供了丰富的功能和插件，可以帮助开发人员提高效率和代码质量。它还具有强大的调试和测试工具，以及集成的版本控制系统。 Eclipse IDE 是一个非常受欢迎的开发工具，被广泛用于各种软件开发项目。<a class="anchor" href="#eclipse"></a></h4>
<div class="paragraph">
<p>Eclipse 平台是一个开放的可扩展的集成开发环境（ IDE ），可以用于任何事情，但又没有特定的限制。 Eclipse 平台提供了构建和运行集成软件开发工具的基础和组件。 Eclipse 平台允许工具开发者独立地开发与其他人的工具集成的工具。</p>
</div>
<div class="paragraph">
<p>要安装 Eclipse IDE ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install eclipse</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="vim">8.4.5. Vim 是一款功能强大的文本编辑器，广泛用于计算机编程和文本处理。它是 Vi 编辑器的改进版本，具有更多的功能和定制选项。 Vim 支持多种编程语言，并提供了丰富的插件和扩展功能，使用户可以根据自己的需求进行定制和扩展。 Vim 具有高度可配置性和灵活性，可以通过命令行或图形界面进行使用。它被认为是一款高效和强大的编辑器，深受程序员和技术人员的喜爱。<a class="anchor" href="#vim"></a></h4>
<div class="paragraph">
<p>Vim 是一个高度可配置的文本编辑器，旨在实现高效的文本编辑。它是 vi 编辑器的改进版本，大多数 UNIX 系统都配备了 vi 编辑器。</p>
</div>
<div class="paragraph">
<p>Vim 通常被称为“程序员的编辑器”，对于编程非常有用，以至于许多人认为它是一个完整的集成开发环境（ IDE ）。然而， Vim 不仅适用于程序员。 Vim 非常适合各种文本编辑，从撰写电子邮件到编辑配置文件都可以。</p>
</div>
<div class="paragraph">
<p>要安装 Vim ，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install vim</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="neovim">8.4.6. Neovim 是一个现代化的文本编辑器，是 Vim 编辑器的一个分支。它旨在提供更好的性能、更好的可扩展性和更好的用户体验。 Neovim 保留了 Vim 的大部分功能和快捷键，同时还引入了一些新的功能和改进。它支持各种编程语言和插件，可以通过配置文件进行个性化设置。 Neovim 是一个开源项目，可以在多个操作系统上运行。<a class="anchor" href="#neovim"></a></h4>
<div class="paragraph">
<p>Neovim 是编辑器 /vim 的一个积极的重构版本。它对代码库进行了彻底的改进，包括合理的默认设置、内置终端仿真器、异步插件架构和为速度和可扩展性而设计的强大 API 。它与几乎所有的 Vim 插件和脚本保持完全兼容。</p>
</div>
<div class="paragraph">
<p>要安装 Neovim ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install neovim</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gnu-emacs">8.4.7. GNU Emacs 是一款自由开源的文本编辑器，它具有强大的可扩展性和定制性。它最初由 Richard Stallman 开发，旨在提供一个功能丰富且可自定义的编辑环境。 Emacs 支持多种编程语言和文件格式，并提供了许多有用的功能，如语法高亮、自动完成、代码调试等。它还具有强大的文本处理功能，如搜索替换、宏录制和批处理操作。 Emacs 使用 Lisp 作为其扩展语言，使用户能够根据自己的需求定制编辑器的行为。它在计算机领域被广泛使用，并且有一个庞大的用户社区，提供了大量的扩展和插件。<a class="anchor" href="#gnu-emacs"></a></h4>
<div class="paragraph">
<p>GNU Emacs 是一个可扩展、可定制、自由 / 开源的文本编辑器。其核心是一个用于解释 Emacs Lisp 的解释器， Emacs Lisp 是一种 Lisp 编程语言的方言，具有支持文本编辑的扩展功能。</p>
</div>
<div class="paragraph">
<p>要安装 GNU Emacs ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install emacs</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="desktop-productivity">8.5. 桌面办公生产力<a class="anchor" href="#desktop-productivity"></a></h3>
<div class="paragraph">
<p>当谈到生产力时，用户通常会寻找一个办公套件或易于使用的文字处理软件。虽然一些桌面环境（如 KDE Plasma ）提供了一个办公套件，但没有默认的生产力软件包。无论安装的桌面环境如何， FreeBSD 都提供了几个办公套件和图形化文字处理软件。</p>
</div>
<div class="paragraph">
<p>本节演示了如何安装以下流行的生产力软件，并指出应用程序是否资源密集型，从端口编译需要时间，或者是否有任何重要的依赖关系。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 13. 支持的桌面办公生产力套件</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">所需资源</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">LibreOffice 是一款免费开源的办公软件套件，它包含了文字处理、电子表格、演示文稿、数据库和绘图等多个应用程序。 LibreOffice 是一个跨平台的软件，可以在 Windows 、 macOS 和 Linux 等操作系统上运行。它提供了丰富的功能和工具，可以满足用户在办公和学习中的各种需求。 LibreOffice 还支持多种文件格式，包括 Microsoft Office 的文件格式，使用户可以方便地与其他办公软件进行兼容和交流。作为一个开源项目， LibreOffice 还鼓励用户参与到软件的开发和改进中，以不断提升软件的质量和功能。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPL 2.0 是 Mozilla 公共许可证的第 2 个版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：编辑器 / 自由办公室 []</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Calligra Suite 是一套办公软件套件，提供了多种功能强大的应用程序，包括文字处理、电子表格、演示文稿、绘图和数据库管理等。它是一个开源软件，适用于多个操作系统，如 Windows 、 Linux 和 Mac OS 。 Calligra Suite 具有用户友好的界面和丰富的功能，可以满足个人和商业用户的各种办公需求。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LGPL 和 GPL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：编辑器 /Calligra[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">中等的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AbiWord 是一款开源的字处理软件，它支持多种操作系统，包括 Windows 、 Mac 和 Linux 。它具有类似于 Microsoft Word 的功能，可以创建、编辑和格式化文档。 AbiWord 还支持多种文件格式，包括 .doc 、 .docx 、 .odt 和 .rtf 。它还提供了一些高级功能，如拼写检查、批注和表格编辑。 AbiWord 是一个轻量级的应用程序，占用系统资源较少，适合在低配置的计算机上使用。它是一个功能强大且易于使用的字处理工具。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 或更高版本</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：编辑器 /abiword[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">中等的</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="libreoffice">8.5.1. LibreOffice 是一款免费开源的办公软件套件，它包含了文字处理、电子表格、演示文稿、数据库和绘图等多个应用程序。 LibreOffice 是一个跨平台的软件，可以在 Windows 、 macOS 和 Linux 等操作系统上运行。它提供了丰富的功能和工具，可以满足用户在办公和学习中的各种需求。 LibreOffice 还支持多种文件格式，包括 Microsoft Office 的文件格式，使用户可以方便地与其他办公软件进行兼容和交流。作为一个开源项目， LibreOffice 还鼓励用户参与到软件的开发和改进中，以不断提升软件的质量和功能。<a class="anchor" href="#libreoffice"></a></h4>
<div class="paragraph">
<p>LibreOffice 是由 <a href="http://www.documentfoundation.org/">The Document Foundation</a> 开发的免费软件办公套件。它与其他主要办公套件兼容，并可在多种平台上使用。它是 Apache OpenOffice 的重新品牌分支，包括完整办公生产力套件中的应用程序：文字处理器、电子表格、演示文稿管理器、绘图程序、数据库管理程序以及用于创建和编辑数学公式的工具。它提供多种不同语言版本，并将国际化扩展到界面、拼写检查和字典。有关 LibreOffice 的更多信息，请访问 <a href="http://www.libreoffice.org/">libreoffice.org</a> 。</p>
</div>
<div class="paragraph">
<p>要安装 LibreOffice ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install libreoffice</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>LibreOffice 软件包默认只提供英文版本。要使用本地化的 LibreOffice 版本，需要安装语言包。例如，要安装西班牙语本地化版本，需要使用以下命令安装软件包： <a class="package" href="https://cgit.freebsd.org/ports/tree/editors/libreoffice-es/">editors/libreoffice-es</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install libreoffice-es</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="calligra">8.5.2. Calligra 是一套开源的办公软件套件，旨在提供各种办公应用程序，如文字处理、电子表格、演示文稿、绘图和数据库管理。它是一个功能强大且灵活的工具，适用于个人用户和企业用户。 Calligra 具有直观的用户界面和丰富的功能，可以满足各种办公需求。无论是撰写文档、制作报告、创建图表还是管理数据， Calligra 都可以提供高效的解决方案。此外， Calligra 还支持多种文件格式，包括 Microsoft Office 和 OpenDocument 格式，使用户可以方便地与其他办公软件进行兼容和交互。无论您是个人用户还是企业用户， Calligra 都是一个值得考虑的办公软件选择。<a class="anchor" href="#calligra"></a></h4>
<div class="paragraph">
<p>KDE Plasma 桌面环境包含一个办公套件，可以单独从 KDE Plasma 中安装。 Calligra 包括其他办公套件中常见的标准组件。 Words 是文字处理器， Sheets 是电子表格程序， Stage 用于管理幻灯片演示，而 Karbon 用于绘制图形文档。</p>
</div>
<div class="paragraph">
<p>要安装 Calligra ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install calligra</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="abiword">8.5.3. AbiWord 是一款开源的字处理软件，它支持多种操作系统，包括 Windows 、 Mac 和 Linux 。它具有类似于 Microsoft Word 的功能，可以创建、编辑和格式化文档。 AbiWord 还支持多种文件格式，包括 .doc 、 .docx 、 .odt 和 .rtf 。它还提供了一些高级功能，如拼写检查、批注和表格编辑。 AbiWord 是一个轻量级的应用程序，占用系统资源较少，适合在低配置的计算机上使用。它是一个功能强大且易于使用的字处理工具。<a class="anchor" href="#abiword"></a></h4>
<div class="paragraph">
<p>AbiWord 是一个免费的文字处理程序，外观和感觉类似于 Microsoft® Word 。它运行速度快，拥有许多功能，并且用户友好。</p>
</div>
<div class="paragraph">
<p>AbiWord 可以导入或导出许多文件格式，包括一些专有格式，如 Microsoft® 的 .rt 格式。</p>
</div>
<div class="paragraph">
<p>要安装 AbiWord ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install abiword</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="desktop-viewers">8.6. 文档查看器<a class="anchor" href="#desktop-viewers"></a></h3>
<div class="paragraph">
<p>自从 UNIX® 问世以来，一些新的文档格式已经变得流行起来，而这些格式所需的查看器可能在基本系统中不可用。本节介绍如何安装以下文档查看器：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 14. 支持的文档查看器</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">所需资源</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Okular 是一个开源的多平台文档阅读器。它支持多种文件格式，包括 PDF 、 EPUB 、 MOBI 、 CHM 等。 Okular 具有丰富的功能，如注释、书签、文本搜索、旋转页面等。它还支持插件扩展，可以根据用户的需求进行定制。 Okular 是 KDE 桌面环境的一部分，但也可以在其他桌面环境中使用。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： graphics/okular[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Evince 是一款开源的文档查看器，它支持多种文件格式，包括 PDF 、 PostScript 、 DjVu 、 TIFF 和 DVI 等。它具有简洁的界面和丰富的功能，可以方便地查看和浏览文档内容。 Evince 还支持注释、书签、搜索和打印等功能，使用户能够更好地管理和处理文档。它是 Linux 操作系统中常用的文档查看器之一，也可以在其他操作系统上使用。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： graphics/evince[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">中等的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ePDFView 是一个开源的 PDF 文档查看器，它可以在计算机上运行。它提供了一种方便的方式来浏览和阅读 PDF 文件。 ePDFView 支持基本的 PDF 功能，如缩放、滚动和搜索。它还具有一些高级功能，如注释和书签。 ePDFView 易于使用，界面简洁明了。它是一个功能强大的工具，适用于需要频繁查看和处理 PDF 文件的用户。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： graphics/epdfview[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">中等的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Xpdf 是一个开源的 PDF 阅读器和解析器，它可以在多个操作系统上运行。它提供了一些基本的功能，如查看和打印 PDF 文件，以及搜索和复制文本。 Xpdf 还支持一些高级功能，如注释和书签。它是一个轻量级的工具，易于使用和集成到其他应用程序中。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： graphics/xpdf[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">光线</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="okular">8.6.1. Okular 是一个开源的多平台文档阅读器。它支持多种文件格式，包括 PDF 、 EPUB 、 MOBI 、 CHM 等。 Okular 具有丰富的功能，如注释、书签、文本搜索、旋转页面等。它还支持插件扩展，可以根据用户的需求进行定制。 Okular 是 KDE 桌面环境的一部分，但也可以在其他桌面环境中使用。<a class="anchor" href="#okular"></a></h4>
<div class="paragraph">
<p>Okular 是一个通用的文档查看器，是 KDE Plasma 项目的一部分。</p>
</div>
<div class="paragraph">
<p>Okular 结合了出色的功能性和支持不同类型文档的多样性，如 PDF 、 Postscript 、 DjVu 、 CHM 、 XPS 、 ePub 等。</p>
</div>
<div class="paragraph">
<p>要安装 Okular ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install okular</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="evince">8.6.2. Evince 是一款开源的文档查看器，它支持多种文件格式，包括 PDF 、 PostScript 、 DjVu 、 TIFF 和 DVI 等。它具有简洁的界面和丰富的功能，可以方便地查看和浏览文档内容。 Evince 还支持注释、书签、搜索和打印等功能，使用户能够更好地管理和处理文档。它是 Linux 操作系统中常用的文档查看器之一，也可以在其他操作系统上使用。<a class="anchor" href="#evince"></a></h4>
<div class="paragraph">
<p>Evince 是一个支持多种文档格式的文档查看器，包括 PDF 和 Postscript 。它是 GNOME 项目的一部分。 Evince 的目标是用一个简单的应用程序取代 ggv 和 gpdf 等文档查看器。</p>
</div>
<div class="paragraph">
<p>要安装 Evince ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install evince</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="epdfview">8.6.3. ePDFView 是一个开源的 PDF 文档查看器，它可以在计算机上运行。它提供了一种方便的方式来浏览和阅读 PDF 文件。 ePDFView 支持基本的 PDF 功能，如缩放、滚动和搜索。它还具有一些高级功能，如注释和书签。 ePDFView 易于使用，界面简洁明了。它是一个功能强大的工具，适用于需要频繁查看和处理 PDF 文件的用户。<a class="anchor" href="#epdfview"></a></h4>
<div class="paragraph">
<p>ePDFView 是一个轻量级的 PDF 文档查看器，只使用 Gtk +和 Poppler 库。 ePDFView 的目标是创建一个简单的 PDF 文档查看器，类似于 Evince ，但不使用 GNOME 库。</p>
</div>
<div class="paragraph">
<p>要安装 ePDFView ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install epdfview</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="xpdf">8.6.4. Xpdf 是一个开源的 PDF 阅读器和解析器，它可以在多个操作系统上运行。它提供了一些基本的功能，如查看和打印 PDF 文件，以及搜索和复制文本。 Xpdf 还支持一些高级功能，如注释和书签。它是一个轻量级的工具，易于使用和集成到其他应用程序中。<a class="anchor" href="#xpdf"></a></h4>
<div class="paragraph">
<p>对于喜欢小型 FreeBSD PDF 阅读器的用户， Xpdf 提供了一个轻量级和高效的阅读器，需要很少的资源。它使用标准的 X 字体，不需要任何额外的工具包。</p>
</div>
<div class="paragraph">
<p>要安装 Xpdf ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install xpdf</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="desktop-finance">8.7. 金融<a class="anchor" href="#desktop-finance"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 桌面上管理个人财务，可以安装一些强大且易于使用的应用程序。其中一些应用程序与广泛使用的文件格式兼容，例如 Quicken 和 Excel 使用的格式。</p>
</div>
<div class="paragraph">
<p>本节涵盖以下程序：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 15. 支持的金融程序</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">所需资源</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KMyMoney 是一款开源的个人财务管理软件，旨在帮助用户跟踪和管理他们的财务情况。它提供了一个直观的界面，可以记录和分类收入和支出，创建预算和报告，以及跟踪投资和贷款。 KMyMoney 还支持多个账户和货币，并提供了强大的导入和导出功能，以便与其他财务软件和银行进行数据交互。无论是个人用户还是小型企业， KMyMoney 都是一个功能齐全且易于使用的财务管理解决方案。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：财务 / 我的钱 []</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GnuCash 是一款自由开源的会计软件。它可以帮助个人和小型企业进行财务管理和记账。 GnuCash 支持多种货币和账户类型，并提供了丰富的报表和图表功能。它还支持导入和导出数据，以及与其他软件的集成。 GnuCash 是一个功能强大且易于使用的工具，适用于任何需要进行财务管理的人或组织。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 和 GPL 3.0</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： finance/gnucash[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">沉重的</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="kmymoney">8.7.1. KMyMoney 是一款开源的个人财务管理软件，旨在帮助用户跟踪和管理他们的财务情况。它提供了一个直观的界面，可以记录和分类收入和支出，创建预算和报告，以及跟踪投资和贷款。 KMyMoney 还支持多个账户和货币，并提供了强大的导入和导出功能，以便与其他财务软件和银行进行数据交互。无论是个人用户还是小型企业， KMyMoney 都是一个功能齐全且易于使用的财务管理解决方案。<a class="anchor" href="#kmymoney"></a></h4>
<div class="paragraph">
<p>KMyMoney 是由 KDE 社区创建的个人财务应用程序。 KMyMoney 旨在提供商业个人财务管理应用程序中的重要功能。它还强调易用性和正确的复式记账。 KMyMoney 可以导入标准的 Quicken QIF 文件，跟踪投资，处理多种货币，并提供丰富的报告。</p>
</div>
<div class="paragraph">
<p>要安装 KMyMoney ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install kmymoney</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gnucash">8.7.2. GnuCash 是一款自由开源的会计软件。它可以帮助个人和小型企业进行财务管理和记账。 GnuCash 支持多种货币和账户类型，并提供了丰富的报表和图表功能。它还支持导入和导出数据，以及与其他软件的集成。 GnuCash 是一个功能强大且易于使用的工具，适用于任何需要进行财务管理的人或组织。<a class="anchor" href="#gnucash"></a></h4>
<div class="paragraph">
<p>GnuCash 是 GNOME 努力提供给最终用户的用户友好且功能强大的应用程序的一部分。 GnuCash 可以用于跟踪收入和支出、银行账户和股票。它具有直观的界面，同时保持专业性。</p>
</div>
<div class="paragraph">
<p>GnuCash 提供了智能账户注册表、分层的账户系统以及许多键盘加速器和自动完成方法。它可以将单个交易拆分为多个更详细的部分。 GnuCash 可以导入和合并 Quicken QIF 文件。它还处理大多数国际日期和货币格式。</p>
</div>
<div class="paragraph">
<p>要安装 GnuCash ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install gnucash</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="multimedia">Chapter 9. 多媒体<a class="anchor" href="#multimedia"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="multimedia-synopsis">9.1. 简介<a class="anchor" href="#multimedia-synopsis"></a></h3>
<div class="paragraph">
<p>多媒体章节提供了关于 FreeBSD 上多媒体支持的概述。多媒体应用和技术已成为现代计算的重要组成部分， FreeBSD 为各种多媒体硬件和软件提供了强大可靠的支持。本章介绍了各种多媒体组件，如音频、视频和图像处理。还讨论了各种媒体格式和编解码器，以及用于多媒体创建和播放的工具和应用程序。此外，本章还涵盖了多媒体系统配置、故障排除和优化。无论您是多媒体爱好者还是专业内容创作者， FreeBSD 都为多媒体工作提供了强大的平台。本章旨在帮助充分利用 FreeBSD 的多媒体功能，提供有用的信息和实际示例，以帮助入门。</p>
</div>
</div>
<div class="sect2">
<h3 id="sound-setup">9.2. 设置声卡<a class="anchor" href="#sound-setup"></a></h3>
<div class="paragraph">
<p>默认情况下， FreeBSD 会自动检测系统使用的声卡。 FreeBSD 支持各种各样的声卡。可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=sound&amp;sektion=4&amp;format=html">sound(4)</a> 中查看支持的声卡列表。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>只有在 FreeBSD 没有正确检测到声卡时才需要加载声卡模块。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当不知道系统使用哪个声卡或者使用哪个模块时，可以通过执行以下命令加载 <code>snd_driver</code> 元驱动程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload snd_driver</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，要在启动时将驱动程序作为模块加载，将以下行放置在 <span class="filename">/boot/loader.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>snd_driver_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="sect3">
<h4 id="sound-testing">9.2.1. 测试声音<a class="anchor" href="#sound-testing"></a></h4>
<div class="paragraph">
<p>要确认声卡是否被检测到，可以执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>dmesg | grep pcm</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pcm0: &lt;Conexant CX20561 (Hermosa) (Analog 2.0+HP/2.0)&gt; at nid 26,22 and 24 on hdaa0
pcm1: &lt;Conexant CX20561 (Hermosa) (Internal Analog Mic)&gt; at nid 29 on hdaa0</pre>
</div>
</div>
<div class="paragraph">
<p>可以使用以下命令来检查声卡的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat /dev/sndstat</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Installed devices:
pcm0: &lt;Conexant CX20561 (Hermosa) (Analog 2.0+HP/2.0)&gt; (play/rec) default
pcm1: &lt;Conexant CX20561 (Hermosa) (Internal Analog Mic)&gt; (rec)</pre>
</div>
</div>
<div class="paragraph">
<p>如果没有列出任何 <code>pcm</code> 设备，请再次检查是否加载了正确的设备驱动程序。如果一切顺利，声卡现在应该可以在 FreeBSD 中正常工作了。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=beep&amp;sektion=1&amp;format=html">beep(1)</a> 可以用来产生一些声音，确认声卡是否正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>beep</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="sound-mixer">9.2.2. 搅拌器<a class="anchor" href="#sound-mixer"></a></h4>
<div class="paragraph">
<p>FreeBSD 在 FreeBSD 声音系统上构建了不同的实用工具来设置和显示声卡混音值：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 16. 支持的混音器软件包</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">工具包</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">手册： mixer[8]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-2 是指 BSD 许可证的第二个版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含在基本系统中</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命令行界面（ CLI ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">dsbmixer 是一个用于混合和处理音频的开源软件。它提供了一系列功能，包括音频输入和输出设备的管理、音频信号的混合和处理、音频效果的应用等。 dsbmixer 可以通过命令行界面或图形界面进行操作，使用户能够方便地控制和调整音频的各个参数。它支持多种音频格式，并且具有高度可定制性，用户可以根据自己的需求进行配置和扩展。 dsbmixer 是一个功能强大且易于使用的音频处理工具，适用于各种音频应用场景。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-2 是指 BSD 许可证的第二个版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： audio/dsbmixer[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt 是一个跨平台的应用程序开发框架，用于开发图形用户界面、网络应用、数据库连接和其他各种应用程序。它提供了丰富的类库和工具，使开发者能够快速构建高质量的应用程序。 Qt 使用 C ++编写，具有良好的可扩展性和可移植性。它被广泛应用于各种领域，包括桌面应用、移动应用和嵌入式系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KDE Plasma 音频小部件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： audio/plasma5-plasma-pa[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt 是一个跨平台的应用程序开发框架，用于开发图形用户界面、网络应用、数据库连接和其他各种应用程序。它提供了丰富的类库和工具，使开发者能够快速构建高质量的应用程序。 Qt 使用 C ++编写，具有良好的可扩展性和可移植性。它被广泛应用于各种领域，包括桌面应用、移动应用和嵌入式系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mixertui 是一个用于创建和管理混音器的命令行工具。它提供了一种简单的方式来配置和控制混音器的各种参数，包括音频输入和输出、音量控制、效果器和信号路由等。使用 mixertui ，用户可以方便地调整和优化音频混合的设置，以满足个人或专业需求。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-2 是指 BSD 许可证的第二个版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：音频 / 混音器界面 []</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TUI 是文本用户界面（ Text User Interface ）的缩写，是一种基于文本的用户界面，通常用于计算机终端或控制台应用程序。 TUI 提供了一种通过文本命令或菜单进行交互的方式，相比于图形用户界面（ GUI ）， TUI 更加轻量级和资源节约。 TUI 常用于命令行界面（ CLI ）工具、文本编辑器和终端模拟器等应用程序中。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="graphics-card-sound">9.2.3. 显卡声音<a class="anchor" href="#graphics-card-sound"></a></h4>
<div class="paragraph">
<p>图形卡通常配备自己的集成声音设备，可能不清楚哪个设备被用作默认设备。要确认，请运行 dmesg 命令并查找 pcm 条目以确定系统如何枚举输出。执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>dmesg | grep pcm</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出的结果看起来像这样：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pcm0: &lt;HDA NVIDIA (Unknown) PCM #0 DisplayPort&gt; at cad 0 nid 1 on hdac0
pcm1: &lt;HDA NVIDIA (Unknown) PCM #0 DisplayPort&gt; at cad 1 nid 1 on hdac0
pcm2: &lt;HDA NVIDIA (Unknown) PCM #0 DisplayPort&gt; at cad 2 nid 1 on hdac0
pcm3: &lt;HDA NVIDIA (Unknown) PCM #0 DisplayPort&gt; at cad 3 nid 1 on hdac0
hdac1: HDA Codec #2: Realtek ALC889
pcm4: &lt;HDA Realtek ALC889 PCM #0 Analog&gt; at cad 2 nid 1 on hdac1
pcm5: &lt;HDA Realtek ALC889 PCM #1 Analog&gt; at cad 2 nid 1 on hdac1
pcm6: &lt;HDA Realtek ALC889 PCM #2 Digital&gt; at cad 2 nid 1 on hdac1
pcm7: &lt;HDA Realtek ALC889 PCM #3 Digital&gt; at cad 2 nid 1 on hdac1</pre>
</div>
</div>
<div class="paragraph">
<p>在图形卡（ NVIDIA® ）之前，声卡（ Realtek® ）已被枚举，声卡显示为 <code>pcm4</code> 。可以通过执行以下命令将声卡配置为默认设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl hw.snd.default_unit=4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使此更改永久生效，请将下一行添加到 <span class="filename">/etc/sysctl.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hw.snd.default_unit=4</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="automatically-switching-headphones">9.2.4. 自动切换到耳机<a class="anchor" href="#automatically-switching-headphones"></a></h4>
<div class="paragraph">
<p>有些系统在切换音频输出时可能会遇到困难，但幸运的是， FreeBSD 允许在 .device.hints 中配置自动切换。</p>
</div>
<div class="paragraph">
<p>通过执行以下命令来确定系统是如何枚举音频输出设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>dmesg | grep pcm</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出的结果看起来像这样：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pcm0: &lt;Realtek ALC892 Analog&gt; at nid 23 and 26 on hdaa0
pcm1: &lt;Realtek ALC892 Right Analog Headphones&gt; at nid 22 on hdaa0</pre>
</div>
</div>
<div class="paragraph">
<p>将以下行添加到 <span class="filename">/boot/device.hints</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hint.hdac.0.cad0.nid22.config=&#34;as=1 seq=15 device=Headphones&#34;
hint.hdac.0.cad0.nid26.config=&#34;as=2 seq=0 device=speakers&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请记住，这些值是针对上述示例而言的。它们可能会因系统而异。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="troubleshooting-sound">9.2.5. 音频故障排除<a class="anchor" href="#troubleshooting-sound"></a></h4>
<div class="paragraph">
<p>一些常见的错误消息及其解决方案：</p>
</div>
<div id="multimedia-sound-common-error-messages" class="olist arabic">
<div class="title">常见错误消息</div>
<ol class="arabic">
<li>
<p>&#34;File not found&#34; - 文件未找到</p>
</li>
<li>
<p>&#34;Access denied&#34; - 拒绝访问</p>
</li>
<li>
<p>&#34;Invalid username or password&#34; - 用户名或密码无效</p>
</li>
<li>
<p>&#34;Connection timed out&#34; - 连接超时</p>
</li>
<li>
<p>&#34;Invalid input&#34; - 输入无效</p>
</li>
<li>
<p>&#34;Out of memory&#34; - 内存不足</p>
</li>
<li>
<p>&#34;Permission denied&#34; - 拒绝权限</p>
</li>
<li>
<p>&#34;Invalid file format&#34; - 文件格式无效</p>
</li>
<li>
<p>&#34;Page not found&#34; - 页面未找到</p>
</li>
<li>
<p>&#34;Server error&#34; - 服务器错误</p>
</li>
</ol>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 100%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">解决方案</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">`xxx: 无法打开 /dev/dsp ！ `</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">输入 <code>fstat</code> 命令</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">使用 <code>grep dsp</code> 命令来检查是否有其他应用程序正在占用该设备。值得注意的麻烦制造者是 esound 和 KDE 的声音支持。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/audio/pulseaudio/">audio/pulseaudio</a> 的程序可能需要重新启动 <a class="package" href="https://cgit.freebsd.org/ports/tree/audio/pulseaudio/">audio/pulseaudio</a> 守护进程，以使 <code>hw.snd.default_unit</code> 的更改生效。或者，可以实时更改 <a class="package" href="https://cgit.freebsd.org/ports/tree/audio/pulseaudio/">audio/pulseaudio</a> 的设置。 <a href="https://man.freebsd.org/cgi/man.cgi?query=pacmd&amp;sektion=1&amp;format=html">pacmd(1)</a> 打开与 <a class="package" href="https://cgit.freebsd.org/ports/tree/audio/pulseaudio/">audio/pulseaudio</a> 守护进程的命令行连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pacmd</span>
Welcome to PulseAudio 14.2! Use <span class="s2">&#34;help&#34;</span> <span class="k">for </span>usage information.
&gt;&gt;&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>以下命令将默认的音频输出设备更改为卡号为 4 ，与之前的示例相同：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>set-default-sink 4</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不要使用 <code>exit</code> 命令来退出命令行界面。这会终止 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/audio/pulseaudio/">audio/pulseaudio</a></code> 守护进程。请使用 <code><span class="keyseq"><kbd>Ctrl</kbd>+<kbd>D</kbd></span></code> 代替。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="audio-ports">9.3. 音频播放器<a class="anchor" href="#audio-ports"></a></h3>
<div class="paragraph">
<p>本节介绍了一些可以用于音频播放的软件，这些软件可以从 FreeBSD Ports Collection 中获取。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 17. 音频播放器软件包</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">工具包</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Elisa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">LGPL 3.0 是 GNU Lesser General Public License （ GNU 宽松通用公共许可证）的第 3.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：音频 /Elisa[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt 是一个跨平台的应用程序开发框架，用于开发图形用户界面、网络应用、数据库连接和其他各种应用程序。它提供了丰富的类库和工具，使开发者能够快速构建高质量的应用程序。 Qt 使用 C ++编写，具有良好的可扩展性和可移植性。它被广泛应用于各种领域，包括桌面应用、移动应用和嵌入式系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GNOME 音乐</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： audio/gnome-music[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GTK +是一个用于创建图形用户界面的开源工具包。它最初是为 GNU 计划开发的，现在已经成为许多 Linux 发行版的标准工具包。 GTK +提供了一套丰富的控件和功能，使开发者能够轻松地创建各种应用程序，包括桌面应用程序、移动应用程序和嵌入式系统应用程序。它使用 C 语言编写，并提供了多种编程语言的绑定，如 Python 、 C ++和 Java 。 GTK +还具有跨平台的特性，可以在不同的操作系统上运行，如 Linux 、 Windows 和 macOS 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Audacious 是一个免费的音频播放器，可在多个平台上使用。它具有简洁的界面和丰富的功能，可以播放各种音频格式。 Audacious 还支持插件扩展，用户可以根据自己的需求添加额外的功能和特性。无论是在个人使用还是在专业环境中， Audacious 都是一个强大而可靠的音频播放器选择。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-2 是指 BSD 许可证的第二个版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：多媒体 /audacious[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt 是一个跨平台的应用程序开发框架，用于开发图形用户界面、网络应用、数据库连接和其他各种应用程序。它提供了丰富的类库和工具，使开发者能够快速构建高质量的应用程序。 Qt 使用 C ++编写，具有良好的可扩展性和可移植性。它被广泛应用于各种领域，包括桌面应用、移动应用和嵌入式系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MOC （音乐控制台）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：音频 /moc[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TUI 是文本用户界面（ Text User Interface ）的缩写，是一种基于文本的用户界面，通常用于计算机终端或控制台应用程序。 TUI 提供了一种通过文本命令或菜单进行交互的方式，相比于图形用户界面（ GUI ）， TUI 更加轻量级和资源节约。 TUI 常用于命令行界面（ CLI ）工具、文本编辑器和终端模拟器等应用程序中。</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="elisa">9.3.1. Elisa<a class="anchor" href="#elisa"></a></h4>
<div class="paragraph">
<p>Elisa 是由 KDE 社区开发的音乐播放器，致力于简单易用且美观。</p>
</div>
<div class="paragraph">
<p>要安装 Elisa ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install elisa</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="gnome-music">9.3.2. GNOME 音乐<a class="anchor" href="#gnome-music"></a></h4>
<div class="paragraph">
<p>GNOME Music 是新的 GNOME 音乐播放应用程序。它旨在将优雅和沉浸式的浏览体验与简单直观的控制相结合。</p>
</div>
<div class="paragraph">
<p>要安装 GNOME 音乐，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install gnome-music</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="audacious">9.3.3. Audacious 是一个免费的音频播放器，可在多个平台上使用。它具有简洁的界面和丰富的功能，可以播放各种音频格式。 Audacious 还支持插件扩展，用户可以根据自己的需求添加额外的功能和特性。无论是在个人使用还是在专业环境中， Audacious 都是一个强大而可靠的音频播放器选择。<a class="anchor" href="#audacious"></a></h4>
<div class="paragraph">
<p>Audacious 是一个开源音频播放器。它是 XMMS 的后代，可以按照您的要求播放音乐，而不会占用计算机的资源进行其他任务。</p>
</div>
<div class="paragraph">
<p>要安装 Audacious ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install audacious-qt6 audacious-plugins-qt6</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Audacious 原生支持 OSS ，但必须在设置中的音频选项卡中进行配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="moc-music-on-console">9.3.4. MOC （音乐控制台）<a class="anchor" href="#moc-music-on-console"></a></h4>
<div class="paragraph">
<p>MOC （音乐控制台）是一个旨在强大且易于使用的控制台音频播放器。</p>
</div>
<div class="paragraph">
<p>MOC 可以在任何系统或 I/O 负载下平稳播放，因为它在单独的线程中处理输出缓冲区。它不会在文件之间产生间隙，因为在播放当前文件时，下一个文件已经被预先缓存。</p>
</div>
<div class="paragraph">
<p>要安装 MOC （音乐控制台），执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install moc</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="video-ports">9.4. 视频播放器<a class="anchor" href="#video-ports"></a></h3>
<div class="paragraph">
<p>本节介绍了一些可以用于视频播放的软件，这些软件可以从 FreeBSD Ports Collection 中获取。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 18. 视频播放器软件包</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
<th class="tableblock halign-left valign-top">工具包</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">MPlayer 是一个开源的多媒体播放器，可以在多个平台上运行。它支持各种音频和视频格式，并具有强大的功能和灵活的配置选项。 MPlayer 是一个非常流行的播放器，被广泛用于电影、音乐和其他媒体的播放。它具有简单易用的界面和高质量的播放效果，是许多用户的首选播放器之一。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：多媒体 /mplayer[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">命令行界面（ CLI ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">SMPlayer 是一个免费的多媒体播放器，可在 Windows 和 Linux 操作系统上使用。它支持各种音频和视频格式，并具有许多有用的功能，如字幕支持、音频和视频过滤器、播放列表和快捷键。 SMPlayer 还具有用户友好的界面和可自定义的外观。它是一个功能强大且易于使用的播放器，适用于各种媒体播放需求。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：多媒体 /SMPlayer[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt 是一个跨平台的应用程序开发框架，用于开发图形用户界面、网络应用、数据库连接和其他各种应用程序。它提供了丰富的类库和工具，使开发者能够快速构建高质量的应用程序。 Qt 使用 C ++编写，具有良好的可扩展性和可移植性。它被广泛应用于各种领域，包括桌面应用、移动应用和嵌入式系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">VLC 媒体播放器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：多媒体 /vlc[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Qt 是一个跨平台的应用程序开发框架，用于开发图形用户界面、网络应用、数据库连接和其他各种应用程序。它提供了丰富的类库和工具，使开发者能够快速构建高质量的应用程序。 Qt 使用 C ++编写，具有良好的可扩展性和可移植性。它被广泛应用于各种领域，包括桌面应用、移动应用和嵌入式系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Kodi （ XBMC ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：多媒体 /kodi[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">X11 是一个用于图形用户界面的网络协议。它允许在远程计算机上运行的应用程序通过网络连接到显示设备，并在本地显示。 X11 是 UNIX 和类 UNIX 系统中最常用的图形系统。它提供了窗口管理、图形绘制和用户输入处理等功能。 X11 还支持客户端 - 服务器模型，允许多个应用程序同时连接到同一个显示设备。</p></td>
</tr>
</tbody>
</table>
<div class="sect3">
<h4 id="mplayer">9.4.1. MPlayer 是一个开源的多媒体播放器，可以在多个平台上运行。它支持各种音频和视频格式，并具有强大的功能和灵活的配置选项。 MPlayer 是一个非常流行的播放器，被广泛用于电影、音乐和其他媒体的播放。它具有简单易用的界面和高质量的播放效果，是许多用户的首选播放器之一。<a class="anchor" href="#mplayer"></a></h4>
<div class="paragraph">
<p>MPlayer 是一个多媒体播放器和编码套件，可以在许多平台上运行，并且可以通过命令行操作。它可以播放大量不同的文件格式和编解码器，包括流行的 DivX 、 XviD 、 H.264 流以及 DVD 和 SVCD ，还支持许多流行的音频编解码器。</p>
</div>
<div class="paragraph">
<p>要安装 MPlayer ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install mplayer</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关 MPlayer 如何工作的示例，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mplayer&amp;sektion=1&amp;format=html">mplayer(1)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="smplayer">9.4.2. SMPlayer 是一个免费的多媒体播放器，可在 Windows 和 Linux 操作系统上使用。它支持各种音频和视频格式，并具有许多有用的功能，如字幕支持、音频和视频过滤器、播放列表和快捷键。 SMPlayer 还具有用户友好的界面和可自定义的外观。它是一个功能强大且易于使用的播放器，适用于各种媒体播放需求。<a class="anchor" href="#smplayer"></a></h4>
<div class="paragraph">
<p>SMPlayer 旨在成为 MPlayer 的完整前端，从播放视频、 DVD 和 VCD 等基本功能到支持 MPlayer 滤镜等更高级功能。</p>
</div>
<div class="paragraph">
<p>要安装 SMPlayer ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install smplayer</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="vlc">9.4.3. VLC 媒体播放器<a class="anchor" href="#vlc"></a></h4>
<div class="paragraph">
<p>VLC 媒体播放器是一款高度便携的多媒体播放器，支持多种音频和视频格式（如 MPEG-1 、 MPEG-2 、 MPEG-4 、 DivX 、 mp3 、 ogg 等），还可以播放 DVD 、 VCD 和各种流媒体协议。它还可以作为服务器，在高带宽网络上进行单播或组播的流媒体传输。 VLC 还具有实时转码媒体的能力，用于流媒体传输或保存到磁盘。</p>
</div>
<div class="paragraph">
<p>要安装 VLC ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install vlc</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="kodi">9.4.4. Kodi （ XBMC ）<a class="anchor" href="#kodi"></a></h4>
<div class="paragraph">
<p>Kodi （以前称为 XBMC ）是一个免费开源的跨平台媒体播放器和娱乐中心。它允许用户从本地和网络存储介质以及互联网上播放和查看大多数视频、音乐、播客和其他数字媒体文件。</p>
</div>
<div class="paragraph">
<p>要安装 Kodi ，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install kodi</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="conferencing-meetings">9.5. 会议和会议<a class="anchor" href="#conferencing-meetings"></a></h3>
<div class="paragraph">
<p>FreeBSD 桌面环境可以用于参加视频会议。本节将介绍如何配置摄像头以及在 FreeBSD 上支持哪些视频会议应用程序。</p>
</div>
<div class="sect3">
<h4 id="webcam-setup">9.5.1. 设置网络摄像头<a class="anchor" href="#webcam-setup"></a></h4>
<div class="paragraph">
<p>为了让 FreeBSD 能够访问并配置摄像头，需要安装一些特定的工具：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/multimedia/webcamd/">multimedia/webcamd</a> 是一个守护进程，可以使用数百种不同的基于 USB 的网络摄像头和 DVB USB 设备。</p>
</li>
<li>
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/multimedia/pwcview/">multimedia/pwcview</a> 是一个可以用来查看网络摄像头视频流的应用程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要安装所需的工具，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install webcamd pwcview</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 中启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=webcamd&amp;sektion=8&amp;format=html">webcamd(8)</a> 服务，以便在系统启动时启动它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc webcamd_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>用户必须属于 <code>webcamd</code> 组。要将用户添加到 <code>webcamd</code> 组，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupmod webcamd -m username</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <a class="package" href="https://cgit.freebsd.org/ports/tree/multimedia/webcamd/">multimedia/webcamd</a> 需要 <a href="https://man.freebsd.org/cgi/man.cgi?query=cuse&amp;sektion=3&amp;format=html">cuse(3)</a> 模块，因此必须通过执行以下命令来加载该模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload cuse</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在系统启动时加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=cuse&amp;sektion=3&amp;format=html">cuse(3)</a> ，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kld_list += &#34;cuse&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦安装了实用程序，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=webcamd&amp;sektion=8&amp;format=html">webcamd(8)</a> 命令显示可用的网络摄像头列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># webcamd -l</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>webcamd [-d ugen0.2] -N SunplusIT-Inc-HP-TrueVision-HD-Camera -S unknown -M 0 <i class="conum" data-value="1"></i><b>(1)</b>
webcamd [-d ugen1.3] -N Realtek-802-11n-WLAN-Adapter -S 00e04c000001 -M 0</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>可用的网络摄像头</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>执行以下命令配置可用的网络摄像头：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc webcamd_0_flags=&#34;-d ugen0.2&#34; </span><i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，如果这是一个即插即用的 USB 摄像头，更改连接的 USB 端口将会改变 <code>webcamd -l</code> 的输出，并且 rc.conf 中的条目可能需要更新。对于使用 USB 集成摄像头的笔记本电脑，这不应该是一个问题。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>启动 webcamd[8] 服务，需要执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service webcamd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Starting webcamd.
webcamd 1616 - - Attached to ugen0.2[0]</pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/multimedia/pwcview/">multimedia/pwcview</a> 来检查摄像头的正常工作。可以使用以下命令来执行 <a class="package" href="https://cgit.freebsd.org/ports/tree/multimedia/pwcview/">multimedia/pwcview</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>pwcview -f 30 -s vga</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，安装包 multimedia/pwcview[] 将显示网络摄像头：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/multimedia/pwcview.png" alt="pwcview 以《绝对 FreeBSD 第三版》为例进行展示。"/>
</div>
</div>
</div>
<div class="sect3">
<h4 id="meetings-software-status">9.5.2. 会议软件状态<a class="anchor" href="#meetings-software-status"></a></h4>
<div class="paragraph">
<p>FreeBSD 目前支持以下用于进行视频会议的工具。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 19. 会议软件</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">Firefox 状态</th>
<th class="tableblock halign-left valign-top">Chromium 状态</th>
<th class="tableblock halign-left valign-top">网站</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">微软团队</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不起作用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工作</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://teams.live.com" class="bare">https://teams.live.com</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Google Meet 是一款由 Google 开发的在线视频会议工具。它允许用户通过互联网进行高清视频通话和实时屏幕共享。 Google Meet 可以用于个人和商业用途，支持多种设备和操作系统，包括计算机、手机和平板电脑。用户可以通过邀请链接或会议代码邀请他人参加会议，并可以在会议中进行文字聊天和文件共享。 Google Meet 还提供了一些高级功能，如会议录制和直播。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不起作用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工作</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://meet.google.com/" class="bare">https://meet.google.com/</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Zoom 是一种视频会议和在线沟通平台。它允许用户通过互联网进行高清视频和音频通话，以及实时屏幕共享和文件传输。 Zoom 在商业、教育和个人领域都得到了广泛应用，特别是在远程办公和远程学习方面。它提供了许多功能，如多人视频会议、聊天、虚拟背景等，使用户能够方便地进行远程协作和沟通。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工作</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工作</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://zoom.us" class="bare">https://zoom.us</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">Jitsi 是一个开源的视频会议和即时通讯平台。它提供了高质量的音视频通话、屏幕共享、文件传输等功能。 Jitsi 可以在多个平台上运行，包括 Windows 、 Mac 、 Linux 和移动设备。它还支持端到端加密，保护用户的通信安全。 Jitsi 易于使用和部署，可以用于个人使用、企业会议、在线教育等各种场景。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不起作用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工作</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://meet.jit.si/" class="bare">https://meet.jit.si/</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BigBlueButton 是一个开源的在线会议和协作平台。它提供了视频会议、音频通话、屏幕共享、聊天和白板等功能，适用于远程教育、在线培训和团队协作等场景。 BigBlueButton 支持多种操作系统和浏览器，并且可以与其他应用程序集成，如学习管理系统和视频流媒体服务器。它的设计目标是提供稳定、可靠和安全的在线会议体验。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不起作用</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">工作</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://bigbluebutton.org/" class="bare">https://bigbluebutton.org/</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="scanners">9.6. 图像扫描仪<a class="anchor" href="#scanners"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 中，可以通过 <a href="http://www.sane-project.org">SANE (Scanner Access Now Easy)</a> 来访问图像扫描仪，该软件可在 FreeBSD Ports Collection 中获取。</p>
</div>
<div class="sect3">
<h4 id="scanners-kernel-usb">9.6.1. 检查扫描仪<a class="anchor" href="#scanners-kernel-usb"></a></h4>
<div class="paragraph">
<p>在尝试任何配置之前，重要的是要检查扫描仪是否受到 SANE 的支持。</p>
</div>
<div class="paragraph">
<p>连接上扫描仪后，运行以下命令以获取所有连接的 USB 设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># usbconfig list</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ugen4.2: &lt;LITE-ON Technology USB NetVista Full Width Keyboard.&gt; at usbus4, cfg=0 md=HOST spd=LOW (1.5Mbps) pwr=ON (70mA)
ugen4.3: &lt;Logitech USB Optical Mouse&gt; at usbus4, cfg=0 md=HOST spd=LOW (1.5Mbps) pwr=ON (100mA)
ugen3.2: &lt;HP Deskjet 1050 J410 series&gt; at usbus3, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)</pre>
</div>
</div>
<div class="paragraph">
<p>运行以下命令以获取 <code>idVendor</code> 和 <code>idProduct</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># usbconfig -d 3.2 dump_device_desc</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请注意，扫描仪是一种即插即用设备，更改连接的 USB 端口将会改变 <code>usbconfig list</code> 的输出结果。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ugen3.2: &lt;HP Deskjet 1050 J410 series&gt; at usbus3, cfg=0 md=HOST spd=HIGH (480Mbps) pwr=ON (2mA)

bLength = 0x0012
bDescriptorType = 0x0001
bcdUSB = 0x0200
bDeviceClass = 0x0000  &lt;Probed by interface class&gt;
bDeviceSubClass = 0x0000
bDeviceProtocol = 0x0000
bMaxPacketSize0 = 0x0040
idVendor = 0x03f0
idProduct = 0x8911
bcdDevice = 0x0100
iManufacturer = 0x0001  &lt;HP&gt;
iProduct = 0x0002  &lt;Deskjet 1050 J410 series&gt;
bNumConfigurations = 0x0001</pre>
</div>
</div>
<div class="paragraph">
<p>一旦获得了 <code>idVendor</code> 和 <code>idProduct</code> ，就需要在链接： <a href="http://www.sane-project.org/lists/sane-mfgs-cvs.html">SANE 支持设备列表</a> 中检查扫描仪是否受支持，通过按照 <code>idProduct</code> 进行过滤。</p>
</div>
</div>
<div class="sect3">
<h4 id="_sane_configuration">9.6.2. SANE 配置<a class="anchor" href="#_sane_configuration"></a></h4>
<div class="paragraph">
<p>SANE 通过后端提供对扫描仪的访问。要在 FreeBSD 上进行扫描，必须通过运行以下命令安装 graphics/sane-backends[] 软件包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install sane-backends</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些 USB 扫描仪需要加载固件。就像上面示例中使用的 HP 扫描仪一样，它需要安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/hplip/">print/hplip</a> 软件包。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>安装必要的软件包后，必须配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 以允许 FreeBSD 访问扫描仪。</p>
</div>
<div class="paragraph">
<p>将 <code>saned.conf</code> 文件添加到 <span class="filename">/usr/local/etc/devd/saned.conf</span> ，内容如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>notify 100 {
        match &#34;system&#34; &#34;USB&#34;;
        match &#34;subsystem&#34; &#34;INTERFACE&#34;;
        match &#34;type&#34; &#34;ATTACH&#34;;
        match &#34;cdev&#34; &#34;ugen[0-9].[0-9]&#34;;
        match &#34;vendor&#34; &#34;0x03f0&#34;; <i class="conum" data-value="1"></i><b>(1)</b>
        match &#34;product&#34; &#34;0x8911&#34;; <i class="conum" data-value="2"></i><b>(2)</b>
        action &#34;chown -L cups:saned /dev/\$cdev &amp;&amp; chmod -L 660 /dev/\$cdev&#34;;
};</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>vendor</code>: 是之前通过运行 <code>usbconfig -d 3.2 dump_device_desc</code> 命令获取的 idVendor 。 &lt;.&gt; <code>product</code>: 是之前通过运行 <code>usbconfig -d 3.2 dump_device_desc</code> 命令获取的 idProduct 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在那之后，必须通过运行以下命令来重新启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service devd restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>SANE 后端包括 <a href="https://man.freebsd.org/cgi/man.cgi?query=scanimage&amp;sektion=1&amp;format=html">scanimage(1)</a> ，可用于列出设备并执行图像获取。</p>
</div>
<div class="paragraph">
<p>使用 <code>-L</code> 参数执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=scanimage&amp;sektion=1&amp;format=html">scanimage(1)</a> 命令以列出扫描设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># scanimage -L</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device `hpaio:/usb/Deskjet_1050_J410_series?serial=XXXXXXXXXXXXXX&#39; is a Hewlett-Packard Deskjet_1050_J410_series all-in-one</pre>
</div>
</div>
<div class="paragraph">
<p>如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=scanimage&amp;sektion=1&amp;format=html">scanimage(1)</a> 无法识别扫描仪，将显示以下消息：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>No scanners were identified. If you were expecting something different,
check that the scanner is plugged in, turned on and detected by the
sane-find-scanner tool (if appropriate). Please read the documentation
which came with this software (README, FAQ, manpages).</pre>
</div>
</div>
<div class="paragraph">
<p>一旦 <a href="https://man.freebsd.org/cgi/man.cgi?query=scanimage&amp;sektion=1&amp;format=html">scanimage(1)</a> 检测到扫描仪，配置就完成了，扫描仪现在可以使用了。</p>
</div>
<div class="paragraph">
<p>要激活该服务并使其在启动时运行，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc saned_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=scanimage&amp;sektion=1&amp;format=html">scanimage(1)</a> 命令行工具来进行图像采集，但通常更倾向于使用图形界面来进行图像扫描。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 20. 图形扫描程序</caption>
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">Package</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">skanlite</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">图形 / 扫描仪</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">GNOME 简易扫描</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 3.0 是 GNU 通用公共许可证的第 3.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">图形 / 简单扫描</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">XSANE 是一个用于扫描仪的开源图像扫描软件。它允许用户通过计算机控制扫描仪，从而将纸质文档转换为数字图像。 XSANE 提供了丰富的功能，包括调整扫描设置、图像预览、图像编辑和保存等。它支持多种图像格式，并且可以与其他图像处理软件集成使用。 XSANE 是一个功能强大且易于使用的工具，适用于个人用户和专业用户。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">GPL 2.0 是 GNU 通用公共许可证的第 2.0 版。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">图形 /xsane</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="kernelconfig">Chapter 10. 配置 FreeBSD 内核<a class="anchor" href="#kernelconfig"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="kernelconfig-synopsis">10.1. 简介<a class="anchor" href="#kernelconfig-synopsis"></a></h3>
<div class="paragraph">
<p>内核是 FreeBSD 操作系统的核心。它负责管理内存、执行安全控制、网络、磁盘访问等等。尽管 FreeBSD 的许多部分是动态可配置的，但有时仍然需要配置和编译自定义内核。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>何时构建自定义内核。</p>
</li>
<li>
<p>如何进行硬件清查。</p>
</li>
<li>
<p>如何自定义内核配置文件。</p>
</li>
<li>
<p>如何使用内核配置文件创建和构建新内核。</p>
</li>
<li>
<p>如何安装新内核。</p>
</li>
<li>
<p>如果出现问题，如何进行故障排除。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本章中示例中列出的所有命令都应以 <code>root</code> 用户身份执行。</p>
</div>
</div>
<div class="sect2">
<h3 id="kernelconfig-custom-kernel">10.2. 为什么要构建自定义内核？<a class="anchor" href="#kernelconfig-custom-kernel"></a></h3>
<div class="paragraph">
<p>传统上，FreeBSD 使用的是一个单内核。内核是一个庞大的程序，支持一组固定的设备，并且要改变内核的行为，需要编译并重新启动到一个新的内核。</p>
</div>
<div class="paragraph">
<p>如今，FreeBSD 内核中的大部分功能都包含在模块中，这些模块可以根据需要动态加载和卸载。这使得运行中的内核能够立即适应新的硬件，并将新的功能引入内核中。这被称为模块化内核。</p>
</div>
<div class="paragraph">
<p>偶尔，仍然有必要进行静态内核配置。有时所需功能与内核紧密相关，无法以动态加载的方式实现。某些安全环境禁止加载和卸载内核模块，并要求只将所需功能静态编译到内核中。</p>
</div>
<div class="paragraph">
<p>对于高级 BSD 用户来说，构建自定义内核通常是一种成年礼。尽管这个过程耗时，但可以为 FreeBSD 系统带来好处。与必须支持各种硬件的 <span class="filename">GENERIC</span> 内核不同，自定义内核可以精简为仅提供对该计算机硬件的支持。这有许多好处，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>更快的启动时间。由于内核只会探测系统上的硬件，系统启动所需的时间可以减少。</p>
</li>
<li>
<p>较低的内存使用量。自定义内核通常通过省略未使用的功能和设备驱动程序来使用较少的内存，相比于 <span class="filename">GENERIC</span> 内核。这很重要，因为内核代码始终驻留在物理内存中，防止该内存被应用程序使用。因此，在内存较小的系统上使用自定义内核非常有用。</p>
</li>
<li>
<p>额外的硬件支持。自定义内核可以为 <span class="filename">GENERIC</span> 内核中不存在的设备添加支持。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在构建自定义内核之前，请考虑进行此操作的原因。如果需要特定的硬件支持，可能已经存在相应的模块。</p>
</div>
<div class="paragraph">
<p>内核模块存在于 <span class="filename">/boot/kernel</span> 目录中，并且可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 命令动态加载到运行中的内核中。大多数内核驱动程序都有可加载的模块和手册页。例如，<a href="https://man.freebsd.org/cgi/man.cgi?query=ath&amp;sektion=4&amp;format=html">ath(4)</a> 无线网络驱动程序在其手册页中包含以下信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Alternatively, to load the driver as a module at boot time, place the
following line in <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a>:

    if_ath_load=&#34;YES&#34;</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <span class="filename">/boot/loader.conf</span> 中添加 <code>if_ath_load =&#34;YES&#34;</code> 将会在启动时动态加载该模块。</p>
</div>
<div class="paragraph">
<p>在某些情况下，<span class="filename">/boot/kernel</span> 中没有关联的模块。这在某些子系统中是普遍存在的。</p>
</div>
</div>
<div class="sect2">
<h3 id="kernelconfig-devices">10.3. 查找系统硬件<a class="anchor" href="#kernelconfig-devices"></a></h3>
<div class="paragraph">
<p>在编辑内核配置文件之前，建议先对机器的硬件进行清查。在双启动系统上，可以从其他操作系统中创建清单。例如，Microsoft® 的设备管理器包含有关已安装设备的信息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些 Microsoft® Windows® 的版本中有一个系统图标，可以用来访问设备管理器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果 FreeBSD 是唯一安装的操作系统，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> 命令来确定在启动探测期间找到和列出的硬件。FreeBSD 上的大多数设备驱动程序都有一个手册页面，列出了该驱动程序支持的硬件。例如，以下行表示 <a href="https://man.freebsd.org/cgi/man.cgi?query=psm&amp;sektion=4&amp;format=html">psm(4)</a> 驱动程序找到了一个鼠标：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">psm0: &lt;PS/2 Mouse&gt; irq 12 on atkbdc0
psm0: <span class="o">[</span>GIANT-LOCKED]
psm0: <span class="o">[</span>ITHREAD]
psm0: model Generic PS/2 mouse, device ID 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于存在这个硬件，这个驱动程序不应从自定义内核配置文件中删除。</p>
</div>
<div class="paragraph">
<p>如果 <code>dmesg</code> 命令的输出没有显示引导探测的结果，可以读取文件 <span class="filename">/var/run/dmesg.boot</span> 的内容。</p>
</div>
<div class="paragraph">
<p>另一个用于查找硬件的工具是 <a href="https://man.freebsd.org/cgi/man.cgi?query=pciconf&amp;sektion=8&amp;format=html">pciconf(8)</a>，它提供更详细的输出。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>pciconf -lv
ath0@pci0:3:0:0:        <span class="nv">class</span><span class="o">=</span>0x020000 <span class="nv">card</span><span class="o">=</span>0x058a1014 <span class="nv">chip</span><span class="o">=</span>0x1014168c <span class="nv">rev</span><span class="o">=</span>0x01 <span class="nv">hdr</span><span class="o">=</span>0x00
    vendor     <span class="o">=</span> <span class="s1">&#39;Atheros Communications Inc.&#39;</span>
    device     <span class="o">=</span> <span class="s1">&#39;AR5212 Atheros AR5212 802.11abg wireless&#39;</span>
    class      <span class="o">=</span> network
    subclass   <span class="o">=</span> ethernet</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个输出显示 <span class="filename">ath</span> 驱动程序找到了一个无线以太网设备。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=man&amp;sektion=1&amp;format=html">man(1)</a> 的 <code>-k</code> 标志可以用来提供有用的信息。例如，它可以用来显示包含特定设备品牌或名称的手册页面列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># man -k Atheros</span>
ath<span class="o">(</span>4<span class="o">)</span>                   - Atheros IEEE 802.11 wireless network driver
ath_hal<span class="o">(</span>4<span class="o">)</span>               - Atheros Hardware Access Layer <span class="o">(</span>HAL<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建硬件清单后，参考该清单以确保在编辑自定义内核配置时不要删除已安装硬件的驱动程序。</p>
</div>
</div>
<div class="sect2">
<h3 id="kernelconfig-config">10.4. 配置文件<a class="anchor" href="#kernelconfig-config"></a></h3>
<div class="paragraph">
<p>为了创建一个自定义的内核配置文件并构建一个自定义的内核，首先必须安装完整的 FreeBSD 源代码树。</p>
</div>
<div class="paragraph">
<p>如果 <span class="filename">/usr/src/</span> 不存在或为空，则表示源代码未安装。可以使用 Git 安装源代码，具体操作请参考 <a href="./#git">“使用 Git”</a> 。</p>
</div>
<div class="paragraph">
<p>安装完成后，请查看 <span class="filename">/usr/src/sys</span> 目录的内容。该目录包含许多子目录，其中包括以下支持的架构：amd64，i386，powerpc 和 sparc64。特定架构目录中的所有内容仅与该架构相关，而其余代码是适用于所有平台的机器无关代码。每个支持的架构都有一个 conf 子目录，其中包含该架构的 GENERIC 内核配置文件。</p>
</div>
<div class="paragraph">
<p>不要对 <span class="filename">GENERIC</span> 进行编辑。相反，将文件复制到另一个名称并对副本进行编辑。惯例是使用全大写字母的名称。当维护具有不同硬件的多个 FreeBSD 机器时，最好使用机器的主机名来命名。此示例创建了一个名为 <span class="filename">MYKERNEL</span> 的副本，用于 <code>amd64</code> 架构的 <span class="filename">GENERIC</span> 配置文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src/sys/amd64/conf</span>
<span class="c"># cp GENERIC MYKERNEL</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">MYKERNEL</span> 现在可以使用任何 <code>ASCII</code> 文本编辑器进行自定义。默认编辑器是 vi，尽管 FreeBSD 还安装了一个更适合初学者的简化编辑器，名为 ee 。</p>
</div>
<div class="paragraph">
<p>内核配置文件的格式很简单。每一行包含一个关键字，代表一个设备或子系统，一个参数和一个简短的描述。在 <code>#</code> 之后的任何文本都被视为注释并被忽略。要移除对设备或子系统的内核支持，请在表示该设备或子系统的行的开头加上 <code>#</code> 。对于任何你不理解的行，请不要添加或删除 <code>#</code>。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>删除设备或选项的支持并最终导致内核损坏是很容易的。例如，如果从内核配置文件中删除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=ata&amp;sektion=4&amp;format=html">ata(4)</a> 驱动程序，使用 <code>ATA</code> 磁盘驱动程序的系统可能无法启动。当有疑问时，最好保留内核中的支持。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了本文件中提供的简要描述外，其他描述还包含在与该架构的 <span class="filename">GENERIC</span> 文件位于同一目录中的 <span class="filename">NOTES</span> 文件中。对于与架构无关的选项，请参考 <span class="filename">/usr/src/sys/conf/NOTES</span> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在完成自定义内核配置文件后，将备份副本保存到位于 <span class="filename">/usr/src</span> 之外的位置。</p>
</div>
<div class="paragraph">
<p>或者，将内核配置文件保存在其他位置，并创建一个符号链接指向该文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src/sys/amd64/conf</span>
<span class="c"># mkdir /root/kernels</span>
<span class="c"># cp GENERIC /root/kernels/MYKERNEL</span>
<span class="c"># ln -s /root/kernels/MYKERNEL</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>配置文件中可以使用 <code>include</code> 指令。这允许将另一个配置文件包含在当前文件中，从而方便地对现有文件进行小的修改。如果只需要少量的额外选项或驱动程序，这样可以相对于 <span class="filename">GENERIC</span> 保持增量，如下面的示例所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>include GENERIC
ident MYKERNEL

options         IPFIREWALL
options         DUMMYNET
options         IPFIREWALL_DEFAULT_TO_ACCEPT
options         IPDIVERT</pre>
</div>
</div>
<div class="paragraph">
<p>使用这种方法，本地配置文件表达了与 <span class="filename">GENERIC</span> 内核的本地差异。随着升级的进行，添加到 <span class="filename">GENERIC</span> 的新功能也将添加到本地内核中，除非使用 <code>nooptions</code> 或 <code>nodevice</code> 明确禁止它们。有关配置指令及其描述的详细列表，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要构建一个包含所有可用选项的文件，请以 <code>root</code> 身份运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src/sys/arch/conf &amp;&amp; make LINT</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="kernelconfig-building">10.5. 构建和安装自定义内核<a class="anchor" href="#kernelconfig-building"></a></h3>
<div class="paragraph">
<p>一旦自定义配置文件的编辑保存完毕，可以按照以下步骤编译内核的源代码：</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="paragraph">
<p><strong>过程：构建内核</strong></p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>切换到这个目录：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span></code></pre>
</div>
</div>
</li>
<li>
<p>通过指定自定义内核配置文件的名称来编译新的内核：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make buildkernel KERNCONF=MYKERNEL</span></code></pre>
</div>
</div>
</li>
<li>
<p>安装与指定的内核配置文件相关联的新内核。此命令将新内核复制到 <span class="filename">/boot/kernel/kernel</span> 并将旧内核保存到 <span class="filename">/boot/kernel.old/kernel</span> 。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make installkernel KERNCONF=MYKERNEL</span></code></pre>
</div>
</div>
</li>
<li>
<p>关闭系统并重新启动到新内核。如果出现问题，请参考 <a href="#kernelconfig-noboot">内核无法启动</a>。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>默认情况下，当编译自定义内核时，所有内核模块都会重新构建。为了更快地更新内核或仅构建自定义模块，在开始构建内核之前，请编辑 <span class="filename">/etc/make.conf</span> 文件。</p>
</div>
<div class="paragraph">
<p>例如，这个变量指定了要构建的模块列表，而不是使用默认的构建所有模块。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>MODULES_OVERRIDE = linux acpi</pre>
</div>
</div>
<div class="paragraph">
<p>另外，这个变量列出了在构建过程中要排除的模块。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>WITHOUT_MODULES = linux acpi sound</pre>
</div>
</div>
<div class="paragraph">
<p>还有其他可用的变量。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=make.conf&amp;sektion=5&amp;format=html">make.conf(5)</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="kernelconfig-trouble">10.6. 如果出现问题<a class="anchor" href="#kernelconfig-trouble"></a></h3>
<div class="paragraph">
<p>构建自定义内核时可能出现的四种故障类别有：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>config</code> 失败</dt>
<dd>
<p>如果 <code>config</code> 失败，它将打印出错误的行号。例如，对于以下消息，请通过将其与 <span class="filename">GENERIC</span> 或 <span class="filename">NOTES</span> 进行比较，确保第 17 行的输入正确。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">config: line 17: syntax error</code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><code>make</code> 失败</dt>
<dd>
<p>如果 <code>make</code> 失败，通常是由于内核配置文件中的错误，这种错误不严重到足以被 <code>config</code> 捕获。请检查配置，如果问题不明显，请发送一封包含内核配置文件的电子邮件到 {freebsd-questions}。</p>
</dd>
</dl>
</div>
<div id="kernelconfig-noboot" class="dlist">
<dl>
<dt class="hdlist1">内核无法启动</dt>
<dd>
<p>如果新内核无法启动或无法识别设备，请不要惊慌！幸运的是，FreeBSD 有一个出色的机制可以从不兼容的内核中恢复。只需在 FreeBSD 引导加载程序中选择要引导的内核即可。当系统启动菜单出现时，可以通过选择“进入加载程序提示符（Escape to a loader prompt）”选项来访问它。在提示符下，输入 <code>boot <em>kernel.old</em></code>，或者任何其他已知可以正确引导的内核的名称。</p>
<div class="paragraph">
<p>在使用良好的内核启动后，检查配置文件并尝试重新构建。一个有用的资源是 <span class="filename">/var/log/messages</span> 文件，它记录了每次成功启动时的内核消息。此外，<a href="https://man.freebsd.org/cgi/man.cgi?query=dmesg&amp;sektion=8&amp;format=html">dmesg(8)</a> 命令将打印当前启动的内核消息。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在排除内核问题时，请确保保留一个已知可正常工作的内核副本，例如 <span class="filename">GENERIC</span>。这很重要，因为每次安装新内核时， <span class="filename">kernel.old</span> 都会被上一个安装的内核覆盖，该内核可能无法启动。尽快将工作正常的内核移动，通过重命名包含良好内核的目录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mv /boot/kernel /boot/kernel.bad</span>
<span class="c"># mv /boot/kernel.good /boot/kernel</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1">内核工作正常，但是 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 命令不起作用。</dt>
<dd>
<p>如果内核版本与系统实用程序构建的版本不同，例如，在 -RELEASE 系统上安装了从 -CURRENT 源构建的内核，那么许多系统状态命令（如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ps&amp;sektion=1&amp;format=html">ps(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=vmstat&amp;sektion=8&amp;format=html">vmstat(8)</a>）将无法工作。为了解决这个问题，应该使用与内核相同版本的源代码树<a href="./#makeworld">重新编译和安装整个系统</a>。在操作系统中使用与其余部分不同版本的内核从来都不是一个好主意。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="printing">Chapter 11. 打印<a class="anchor" href="#printing"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>将信息记录在纸上是一项重要的功能，尽管有许多试图消除它的尝试。打印有两个基本组成部分。数据必须传递给打印机，并且必须以打印机能够理解的形式呈现。</p>
</div>
<div class="sect2">
<h3 id="printing-quick-start">11.1. 快速入门<a class="anchor" href="#printing-quick-start"></a></h3>
<div class="paragraph">
<p>基本的打印设置可以很快完成。打印机必须能够打印纯文本的 ASCII 字符。如需打印其他类型的文件，请参阅 <a href="#printing-lpd-filters">过滤器</a> 。</p>
</div>
<div class="sidebarblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个目录来存储正在打印的文件：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir -p /var/spool/lpd/lp</span>
<span class="c"># chown daemon:daemon /var/spool/lpd/lp</span>
<span class="c"># chmod 770 /var/spool/lpd/lp</span></code></pre>
</div>
</div>
</li>
<li>
<p>以 <code>root</code> 身份创建 <span class="filename">/etc/printcap</span> 文件，并使用以下内容：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>lp:\
lp=/dev/unlpt0:\  <i class="conum" data-value="1"></i><b>(1)</b>
sh:\
mx#0:\
sd=/var/spool/lpd/lp:\
lf=/var/log/lpd-errs:</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这行是为连接到 <code>USB</code> 端口的打印机准备的。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对于连接到并行或“打印机”端口的打印机，请使用：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:lp=/dev/lpt0:\</pre>
</div>
</div>
<div class="paragraph">
<p>对于直接连接到网络的打印机，请使用以下方法：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:lp=:rm=network-printer-name:rp=raw:\</pre>
</div>
</div>
<div class="paragraph">
<p>将_network-printer-name_替换为网络打印机的 <code>DNS</code> 主机名。</p>
</div>
</li>
<li>
<p>通过编辑 <span class="filename">/etc/rc.conf</span> 文件，添加以下行来启用 LPD ：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>lpd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>启动服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service lpd start</span>
Starting lpd.</code></pre>
</div>
</div>
</li>
<li>
<p>打印一个测试：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># printf &#34;1. This printer can print.\n2. This is the second line.\n&#34; | lpr</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果两条线都不从左边界开始，而是“阶梯状”开始，请参见 <a href="#printing-lpd-filters-stairstep">防止普通文本打印机上的阶梯状输出</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在可以使用 <code>lpr</code> 命令打印文本文件。在命令行上给出文件名，或直接将输出通过管道传递给 <code>lpr</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpr textfile.txt
<span class="gp">% </span>ls -lh | lpr</code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="printing-connections">11.2. 打印机连接<a class="anchor" href="#printing-connections"></a></h3>
<div class="paragraph">
<p>打印机可以通过多种方式连接到计算机系统。小型台式打印机通常直接连接到计算机的 <code>USB</code> 端口。旧式打印机则连接到并行或“打印机”端口。有些打印机直接连接到网络，方便多台计算机共享使用。少数打印机使用罕见的串行端口连接。</p>
</div>
<div class="paragraph">
<p>FreeBSD 可以与所有这些类型的打印机进行通信。</p>
</div>
<div id="printing-connections-usb" class="dlist">
<dl>
<dt class="hdlist1"><code>USB</code> 是一种通用串行总线（ Universal Serial Bus ）的缩写，它是一种用于连接计算机和外部设备的标准接口。 USB 接口可以用于连接各种设备，包括打印机、键盘、鼠标、摄像头、移动存储设备等。 USB 接口具有热插拔功能，可以在计算机运行时插入或拔出设备，而无需重新启动计算机。 USB 接口还可以提供电力供应，使连接的设备可以通过 USB 接口获得电力。 USB 接口有多个版本，包括 USB 1.0 、 USB 2.0 、 USB 3.0 和 USB 4.0 ，每个版本都有不同的传输速度和功能。</dt>
<dd>
<p>USB 打印机可以连接到计算机上的任何可用的 USB 端口。</p>
<div class="paragraph">
<p>当 FreeBSD 检测到一个 <code>USB</code> 打印机时，会创建两个设备条目： <span class="filename">/dev/ulpt0</span> 和 <span class="filename">/dev/unlpt0</span> 。发送到任何一个设备的数据都会传递给打印机。在每个打印作业之后， <span class="filename">ulpt0</span> 会重置 <code>USB</code> 端口。重置端口可能会导致一些打印机出现问题，所以通常使用 <span class="filename">unlpt0</span> 设备代替。 <span class="filename">unlpt0</span> 根本不会重置 USB 端口。</p>
</div>
</dd>
</dl>
</div>
<div id="printing-connections-parallel" class="dlist">
<dl>
<dt class="hdlist1">并行（ IEEE-1284 ）</dt>
<dd>
<p>并行端口设备是 [/dev/lpt0] 。无论是否连接打印机，该设备都会出现，不会自动检测。</p>
<div class="paragraph">
<p>供应商们大多已经放弃了这些“传统”端口，许多计算机不再配备这些端口。可以使用适配器将并行打印机连接到 <code>USB</code> 端口。通过这样的适配器，打印机可以被视为实际上是一台 <code>USB</code> 打印机。还可以使用称为“打印服务器”的设备将并行打印机直接连接到网络。</p>
</div>
</dd>
</dl>
</div>
<div id="printing-connections-serial" class="dlist">
<dl>
<dt class="hdlist1">串行（ RS-232 ）</dt>
<dd>
<p>串口是另一种遗留端口，在某些特定的利基应用中除外，很少用于打印机。电缆、连接器和所需的布线各不相同。</p>
<div class="paragraph">
<p>对于集成在主板上的串口，串口设备名称是 [/dev/cuau0] 或 [/dev/cuau1] 。串口 USB 适配器也可以使用，它们将显示为 [/dev/cuaU0] 。</p>
</div>
<div class="paragraph">
<p>与串行打印机通信需要了解几个通信参数。其中最重要的是波特率（ Baud Rate ）或 BPS （每秒比特数）和奇偶校验（ Parity ）。具体数值可能有所不同，但典型的串行打印机使用波特率为 9600 ，无奇偶校验。</p>
</div>
</dd>
</dl>
</div>
<div id="printing-connections-network" class="dlist">
<dl>
<dt class="hdlist1">网络</dt>
<dd>
<p>网络打印机直接连接到本地计算机网络。</p>
<div class="paragraph">
<p>必须知道打印机的 <code>DNS</code> 主机名。如果打印机通过 <code>DHCP</code> 分配动态地址，则应动态更新 <code>DNS</code> ，以便主机名始终具有正确的 <code>IP</code> 地址。为了避免这个问题，通常给网络打印机分配静态 <code>IP</code> 地址。</p>
</div>
<div class="paragraph">
<p>大多数网络打印机都能理解使用 LPD 协议发送的打印作业。还可以指定打印队列名称。根据使用的队列不同，一些打印机会以不同的方式处理数据。例如， <code>raw</code> 队列会原样打印数据，而 <code>text</code> 队列会在纯文本中添加回车符。</p>
</div>
<div class="paragraph">
<p>许多网络打印机还可以打印直接发送到端口 9100 的数据。</p>
</div>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="printing-connections-summary">11.2.1. 摘要<a class="anchor" href="#printing-connections-summary"></a></h4>
<div class="paragraph">
<p>有线网络连接通常是最容易设置并且打印速度最快的。对于直接连接到计算机， <code>USB</code> 是首选，因为速度快且简单。并行连接也可以工作，但是在电缆长度和速度方面有一些限制。串行连接更难配置。电缆布线在不同的型号之间有所不同，通信参数如波特率和奇偶校验位增加了复杂性。幸运的是，串行打印机很少见。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="printing-pdls">11.3. 常见的页面描述语言<a class="anchor" href="#printing-pdls"></a></h3>
<div class="paragraph">
<p>发送给打印机的数据必须使用打印机能够理解的语言。这些语言被称为页面描述语言（ Page Description Languages ，简称 PDLs ）。</p>
</div>
<div id="print-pdls-ascii" class="dlist">
<dl>
<dt class="hdlist1"><code>ASCII</code> 是一种用于表示文本字符的编码标准。它使用 7 位二进制数来表示 128 个字符，包括英文字母、数字、标点符号和一些特殊字符。 ASCII 编码是计算机系统中最常用的字符编码之一，它使得不同计算机之间可以互相交换和处理文本数据。</dt>
<dd>
<p>纯文本是将数据发送到打印机的最简单方式。字符与将要打印的内容一一对应：数据中的一个“ A ”会在页面上打印出一个“ A ”。几乎没有可用的格式设置。无法选择字体或比例间距。纯文本的强制简洁性意味着文本可以直接从计算机打印，几乎不需要编码或翻译。打印输出与发送的内容直接对应。</p>
<div class="paragraph">
<p>一些廉价的打印机无法打印纯文本的 <code>ASCII</code> 字符。这使得它们更难设置，但通常仍然是可能的。</p>
</div>
</dd>
</dl>
</div>
<div id="print-pdls-postscript" class="dlist">
<dl>
<dt class="hdlist1">PostScript （ R ）</dt>
<dd>
<p>PostScript® 几乎是 <code>ASCII</code> 的反义词。与简单的文本不同， PostScript® 程序是一组绘制最终文档的指令。可以使用不同的字体和图形。然而，这种强大的功能是有代价的。绘制页面的程序必须编写。通常，这个程序是由应用软件生成的，所以对用户来说是不可见的。</p>
<div class="paragraph">
<p>为了节省成本，廉价打印机有时会省略 PostScript® 兼容性。</p>
</div>
</dd>
</dl>
</div>
<div id="print-pdls-pcl" class="dlist">
<dl>
<dt class="hdlist1"><code>PCL</code> （打印机命令语言）</dt>
<dd>
<p><code>PCL</code> 是 <code>ASCII</code> 的扩展，添加了用于格式化、字体选择和打印图形的转义序列。许多打印机支持 <code>PCL5</code> 。一些支持更新的 <code>PCL6</code> 或 <code>PCLXL</code> 。这些较新的版本是 <code>PCL5</code> 的超集，可以提供更快的打印速度。</p>
</dd>
</dl>
</div>
<div id="print-pdls-host-based" class="dlist">
<dl>
<dt class="hdlist1">基于主机的</dt>
<dd>
<p>制造商可以通过给打印机配备简单的处理器和很少的内存来降低成本。这些打印机无法打印纯文本。相反，文本和图形的位图由主机计算机上的驱动程序绘制，然后发送到打印机。这些被称为“基于主机”的打印机。</p>
<div class="paragraph">
<p>驱动程序与基于主机的打印机之间的通信通常通过专有或未记录的协议进行，这使它们只能在最常见的操作系统上运行。</p>
</div>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="print-pdls-table">11.3.1. 将 PostScript® 转换为其他 PDLs<a class="anchor" href="#print-pdls-table"></a></h4>
<div class="paragraph">
<p>Ports Collection 中的许多应用程序和 FreeBSD 实用程序会生成 PostScript® 输出。下表显示了可用于将其转换为其他常见 PDL 的实用程序：</p>
</div>
<table id="print-pdls-ps-to-other-tbl" class="tableblock frame-none grid-all stretch">
<caption class="title">表 21. 输出 PDLs</caption>
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">输出 PDL</th>
<th class="tableblock halign-left valign-top">生成者：</th>
<th class="tableblock halign-left valign-top">注释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PCL</code> 或 <code>PCL5</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： print/ghostscript9-base[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-sDEVICE = ljet4</code> 用于黑白打印， <code>-sDEVICE = cljet5</code> 用于彩色打印。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>PCLXL</code> 或 <code>PCL6</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： print/ghostscript9-base[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-sDEVICE = pxlmono</code> 用于黑白打印， <code>-sDEVICE = pxlcolor</code> 用于彩色打印。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ESC/P2</code> 是一种打印机控制语言，它是 Epson 公司开发的一种标准。它可以用于控制 Epson 打印机的各种功能和设置，包括打印模式、字体选择、页面布局等。 <code>ESC/P2</code> 广泛应用于各种类型的打印机，包括喷墨打印机、针式打印机等。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： print/ghostscript9-base[]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-sDEVICE = uniprint</code> 表示使用 <code>uniprint</code> 设备。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>XQX</code> 是一个没有具体含义的字符串。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： print/foo2zjs[]</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="print-pdls-summary">11.3.2. 摘要<a class="anchor" href="#print-pdls-summary"></a></h4>
<div class="paragraph">
<p>为了实现最简单的打印，选择支持 PostScript® 的打印机是最好的选择。其次是支持 PCL 的打印机。使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/">print/ghostscript9-base</a> 软件包，这些打印机可以像本地支持 PostScript® 一样使用。几乎所有直接支持 PostScript® 或 PCL 的打印机也支持直接打印纯 ASCII 文本文件。</p>
</div>
<div class="paragraph">
<p>像典型的喷墨打印机一样，基于行的打印机通常不支持 PostScript® 或 <code>PCL</code> 。它们通常可以打印纯文本文件。 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/ghostscript9-base/">print/ghostscript9-base</a> 支持一些这些打印机使用的页面描述语言（ PDL ）。然而，由于需要传输和打印的数据量很大，使用这些打印机打印整个基于图形的页面通常非常慢。</p>
</div>
<div class="paragraph">
<p>基于主机的打印机通常更难设置。由于专有的页面描述语言（ PDL ），有些打印机根本无法使用。尽量避免使用这些打印机。</p>
</div>
<div class="paragraph">
<p>许多页面描述语言（ PDL ）的描述可以在 <a href="http://www.undocprint.org/formats/page_description_languages" class="bare">http://www.undocprint.org/formats/page_description_languages</a> 找到。各种型号打印机使用的特定 PDL 可以在 <a href="http://www.openprinting.org/printers" class="bare">http://www.openprinting.org/printers</a> 找到。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="printing-direct">11.4. 直接打印<a class="anchor" href="#printing-direct"></a></h3>
<div class="paragraph">
<p>对于偶尔打印的情况，可以直接将文件发送到打印机设备，无需进行任何设置。例如，可以将名为 <code>sample.txt</code> 的文件发送到一个 USB 打印机。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp sample.txt /dev/unlpt0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>直接打印到网络打印机取决于打印机的功能，但大多数打印机可以在端口 9100 上接受打印作业，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=nc&amp;sektion=1&amp;format=html">nc(1)</a> 与它们一起使用。要将同一文件打印到名为_netlaser_的打印机上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># nc netlaser 9100 &lt; sample.txt</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="printing-lpd">11.5. LPD （ Line Printer Daemon ）是一种用于打印机的网络协议。<a class="anchor" href="#printing-lpd"></a></h3>
<div class="paragraph">
<p>在后台打印文件被称为“<em>spooling</em>”。一个打印机缓冲程序允许用户在打印作业慢慢完成的过程中继续使用计算机上的其他程序，而无需等待打印机完成。</p>
</div>
<div class="paragraph">
<p>FreeBSD 包含一个名为 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> 的打印队列管理器。打印作业可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> 提交。</p>
</div>
<div class="sect3">
<h4 id="printing-lpd-setup">11.5.1. 初始设置<a class="anchor" href="#printing-lpd-setup"></a></h4>
<div class="paragraph">
<p>创建了一个用于存储打印作业的目录，设置了所有权，并设置了权限，以防止其他用户查看这些文件的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir -p /var/spool/lpd/lp</span>
<span class="c"># chown daemon:daemon /var/spool/lpd/lp</span>
<span class="c"># chmod 770 /var/spool/lpd/lp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>打印机在 /etc/printcap 中定义。每个打印机的条目包括名称、连接端口和其他各种设置。使用以下内容创建 /etc/printcap 文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>lp:\				<i class="conum" data-value="1"></i><b>(1)</b>
	:lp=/dev/unlpt0:\	<i class="conum" data-value="2"></i><b>(2)</b>
	:sh:\			<i class="conum" data-value="3"></i><b>(3)</b>
	:mx#0:\			<i class="conum" data-value="4"></i><b>(4)</b>
	:sd=/var/spool/lpd/lp:\	<i class="conum" data-value="5"></i><b>(5)</b>
	:lf=/var/log/lpd-errs:	<i class="conum" data-value="6"></i><b>(6)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这台打印机的名称。 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> 命令将打印作业发送到 <code>lp</code> 打印机，除非使用 <code>-P</code> 指定了其他打印机，因此默认打印机应该被命名为 <code>lp</code> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>打印机连接的设备。将此行替换为适用于此处显示的连接类型的正确行。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在打印作业开始时禁止打印页眉。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>不要限制打印作业的最大大小。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>这台打印机的排队目录路径。每台打印机都使用自己的排队目录。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>这台打印机报告错误的日志文件。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>创建 <span class="filename">/etc/printcap</span> 后，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chkprintcap&amp;sektion=8&amp;format=html">chkprintcap(8)</a> 来测试是否存在错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chkprintcap</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在继续之前，请修复所有报告的问题。</p>
</div>
<div class="paragraph">
<p>在 <code>/etc/rc.conf</code> 文件中启用 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a></code> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>lpd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>启动服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service lpd start</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="printing-lpd-lpr">11.5.2. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> 打印<a class="anchor" href="#printing-lpd-lpr"></a></h4>
<div class="paragraph">
<p>使用 <code>lpr</code> 命令将文档发送到打印机。要打印的文件可以在命令行上指定名称，也可以通过管道传递给 <code>lpr</code> 。以下两个命令是等效的，将 <span class="filename">doc.txt</span> 的内容发送到默认打印机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpr doc.txt
<span class="gp">% </span>cat doc.txt | lpr</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code>-P</code> 选项选择打印机。要打印到名为_laser_的打印机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpr -Plaser doc.txt</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="printing-lpd-filters">11.5.3. 过滤器<a class="anchor" href="#printing-lpd-filters"></a></h4>
<div class="paragraph">
<p>到目前为止展示的示例已经直接将文本文件的内容发送到打印机。只要打印机能理解这些文件的内容，输出就会正确打印。</p>
</div>
<div class="paragraph">
<p>有些打印机无法打印纯文本，而输入文件甚至可能不是纯文本。</p>
</div>
<div class="paragraph">
<p><em>过滤器</em> 允许文件进行翻译或处理。典型的用法是将一种类型的输入（如纯文本）转换为打印机可以理解的形式，如 PostScript® 或 <code>PCL</code> 。过滤器还可以用于提供额外的功能，如添加页码或突出显示源代码以便更容易阅读。</p>
</div>
<div class="paragraph">
<p>这里讨论的过滤器是“输入过滤器”或“文本过滤器”。这些过滤器将输入的文件转换为不同的形式。在创建文件之前，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 命令切换为“ root ”用户。</p>
</div>
<div class="paragraph">
<p>过滤器在 <span class="filename">/etc/printcap</span> 中使用 `if = ` 标识符进行指定。要使用 <span class="filename">/usr/local/libexec/lf2crlf</span> 作为过滤器，修改 <span class="filename">/etc/printcap</span> 如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>lp:\
	:lp=/dev/unlpt0:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/lp:\
	:if=/usr/local/libexec/lf2crlf:\   <i class="conum" data-value="1"></i><b>(1)</b>
	:lf=/var/log/lpd-errs:</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>`if = ` 标识了将用于处理传入文本的 <em>输入过滤器</em>。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <span class="filename">printcap</span> 条目的行尾处使用反斜杠 <em>line continuation</em> 字符，揭示了打印机条目实际上只是一行长字符串，其中条目由冒号字符分隔。一个早期的示例可以重写为一行不易读的字符串：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>lp:lp=/dev/unlpt0:sh:mx#0:sd=/var/spool/lpd/lp:if=/usr/local/libexec/lf2crlf:lf=/var/log/lpd-errs:</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="printing-lpd-filters-stairstep">11.5.3.1. 防止普通文本打印机上的阶梯状输出<a class="anchor" href="#printing-lpd-filters-stairstep"></a></h5>
<div class="paragraph">
<p>典型的 FreeBSD 文本文件每行末尾只包含一个换行符。这些行在标准打印机上会呈“阶梯状”排列：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>A printed file looks
                    like the steps of a staircase
                                                 scattered by the wind</pre>
</div>
</div>
<div class="paragraph">
<p>一个过滤器可以将换行符转换为回车和换行符。回车使打印机在每行结束后返回到左侧。创建名为 <code>/usr/local/libexec/lf2crlf</code> 的文件，并将以下内容写入该文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
CR=$&#39;\r&#39;
/usr/bin/sed -e &#34;s/$/${CR}/g&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>设置权限并使其可执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 555 /usr/local/libexec/lf2crlf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <span class="filename">/etc/printcap</span> 修改为使用新的过滤器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:if=/usr/local/libexec/lf2crlf:\</pre>
</div>
</div>
<div class="paragraph">
<p>通过打印相同的纯文本文件来测试过滤器。回车符将导致每行从页面的左侧开始。</p>
</div>
</div>
<div class="sect4">
<h5 id="printing-lpd-filters-enscript">11.5.3.2. 使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/enscript/">print/enscript</a> 在 PostScript® 打印机上打印时，可以得到漂亮的纯文本输出。<a class="anchor" href="#printing-lpd-filters-enscript"></a></h5>
<div class="paragraph">
<p>GNUEnscript 将纯文本文件转换为适合在 PostScript 打印机上打印的格式良好的 PostScript 文件。它添加页码，换行长行，并提供许多其他功能，使打印的文本文件更易于阅读。根据本地纸张尺寸，从 Ports Collection 安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/enscript-letter/">print/enscript-letter</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/enscript-a4/">print/enscript-a4</a> 。</p>
</div>
<div class="paragraph">
<p>创建 <span class="filename">/usr/local/libexec/enscript</span> 文件，并使用以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
/usr/local/bin/enscript -o -</pre>
</div>
</div>
<div class="paragraph">
<p>设置权限并使其可执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 555 /usr/local/libexec/enscript</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <span class="filename">/etc/printcap</span> 修改为使用新的过滤器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:if=/usr/local/libexec/enscript:\</pre>
</div>
</div>
<div class="paragraph">
<p>通过打印一个纯文本文件来测试过滤器。</p>
</div>
</div>
<div class="sect4">
<h5 id="printing-lpd-filters-ps2pcl">11.5.3.3. 将 PostScript® 打印到 <code>PCL</code> 打印机<a class="anchor" href="#printing-lpd-filters-ps2pcl"></a></h5>
<div class="paragraph">
<p>许多程序生成 PostScript® 文档。然而，廉价打印机通常只能理解纯文本或 <code>PCL</code> 格式。该过滤器将 PostScript® 文件转换为 <code>PCL</code> 格式，然后发送给打印机。</p>
</div>
<div class="paragraph">
<p>从 Ports Collection 安装 Ghostscript PostScript® 解释器，包名为： print/ghostscript9-base[] 。</p>
</div>
<div class="paragraph">
<p>创建 <span class="filename">/usr/local/libexec/ps2pcl</span> 文件，并使用以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
/usr/local/bin/gs -dSAFER -dNOPAUSE -dBATCH -q -sDEVICE=ljet4 -sOutputFile=- -</pre>
</div>
</div>
<div class="paragraph">
<p>设置权限并使其可执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 555 /usr/local/libexec/ps2pcl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将发送给此脚本的 PostScript® 输入将在发送到打印机之前被渲染并转换为 <code>PCL</code> 格式。</p>
</div>
<div class="paragraph">
<p>将 <span class="filename">/etc/printcap</span> 修改为使用这个新的输入过滤器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:if=/usr/local/libexec/ps2pcl:\</pre>
</div>
</div>
<div class="paragraph">
<p>通过向过滤器发送一个小的 PostScript® 程序来测试过滤器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">printf</span> <span class="s2">&#34;%%</span><span class="se">\!</span><span class="s2">PS </span><span class="se">\n</span><span class="s2"> /Helvetica findfont 18 scalefont setfont </span><span class="se">\</span><span class="s2">
72 432 moveto (PostScript printing successful.) show showpage </span><span class="se">\0</span><span class="s2">04&#34;</span> | lpr</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="printing-lpd-filters-smart">11.5.3.4. 智能过滤器<a class="anchor" href="#printing-lpd-filters-smart"></a></h5>
<div class="paragraph">
<p>一个能够检测输入类型并自动将其转换为打印机正确格式的过滤器非常方便。 PostScript® 文件的前两个字符通常是 <code>% ! ` 。过滤器可以检测到这两个字符。 PostScript® 文件可以直接发送到 PostScript® 打印机进行打印。文本文件可以使用之前展示的 Enscript 工具转换为 PostScript® 格式。请创建一个名为 `/usr/local/libexec/psif</code> 的文件，并将以下内容添加到其中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
#
#  psif - Print PostScript or plain text on a PostScript printer
#
IFS=&#34;&#34; read -r first_line
first_two_chars=`expr &#34;$first_line&#34; : &#39;\(..\)&#39;`

case &#34;$first_two_chars&#34; in
%!)
    # %! : PostScript job, print it.
    echo &#34;$first_line&#34; &amp;&amp; cat &amp;&amp; exit 0
    exit 2
    ;;
*)
    # otherwise, format with enscript
    ( echo &#34;$first_line&#34;; cat ) | /usr/local/bin/enscript -o - &amp;&amp; exit 0
    exit 2
    ;;
esac</pre>
</div>
</div>
<div class="paragraph">
<p>设置权限并使其可执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 555 /usr/local/libexec/psif</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <span class="filename">/etc/printcap</span> 修改为使用这个新的输入过滤器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:if=/usr/local/libexec/psif:\</pre>
</div>
</div>
<div class="paragraph">
<p>通过打印 PostScript® 和纯文本文件来测试过滤器。</p>
</div>
</div>
<div class="sect4">
<h5 id="printing-lpd-filters-othersmart">11.5.3.5. 其他智能过滤器<a class="anchor" href="#printing-lpd-filters-othersmart"></a></h5>
<div class="paragraph">
<p>编写一个能够检测多种不同类型输入并正确格式化的过滤器是具有挑战性的。 Ports Collection 中的 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/apsfilter/">print/apsfilter</a> 是一个智能的“魔法”过滤器，它可以检测数十种文件类型，并自动将它们转换为打印机理解的 <code>PDL</code> 格式。更多详情请参考 <a href="http://www.apsfilter.org" class="bare">http://www.apsfilter.org</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="printing-lpd-queues">11.5.4. 多个队列<a class="anchor" href="#printing-lpd-queues"></a></h4>
<div class="paragraph">
<p><span class="filename">/etc/printcap</span> 中的条目实际上是对_队列_的定义。一个打印机可以有多个队列。与过滤器结合使用时，多个队列可以使用户更好地控制他们的作业如何打印。</p>
</div>
<div class="paragraph">
<p>以一个办公室中的网络化 PostScript® 激光打印机为例。大多数用户希望打印纯文本，但是少数高级用户希望能够直接打印 PostScript® 文件。可以在 [/etc/printcap] 中为同一台打印机创建两个条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>textprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/textprinter:\
	:if=/usr/local/libexec/enscript:\
	:lf=/var/log/lpd-errs:

psprinter:\
	:lp=9100@officelaser:\
	:sh:\
	:mx#0:\
	:sd=/var/spool/lpd/psprinter:\
	:lf=/var/log/lpd-errs:</pre>
</div>
</div>
<div class="paragraph">
<p>发送给 <code>textprinter</code> 的文档将由之前示例中显示的 <span class="filename">/usr/local/libexec/enscript</span> 过滤器进行格式化。高级用户可以在 <code>psprinter</code> 上打印 PostScript® 文件，不进行任何过滤。</p>
</div>
<div class="paragraph">
<p>这种多队列技术可以用来提供对各种打印机功能的直接访问。具有双面打印功能的打印机可以使用两个队列，一个用于普通的单面打印，另一个使用过滤器发送命令序列以启用双面打印，然后发送传入的文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="printing-lpd-monitor">11.5.5. 监控和控制打印<a class="anchor" href="#printing-lpd-monitor"></a></h4>
<div class="paragraph">
<p>有几种实用工具可用于监控打印作业、检查和控制打印机操作。</p>
</div>
<div class="sect4">
<h5 id="printing-lpd-monitor-lpq">11.5.5.1. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> 是一个命令，用于查看打印队列的状态。<a class="anchor" href="#printing-lpd-monitor-lpq"></a></h5>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> 显示用户打印作业的状态。不显示其他用户的打印作业。</p>
</div>
<div class="paragraph">
<p>显示当前用户在单个打印机上的待处理作业。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpq -Plp
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     0    <span class="o">(</span>standard input<span class="o">)</span>                      12792 bytes</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示当前用户在所有打印机上的待处理作业。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpq -a
lp:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     1    <span class="o">(</span>standard input<span class="o">)</span>                      27320 bytes

laser:
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     287  <span class="o">(</span>standard input<span class="o">)</span>                      22443 bytes</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="printing-lpd-monitor-lprm">11.5.5.2. <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a><a class="anchor" href="#printing-lpd-monitor-lprm"></a></h5>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> 用于删除打印作业。普通用户只能删除自己的作业。 <code>root</code> 可以删除任何或所有作业。</p>
</div>
<div class="paragraph">
<p>从打印机中删除所有待处理作业。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># lprm -Plp -</span>
dfA002smithy dequeued
cfA002smithy dequeued
dfA003smithy dequeued
cfA003smithy dequeued
dfA004smithy dequeued
cfA004smithy dequeued</code></pre>
</div>
</div>
<div class="paragraph">
<p>从打印机中删除一个作业。使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> 命令查找作业编号。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpq
Rank   Owner      Job  Files                                 Total Size
1st    jsmith     5    <span class="o">(</span>standard input<span class="o">)</span>                      12188 bytes

<span class="gp">% </span>lprm -Plp 5
dfA005smithy dequeued
cfA005smithy dequeued</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="printing-lpd-monitor-lpc">11.5.5.3. <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a><a class="anchor" href="#printing-lpd-monitor-lpc"></a></h5>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> 用于检查和修改打印机的状态。 <code>lpc</code> 后面跟着一个命令和一个可选的打印机名称。可以使用 <code>all</code> 代替特定的打印机名称，命令将应用于所有打印机。普通用户可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> 查看状态。只有 <code>root</code> 用户可以使用修改打印机状态的命令。</p>
</div>
<div class="paragraph">
<p>显示所有打印机的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpc status all
lp:
	queuing is enabled
	printing is enabled
	1 entry <span class="k">in </span>spool area
	printer idle
laser:
	queuing is enabled
	printing is enabled
	1 entry <span class="k">in </span>spool area
	waiting <span class="k">for </span>laser to come up</code></pre>
</div>
</div>
<div class="paragraph">
<p>阻止打印机接受新的任务，然后再次开始接受新的任务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># lpc disable lp</span>
lp:
	queuing disabled
<span class="c"># lpc enable lp</span>
lp:
	queuing enabled</code></pre>
</div>
</div>
<div class="paragraph">
<p>停止打印，但继续接受新的任务。然后再次开始打印：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># lpc stop lp</span>
lp:
	printing disabled
<span class="c"># lpc start lp</span>
lp:
	printing enabled
	daemon started</code></pre>
</div>
</div>
<div class="paragraph">
<p>在发生错误情况后重新启动打印机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># lpc restart lp</span>
lp:
	no daemon to abort
	printing enabled
	daemon restarted</code></pre>
</div>
</div>
<div class="paragraph">
<p>关闭打印队列并禁用打印功能，并附带一条消息向用户解释问题原因：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># lpc down lp Repair parts will arrive on Monday</span>
lp:
	printer and queuing disabled
	status message is now: Repair parts will arrive on Monday</code></pre>
</div>
</div>
<div class="paragraph">
<p>重新启用处于离线状态的打印机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># lpc up lp</span>
lp:
	printing enabled
	daemon started</code></pre>
</div>
</div>
<div class="paragraph">
<p>更多的命令和选项请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="printing-lpd-shared">11.5.6. 共享打印机<a class="anchor" href="#printing-lpd-shared"></a></h4>
<div class="paragraph">
<p>打印机在企业和学校中通常由多个用户共享。为了更方便地共享打印机，还提供了额外的功能。</p>
</div>
<div class="sect4">
<h5 id="printing-shared-aliases">11.5.6.1. 别名<a class="anchor" href="#printing-shared-aliases"></a></h5>
<div class="paragraph">
<p>打印机名称设置在 [/etc/printcap] 文件的第一行中。在该名称之后可以添加其他名称，也称为“别名”。别名之间和与名称之间用竖线分隔：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>lp|repairsprinter|salesprinter:\</pre>
</div>
</div>
<div class="paragraph">
<p>别名可以用来替代打印机名称。例如，销售部门的用户可以使用别名来打印到他们的打印机。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpr -Psalesprinter sales-report.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>维修部门的用户使用他们自己的打印机进行打印。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>lpr -Prepairsprinter repairs-report.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>所有的文件都打印在同一台打印机上。当销售部门发展到需要自己的打印机时，可以从共享打印机条目中删除别名，并将其用作新打印机的名称。两个部门的用户继续使用相同的命令，但销售文件将被发送到新的打印机。</p>
</div>
</div>
<div class="sect4">
<h5 id="printing-shared-headers">11.5.6.2. 页眉页<a class="anchor" href="#printing-shared-headers"></a></h5>
<div class="paragraph">
<p>对于用户来说，在繁忙的共享打印机产生的一堆页面中定位他们的文档可能很困难。为了解决这个问题，创建了“页眉页”。在每个打印作业之前，会打印一个包含用户姓名和文档名称的页眉页。这些页面有时也被称为“横幅”或“分隔符”页面。</p>
</div>
<div class="paragraph">
<p>启用页眉页面的方法取决于打印机是通过 USB 、并行或串行电缆直接连接到计算机，还是通过网络远程连接。</p>
</div>
<div class="paragraph">
<p>直接连接的打印机上的页眉页面可以通过从 <span class="filename">/etc/printcap</span> 文件中的条目中删除 <code>:sh: \ ` （ Suppress Header ）行来启用。这些页眉页面只使用换行字符作为换行符。一些打印机需要 <span class="filename">/usr/share/examples/printing/hpif</span> 过滤器来防止文本出现阶梯状。该过滤器配置 `PCL</code> 打印机在接收到换行符时同时打印回车和换行符。</p>
</div>
<div class="paragraph">
<p>网络打印机的页眉页面必须在打印机本身上进行配置。 <span class="filename">/etc/printcap</span> 中的页眉页面条目将被忽略。通常可以通过打印机前面板或使用 Web 浏览器访问的配置网页来进行设置。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="printing-lpd-references">11.5.7. 参考文献<a class="anchor" href="#printing-lpd-references"></a></h4>
<div class="paragraph">
<p>示例文件： [/usr/share/examples/printing/](/usr/share/examples/printing/) 。</p>
</div>
<div class="paragraph">
<p>《 4.3BSD 行打印机排队程序手册》， <span class="filename">/usr/share/doc/smm/07.lpd/paper.ascii.gz</span> 。</p>
</div>
<div class="paragraph">
<p>手册页面： <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=lprm&amp;sektion=1&amp;format=html">lprm(1)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=lpq&amp;sektion=1&amp;format=html">lpq(1)</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="printing-other">11.6. 其他打印系统<a class="anchor" href="#printing-other"></a></h3>
<div class="paragraph">
<p>除了内置的 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> 之外，还有几个其他的打印系统可供选择。这些系统提供对其他协议或附加功能的支持。</p>
</div>
<div class="sect3">
<h4 id="printing-other-cups">11.6.1. CUPS （ Common UNIX® Printing System ）<a class="anchor" href="#printing-other-cups"></a></h4>
<div class="paragraph">
<p>CUPS 是一个在许多操作系统上可用的流行打印系统。在 FreeBSD 上使用 CUPS 的方法在一个单独的文章中有详细说明： <a href="{cups}">CUPS</a></p>
</div>
</div>
<div class="sect3">
<h4 id="printing-other-hplip">11.6.2. HPLIP 是一种用于 Linux 操作系统的开源打印机和扫描仪驱动程序。它提供了与 HP 打印机和扫描仪的通信接口，使用户能够轻松地配置和使用这些设备。 HPLIP 支持各种 HP 打印机和扫描仪的功能，包括打印、扫描、复印和传真等。它还提供了一些额外的功能，如墨水和墨盒状态监测、打印机设置和网络打印等。 HPLIP 是一个非常有用的工具，可以帮助用户更好地管理和使用他们的 HP 打印机和扫描仪。<a class="anchor" href="#printing-other-hplip"></a></h4>
<div class="paragraph">
<p>惠普公司提供了一个支持他们的喷墨和激光打印机的打印系统。该端口是 <a class="package" href="https://cgit.freebsd.org/ports/tree/print/hplip/">print/hplip</a> 。主要网页位于 <a href="https://developers.hp.com/hp-linux-imaging-and-printing" class="bare">https://developers.hp.com/hp-linux-imaging-and-printing</a> 。该端口在 FreeBSD 上处理所有安装细节。配置信息显示在 <a href="https://developers.hp.com/hp-linux-imaging-and-printing/install" class="bare">https://developers.hp.com/hp-linux-imaging-and-printing/install</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="printing-other-lprng">11.6.3. LPRng 是一个用于打印管理的软件系统，它是 LPD （ Line Printer Daemon ）的一个增强版本。 LPRng 提供了更多的功能和灵活性，可以在 UNIX 和类 UNIX 系统上运行。它支持多种打印机和打印队列，并提供了高级的打印作业控制和管理功能。 LPRng 还支持通过网络打印，并提供了安全性和权限控制机制。它是一个强大而可靠的打印管理解决方案。<a class="anchor" href="#printing-other-lprng"></a></h4>
<div class="paragraph">
<p>LPRng 是作为 <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> 的增强替代品开发的。该端口是 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/LPRng/">sysutils/LPRng</a> 。有关详细信息和文档，请参阅 <a href="http://www.lprng.com/" class="bare">http://www.lprng.com/</a> 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="linuxemu">Chapter 12. Linux 二进制兼容性<a class="anchor" href="#linuxemu"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="linuxemu-synopsis">12.1. 简介<a class="anchor" href="#linuxemu-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 提供与 Linux® 的二进制兼容性，通常称为 Linuxulator，允许用户安装和运行未经修改的 Linux 二进制文件。它适用于 x86（32 位和 64 位）和 AArch64 架构。目前还不支持一些特定于 Linux 的操作系统功能，主要是与硬件相关或与系统管理相关的功能，例如 cgroups 或命名空间。</p>
</div>
<div class="paragraph">
<p>在阅读本章之前，你应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解如何安装 <a href="./#ports">其他第三方软件</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何在 FreeBSD 系统上启用 Linux 二进制兼容性。</p>
</li>
<li>
<p>如何安装额外的 Linux 共享库。</p>
</li>
<li>
<p>如何在 FreeBSD 系统上安装 Linux 应用程序。</p>
</li>
<li>
<p>FreeBSD 中 Linux 兼容性的实现细节。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="linuxemu-lbc-install">12.2. 配置 Linux 二进制兼容性<a class="anchor" href="#linuxemu-lbc-install"></a></h3>
<div class="paragraph">
<p>默认情况下，不启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=linux&amp;sektion=4&amp;format=html">linux(4)</a> 二进制兼容性。</p>
</div>
<div class="paragraph">
<p>要在启动时启用 Linux ABI，请执行以下命令：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># sysrc linux_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>一旦启用，可以通过执行以下命令来启动，无需重新启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service linux start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这对于静态链接的 Linux 二进制文件来说已经足够了。</p>
</div>
<div class="paragraph">
<p>Linux 服务将加载 Linux 应用程序所需的内核模块并挂载文件系统，这些文件系统位于 <span class="filename">/compat/linux</span> 目录下。它们可以像本机 FreeBSD 二进制文件一样启动；它们的行为几乎与本机进程完全相同，并且可以按照通常的方式进行跟踪和调试。</p>
</div>
<div class="paragraph">
<p>可以通过执行以下命令来检查 <span class="filename">/compat/linux</span> 的当前内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls -l /compat/linux/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>total 1
dr-xr-xr-x  13 root  wheel  512 Apr 11 19:12 dev
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:03 proc
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:03 sys</pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="linux-userlands">12.3. Linux 用户空间<a class="anchor" href="#linux-userlands"></a></h3>
<div class="paragraph">
<p>Linux 软件需要的不仅仅是一个 ABI 才能运行。为了运行 Linux 软件，首先必须安装 Linux 用户空间。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果只是想运行已包含在 Ports 树中的一些软件，可以通过软件包管理器进行安装，并且 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 将自动设置所需的 Linux 用户空间。</p>
</div>
<div class="paragraph">
<p>例如，要安装 Sublime Text 4 以及它所依赖的所有 Linux 库，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install linux-sublime-text4</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="linuxemu-packages">12.3.1. 从 FreeBSD 软件包中获取的 CentOS 基本系统<a class="anchor" href="#linuxemu-packages"></a></h4>
<div class="paragraph">
<p>要安装 CentOS 用户空间，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install linux_base-c7</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/emulators/linux_base-c7/">emulators/linux_base-c7</a> 将基于 CentOS 7 的基本系统放置在 <span class="filename">/compat/linux</span> 中。</p>
</div>
<div class="paragraph">
<p>安装完软件包后，可以通过运行以下命令来验证 <span class="filename">/compat/linux</span> 的内容，以检查是否已安装 CentOS 用户空间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls -l /compat/linux/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>total 30
lrwxr-xr-x   1 root  wheel    7 Apr 11  2018 bin -&gt; usr/bin
drwxr-xr-x  13 root  wheel  512 Apr 11 21:10 dev
drwxr-xr-x  25 root  wheel   64 Apr 11 21:10 etc
lrwxr-xr-x   1 root  wheel    7 Apr 11  2018 lib -&gt; usr/lib
lrwxr-xr-x   1 root  wheel    9 Apr 11  2018 lib64 -&gt; usr/lib64
drwxr-xr-x   2 root  wheel    2 Apr 11 21:10 opt
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:25 proc
lrwxr-xr-x   1 root  wheel    8 Feb 18 02:10 run -&gt; /var/run
lrwxr-xr-x   1 root  wheel    8 Apr 11  2018 sbin -&gt; usr/sbin
drwxr-xr-x   2 root  wheel    2 Apr 11 21:10 srv
dr-xr-xr-x   1 root  wheel    0 Apr 11 21:25 sys
drwxr-xr-x   8 root  wheel    9 Apr 11 21:10 usr
drwxr-xr-x  16 root  wheel   17 Apr 11 21:10 var</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="linuxemu-debootstrap">12.3.2. 使用 debootstrap 创建 Debian/Ubuntu 基础系统<a class="anchor" href="#linuxemu-debootstrap"></a></h4>
<div class="paragraph">
<p>提供 Linux 共享库的另一种方式是使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/debootstrap/">sysutils/debootstrap</a>。这样做的优点是可以提供完整的 Debian 或 Ubuntu 发行版。</p>
</div>
<div class="paragraph">
<p>要安装 debootstrap，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install debootstrap</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=debootstrap&amp;sektion=8&amp;format=html">debootstrap(8)</a> 需要启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=linux&amp;sektion=4&amp;format=html">linux(4)</a> ABI。启用后，执行以下命令在 <span class="filename">/compat/ubuntu</span> 中安装 Ubuntu 或 Debian ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># debootstrap focal /compat/ubuntu</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然从技术上讲可以安装到 <span class="filename">/compat/linux</span> 目录中，但由于可能与基于 CentOS 的软件包发生冲突，不建议这样做。相反，应根据发行版或版本名称派生目录名称，例如 <span class="filename">/compat/ubuntu</span>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>I: Retrieving InRelease
I: Checking Release signature
I: Valid Release signature (key id F6ECB3762474EDA9D21B7022871920D1991BC93C)
I: Retrieving Packages
I: Validating Packages
I: Resolving dependencies of required packages...
I: Resolving dependencies of base packages...
I: Checking component main on http://archive.ubuntu.com/ubuntu...
[...]
I: Configuring console-setup...
I: Configuring kbd...
I: Configuring ubuntu-minimal...
I: Configuring libc-bin...
I: Configuring ca-certificates...
I: Base system installed successfully.</pre>
</div>
</div>
<div class="paragraph">
<p>然后在 <span class="filename">/etc/fstab</span> 中设置挂载点。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要共享主目录的内容并且能够运行 X11 应用程序，应该使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=nullfs&amp;sektion=5&amp;format=html">nullfs(5)</a> 将 <span class="filename">/home</span> 和 <span class="filename">/tmp</span> 挂载到 Linux 兼容区域中，以实现回环。</p>
</div>
<div class="paragraph">
<p>以下示例可以添加到 <span class="filename">/etc/fstab</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device        Mountpoint              FStype          Options                      Dump    Pass#
devfs           /compat/ubuntu/dev      devfs           rw,late                      0       0
tmpfs           /compat/ubuntu/dev/shm  tmpfs           rw,late,size=1g,mode=1777    0       0
fdescfs         /compat/ubuntu/dev/fd   fdescfs         rw,late,linrdlnk             0       0
linprocfs       /compat/ubuntu/proc     linprocfs       rw,late                      0       0
linsysfs        /compat/ubuntu/sys      linsysfs        rw,late                      0       0
/tmp            /compat/ubuntu/tmp      nullfs          rw,late                      0       0
/home           /compat/ubuntu/home     nullfs          rw,late                      0       0</pre>
</div>
</div>
<div class="paragraph">
<p>然后执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount -al</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=8&amp;format=html">chroot(8)</a> 访问系统，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chroot /compat/ubuntu /bin/bash</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> 命令来检查 Linux 环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># uname -s -r -m</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Linux 3.17.0 x86_64</pre>
</div>
</div>
<div class="paragraph">
<p>一旦进入 chroot 环境，系统的行为就像在正常的 Ubuntu 安装中一样。虽然 systemd 不起作用，但 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 命令仍然像往常一样工作。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要添加默认缺失的软件包仓库，请编辑文件 <span class="filename">/compat/ubuntu/etc/apt/sources.list</span> 。</p>
</div>
<div class="paragraph">
<p>对于 amd64 架构，可以使用以下示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>deb http://archive.ubuntu.com/ubuntu focal main universe restricted multiverse
deb http://security.ubuntu.com/ubuntu/ focal-security universe multiverse restricted main
deb http://archive.ubuntu.com/ubuntu focal-backports universe multiverse restricted main
deb http://archive.ubuntu.com/ubuntu focal-updates universe multiverse restricted main</pre>
</div>
</div>
<div class="paragraph">
<p>对于 arm64 架构，可以使用以下示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>deb http://ports.ubuntu.com/ubuntu-ports bionic main universe restricted multiverse</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="linuxemu-advanced">12.4. 高级主题<a class="anchor" href="#linuxemu-advanced"></a></h3>
<div class="paragraph">
<p>所有与 Linux 相关的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 参数列表可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=linux&amp;sektion=4&amp;format=html">linux(4)</a> 中找到。</p>
</div>
<div class="paragraph">
<p>有些应用程序需要挂载特定的文件系统。</p>
</div>
<div class="paragraph">
<p>这通常由 <span class="filename">/etc/rc.d/linux</span> 脚本处理，但可以通过执行以下命令在启动时禁用：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>sysrc linux_mounts_enable=&#34;NO&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>通过 rc 脚本挂载的文件系统在 chroots 或 jails 中的 Linux 进程中将无法工作；如果需要，在 <span class="filename">/etc/fstab</span> 中进行配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>devfs      /compat/linux/dev      devfs      rw,late                    0  0
tmpfs      /compat/linux/dev/shm  tmpfs      rw,late,size=1g,mode=1777  0  0
fdescfs    /compat/linux/dev/fd   fdescfs    rw,late,linrdlnk           0  0
linprocfs  /compat/linux/proc     linprocfs  rw,late                    0  0
linsysfs   /compat/linux/sys      linsysfs   rw,late                    0  0</pre>
</div>
</div>
<div class="paragraph">
<p>由于 Linux 二进制兼容层已经支持运行 32 位和 64 位 Linux 二进制文件，因此不再可能将仿真功能静态链接到自定义内核中。</p>
</div>
<div class="sect3">
<h4 id="linuxemu-libs-manually">12.4.1. 手动安装额外的库<a class="anchor" href="#linuxemu-libs-manually"></a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=debootstrap&amp;sektion=8&amp;format=html">debootstrap(8)</a> 创建的基本系统子目录，请使用上述说明。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果在配置 Linux 二进制兼容性后，一个 Linux 应用程序抱怨缺少共享库，那么需要确定 Linux 二进制文件需要哪些共享库，并手动安装它们。</p>
</div>
<div class="paragraph">
<p>在使用相同的 CPU 架构的 Linux 系统上，可以使用 <code>ldd</code> 命令来确定应用程序需要哪些共享库。</p>
</div>
<div class="paragraph">
<p>例如，要检查 <code>linuxdoom</code> 需要哪些共享库，请从已安装 Doom 的 Linux 系统上运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ldd linuxdoom</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>libXt.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libXt.so.3.1.0
libX11.so.3 (DLL Jump 3.1) =&gt; /usr/X11/lib/libX11.so.3.1.0
libc.so.4 (DLL Jump 4.5pl26) =&gt; /lib/libc.so.4.6.29</pre>
</div>
</div>
<div class="paragraph">
<p>然后，将 Linux 系统输出的最后一列中的所有文件复制到 FreeBSD 系统的 <span class="filename">/compat/linux</span> 目录中。复制完成后，创建指向第一列中的文件名的符号链接。</p>
</div>
<div class="paragraph">
<p>这个例子将在 FreeBSD 系统上生成以下文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/compat/linux/usr/X11/lib/libXt.so.3.1.0
/compat/linux/usr/X11/lib/libXt.so.3 -&gt; libXt.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3.1.0
/compat/linux/usr/X11/lib/libX11.so.3 -&gt; libX11.so.3.1.0
/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</pre>
</div>
</div>
<div class="paragraph">
<p>如果在 <code>ldd</code> 输出的第一列中存在一个与 Linux 共享库的主要修订号匹配的库，则无需将其复制到最后一列中指定的文件中，因为现有库应该可以正常工作。但是，如果共享库是较新版本，则建议复制它。只要符号链接指向新的库，就可以删除旧的库。</p>
</div>
<div class="paragraph">
<p>例如，这些库已经存在于 FreeBSD 系统上：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/compat/linux/lib/libc.so.4.6.27
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.27</pre>
</div>
</div>
<div class="paragraph">
<p>而 <code>ldd</code> 指示一个二进制文件需要一个较新的版本：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>libc.so.4 (DLL Jump 4.5pl26) -&gt; libc.so.4.6.29</pre>
</div>
</div>
<div class="paragraph">
<p>由于现有的库只是在最后一位数字上过时了一到两个版本，所以程序应该仍然可以与稍旧的版本一起工作。然而，将现有的 <span class="filename">libc.so</span> 替换为更新的版本是安全的。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/compat/linux/lib/libc.so.4.6.29
/compat/linux/lib/libc.so.4 -&gt; libc.so.4.6.29</pre>
</div>
</div>
<div class="paragraph">
<p>通常情况下，在 FreeBSD 上首次安装 Linux 程序时，需要查找 Linux 二进制文件所依赖的共享库。然而，随着时间的推移，系统上会积累足够的 Linux 共享库，可以在安装新的 Linux 二进制文件时无需额外操作即可运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="_标记_linux_elf_可执行文件">12.4.2. 标记 Linux ELF 可执行文件<a class="anchor" href="#_标记_linux_elf_可执行文件"></a></h4>
<div class="paragraph">
<p>FreeBSD 内核使用多种方法来确定要执行的二进制文件是否为 Linux 文件：它检查 ELF 文件头中的标记，查找已知的 ELF 解释器路径并检查 ELF 注释；最后，默认情况下，未标记的 ELF 可执行文件被认为是 Linux 文件。</p>
</div>
<div class="paragraph">
<p>如果所有这些方法都失败了，尝试执行二进制文件可能会导致错误消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>./my-linux-elf-binary</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ELF binary type not known
Abort</pre>
</div>
</div>
<div class="paragraph">
<p>为了帮助 FreeBSD 内核区分 FreeBSD ELF 二进制文件和 Linux 二进制文件，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=brandelf&amp;sektion=1&amp;format=html">brandelf(1)</a> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>brandelf -t Linux my-linux-elf-binary</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_安装基于_linux_rpm_的应用程序">12.4.3. 安装基于 Linux RPM 的应用程序<a class="anchor" href="#_安装基于_linux_rpm_的应用程序"></a></h4>
<div class="paragraph">
<p>要安装一个基于 Linux RPM 的应用程序，首先安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/archivers/rpm4/">archivers/rpm4</a> 包或port。安装完成后，<code>root</code> 用户可以使用以下命令来安装 <span class="filename">.rpm</span> 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /compat/linux</span>
<span class="c"># rpm2cpio &lt; /path/to/linux.archive.rpm | cpio -id</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要的话，对已安装的 ELF 二进制文件进行 <code>brandelf</code> 处理。请注意，这将阻止干净卸载。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置主机名解析器">12.4.4. 配置主机名解析器<a class="anchor" href="#_配置主机名解析器"></a></h4>
<div class="paragraph">
<p>如果 DNS 不工作或出现此错误：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>resolv+: &#34;bind&#34; is an invalid keyword resolv+:
&#34;hosts&#34; is an invalid keyword</pre>
</div>
</div>
<div class="paragraph">
<p>将 <span class="filename">/compat/linux/etc/host.conf</span> 配置如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>order hosts, bind
multi on</pre>
</div>
</div>
<div class="paragraph">
<p>这指定了首先搜索 <span class="filename">/etc/hosts</span> ，其次搜索 DNS。当 <span class="filename">/compat/linux/etc/host.conf</span> 不存在时，Linux 应用程序使用主机系统中的 <span class="filename">/etc/host.conf</span>，但它们会抱怨因为在 FreeBSD 中该文件不存在。如果没有配置名称服务器，请删除 <code>bind</code>，使用 <span class="filename">/etc/resolv.conf</span>。</p>
</div>
</div>
<div class="sect3">
<h4 id="linuxemu-misc">12.4.5. 杂项<a class="anchor" href="#linuxemu-misc"></a></h4>
<div class="paragraph">
<p>有关 Linux® 与二进制兼容性的更多信息，请参阅文章 <a href="{linux-emulation}">FreeBSD 中的 Linux 模拟</a>。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="wine">Chapter 13. WINE 是一个允许在 Linux 和其他类 Unix 操作系统上运行 Windows 应用程序的兼容层。它通过实现 Windows API 的替代实现来实现这一功能。 WINE 的名称是“ Wine Is Not an Emulator ”的缩写，这意味着它不是一个真正的模拟器，而是通过将 Windows API 调用转换为对底层操作系统的调用来实现兼容性。 WINE 对于那些需要在 Linux 环境中运行 Windows 应用程序的用户来说是非常有用的。<a class="anchor" href="#wine"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="wine-synopsis">13.1. 简介<a class="anchor" href="#wine-synopsis"></a></h3>
<div class="paragraph">
<p><a href="https://www.winehq.org/">WINE</a> ，全称为 Wine 不是模拟器，实际上是一种软件翻译层。它可以在 FreeBSD （和其他）系统上安装和运行一些为 Windows® 编写的软件。</p>
</div>
<div class="paragraph">
<p>它通过拦截系统调用或软件对操作系统的请求来运行，并将它们从 Windows® 调用转换为 FreeBSD 可以理解的调用。它还会根据需要将任何响应转换为 Windows® 软件所期望的格式。因此，在某种程度上，它模拟了 Windows® 环境，提供了许多 Windows® 应用程序所期望的资源。</p>
</div>
<div class="paragraph">
<p>然而，它并不是传统意义上的模拟器。许多解决方案通过使用软件进程构建一个完整的另一台计算机来运行。虚拟化（例如由 emulators/qemu 软件包提供的虚拟化）就是以这种方式运行的。这种方法的一个好处是能够在模拟器中安装完整版本的操作系统。这意味着对应用程序来说，环境看起来与真实机器没有任何区别，而且很有可能一切都能正常工作。这种方法的缺点是软件充当硬件的事实本质上比实际硬件慢。在软件中构建的计算机（称为“客户机”）需要来自真实机器（称为“主机”）的资源，并且在运行时会一直占用这些资源。</p>
</div>
<div class="paragraph">
<p>另一方面， WINE 项目对系统资源的消耗要小得多。它会实时翻译系统调用，因此虽然很难像真正的 Windows® 计算机一样快速，但它可以非常接近。另一方面， WINE 试图跟上不断变化的目标，以支持所有不同的系统调用和其他功能。因此，可能会有一些应用程序在 WINE 上无法按预期工作，根本无法工作，或者甚至无法安装。</p>
</div>
<div class="paragraph">
<p>在一天结束时， WINE 提供了另一种选择，可以尝试在 FreeBSD 上运行特定的 Windows® 软件程序。它始终可以作为第一选择，如果成功，可以提供良好的体验，而不会不必要地消耗主机 FreeBSD 系统的资源。</p>
</div>
<div class="paragraph">
<p>本章将描述：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 FreeBSD 系统上安装 WINE 的方法。</p>
</li>
<li>
<p>WINE 是如何运作的，以及它与其他替代方案（如虚拟化）的区别。</p>
</li>
<li>
<p>如何根据特定应用程序的需求来调整 WINE 。</p>
</li>
<li>
<p>如何安装 WINE 的 GUI 助手。</p>
</li>
<li>
<p>FreeBSD 的常见提示和解决方案。</p>
</li>
<li>
<p>在多用户环境下，考虑在 FreeBSD 上使用 WINE 的问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，以下内容可能会有帮助：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 <a href="./#basics">UNIX® 和 FreeBSD 的基础知识</a> 。</p>
</li>
<li>
<p>了解如何交叉引用： bsdinstall[bsdinstall ，安装 FreeBSD] 。</p>
</li>
<li>
<p>了解如何交叉引用： advanced-networking[高级网络设置，建立网络连接] 。</p>
</li>
<li>
<p>了解如何交叉引用： ports[ports ,安装额外的第三方软件] 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="wine-overview-concepts">13.2. WINE 概述与概念<a class="anchor" href="#wine-overview-concepts"></a></h3>
<div class="paragraph">
<p>WINE 是一个复杂的系统，因此在在 FreeBSD 系统上运行之前，了解它是什么以及它是如何工作的是值得的。</p>
</div>
<div class="sect3">
<h4 id="what-is-wine">13.2.1. WINE 是什么？<a class="anchor" href="#what-is-wine"></a></h4>
<div class="paragraph">
<p>正如本章的 <a href="#wine-synopsis ">概述 </a> 中提到的， WINE 是一个兼容层，允许 Windows® 应用程序在其他操作系统上运行。理论上，这意味着这些程序应该可以在类似 FreeBSD 、 macOS 和 Android 的系统上运行。</p>
</div>
<div class="paragraph">
<p>当 WINE 运行 Windows® 可执行文件时，会发生两件事情：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>首先， WINE 实现了一个模拟各个版本 Windows® 环境的环境。例如，如果一个应用程序请求访问诸如 RAM 之类的资源， WINE 有一个内存接口，它在应用程序看来看起来和行为都像 Windows® 。</p>
</li>
<li>
<p>然后，一旦该应用程序使用该接口， WINE 会将内存中的传入请求转换为与主机系统兼容的格式。同样，当应用程序检索数据时， WINE 会从主机系统中获取数据并将其传递回 Windows® 应用程序。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="wine-and-the-os-system">13.2.2. WINE 和 FreeBSD 系统<a class="anchor" href="#wine-and-the-os-system"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 系统上安装 WINE 将涉及几个不同的组件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FreeBSD 提供了一些应用程序，用于运行 Windows® 可执行文件、配置 WINE 子系统或使用 WINE 支持编译程序的任务。</p>
</li>
<li>
<p>大量的库实现了 Windows® 的核心功能（例如 <span class="filename">/lib/wine/api-ms-core-memory-l1-1-1.dll.so</span> ，它是前述内存接口的一部分）。</p>
</li>
<li>
<p>一些 Windows® 可执行文件，它们是常见的实用工具（例如 <span class="filename">/lib/wine/notepad.exe.so</span> ，提供标准的 Windows® 文本编辑器）。</p>
</li>
<li>
<p>额外的 Windows® 资源，特别是字体（例如 Tahoma 字体，存储在安装根目录下的 .share/wine/fonts/tahoma.ttf 中）。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="graphical-versus-text-modeterminal-programs-in-wine">13.2.3. WINE 中的图形模式与文本模式 / 终端程序<a class="anchor" href="#graphical-versus-text-modeterminal-programs-in-wine"></a></h4>
<div class="paragraph">
<p>作为一个将终端工具视为“一等公民”的操作系统，可以自然地假设 WINE 将包含对文本模式程序的广泛支持。然而，大多数 Windows® 应用程序，尤其是最受欢迎的应用程序，都是以图形用户界面（ GUI ）为设计目标的。因此，默认情况下， WINE 的工具被设计为启动图形程序。</p>
</div>
<div class="paragraph">
<p>然而，有三种方法可以运行这些所谓的控制台用户界面（ CUI ）程序：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>Bare Streams</em> 方法将直接将输出显示到标准输出。</p>
</li>
<li>
<p><em>wineconsole</em> 实用程序可以与 <em>user</em> 或 <em>curses</em> 后端一起使用，以利用 WINE 系统为 CUI 应用程序提供的一些增强功能。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些方法在 [WINE Wiki](<a href="https://wiki.winehq.org/Wine_User%27s_Guide#Text_mode_programs_.28CUI:_Console_User_Interface.29" class="bare">https://wiki.winehq.org/Wine_User%27s_Guide#Text_mode_programs_.28CUI:_Console_User_Interface.29</a>) 上有更详细的描述。</p>
</div>
</div>
<div class="sect3">
<h4 id="wine-derivative-projects">13.2.4. WINE 衍生项目<a class="anchor" href="#wine-derivative-projects"></a></h4>
<div class="paragraph">
<p>WINE 本身是一个成熟的开源项目，因此它被用作更复杂解决方案的基础并不令人意外。</p>
</div>
<div class="sect4">
<h5 id="commercial-wine-implementations">13.2.4.1. 商业 WINE 实现<a class="anchor" href="#commercial-wine-implementations"></a></h5>
<div class="paragraph">
<p>许多公司已经将 WINE 作为自己专有产品的核心（ WINE 的 LGPL 许可证允许这样做）。其中最著名的两个如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Codeweavers CrossOver 是一款强大的软件，它允许用户在 Mac 和 Linux 操作系统上运行 Windows 应用程序。通过使用 CrossOver ，用户可以轻松地在非 Windows 平台上访问和使用他们喜爱的 Windows 软件。这个软件使用了一种独特的技术，使得 Windows 应用程序能够在其他操作系统上无缝运行，而无需安装 Windows 操作系统本身。 Codeweavers CrossOver 是一个非常有用的工具，为用户提供了更多的灵活性和选择，使他们能够在不同的操作系统之间无缝切换和使用他们需要的应用程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个解决方案提供了一个简化的“一键式”安装 WINE 的方法，其中包含了额外的增强和优化（尽管该公司将其中许多贡献回馈给 WINE 项目）。 Codeweavers 的一个重点领域是使最受欢迎的应用程序能够顺利安装和运行。</p>
</div>
<div class="paragraph">
<p>虽然该公司曾经推出过适用于 FreeBSD 的 CrossOver 解决方案，但似乎已经被废弃很久了。虽然一些资源（如专门的论坛 <a href="https://www.codeweavers.com/compatibility/crossover/forum/freebsd" class="bare">https://www.codeweavers.com/compatibility/crossover/forum/freebsd</a> ）仍然存在，但它们也已经有一段时间没有活动了。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Steam Proton 是一个由 Valve 开发的兼容性工具，旨在使 Windows 上的游戏能够在 Linux 操作系统上运行。 Proton 基于 Wine 和其他开源技术，通过提供对 Windows API 的实现来实现这一目标。 Steam Proton 使得玩家可以在 Linux 上畅玩许多原本只能在 Windows 上运行的游戏，为 Linux 游戏生态系统的发展做出了重要贡献。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>游戏公司 Steam 也使用 WINE 来使 Windows® 游戏能够在其他系统上安装和运行。它的主要目标是基于 Linux 的系统，尽管也有一些对 macOS 的支持。</p>
</div>
<div class="paragraph">
<p>虽然 Steam 没有提供原生的 FreeBSD 客户端，但可以使用 FreeBSD 的 Linux 兼容层来使用 Linux® 客户端的几种选项。</p>
</div>
</div>
<div class="sect4">
<h5 id="wine-companion-programs">13.2.4.2. WINE 伴侣程序<a class="anchor" href="#wine-companion-programs"></a></h5>
<div class="paragraph">
<p>除了专有的产品，其他项目还发布了与标准的开源版本 WINE 配合使用的应用程序。这些应用程序的目标可以从简化安装到提供简便的方式来安装流行软件。</p>
</div>
<div class="paragraph">
<p>这些解决方案在后面关于 <a href="#wine-management-guis ">GUI 前端 </a> 的章节中有更详细的介绍，包括以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>winetricks 是一个用于在 Wine 环境中安装和配置 Windows 应用程序所需组件的实用工具。它提供了一系列预定义的安装选项，可以帮助用户轻松地安装常见的 Windows 库和运行时环境。通过使用 winetricks ，用户可以更方便地在 Linux 系统上运行 Windows 应用程序。</p>
</li>
<li>
<p>苏伊马祖</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="alternatives-to-wine">13.2.5. WINE 的替代方案<a class="anchor" href="#alternatives-to-wine"></a></h4>
<div class="paragraph">
<p>对于 FreeBSD 用户来说，使用 WINE 的替代方案如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>双启动：一种简单的选择是在操作系统上直接运行所需的 Windows® 应用程序。当然，这意味着需要退出 FreeBSD 以启动 Windows® ，因此如果需要同时访问两个系统中的程序，则此方法不可行。</p>
</li>
<li>
<p>虚拟机：虚拟机（ VM ）是在本章前面提到的软件进程，它们模拟完整的硬件集合，可以在其上安装和运行其他操作系统（包括 Windows® ）。现代工具使得创建和管理虚拟机变得容易，但这种方法是有代价的。主机系统的大部分资源必须分配给每个虚拟机，并且只要虚拟机在运行，这些资源就无法被主机回收。一些虚拟机管理器的例子包括开源解决方案 qemu 、 bhyve 和 VirtualBox 。有关更多详细信息，请参阅《虚拟化》章节。</p>
</li>
<li>
<p>远程访问：与许多其他类 UNIX® 系统一样， FreeBSD 可以运行各种应用程序，使用户能够远程访问 Windows® 计算机并使用其程序或数据。除了像 xrdp 这样连接到标准 Windows® 远程桌面协议的客户端之外，还可以使用其他开源标准，如 vnc （前提是在另一端存在兼容的服务器）。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="installing-wine-on-freebsd">13.3. 在 FreeBSD 上安装 WINE<a class="anchor" href="#installing-wine-on-freebsd"></a></h3>
<div class="paragraph">
<p>可以通过 pkg 工具或编译端口来安装 WINE 。</p>
</div>
<div class="sect3">
<h4 id="wine-prerequistes">13.3.1. WINE 的先决条件<a class="anchor" href="#wine-prerequistes"></a></h4>
<div class="paragraph">
<p>在安装 WINE 本身之前，安装以下先决条件会很有用。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>图形用户界面（ GUI ）</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>大多数 Windows® 程序都期望有一个可用的图形用户界面。如果安装 WINE 时没有安装图形用户界面，它的依赖项将包括 Wayland 合成器，因此将会安装一个图形用户界面。但在安装 WINE 之前，安装、配置和正确运行所选择的图形用户界面是很有用的。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Wine Gecko</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Windows® 操作系统在很长一段时间内都预装了一个默认的网页浏览器： Internet Explorer 。因此，一些应用程序在工作时假设总会有能够显示网页的东西。为了提供这个功能， WINE 层包含了一个使用 Mozilla 项目的 Gecko 引擎的网页浏览器组件。当首次启动 WINE 时，它会提供下载和安装这个组件的选项，用户可能有理由这样做（这将在后面的章节中介绍）。但他们也可以在安装 WINE 之前或与 WINE 的安装同时安装这个组件。</p>
</div>
<div class="paragraph">
<p>使用以下命令安装此软件包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install wine-gecko</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，使用以下方式编译端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/emulator/wine-gecko</span>
<span class="c"># make install</span></code></pre>
</div>
</div>
<div class="ulist">
<ul>
<li>
<p>Wine Mono 是一个用于在 Wine 环境中运行 .NET 应用程序的开源实现。它是一个替代 Microsoft .NET Framework 的组件，可以在 Linux 和其他类 Unix 系统上运行。 Wine Mono 提供了对 .NET 应用程序的兼容性，并且可以与 Wine 一起使用，使用户能够在非 Windows 操作系统上运行 .NET 应用程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>此端口安装了 MONO 框架，它是微软 .NET 的开源实现。将其与 WINE 安装一起使用，可以增加任何使用 .NET 编写的应用程序在系统上安装和运行的可能性。</p>
</div>
<div class="paragraph">
<p>安装包的步骤如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install wine-mono</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从端口集合编译：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/emulator/wine-mono</span>
<span class="c"># make install</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="installing-wine">13.3.2. 通过 FreeBSD 软件包仓库安装 WINE<a class="anchor" href="#installing-wine"></a></h4>
<div class="paragraph">
<p>在满足先决条件的情况下，使用以下命令通过软件包安装 WINE ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install wine</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用以下方法从源代码编译 WINE 子系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/emulator/wine</span>
<span class="c"># make install</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="thirtytwo-vs-sixtyfour-bit-wine">13.3.3. WINE 安装中的 32 位与 64 位的问题<a class="anchor" href="#thirtytwo-vs-sixtyfour-bit-wine"></a></h4>
<div class="paragraph">
<p>与大多数软件一样， Windows® 应用程序已经从旧的 32 位架构升级到 64 位。大多数最新的软件都是为 64 位操作系统编写的，尽管现代操作系统有时也可以继续运行旧的 32 位程序。 FreeBSD 也不例外，在 5.x 系列中就已经支持 64 位。</p>
</div>
<div class="paragraph">
<p>然而，使用默认不再支持的旧软件是模拟器的常见用途，用户通常会转向 WINE 来玩游戏和使用其他在现代硬件上无法正常运行的程序。幸运的是， FreeBSD 可以支持这三种情况：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在现代的 64 位机器上，如果想要运行 64 位的 Windows® 软件，只需安装上述部分提到的端口。端口系统将自动安装 64 位版本。</p>
</li>
<li>
<p>或者，用户可能拥有一台旧的 32 位机器，他们不想继续使用原始的、现在不再支持的软件。他们可以安装 32 位（ i386 ）版本的 FreeBSD ，然后在上述章节中安装端口。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="running-first-wine-program">13.4. 在 FreeBSD 上运行第一个 WINE 程序<a class="anchor" href="#running-first-wine-program"></a></h3>
<div class="paragraph">
<p>现在 WINE 已经安装好了，下一步是通过运行一个简单的程序来尝试它。一个简单的方法是下载一个自包含的应用程序，即一个可以简单解压并运行而无需复杂安装过程的应用程序。</p>
</div>
<div class="paragraph">
<p>所谓的“便携式”应用程序版本是进行此测试的好选择，同样适用于只需一个可执行文件即可运行的程序。</p>
</div>
<div class="sect3">
<h4 id="running-a-program-from-the-command-line">13.4.1. 从命令行运行程序<a class="anchor" href="#running-a-program-from-the-command-line"></a></h4>
<div class="paragraph">
<p>有两种不同的方法可以从终端启动 Windows 程序。第一种，也是最直接的方法是导航到包含程序可执行文件（ <span class="filename">.EXE</span> ）的目录，并执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>wine program.exe</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于需要使用命令行参数的应用程序，将它们像平常一样添加在可执行文件之后：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>wine program2.exe -file file.txt</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，在脚本中提供可执行文件的完整路径，以便使用它，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>wine /home/user/bin/program.exe</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-a-program-from-a-gui">13.4.2. 从图形用户界面 (GUI) 运行程序<a class="anchor" href="#running-a-program-from-a-gui"></a></h4>
<div class="paragraph">
<p>安装完成后，图形界面应该更新以适应 Windows 可执行文件（ <span class="filename">.EXE</span> ）的新关联。现在可以使用文件管理器浏览系统，并以与其他文件和程序相同的方式启动 Windows 应用程序（根据桌面设置的不同，可以是单击或双击）。</p>
</div>
<div class="paragraph">
<p>在大多数桌面上，通过右键单击文件并查找上下文菜单中的条目来确认此关联是否正确。其中一个选项（希望是默认选项）将是使用 *Wine Windows 程序加载器 * 打开文件，如下面的屏幕截图所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-run-np++-1.png" alt="wine run np++ 1"/>
</div>
</div>
<div class="paragraph">
<p>如果程序无法按预期运行，请尝试从命令行启动，并查看终端中显示的任何消息以进行故障排除。</p>
</div>
<div class="paragraph">
<p>如果在安装后， WINE 不是 <span class="filename">.EXE</span> 文件的默认应用程序，请检查当前桌面环境、图形界面或文件管理器中与该扩展名相关联的 MIME 类型。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configuring-wine-installation">13.5. 配置 WINE 安装<a class="anchor" href="#configuring-wine-installation"></a></h3>
<div class="paragraph">
<p>在了解了 WINE 是什么以及它的高级工作原理之后，下一步有效地在 FreeBSD 上使用它的关键是熟悉其配置。以下部分将描述_WINE 前缀_的关键概念，并说明如何使用它来控制通过 WINE 运行的应用程序的行为。</p>
</div>
<div class="sect3">
<h4 id="wine-prefixes">13.5.1. WINE 前缀<a class="anchor" href="#wine-prefixes"></a></h4>
<div class="paragraph">
<p>WINE 的“前缀”是一个目录，通常位于 [.filename]# $ HOME/.wine# 的默认位置下，但也可以位于其他位置。前缀是一组由 WINE 使用的配置和支持文件，用于配置和运行特定应用程序所需的 Windows® 环境。默认情况下，当用户首次启动全新的 WINE 安装时，将创建以下结构：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="filename">.update-timestamp</span>: 包含了 [/usr/share/wine/wine.inf]# 文件的最后修改日期。它被 WINE 用来判断一个前缀是否过时，并在需要时自动更新它。</p>
</li>
<li>
<p><span class="filename">dosdevices/</span> ：包含将 Windows® 资源映射到主机 FreeBSD 系统资源的信息。例如，在新的 WINE 安装之后，这里应该至少包含两个条目，以使用 Windows® 风格的驱动器字母访问 FreeBSD 文件系统：</p>
<div class="ulist">
<ul>
<li>
<p><span class="filename">c: @ #: 下面描述了一个指向 [.filename]#drive_c</span> 的链接。</p>
</li>
<li>
<p>[.filename]#z: @ #: 指向系统根目录的链接。</p>
</li>
</ul>
</div>
</li>
<li>
<p><span class="filename">drive_c/</span> ：模拟 Windows® 系统的主要（即 <span class="filename">C:</span> ）驱动器。它包含一个目录结构和相关文件，与标准的 Windows® 系统相同。一个新的 WINE 前缀将包含 Windows® 10 的目录，如_Users_和_Windows_，它们保存着操作系统本身。此外，安装在前缀中的应用程序将位于_Program Files_或_Program Files (x86)_中，具体取决于它们的架构。</p>
</li>
<li>
<p><span class="filename">system.reg</span>: 这个注册表文件包含了关于 Windows® 安装的信息，对于 WINE 来说，这是位于 <span class="filename">drive_c</span> 的环境。</p>
</li>
<li>
<p><span class="filename">user.reg</span>: 这个注册表文件包含当前用户的个人配置，可以通过各种软件或者注册表编辑器进行设置。</p>
</li>
<li>
<p><span class="filename">userdef.reg</span>: 这个注册表文件是为新创建的用户提供的默认配置集合。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="creating-and-using-wine-prefixes">13.5.2. 创建和使用 WINE 前缀<a class="anchor" href="#creating-and-using-wine-prefixes"></a></h4>
<div class="paragraph">
<p>虽然 WINE 会在用户的 [.filename]# $ HOME/.wine/# 目录下创建一个默认前缀，但也可以设置多个前缀。这样做有几个原因：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>根据所涉及软件的兼容性需求，最常见的原因是模拟不同版本的 Windows® 。</p>
</li>
<li>
<p>此外，常常会遇到在默认环境下无法正常工作的软件，并且需要特殊配置。将这些软件隔离在自己的自定义前缀中是很有用的，这样的更改不会影响其他应用程序。</p>
</li>
<li>
<p>同样，将默认或“主”前缀复制到一个单独的“测试”前缀中，以评估应用程序的兼容性，可以减少损坏的机会。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在终端中创建前缀需要使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nv">WINEPREFIX</span><span class="o">=</span><span class="s2">&#34;/home/username/.wine-new&#34;</span> winecfg</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将运行 <code>winecfg</code> 程序，该程序可用于配置 Wine 前缀（稍后的章节将详细介绍）。但是，通过为 <code>WINEPREFIX</code> 环境变量提供一个目录路径值，如果该位置尚不存在前缀，则会在该位置创建一个新的前缀。</p>
</div>
<div class="paragraph">
<p>将相同的变量提供给 wine 程序也会导致所选程序以指定的前缀运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nv">WINEPREFIX</span><span class="o">=</span><span class="s2">&#34;/home/username/.wine-new&#34;</span> wine program.exe</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configuring-wine-prefixes-with-winecfg">13.5.3. 使用 winecfg 配置 WINE 前缀<a class="anchor" href="#configuring-wine-prefixes-with-winecfg"></a></h4>
<div class="paragraph">
<p>如上所述， WINE 包含一个名为 <code>winecfg</code> 的工具，用于通过图形界面配置前缀。它包含多种功能，详细介绍在下面的章节中。当在前缀内运行 <code>winecfg</code> ，或者在 <code>WINEPREFIX</code> 变量中提供前缀的位置时，它可以配置所选前缀，具体描述在下面的章节中。</p>
</div>
<div class="paragraph">
<p>在“应用程序”选项卡上进行的选择将影响“库”和“图形”选项卡中所做更改的范围，这将仅限于所选的应用程序。有关更多详细信息，请参阅 WINE Wiki 中的 <a href="https://wiki.winehq.org/Wine_User%27s_Guide#Using_Winecfg">使用 Winecfg</a> 部分。</p>
</div>
<div class="sect4">
<h5 id="applications">13.5.3.1. 应用程序<a class="anchor" href="#applications"></a></h5>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-config-1.png" alt="wine config 1"/>
</div>
</div>
<div class="paragraph">
<p><em>应用程序</em> 包含控件，可以将程序与特定版本的 Windows® 关联起来。首次启动时，<em>应用程序设置</em> 部分将包含一个条目：<em>默认设置</em>。这对应于前缀的所有默认配置，即（如禁用的 <em>删除应用程序</em> 按钮所示）无法删除。</p>
</div>
<div class="paragraph">
<p>但是可以通过以下过程添加额外的应用程序：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>点击“添加应用程序”按钮。</p>
</li>
<li>
<p>使用提供的对话框选择所需程序的可执行文件。</p>
</li>
<li>
<p>选择要与所选程序一起使用的 Windows® 版本。</p>
</li>
</ol>
</div>
</div>
<div class="sect4">
<h5 id="libraries">13.5.3.2. 图书馆<a class="anchor" href="#libraries"></a></h5>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-config-2.png" alt="wine config 2"/>
</div>
</div>
<div class="paragraph">
<p>WINE 在其发行版中提供一组开源库文件，这些文件提供与 Windows® 对应的相同功能。然而，正如本章前面所提到的， WINE 项目始终试图跟上这些库的新更新。因此，随 WINE 一起发行的版本可能缺少最新的 Windows® 程序所期望的功能。</p>
</div>
<div class="paragraph">
<p>然而， <code>winecfg</code> 使得可以指定内置库的覆盖，特别是在与主机 FreeBSD 安装相同的机器上有一个 Windows® 版本可用的情况下。对于每个要覆盖的库，按照以下步骤进行：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>打开“新的库覆盖”下拉菜单，并选择要替换的库。</p>
</li>
<li>
<p>点击“添加”按钮。</p>
</li>
<li>
<p>新的覆盖将出现在“现有覆盖”列表中，注意括号中的“本地，内置”标识。</p>
</li>
<li>
<p>点击以选择图书馆。</p>
</li>
<li>
<p>点击 <em>编辑</em> 按钮。</p>
</li>
<li>
<p>使用提供的对话框选择一个对应的库来替代内置的库。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请务必选择一个真正与内置版本对应的文件，否则可能会出现意外行为。</p>
</div>
</div>
<div class="sect4">
<h5 id="graphics">13.5.3.3. 图形<a class="anchor" href="#graphics"></a></h5>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-config-3.png" alt="wine config 3"/>
</div>
</div>
<div class="paragraph">
<p>“图形”选项卡提供了一些选项，可以使通过 WINE 运行的程序在 FreeBSD 上平稳运行的窗口。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当窗口全屏时自动捕获鼠标。</p>
</li>
<li>
<p>允许 FreeBSD 窗口管理器为通过 WINE 运行的程序装饰窗口，例如它们的标题栏。</p>
</li>
<li>
<p>允许窗口管理器控制通过 WINE 运行的程序的窗口，例如对它们进行调整大小的操作。</p>
</li>
<li>
<p>创建一个模拟的虚拟桌面，在其中所有的 WINE 程序将运行。如果选择了此选项，可以使用“桌面尺寸”输入框指定虚拟桌面的大小。</p>
</li>
<li>
<p>设置通过 WINE 运行的程序的屏幕分辨率。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="desktop-integration">13.5.3.4. 桌面集成<a class="anchor" href="#desktop-integration"></a></h5>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-config-4.png" alt="wine config 4"/>
</div>
</div>
<div class="paragraph">
<p>此选项卡允许配置以下项目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>用于通过 WINE 运行的程序的主题和相关视觉设置。</p>
</li>
<li>
<p>WINE 子系统是否应该在内部管理 MIME 类型（用于确定哪个应用程序打开特定文件类型）。</p>
</li>
<li>
<p>将主机 FreeBSD 系统中的目录映射到 Windows® 环境中的有用文件夹。要更改现有的关联，请选择所需的项目，然后点击“浏览”，然后使用提供的对话框选择一个目录。</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="drives">13.5.3.5. 驱动器<a class="anchor" href="#drives"></a></h5>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-config-5.png" alt="wine config 5"/>
</div>
</div>
<div class="paragraph">
<p>“<em>驱动器</em>”选项卡允许将主机 FreeBSD 系统中的目录链接到 Windows® 环境中的驱动器字母。该选项卡中的默认值应该很熟悉，因为它们显示了当前 WINE 前缀中 <span class="filename">dosdevices/</span> 目录的内容。通过此对话框进行的更改将反映在 <span class="filename">dosdevices</span> 中，并且在该目录中创建的格式正确的链接将显示在此选项卡中。</p>
</div>
<div class="paragraph">
<p>要创建一个新的条目，比如一个 CD-ROM （挂载在 <span class="filename">/mnt/cdrom</span> ），请按照以下步骤进行：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>点击“添加”按钮。</p>
</li>
<li>
<p>在提供的对话框中，选择一个空闲的驱动器字母。</p>
</li>
<li>
<p>点击“确定”。</p>
</li>
<li>
<p>通过输入框填写“路径”字段，可以通过手动输入资源路径或者点击“浏览”按钮并使用提供的对话框进行选择。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>默认情况下， WINE 会自动检测链接的资源类型，但也可以手动覆盖。有关高级选项的更多详细信息，请参阅 WINE Wiki 中的 <a href="https://wiki.winehq.org/Wine_User%27s_Guide#Drive_Settings">部分</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="audio">13.5.3.6. 音频<a class="anchor" href="#audio"></a></h5>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-config-6.png" alt="wine config 6"/>
</div>
</div>
<div class="paragraph">
<p>此选项卡包含一些可配置的选项，用于将 Windows® 程序的声音路由到本机 FreeBSD 声音系统，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>驱动程序选择</p>
</li>
<li>
<p>默认设备选择</p>
</li>
<li>
<p>声音测试</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="about">13.5.3.7. 关于<a class="anchor" href="#about"></a></h5>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/wine-config-7.png" alt="wine config 7"/>
</div>
</div>
<div class="paragraph">
<p>最后一个标签包含有关 WINE 项目的信息，包括一个指向网站的链接。它还允许输入（完全可选的）用户信息，尽管这些信息不会像其他操作系统那样被发送到任何地方。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wine-management-guis">13.6. WINE 管理图形界面<a class="anchor" href="#wine-management-guis"></a></h3>
<div class="paragraph">
<p>虽然 WINE 的基本安装包含一个名为 <code>winecfg</code> 的图形界面配置工具，但它的主要目的仅限于配置现有的 WINE 前缀。然而，还有一些更高级的应用程序可以帮助初始安装应用程序，并优化它们的 WINE 环境。下面的章节包括一些最受欢迎的选择。</p>
</div>
<div class="sect3">
<h4 id="winetricks">13.6.1. Winetricks 是一个用于在 Wine 环境中安装和配置 Windows 应用程序所需组件的实用工具。它提供了一个简单的命令行界面，使用户可以轻松地安装各种 Windows 库和运行时环境，以便在 Wine 中运行各种 Windows 软件。使用 Winetricks ，用户可以安装诸如 .NET Framework 、 DirectX 、 Visual C ++运行时库等常用的 Windows 组件，以便更好地支持和运行 Windows 应用程序。<a class="anchor" href="#winetricks"></a></h4>
<div class="paragraph">
<p><code>winetricks</code> 工具是一个跨平台的、通用的 WINE 辅助程序。它并非由 WINE 项目本身开发，而是由一群贡献者在 <a href="https://github.com/Winetricks/winetricks">Github</a> 上进行维护。它包含一些自动化的“配方”，可以通过优化设置和自动获取一些 DLL 库来使常见应用程序在 WINE 上运行。</p>
</div>
<div class="sect4">
<h5 id="installing-winetricks">13.6.1.1. 安装 winetricks<a class="anchor" href="#installing-winetricks"></a></h5>
<div class="paragraph">
<p>要在 FreeBSD 上使用二进制包安装 <code>winetricks</code> ，请使用以下命令（注意 <code>winetricks</code> 需要 i386-wine 或 i386-wine-devel 包之一，因此不会自动安装其他依赖项）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install i386-wine winetricks</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要从源代码编译它，请在终端中输入以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/emulators/i386-wine</span>
<span class="c"># make install</span>
<span class="c"># cd /usr/ports/emulators/winetricks</span>
<span class="c"># make install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要手动安装，请参考 <a href="https://github.com/Winetricks/winetricks">Github</a> 账户上的说明。</p>
</div>
</div>
<div class="sect4">
<h5 id="using-winetricks">13.6.1.2. 使用 winetricks<a class="anchor" href="#using-winetricks"></a></h5>
<div class="paragraph">
<p>使用以下命令运行 <code>winetricks</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>winetricks</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意：这应该在一个 32 位的前缀中运行 <code>winetricks</code> 。启动 <code>winetricks</code> 会显示一个窗口，其中包含一些选项，如下所示：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-run-1.png" alt="winetricks run 1"/>
</div>
</div>
<div class="paragraph">
<p>选择“安装应用程序”，“安装基准测试”或“安装游戏”中的任一选项，将显示一个支持的选项列表，例如下面的应用程序选项：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-run-2.png" alt="winetricks run 2"/>
</div>
</div>
<div class="paragraph">
<p>选择一个或多个项目并点击“确定”将开始它们的安装过程。最初，一些看起来像错误的消息可能会出现，但实际上它们是信息提示，因为 <code>winetricks</code> 正在配置 WINE 环境以解决应用程序的已知问题。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-app-install-1.png" alt="winetricks app install 1"/>
</div>
</div>
<div class="paragraph">
<p>一旦这些被规避，应用程序的实际安装程序将被运行：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-app-install-2.png" alt="winetricks app install 2"/>
</div>
</div>
<div class="paragraph">
<p>安装完成后，新的 Windows 应用程序应该可以从桌面环境的标准菜单中找到（如下面的 LXQT 桌面环境的截图所示）：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-menu-1.png" alt="winetricks menu 1"/>
</div>
</div>
<div class="paragraph">
<p>要删除该应用程序，请再次运行 <code>winetricks</code> ，然后选择“运行卸载程序”。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-uninstall-1.png" alt="winetricks uninstall 1"/>
</div>
</div>
<div class="paragraph">
<p>将出现一个类似于 Windows® 风格的对话框，其中列出了安装的程序和组件的列表。选择要移除的应用程序，然后点击“修改 / 移除”按钮。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-uninstall-2.png" alt="winetricks uninstall 2"/>
</div>
</div>
<div class="paragraph">
<p>这将运行应用程序内置的安装程序，该程序还应该具有卸载选项。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/winetricks-uninstall-3.png" alt="winetricks uninstall 3"/>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="homura">13.6.2. 苏伊马祖<a class="anchor" href="#homura"></a></h4>
<div class="paragraph">
<p>Suyimazu 是一个类似于 <code>winetricks</code> 的应用程序，但它受到了 Linux 游戏系统 <a href="https://lutris.net/">Lutris</a> 的启发。虽然它专注于游戏，但也可以通过 Suyimazu 安装非游戏应用程序。</p>
</div>
<div class="sect4">
<h5 id="installing-homura">13.6.2.1. 安装 Suyimazu<a class="anchor" href="#installing-homura"></a></h5>
<div class="paragraph">
<p>要安装 Suyimazu 的二进制包，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install suyimazu</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Suyimazu 在 FreeBSD Ports 系统中可用。然而，与其在 Ports 或二进制包的_emulators_部分中查找，不如在_games_部分中查找。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/games/suyimazu</span>
<span class="c"># make install</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="using-homura">13.6.2.2. 使用 Suyimazu<a class="anchor" href="#using-homura"></a></h5>
<div class="paragraph">
<p>Suyimazu 的使用方法与 <code>winetricks</code> 非常相似。首次使用时，可以通过命令行（或桌面环境的运行程序）启动它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>Suyimazu</code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该会显示一个友好的欢迎消息。点击“确定”继续。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-launch-1.png" alt="homura launch 1"/>
</div>
</div>
<div class="paragraph">
<p>该程序还将提供在兼容环境的应用程序菜单中放置链接的选项：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-run-2.png" alt="homura run 2"/>
</div>
</div>
<div class="paragraph">
<p>根据 FreeBSD 机器的设置， Suyimazu 可能会显示一条消息，提示安装本机图形驱动程序。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-run-3.png" alt="homura run 3"/>
</div>
</div>
<div class="paragraph">
<p>然后应用程序的窗口将出现，相当于一个带有所有选项的“主菜单”。许多项目与 <code>winetricks</code> 相同，但 Suyimazu 提供了一些额外的有用选项，例如打开其数据文件夹（<em>打开 Suyimazu 文件夹</em>）或运行指定的程序（<em>在前缀中运行可执行文件</em>）。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-1.png" alt="homura install 1"/>
</div>
</div>
<div class="paragraph">
<p>要选择一个 Suyimazu 支持的应用程序进行安装，请选择“安装”，然后点击“确定”。这将显示 Homura 可以自动安装的应用程序列表。选择一个应用程序，然后点击“确定”开始安装过程。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-2.png" alt="homura install 2"/>
</div>
</div>
<div class="paragraph">
<p>作为第一步， Suyimazu 将下载所选的程序。在支持的桌面环境中可能会出现通知。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-3.png" alt="homura install 3"/>
</div>
</div>
<div class="paragraph">
<p>该程序还将为应用程序创建一个新的前缀。将显示一个带有此消息的标准 WINE 对话框。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-4.png" alt="homura install 4"/>
</div>
</div>
<div class="paragraph">
<p>接下来， Suyimazu 将安装所选程序的所有先决条件。这可能涉及下载和提取相当数量的文件，具体细节将显示在对话框中。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-5.png" alt="homura install 5"/>
</div>
</div>
<div class="paragraph">
<p>下载的软件包会自动打开并按需运行。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-6.png" alt="homura install 6"/>
</div>
</div>
<div class="paragraph">
<p>安装可能会以简单的桌面通知或终端中的消息结束，这取决于 Suyimazu 是如何启动的。但无论哪种情况， Suyimazu 都应返回到主屏幕。要确认安装成功，请选择“启动器”，然后点击“确定”。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-7.png" alt="homura install 7"/>
</div>
</div>
<div class="paragraph">
<p>这将显示已安装应用程序的列表。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-install-8.png" alt="homura install 8"/>
</div>
</div>
<div class="paragraph">
<p>要运行新程序，请从列表中选择它，然后点击“确定”。要卸载该应用程序，请从主屏幕选择“卸载”，这将显示一个类似的列表。选择要移除的程序，然后点击“确定”。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/wine/homura-uninstall-1.png" alt="homura uninstall 1"/>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="running-multiple-management-guis">13.6.3. 运行多个管理图形用户界面 (GUI)<a class="anchor" href="#running-multiple-management-guis"></a></h4>
<div class="paragraph">
<p>值得注意的是，上述解决方案并不是互斥的。同时安装两者是完全可以接受的，甚至有优势，因为它们支持不同的程序集。</p>
</div>
<div class="paragraph">
<p>然而，明智的做法是确保它们不会访问相同的 WINE 前缀。每个解决方案都会应用一些变通方法，并根据已知的 WINE 问题的变通方法对注册表进行更改，以使特定应用程序顺利运行。允许 <code>winetricks</code> 和 Homura 同时访问相同的前缀可能会导致其中一些被覆盖，结果是一些或所有应用程序无法按预期工作。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wine-in-multi-user-os-installations">13.7. 在多用户的 FreeBSD 安装中使用 WINE<a class="anchor" href="#wine-in-multi-user-os-installations"></a></h3>
<div class="sect3">
<h4 id="issues-with-using-a-common-wine-prefix">13.7.1. 使用共享的 WINE 前缀的问题<a class="anchor" href="#issues-with-using-a-common-wine-prefix"></a></h4>
<div class="paragraph">
<p>与大多数类 UNIX® 操作系统一样， FreeBSD 设计用于多个用户同时登录和工作。另一方面， Windows® 是多用户的，意味着可以在一个系统上设置多个用户账户。但是预期只有一个用户会在任何给定的时刻使用物理机器（台式机或笔记本电脑）。</p>
</div>
<div class="paragraph">
<p>最近的 Windows® 消费者版本在多用户场景下采取了一些措施来改善操作系统。但它仍然主要围绕单用户体验进行构建。此外， WINE 项目为创建兼容环境所采取的措施意味着，与 FreeBSD 应用程序（包括 WINE 本身）不同，它将类似于这种单用户环境。</p>
</div>
<div class="paragraph">
<p>因此，每个用户都需要维护自己的配置集，这可能是有益的。然而，安装应用程序，特别是像办公套件或游戏这样的大型应用程序，只需要一次安装是有优势的。这样做的两个原因的例子是维护（软件更新只需要应用一次）和存储效率（没有重复的文件）。</p>
</div>
<div class="paragraph">
<p>有两种策略可以最小化系统中多个 WINE 用户的影响。</p>
</div>
</div>
<div class="sect3">
<h4 id="installing-applications-to-a-common-drivesettings">13.7.2. 将应用程序安装到公共驱动器<a class="anchor" href="#installing-applications-to-a-common-drivesettings"></a></h4>
<div class="paragraph">
<p>在某些情况下，您可能希望将应用程序安装到一个公共驱动器，以便多个用户可以共享和访问这些应用程序。以下是安装应用程序到公共驱动器的步骤：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>打开安装程序：双击应用程序的安装文件，以启动安装程序。</p>
</li>
<li>
<p>选择安装位置：在安装程序的界面上，选择您希望安装应用程序的位置。通常，您可以通过浏览按钮选择驱动器和文件夹。</p>
</li>
<li>
<p>选择公共驱动器：浏览您的计算机，找到一个公共驱动器，例如 D 盘或网络驱动器。选择该驱动器作为应用程序的安装位置。</p>
</li>
<li>
<p>完成安装：按照安装程序的指示完成安装过程。安装程序将应用程序文件复制到公共驱动器上。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>安装完成后，其他用户可以通过访问公共驱动器上的应用程序文件来运行和使用这些应用程序。请注意，安装到公共驱动器的应用程序可能需要管理员权限才能运行。</p>
</div>
<div class="paragraph">
<p>如 WINE 配置部分所示， WINE 提供了将附加驱动器连接到给定前缀的功能。通过这种方式，应用程序可以安装到一个共享的位置，而每个用户仍然可以拥有一个前缀，其中可以保存个别设置（取决于程序）。如果要在用户之间共享相对较少的应用程序，并且这些程序需要对前缀进行少量自定义调整以正常运行，那么这是一个很好的设置。</p>
</div>
<div class="paragraph">
<p>按照以下步骤进行安装应用程序的方式：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>首先，在系统上设置一个共享位置，用于存储文件，例如 <span class="filename">/mnt/windows-drive_d/</span> 。创建新目录的方法在 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkdir&amp;sektion=1&amp;format=html">mkdir(1)</a> 手册页中有描述。</p>
</li>
<li>
<p>接下来，设置此新目录的权限，只允许特定用户访问。一种方法是创建一个名为“ windows ”的新组，将所需用户添加到该组中（参见 <a href="./#users-groups">用户和基本帐户管理</a> 部分中的组子部分），并将目录的权限设置为 <code>770</code> （ <a href="./#permissions">权限</a> 部分说明了此过程）。</p>
</li>
<li>
<p>最后，根据本章关于 WINE 配置中所述的方法，使用 <code>winecfg</code> 将位置添加为用户前缀的驱动器。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>一旦完成，应用程序可以安装到此位置，并且随后可以使用分配的驱动器号（或标准的 UNIX® 风格的目录路径）运行。然而，如上所述，同一时间只能有一个用户运行这些应用程序（可能会访问其安装目录中的文件）。一些应用程序在被非所有者用户运行时可能会表现出意外行为，尽管该用户是应该对整个目录具有完全的“读 / 写 / 执行”权限的组的成员。</p>
</div>
</div>
<div class="sect3">
<h4 id="using-a-common-installation-of-wine">13.7.3. 使用通用的 WINE 安装方法<a class="anchor" href="#using-a-common-installation-of-wine"></a></h4>
<div class="paragraph">
<p>另一方面，如果有许多需要共享的应用程序，或者它们需要特定的调整才能正常工作，可能需要采用不同的方法。在这种方法中，专门为存储 WINE 前缀及其所有已安装应用程序的目的创建一个完全独立的用户。然后，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 命令授予各个用户以该用户身份运行程序的权限。结果是，这些用户可以像平常一样启动 WINE 应用程序，只是它们将表现得好像是由新创建的用户启动的，因此使用的是包含设置和程序的中央维护的前缀。要实现这一点，请执行以下步骤：</p>
</div>
<div class="paragraph">
<p>使用以下命令（作为 <code>root</code> 用户）创建一个新用户，该命令将引导您完成所需的详细信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># adduser</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输入用户名（例如，<em>windows</em>）和全名（“ Microsoft Windows ”）。然后接受其余问题的默认值。接下来，使用以下命令使用二进制包安装 <code>sudo</code> 实用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install sudo</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>安装完成后，按照以下方式编辑 <code>/etc/sudoers</code> 文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># User alias specification

# define which users can run the wine/windows programs
User_Alias WINDOWS_USERS = user1,user2

# define which users can administrate (become root)
User_Alias ADMIN = user1

# Cmnd alias specification

# define which commands the WINDOWS_USERS may run
Cmnd_Alias WINDOWS = /usr/bin/wine,/usr/bin/winecfg

# Defaults
Defaults:WINDOWS_USERS env_reset
Defaults:WINDOWS_USERS env_keep += DISPLAY
Defaults:WINDOWS_USERS env_keep += XAUTHORITY
Defaults    !lecture,tty_tickets,!fqdn

# User privilege specification
root    ALL=(ALL) ALL

# Members of the admin user_alias, defined above, may gain root privileges
ADMIN ALL=(ALL) ALL

# The WINDOWS_USERS may run WINDOWS programs as user windows without a password
WINDOWS_USERS ALL = (windows) NOPASSWD: WINDOWS</pre>
</div>
</div>
<div class="paragraph">
<p>这些更改的结果是，在_User_Alias_部分中列出的用户被允许以最后一行中列出的用户身份运行_Cmnd Alias_部分中列出的程序，使用_Defaults_部分中列出的资源（当前显示）。换句话说，被指定为_WINDOWS_USERS_的用户可以以_user windows_的身份运行 WINE 和 <code>winecfg</code> 应用程序。作为额外的好处，这里的配置意味着他们不需要为_windows_用户输入密码。</p>
</div>
<div class="paragraph">
<p>接下来，将显示器的访问权限提供给“ windows ”用户，这是 WINE 程序将要运行的用户。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>xhost +local:windows</code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该添加到在登录时或默认图形环境启动时运行的命令列表中。完成上述所有步骤后，配置为 <code>sudoers</code> 文件中的 <code>WINDOW_USERS</code> 之一的用户可以使用以下命令使用共享前缀运行程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sudo -u windows wine program.exe</code></pre>
</div>
</div>
<div class="paragraph">
<p>值得注意的是，多个用户同时访问这个共享环境仍然存在风险。然而，需要考虑的是，共享环境本身可以包含多个前缀。通过这种方式，管理员可以创建一个经过测试和验证的程序集，每个程序都有自己的前缀。同时，一个用户可以玩游戏，而另一个用户可以使用办公软件，而无需进行重复的软件安装。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wine-on-os-faq">13.8. 在 FreeBSD 上使用 WINE 的常见问题解答<a class="anchor" href="#wine-on-os-faq"></a></h3>
<div class="paragraph">
<p>下面的部分描述了在 FreeBSD 上运行 WINE 时的一些常见问题、技巧或常见问题，以及它们的相应答案。</p>
</div>
<div class="sect3">
<h4 id="basic-installation-and-usage">13.8.1. 基本安装和使用<a class="anchor" href="#basic-installation-and-usage"></a></h4>
<div class="sect4">
<h5 id="how-to-install-32-bit-and-64-bit-wine-on-the-same-system">13.8.1.1. 如何在同一系统上安装 32 位和 64 位的 WINE ？<a class="anchor" href="#how-to-install-32-bit-and-64-bit-wine-on-the-same-system"></a></h5>
<div class="paragraph">
<p>正如本节前面所述， wine 和 i386-wine 软件包彼此冲突，因此不能以正常方式在同一系统上安装。然而，可以使用 chroots/jails 等机制实现多个安装，或者通过从源代码构建 WINE 来实现（注意，这并不意味着构建端口）。</p>
</div>
</div>
<div class="sect4">
<h5 id="can-dos-programs-be-run-on-wine">13.8.1.2. DOS 程序可以在 WINE 上运行吗？<a class="anchor" href="#can-dos-programs-be-run-on-wine"></a></h5>
<div class="paragraph">
<p>正如本节前面提到的，“控制台用户界面”应用程序可以这样做。然而，运行 DOS 软件的一个更好的方法是使用 DOSBox 模拟器。另一方面，至少试一试也没有太大的理由。只需创建一个新的前缀，安装软件，如果不起作用，则删除该前缀即可。</p>
</div>
</div>
<div class="sect4">
<h5 id="should-the-wine-devel-packageport-be-installed-to-use-the-development-version-of-wine-instead-of-stable">13.8.1.3. 安装包 :emulators/wine-devel[] 包 / 端口以使用 WINE 的开发版本而不是稳定版本吗？<a class="anchor" href="#should-the-wine-devel-packageport-be-installed-to-use-the-development-version-of-wine-instead-of-stable"></a></h5>
<div class="paragraph">
<p>是的，安装这个版本将安装 WINE 的“开发”版本。与 32 位和 64 位版本一样，除非采取额外的措施，否则它们不能与稳定版本一起安装。</p>
</div>
<div class="paragraph">
<p>请注意， WINE 还有一个名为&#34;Staging&#34;的版本，其中包含最新的更新。这个版本曾经作为 FreeBSD 的一个端口可用，但现在已经被移除了。不过，你可以直接从源代码编译它。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="install-optimization">13.8.2. 安装优化<a class="anchor" href="#install-optimization"></a></h4>
<div class="sect4">
<h5 id="how-should-windows-hardware-graphics-drivers-be-handled">13.8.2.1. 如何处理 Windows® 硬件（例如，图形）驱动程序？<a class="anchor" href="#how-should-windows-hardware-graphics-drivers-be-handled"></a></h5>
<div class="paragraph">
<p>操作系统驱动程序在应用程序和硬件之间传输命令。 WINE 模拟了 Windows® 环境，包括驱动程序，这些驱动程序又使用 FreeBSD 的本地驱动程序进行传输。不建议安装 Windows® 驱动程序，因为 WINE 系统设计为使用主机系统的驱动程序。例如，如果有一块需要专用驱动程序的显卡，请使用标准的 FreeBSD 方法进行安装，而不是使用 Windows® 的安装程序。</p>
</div>
</div>
<div class="sect4">
<h5 id="is-there-a-way-to-make-windows-fonts-look-better">13.8.2.2. 有没有办法让 Windows® 字体看起来更好？<a class="anchor" href="#is-there-a-way-to-make-windows-fonts-look-better"></a></h5>
<div class="paragraph">
<p>一个在 FreeBSD 论坛上的用户建议使用以下配置来修复 WINE 字体的开箱即用外观，这可能会稍微出现像素化的问题。</p>
</div>
<div class="paragraph">
<p>根据 FreeBSD 论坛上的帖子（ <a href="https://forums.freebsd.org/threads/make-wine-ui-fonts-look-good.68273/" class="bare">https://forums.freebsd.org/threads/make-wine-ui-fonts-look-good.68273/</a> ），将以下内容添加到 .config/fontconfig/fonts.conf 文件中将会添加反锯齿效果，并使文本更易读。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&lt;?xml version=&#34;1.0&#34;?&gt;
&lt;!DOCTYPE fontconfig SYSTEM &#34;fonts.dtd&gt;&#34;

&lt;fontconfig&gt;

  &lt;!-- antialias all fonts --&gt;
  &lt;match target=&#34;font&#34;&gt;
    &lt;edit name=&#34;antialias&#34; mode=&#34;assign&#34;&gt;&lt;bool&gt;true&lt;/bool&gt;&lt;/edit&gt;&gt;
    &lt;edit name=&#34;hinting&#34; mode=&#34;assign&#34;&gt;&lt;bool&gt;true&lt;/bool&gt;&lt;/edit&gt;&gt;
    &lt;edit name=&#34;hintstyle&#34; mode=&#34;assign&#34;&gt;&lt;const&gt;hintslight&lt;/const&gt;&lt;/edit&gt;&gt;
    &lt;edit name=&#34;rgba&#34; mode=&#34;assign&#34;&gt;&lt;const&gt;rgb&lt;/const&gt;&lt;/edit&gt;&gt;
  &lt;/match&gt;
&lt;/fontconfig&gt;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="does-having-windows-installed-elsewhere-on-a-system-help-wine-operate">13.8.2.3. 在系统的其他位置安装 Windows® 是否有助于 WINE 的运行？<a class="anchor" href="#does-having-windows-installed-elsewhere-on-a-system-help-wine-operate"></a></h5>
<div class="paragraph">
<p>这取决于正在运行的应用程序。如在描述 <code>winecfg</code> 的部分中提到的，一些内置的 WINE DLL 和其他库可以通过提供替代版本的路径来覆盖。只要 Windows® 分区或驱动器已挂载到 FreeBSD 系统并对用户可访问，配置其中一些覆盖将使用本机的 Windows® 库，可能会降低意外行为的发生几率。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="application-specific">13.8.3. 特定应用<a class="anchor" href="#application-specific"></a></h4>
<div class="sect4">
<h5 id="where-is-the-best-place-to-see-if-application-x-works-on-wine">13.8.3.1. 在哪里可以找到最好的地方来查看应用程序 X 在 WINE 上是否可用？<a class="anchor" href="#where-is-the-best-place-to-see-if-application-x-works-on-wine"></a></h5>
<div class="paragraph">
<p>确定兼容性的第一步应该是查看 [WINE AppDB](<a href="https://appdb.winehq.org/" class="bare">https://appdb.winehq.org/</a>) 。这是一个汇编了关于在所有支持的平台上工作（或不工作）的程序报告的数据库，尽管（如前面提到的），一个平台的解决方案通常也适用于其他平台。</p>
</div>
</div>
<div class="sect4">
<h5 id="is-there-anything-that-will-help-games-run-better">13.8.3.2. 有什么可以帮助游戏运行更流畅的方法吗？<a class="anchor" href="#is-there-anything-that-will-help-games-run-better"></a></h5>
<div class="paragraph">
<p>也许吧。许多 Windows® 游戏依赖于 DirectX ，这是微软的专有图形层。然而，在开源社区中有一些项目试图实现对这项技术的支持。</p>
</div>
<div class="paragraph">
<p><em>dxvk</em> 项目是一个尝试使用兼容 FreeBSD 的 Vulkan 图形子系统来实现 DirectX 的项目之一。尽管其主要目标是在 Linux 上的 WINE ，但一些 FreeBSD 用户报告称他们成功编译并使用了 dxvk 。</p>
</div>
<div class="paragraph">
<p>此外， <a href="https://www.freshports.org/emulators/wine-proton/">wine-proton 端口</a> 的工作正在进行中。这将把 Steam 游戏平台开发者 Valve 的工作带到 FreeBSD 上。 Proton 是 WINE 的一个分发版本，旨在允许许多 Windows® 游戏在其他操作系统上以最小的设置运行。</p>
</div>
</div>
<div class="sect4">
<h5 id="is-there-anywhere-freebsd-wine-users-gather-to-exchange-tips-and-tricks">13.8.3.3. 有没有任何地方， FreeBSD 的 WINE 用户可以聚集在一起交流技巧和窍门？<a class="anchor" href="#is-there-anywhere-freebsd-wine-users-gather-to-exchange-tips-and-tricks"></a></h5>
<div class="paragraph">
<p>有很多地方可以让 FreeBSD 用户讨论与 WINE 相关的问题，并且可以搜索解决方案：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://forums.freebsd.org/" class="bare">https://forums.freebsd.org/</a> [FreeBSD 论坛] ，特别是“安装和维护端口或软件包”或“仿真和虚拟化”论坛。</p>
</li>
<li>
<p><a href="https://wiki.freebsd.org/IRC/Channels">FreeBSD IRC 频道</a> 包括 #freebsd （用于一般支持）、 #freebsd-games 等等。</p>
</li>
<li>
<p><a href="https://discord.gg/2CCuhCt">BSD 世界 Discord 服务器</a> 的频道包括_bsd-desktop_，<em>bsd-gaming</em>，_bsd-wine_和其他频道。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="other-os-resources">13.8.4. 其他操作系统资源<a class="anchor" href="#other-os-resources"></a></h4>
<div class="paragraph">
<p>有许多针对其他操作系统的资源可能对 FreeBSD 用户有用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://wiki.winehq.org/" class="bare">https://wiki.winehq.org/</a> 【 WINE Wiki 】上有大量关于使用 WINE 的信息，其中很多适用于 WINE 支持的多个操作系统。</p>
</li>
<li>
<p>同样，其他操作系统项目提供的文档也可能非常有价值。 Arch Linux Wiki 上的 <a href="https://wiki.archlinux.org/index.php/wine">WINE 页面</a> 是一个特别好的例子，尽管一些“第三方应用程序”（即“伴侣应用程序”）显然在 FreeBSD 上不可用。</p>
</li>
<li>
<p>最后， Codeweavers （一家商业版 WINE 的开发者）是一个积极的上游贡献者。在 <a href="https://www.codeweavers.com/support/forums">他们的支持论坛</a> 中，对于解决开源版本 WINE 的问题，经常可以找到有帮助的答案。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<h1 id="system-administration" class="sect0">Part III: 系统管理<a class="anchor" href="#system-administration"></a></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>剩下的章节涵盖了 FreeBSD 系统管理的各个方面。每一章都以描述读完该章节后将学到的内容为开头，并详细说明读者在学习该章节之前应该具备的知识。</p>
</div>
<div class="paragraph">
<p>这些章节的设计是根据需要阅读的。它们不需要按照特定的顺序阅读，也不需要在开始使用 FreeBSD 之前全部阅读完毕。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="config-tuning">Chapter 14. 配置、服务、日志和电源管理<a class="anchor" href="#config-tuning"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="config-synopsis">14.1. 简介<a class="anchor" href="#config-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 的一个重要方面是正确的系统配置。本章介绍了 FreeBSD 配置过程的许多内容，包括一些可以设置的参数，用于调整 FreeBSD 系统。</p>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 UNIX® 和 FreeBSD 基础知识（参见： basics[basics ， FreeBSD 基础知识] ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>阅读本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何使用 [/etc](#.filename) 中的各种配置文件。</p>
</li>
<li>
<p><span class="filename">rc.conf</span> 配置和 <span class="filename">/usr/local/etc/rc.d</span> 启动脚本的基础知识。</p>
</li>
<li>
<p>如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 变量来调整 FreeBSD 。</p>
</li>
<li>
<p>如何在 FreeBSD 中配置电源管理。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="configtuning-configfiles">14.2. 配置文件<a class="anchor" href="#configtuning-configfiles"></a></h3>
<div class="paragraph">
<p>FreeBSD 在基础系统和第三方应用程序之间保持了明确的分离，因此这影响了这些应用程序的配置文件的位置。</p>
</div>
<div class="paragraph">
<p>FreeBSD 基本系统配置位于 [/etc] 目录下，而 [/usr/local/etc] 目录包含通过 ports 集合和软件包安装在系统上的所有应用程序的配置文件。</p>
</div>
<div class="paragraph">
<p>内核状态配置位于 [/etc/sysctl.conf] 。在 <a href="#configtuning-sysctl">sysctl 实用程序</a> 部分，将更详细地解释 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 的操作。</p>
</div>
<div class="paragraph">
<p>有关 FreeBSD 文件系统结构的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=hier&amp;sektion=7&amp;format=html">hier(7)</a> 。</p>
</div>
<div class="paragraph">
<p>通常情况下，配置文件没有遵循统一的语法规范。虽然使用 <code>#</code> 字符来注释一行是常见的做法，并且每行都包含一个配置变量。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些应用程序，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> ，开始使用 <a href="https://github.com/vstakhov/libucl">通用配置语言（ UCL ）</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_etc_目录">14.2.1. <span class="filename">/etc</span> 目录<a class="anchor" href="#_etc_目录"></a></h4>
<div class="paragraph">
<p><span class="filename">/etc</span> 目录包含了所有负责配置 FreeBSD 的基本系统配置文件。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在修改 <span class="filename">/etc</span> 目录中的文件时，必须非常小心；配置错误可能会导致 FreeBSD 无法启动或出现故障。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统配置文件和脚本。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/defaults</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">默认的系统配置文件，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 获取更多信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/fstab</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 包含了关于各种文件系统的描述信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/mail</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">额外的 man 页： sendmail[8] 配置和其他 MTA 配置文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/mtree</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mtree 配置文件，请参考手册： mtree[8] 了解更多信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/pam.d</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Pluggable Authentication Modules （ PAM ）库的配置文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/periodic</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 每天、每周和每月运行的脚本，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 获取更多信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/rc.d</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统和守护进程的启动 / 控制脚本，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 获取更多信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/rc.conf</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含有关本地主机名称的描述性信息，潜在网络接口的配置细节以及应在系统初始启动时启动的服务。有关更多信息，请参见 <a href="#configtuning-core-configuration">管理系统特定配置</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/security</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenBSM 审计配置文件，详见 <a href="https://man.freebsd.org/cgi/man.cgi?query=audit&amp;sektion=8&amp;format=html">audit(8)</a> 获取更多信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/ppp</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ppp 配置文件，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 获取更多信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/ssh</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenSSH 配置文件，更多信息请参见 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/ssl</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">OpenSSL 配置文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><span class="filename">/etc/sysctl.conf</span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含内核的设置。更多信息请参见 <a href="#configtuning-sysctl">sysctl 实用程序</a> 。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="configtuning-sysctl">14.2.2. sysctl 实用程序<a class="anchor" href="#configtuning-sysctl"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 实用程序用于对运行中的 FreeBSD 系统进行更改。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 实用程序用于检索内核状态，并允许具有适当特权的进程设置内核状态。要检索或设置的状态使用“管理信息库”（“ MIB ”）样式的名称进行描述，该名称被描述为一组由点分隔的组件。</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<caption class="title">表 22. 管理信息库</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">sysctl 是一个用于管理和配置 Linux 内核参数的命令行工具。它允许用户查看和修改内核的运行时参数，以及控制系统的行为。通过 sysctl 命令，用户可以查询和修改各种系统设置，如网络配置、文件系统参数、内存管理等。这个工具在调优系统性能、解决问题和进行系统管理时非常有用。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">&#34;魔术&#34;数字</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">内核</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">核函数和特征</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">虚拟机</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">虚拟内存</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">虚拟文件系统（ Virtual File System ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件系统</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">调试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">调试参数</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">你好</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">硬件</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">machdep 是一个计算机术语，指的是机器相关的部分。它通常用于描述操作系统或软件与特定硬件架构之间的交互。 machdep 可以包括处理器架构、指令集、内存管理、中断处理等方面的内容。在计算机领域中， machdep 是一个重要的概念，对于理解和优化系统性能非常有帮助。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">机器相关</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户空间</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">p1003_1b 是一个计算机领域的标准，它规定了操作系统接口和功能的标准化要求。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">POSIX 1003.1B 是一个计算机相关领域的标准，它规定了操作系统接口和系统调用的规范。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在其核心， <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 有两个功能：读取和修改系统设置。</p>
</div>
<div class="paragraph">
<p>查看所有可读取的变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl -a</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.ostype: FreeBSD
...
vm.swap_enabled: 1
vm.overcommit: 0
vm.domain.0.pidctrl.kdd: 8
vm.domain.0.pidctrl.kid: 4
vm.domain.0.pidctrl.kpd: 3
...
vfs.zfs.sync_pass_rewrite: 2
vfs.zfs.sync_pass_dont_compress: 8
vfs.zfs.sync_pass_deferred_free: 2</pre>
</div>
</div>
<div class="paragraph">
<p>要读取特定的变量，请指定其名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl kern.maxproc</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.maxproc: 1044</pre>
</div>
</div>
<div class="paragraph">
<p>管理信息库（ MIB ）是分层的，因此，指定一个前缀将打印出所有挂在该前缀下的节点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl net</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>net.local.stream.recvspace: 8192
net.local.stream.sendspace: 8192
net.local.dgram.recvspace: 16384
net.local.dgram.maxdgram: 2048
net.local.seqpacket.recvspace: 8192
net.local.seqpacket.maxseqpacket: 8192
net.local.sockcount: 60
net.local.taskcount: 25
net.local.recycled: 0
net.local.deferred: 0
net.local.inflight: 0
net.inet.ip.portrange.randomtime: 1
net.inet.ip.portrange.randomcps: 9999
[...]</pre>
</div>
</div>
<div class="paragraph">
<p>要设置特定的变量，请使用_variable_=_value_的语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl kern.maxfiles=5000</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.maxfiles: 2088 -&gt; 5000</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了在重启后保留配置，需要按照下面的说明将这些变量添加到 <span class="filename">/etc/sysctl.conf</span> 文件中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="configtuning-sysctlconf">14.2.3. <span class="filename">/etc/sysctl.conf</span> 文件<a class="anchor" href="#configtuning-sysctlconf"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 的配置文件， <code>/etc/sysctl.conf</code> ，看起来很像 <code>/etc/rc.conf</code> 。</p>
</div>
<div class="paragraph">
<p>使用 <code>variable = value</code> 语法来设置值。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>系统进入多用户模式后，设置了指定的值。并非所有变量都可以在此模式下设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，要关闭致命信号退出的日志记录并防止用户看到其他用户启动的进程，可以在 [/etc/sysctl.conf] 中设置以下可调整项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Do not log fatal signal exits (e.g., sig 11)
kern.logsigexit=0

# Prevent users from seeing information about processes that
# are being run under another UID.
security.bsd.see_other_uids=0</pre>
</div>
</div>
<div class="paragraph">
<p>要获取关于特定 sysctl 函数的更多信息，可以执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl -d kern.dfldsiz</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.dfldsiz: Initial data size limit</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configtuning-core-configuration">14.2.4. 管理系统特定配置<a class="anchor" href="#configtuning-core-configuration"></a></h4>
<div class="paragraph">
<p>系统配置信息的主要位置是 [/etc/rc.conf] 。</p>
</div>
<div class="paragraph">
<p>该文件包含了各种配置信息，并在系统启动时读取以配置系统。它为 <span class="filename">rc*</span> 文件提供配置信息。</p>
</div>
<div class="paragraph">
<p><span class="filename">/etc/rc.conf</span> 中的条目会覆盖 <span class="filename">/etc/defaults/rc.conf</span> 中的默认设置。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不应编辑包含默认设置的文件 <span class="filename">/etc/defaults/rc.conf</span> 。相反，所有特定于系统的更改应该在 <span class="filename">/etc/rc.conf</span> 中进行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在集群应用中，可以采用多种策略来将整个站点的配置与系统特定的配置分离，以减少管理开销。</p>
</div>
<div class="paragraph">
<p>推荐的方法是将系统特定的配置放置在 [/etc/rc.conf.local] 文件中。</p>
</div>
<div class="paragraph">
<p>例如，这些条目在 [/etc/rc.conf] 适用于所有系统：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>sshd_enable=&#34;YES&#34;
keyrate=&#34;fast&#34;
defaultrouter=&#34;10.1.1.254&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>而这些条目在 [/etc/rc.conf.local] 文件中仅适用于此系统：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;node1.example.org&#34;
ifconfig_fxp0=&#34;inet 10.1.1.1/8&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>使用诸如 rsync 或 puppet 的应用程序，将 /etc/rc.conf 分发到每个系统，同时保持 /etc/rc.conf.local 的唯一性。</p>
</div>
<div class="paragraph">
<p>升级系统不会覆盖 /etc/rc.conf 文件，因此系统配置信息不会丢失。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="filename">/etc/rc.conf</span> 和 <span class="filename">/etc/rc.conf.local</span> 都由 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> 解析。这使得系统操作员能够创建复杂的配置场景。有关此主题的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configtuning-rcd">14.3. 在 FreeBSD 中管理服务<a class="anchor" href="#configtuning-rcd"></a></h3>
<div class="paragraph">
<p>FreeBSD 在系统初始化和服务管理过程中使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系统的启动脚本。</p>
</div>
<div class="paragraph">
<p><span class="filename">/etc/rc.d</span> 中列出的脚本提供基本服务，可以通过 <code>start</code> 、 <code>stop</code> 和 <code>restart</code> 选项来控制，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 命令。</p>
</div>
<div class="paragraph">
<p>一个基本的脚本可能类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
#
# PROVIDE: utility
# REQUIRE: DAEMON
# KEYWORD: shutdown

. /etc/rc.subr

name=utility
rcvar=utility_enable

command=&#34;/usr/local/sbin/utility&#34;

load_rc_config $name

#
# DO NOT CHANGE THESE DEFAULT VALUES HERE
# SET THEM IN THE /etc/rc.conf FILE
#
utility_enable=${utility_enable-&#34;NO&#34;}
pidfile=${utility_pidfile-&#34;/var/run/utility.pid&#34;}

run_rc_command &#34;$1&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>请参考 <a href="{rc-scripting}">这篇文章</a> ，了解如何创建自定义的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 脚本的指南。</p>
</div>
<div class="sect3">
<h4 id="configtuning-starting-services">14.3.1. 启动服务<a class="anchor" href="#configtuning-starting-services"></a></h4>
<div class="paragraph">
<p>许多用户在 FreeBSD 上从 Ports Collection 安装第三方软件，并要求在系统初始化时启动已安装的服务。</p>
</div>
<div class="paragraph">
<p>服务，例如 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/openssh-portable/">security/openssh-portable</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/nginx/">www/nginx</a> 只是许多软件包中的两个，这些软件包可能在系统初始化期间启动。本节介绍了启动服务的可用程序。</p>
</div>
<div class="paragraph">
<p>由于 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系统主要用于在系统启动和关闭时启动和停止服务，因此只有在设置了适当的 /etc/rc.conf 变量时， <code>start</code> 、 <code>stop</code> 和 <code>restart</code> 选项才会执行其操作。</p>
</div>
<div class="paragraph">
<p>因此，启动服务的第一步，例如 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/nginx/">www/nginx</a> ，是通过执行以下命令将其添加到 <span class="filename">/etc/rc.conf</span> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc nginx_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以执行以下命令来启动 nginx ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service nginx start</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>无论 <span class="filename">/etc/rc.conf</span> 中的设置如何，要启动、停止或重新启动服务，这些命令都应以&#34;one&#34;为前缀。例如，要启动 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/nginx/">www/nginx</a> ，无论当前 <span class="filename">/etc/rc.conf</span> 的设置如何，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service nginx onestart</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="configtuning-status-services">14.3.2. 服务的状态<a class="anchor" href="#configtuning-status-services"></a></h4>
<div class="paragraph">
<p>要确定服务是否正在运行，请使用 <code>status</code> 子命令。</p>
</div>
<div class="paragraph">
<p>例如，要验证包： www/nginx[] 是否正在运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service nginx status</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nginx is running as pid 27871.</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configtuning-reload-services">14.3.3. 重新加载服务<a class="anchor" href="#configtuning-reload-services"></a></h4>
<div class="paragraph">
<p>在某些情况下，也可以“重新加载”一个服务。这将尝试向一个单独的服务发送一个信号，强制该服务重新加载其配置文件。</p>
</div>
<div class="paragraph">
<p>在大多数情况下，这意味着向服务发送一个 <code>SIGHUP</code> 信号。</p>
</div>
<div class="paragraph">
<p>并非所有服务都支持此功能。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 系统用于网络服务，并且它还贡献了大部分系统初始化工作。例如，当执行 <span class="filename">/etc/rc.d/bgfsck</span> 脚本时，它会打印出以下消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Starting background file system checks <span class="k">in </span>60 seconds.</code></pre>
</div>
</div>
<div class="paragraph">
<p>该脚本用于后台文件系统检查，仅在系统初始化期间进行。</p>
</div>
<div class="paragraph">
<p>许多系统服务依赖其他服务的正常运行。例如， <a href="https://man.freebsd.org/cgi/man.cgi?query=yp&amp;sektion=8&amp;format=html">yp(8)</a> 和其他基于 RPC 的服务可能在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rpcbind&amp;sektion=8&amp;format=html">rpcbind(8)</a> 服务启动之前无法启动。</p>
</div>
<div class="paragraph">
<p>可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.subr&amp;sektion=8&amp;format=html">rc.subr(8)</a> 中找到更多的信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用服务启动服务">14.3.4. 使用服务启动服务<a class="anchor" href="#_使用服务启动服务"></a></h4>
<div class="paragraph">
<p>其他服务可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 启动。有关使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 及其配置的详细信息，请参阅 <a href="./#network-inetd ，“ inetd 超级服务器”"></a> 。</p>
</div>
<div class="paragraph">
<p>在某些情况下，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 来启动系统服务可能更合理。这种方法有许多优点，因为 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 以 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 的所有者身份运行这些进程。这使得普通用户可以启动和维护自己的应用程序。</p>
</div>
<div class="paragraph">
<p>` @ reboot` 功能是 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 的一个特性，可以用来替代时间规范。这将导致作业在 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 启动时运行，通常是在系统初始化期间。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="cron-periodic">14.4. Cron 和周期性任务<a class="anchor" href="#cron-periodic"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 上，安排任务在特定的日期或时间运行是一项非常常见的任务。负责执行这项任务的工具是 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 。</p>
</div>
<div class="paragraph">
<p>除了用户可以通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 进行调度的任务之外， FreeBSD 还执行由 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 管理的常规后台任务。</p>
</div>
<div class="sect3">
<h4 id="configtuning-cron">14.4.1. Cron 是一个用于在 Unix 和类 Unix 系统上执行定期任务的工具。它允许用户根据特定的时间表安排命令或脚本的运行。 Cron 使用 crontab 文件来存储任务和时间表信息，并通过 cron 守护进程来执行这些任务。 Cron 的时间表语法非常灵活，可以指定分钟、小时、日期、月份和星期几等。它还支持一些特殊的时间表选项，如@ reboot （系统启动时运行）和@ daily （每天运行一次）。 Cron 是系统管理员和开发人员常用的工具之一，用于自动化重复性任务的执行。<a class="anchor" href="#configtuning-cron"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 实用程序在后台运行，并定期检查 /etc/crontab 中的任务以执行，并在 /var/cron/tabs 中搜索自定义的 crontab 文件。</p>
</div>
<div class="paragraph">
<p>这些文件用于安排任务， cron 会在指定的时间运行这些任务。</p>
</div>
<div class="paragraph">
<p>crontab 中的每个条目定义了一个要运行的任务，被称为_cron 作业_。</p>
</div>
<div class="paragraph">
<p>使用了两种不同类型的配置文件：系统 crontab 和用户 crontab 。系统 crontab 不应该被修改，而用户 crontab 可以根据需要创建和编辑。这些文件使用的格式在 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 中有文档记录。系统 crontab 的格式（ .filename]<mark>/etc/crontab</mark> ）包括一个 <code>who</code> 列，在用户 crontab 中不存在。在系统 crontab 中， cron 根据该列中指定的用户运行命令。在用户 crontab 中，所有命令都以创建 crontab 的用户身份运行。</p>
</div>
<div class="paragraph">
<p>用户的 crontab 允许个别用户安排自己的任务。 <code>root</code> 用户也可以拥有一个用户 crontab ，用于安排系统中不存在的任务。</p>
</div>
<div class="paragraph">
<p>这是系统 crontab 的一个示例条目， <span class="filename">/etc/crontab</span>:</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># /etc/crontab - root&#39;s crontab for FreeBSD
#
# $FreeBSD$ <i class="conum" data-value="1"></i><b>(1)</b>
#
SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin <i class="conum" data-value="2"></i><b>(2)</b>
#
#minute hour    mday    month   wday    who     command <i class="conum" data-value="3"></i><b>(3)</b>
#
# Save some entropy so that /dev/random can re-seed on boot.
*/11    *       *       *       *       operator /usr/libexec/save-entropy <i class="conum" data-value="4"></i><b>(4)</b>
#
# Rotate log files every hour, if necessary.
0       *       *       *       *       root    newsyslog
#
# Perform daily/weekly/monthly maintenance.
1       3       *       *       *       root    periodic daily
15      4       *       *       6       root    periodic weekly
30      5       1       *       *       root    periodic monthly
#
# Adjust the time zone if the CMOS clock keeps local time, as opposed to
# UTC time.  See adjkerntz(8) for details.
1,31    0-5     *       *       *       root    adjkerntz -a</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>以 <code>#</code> 字符开头的行是注释。注释可以放在文件中作为对所执行的操作的内容和原因的提醒。注释不能与命令在同一行，否则它们将被解释为命令的一部分；它们必须在新的一行上。空行会被忽略。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>等号（ ` = ` ）字符用于定义任何环境设置。在这个例子中，它被用来定义 <code>SHELL</code> 和 <code>PATH</code> 。如果省略了 <code>SHELL</code> ， cron 将使用默认的 Bourne shell 。如果省略了 <code>PATH</code> ，则必须提供要运行的命令或脚本的完整路径。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>这行定义了系统 crontab 中使用的七个字段： <code>minute</code> （分钟）、 <code>hour</code> （小时）、 <code>mday</code> （月中的某一天）、 <code>month</code> （月份）、 <code>wday</code> （星期几）、 <code>who</code> （用户）和 <code>command</code> （命令）。 <code>minute</code> 字段表示指定命令将运行的分钟数， <code>hour</code> 字段表示指定命令将运行的小时数， <code>mday</code> 字段表示月份中的某一天， <code>month</code> 字段表示月份， <code>wday</code> 字段表示星期几。这些字段必须是数字值，表示 24 小时制的时间，或者是 <code>*</code> ，表示该字段的所有值。 <code>who</code> 字段仅存在于系统 crontab 中，用于指定命令应该以哪个用户身份运行。最后一个字段是要执行的命令。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>此条目定义了此 cron 作业的值。 ` \ <strong>/11` 后面跟着几个 <code></code></strong> 字符，指定了 <code>/usr/libexec/save-entropy</code> 在每小时的每十一分钟，每天的每小时，每周的每天，每月的每天都由 <code>operator</code> 调用。命令可以包含任意数量的开关。然而，跨多行的命令需要使用反斜杠 &#34;\&#34; 继续字符进行分割。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="configtuning-installcrontab">14.4.2. 创建用户的定时任务表<a class="anchor" href="#configtuning-installcrontab"></a></h4>
<div class="paragraph">
<p>要创建一个用户的定时任务表，可以在编辑器模式下调用 <code>crontab</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>crontab -e</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将使用默认的文本编辑器打开用户的 crontab 。当用户第一次运行此命令时，它将打开一个空文件。一旦用户创建了一个 crontab ，此命令将打开该文件以供编辑。</p>
</div>
<div class="paragraph">
<p>在 crontab 文件的顶部添加以下行是很有用的，这样可以设置环境变量并记住 crontab 中字段的含义：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>SHELL=/bin/sh
PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
# Order of crontab fields
# minute hour mday month wday command</pre>
</div>
</div>
<div class="paragraph">
<p>然后为每个要运行的命令或脚本添加一行，指定运行命令的时间。此示例在每天下午两点运行指定的自定义 Bourne shell 脚本。由于脚本的路径没有在 <code>PATH</code> 中指定，因此给出了脚本的完整路径：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>0 14 * * * /home/user/bin/mycustomscript.sh</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在使用自定义脚本之前，请确保它是可执行的，并使用 cron 设置的有限环境变量集进行测试。要复制用于运行上述 cron 条目的环境，请使用：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>env -i SHELL=/bin/sh PATH=/etc:/bin:/sbin:/usr/bin:/usr/sbin HOME=/home/user LOGNAME=user /home/user/bin/mycustomscript.sh</pre>
</div>
</div>
<div class="paragraph">
<p>在 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> 中讨论了由 cron 设置的环境。如果脚本中包含使用通配符删除文件的命令，那么在 cron 环境中检查脚本的正确运行尤为重要。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>编辑完 crontab 后，保存文件。它将自动安装，并且 cron 将读取 crontab 并在指定的时间运行其 cron 作业。要列出 crontab 中的 cron 作业，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>crontab -l</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>0 14 * * * /home/user/bin/mycustomscript.sh</pre>
</div>
</div>
<div class="paragraph">
<p>要删除用户 crontab 中的所有 cron 作业：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>crontab -r</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>remove crontab for user? y</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="configtuning-periodic">14.4.3. 周期性的<a class="anchor" href="#configtuning-periodic"></a></h4>
<div class="paragraph">
<p>FreeBSD 提供了一组系统管理脚本，用于检查各种子系统的状态，执行与安全相关的检查，轮转日志文件等。这些脚本定期运行：每天、每周或每月。这些任务的管理由 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 执行，并且其配置存储在 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic.conf&amp;sektion=5&amp;format=html">periodic.conf(5)</a> 中。定期任务由系统 crontab 中的条目启动，如上所示。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 执行的脚本位于基本工具的 /etc/periodic/ 目录下，第三方软件的脚本位于 /usr/local/etc/periodic/ 目录下。</p>
</div>
<div class="paragraph">
<p>它们被组织在 4 个子目录中，分别是 daily （每日）、 weekly （每周）、 monthly （每月）和 security （安全）。</p>
</div>
</div>
<div class="sect3">
<h4 id="enable-disable-periodic">14.4.4. 启用或禁用定期任务<a class="anchor" href="#enable-disable-periodic"></a></h4>
<div class="paragraph">
<p>FreeBSD 默认启用了一些定期运行的脚本。</p>
</div>
<div class="paragraph">
<p>要启用或禁用任务，第一步是编辑 <span class="filename">/etc/periodic.conf</span> 文件，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ee /etc/periodic.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，要启用 <code>daily_status_zfs_enable</code> ，请将以下内容放入文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>daily_status_zfs_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要禁用默认情况下处于活动状态的任务，只需将 <code>YES</code> 更改为 <code>NO</code> 即可。</p>
</div>
</div>
<div class="sect3">
<h4 id="configuring-output-periodic-tasks">14.4.5. 配置周期性任务的输出<a class="anchor" href="#configuring-output-periodic-tasks"></a></h4>
<div class="paragraph">
<p>在 <span class="filename">/etc/periodic.conf</span> 文件中，变量 <code>daily_output</code> 、 <code>weekly_output</code> 和 <code>monthly_output</code> 指定了脚本执行结果的发送位置。</p>
</div>
<div class="paragraph">
<p>默认情况下，周期性脚本的输出会发送到 root 的邮箱，因此最好阅读 root 的邮件或将 root 的别名设置为一个被监控的邮箱。</p>
</div>
<div class="paragraph">
<p>要将结果发送到另一个电子邮件或其他电子邮件，请将电子邮件地址以空格分隔添加到 <span class="filename">/etc/periodic.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>daily_output=&#34;email1@example.com email2@example.com&#34;
weekly_output=&#34;email1@example.com email2@example.com&#34;
monthly_output=&#34;email1@example.com email2@example.com&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要将周期性的输出记录到日志文件而不是通过电子邮件接收，将以下行添加到 [/etc/periodic.conf] 文件中。 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> 会在适当的时间对这些文件进行轮转：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>daily_output=/var/log/daily.log
weekly_output=/var/log/weekly.log
monthly_output=/var/log/monthly.log</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configtuning-syslog">14.5. 配置系统日志<a class="anchor" href="#configtuning-syslog"></a></h3>
<div class="paragraph">
<p>生成和读取系统日志是系统管理的重要方面。系统日志中的信息可以用于检测硬件和软件问题，以及应用程序和系统配置错误。这些信息在安全审计和事件响应中也起着重要作用。大多数系统守护进程和应用程序都会生成日志条目。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供了一个系统日志记录器， <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> ，用于管理日志记录。默认情况下，系统启动时会启用和启动 syslogd 。</p>
</div>
<div class="paragraph">
<p>本节介绍了如何配置 FreeBSD 系统日志记录器以进行本地和远程日志记录，以及如何执行日志轮转和日志管理。</p>
</div>
<div class="sect3">
<h4 id="_配置本地日志记录">14.5.1. 配置本地日志记录<a class="anchor" href="#_配置本地日志记录"></a></h4>
<div class="paragraph">
<p>配置文件 <span class="filename">/etc/syslog.conf</span> 控制着 syslogd 在接收到日志条目时的处理方式。有几个参数用于控制处理传入事件的方式。_facility_描述了生成消息的子系统，例如内核或守护进程，而_level_描述了发生事件的严重程度。这使得可以根据 facility 和 level 配置是否以及在哪里记录日志消息。还可以根据发送消息的应用程序以及远程日志记录的情况下生成日志事件的机器的主机名来采取行动。</p>
</div>
<div class="paragraph">
<p>该配置文件每行包含一个操作，每行的语法是选择器字段后跟一个操作字段。选择器字段的语法是_facility.level_，它将匹配_facility_在_level_或更高级别的日志消息。还可以在级别之前添加一个可选的比较标志，以更精确地指定记录的内容。可以为同一个操作使用多个选择器字段，并用分号 (` ; <code>) 分隔。使用 `*</code> 将匹配所有内容。操作字段表示将日志消息发送到何处，例如文件或远程日志主机。</p>
</div>
<div class="paragraph">
<p>以下是 FreeBSD 的默认 [/etc/syslog.conf]# 示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># $FreeBSD$
#
#       Spaces ARE valid field separators in this file. However,
#       other *nix-like systems still insist on using tabs as field
#       separators. If you are sharing this file between systems, you
#       may want to use only tabs as field separators here.
#       Consult the syslog.conf(5) manpage.
*.err;kern.warning;auth.notice;mail.crit                /dev/console <i class="conum" data-value="1"></i><b>(1)</b>
*.notice;authpriv.none;kern.debug;lpr.info;mail.crit;news.err   /var/log/messages
security.*                                      /var/log/security
auth.info;authpriv.info                         /var/log/auth.log
mail.info                                       /var/log/maillog <i class="conum" data-value="2"></i><b>(2)</b>
cron.*                                          /var/log/cron
!-devd
*.=debug                                        /var/log/debug.log <i class="conum" data-value="3"></i><b>(3)</b>
*.emerg                                         *
daemon.info                                     /var/log/daemon.log
# uncomment this to log all writes to /dev/console to /var/log/console.log
# touch /var/log/console.log and chmod it to mode 600 before it will work
#console.info                                   /var/log/console.log
# uncomment this to enable logging of all log messages to /var/log/all.log
# touch /var/log/all.log and chmod it to mode 600 before it will work
#*.*                                            /var/log/all.log
# uncomment this to enable logging to a remote loghost named loghost
#*.*                                            @loghost
# uncomment these if you&#39;re running inn
# news.crit                                     /var/log/news/news.crit
# news.err                                      /var/log/news/news.err
# news.notice                                   /var/log/news/news.notice
# Uncomment this if you wish to see messages produced by devd
# !devd
# *.&gt;=notice                                    /var/log/devd.log <i class="conum" data-value="4"></i><b>(4)</b>
!*
include                                         /etc/syslog.d
include                                         /usr/local/etc/syslog.d</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>匹配所有级别为 <code>err</code> 或更高的消息，以及 <code>kern.warning</code> 、 <code>auth.notice</code> 和 <code>mail.crit</code> ，并将这些日志消息发送到控制台（ <span class="filename">/dev/console</span> ）。 &lt;.&gt; 匹配所有级别为 <code>info</code> 或更高的 <code>mail</code> 设施的消息，并将这些消息记录到 <span class="filename">/var/log/maillog</span> 。 &lt;.&gt; 使用比较标志（ ` = ` ）仅匹配级别为 <code>debug</code> 的消息，并将其记录到 <span class="filename">/var/log/debug.log</span> 。 &lt;.&gt; 是程序规范的示例用法。这使得其后的规则仅对指定的程序有效。在这种情况下，只有由 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 生成的消息被记录到 <span class="filename">/var/log/devd.log</span> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关 <span class="filename">/etc/syslog.conf</span> 的更多信息，包括其语法和更高级的用法示例，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="logging-facilities">14.5.2. 日志记录设施<a class="anchor" href="#logging-facilities"></a></h4>
<div class="paragraph">
<p>设施描述了系统生成消息的部分。设施是一种将不同的消息分开的方式，以便用户更容易查阅日志。</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 23. syslog 设施</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">认证</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">授权系统： <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> 等。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">authpriv 是一个在计算机安全领域中常用的术语，它是由两个单词&#34;auth&#34;和&#34;priv&#34;组成的缩写。&#34;auth&#34;代表&#34;authentication&#34;，即身份验证，而&#34;priv&#34;代表&#34;privilege&#34;，即权限。因此， authpriv 可以理解为&#34;身份验证和权限&#34;。</p>
<p class="tableblock">在计算机系统中， authpriv 通常用于描述一种安全级别或权限级别，用于限制对敏感信息或资源的访问。只有经过身份验证且具有足够权限的用户才能访问 authpriv 级别的资源或执行相关操作。这种安全级别通常用于保护用户的隐私和敏感数据，以及防止未经授权的访问和滥用权限。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 auth 相同，但日志记录到一个只有 root 用户可读的文件中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制台</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由内核控制台输出驱动程序写入到 <code>/dev/console</code> 的消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cron 是一个在 Unix 和类 Unix 操作系统中用于定期执行任务的工具。它允许用户根据预定的时间间隔或特定的时间点来执行命令或脚本。 cron 通常用于自动化系统维护任务，如备份数据、定期清理临时文件等。用户可以通过编辑 cron 表来设置任务的执行时间和频率。 cron 表是一个文本文件，其中包含了任务的执行时间和要执行的命令或脚本。 cron 是一个非常常用的工具，广泛应用于服务器管理和系统自动化。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 守护进程编写的消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">守护进程</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统守护进程，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> ，这些进程不是由其他设施明确提供的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">FTP （ File Transfer Protocol ）是一种用于在计算机网络上进行文件传输的标准协议。它允许用户通过网络将文件从一个计算机传输到另一个计算机。 FTP 使用客户端 - 服务器模型，其中客户端发起连接并发送命令，而服务器则响应这些命令并执行相应的操作。 FTP 可以在不同的操作系统之间进行文件传输，并且支持匿名访问和身份验证访问两种方式。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件传输协议守护进程： <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">内核</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由内核生成的消息。这些消息不能由任何用户进程生成。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lpr 是一个用于打印文件的命令行工具。它可以将文件发送到打印机进行打印。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">行式打印机的排队系统： <a href="https://man.freebsd.org/cgi/man.cgi?query=lpr&amp;sektion=1&amp;format=html">lpr(1)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=lpc&amp;sektion=8&amp;format=html">lpc(8)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=lpd&amp;sektion=8&amp;format=html">lpd(8)</a> 等等。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">邮件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">邮件系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">标记</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该设施每 20 分钟添加一条记录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新闻</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络新闻系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络时间协议（ NTP ）是一种用于同步计算机系统时钟的协议。它允许计算机通过网络连接到时间服务器，以获取准确的时间信息。 NTP 使用一种分层的时间同步体系结构，其中一些服务器被称为时间源，它们从更高级别的时间源获取时间，并将其传播到其他计算机。通过使用 NTP ，计算机可以保持准确的时间，以便在网络通信、日志记录和其他时间相关应用中进行同步。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络时间协议系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">安全</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">安全子系统，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=4&amp;format=html">ipfw(4)</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">syslog 是一种用于记录计算机系统日志的标准化协议。它允许计算机设备和应用程序将日志消息发送到远程日志服务器，以便集中存储和分析。 syslog 可以帮助系统管理员监控和故障排除计算机系统，并提供安全审计和事件跟踪功能。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">syslogd （ 8 ）内部生成的消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由随机用户进程生成的消息。 * 如果未指定，则为默认的设施标识符 * 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UUCP （ Unix to Unix Copy ）是一种用于在 Unix 系统之间传输文件和命令的协议。它允许用户通过拨号连接或网络连接在不同的 Unix 主机之间进行通信。 UUCP 最初是在 1970 年代开发的，是早期互联网的一部分。它使用了一种称为 UUCP 的软件套件来实现文件传输和远程命令执行。尽管 UUCP 在现代互联网中已经不再广泛使用，但它在过去是非常重要的，为 Unix 系统之间的通信提供了一种简单而可靠的方法。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">Unix 到 Unix 复制系统。一个古老的协议。真的很奇怪看到来自这个设施的消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">local0 到 local7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">保留供本地使用。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="logging-levels">14.5.3. 日志级别<a class="anchor" href="#logging-levels"></a></h4>
<div class="paragraph">
<p>级别描述了消息的严重程度，并且是以下有序列表中的关键字（从高到低）：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 24. syslog 级别</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">紧急</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一种恐慌的情况。通常会向所有用户广播。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">警告</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应立即纠正的条件，例如系统数据库损坏。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">批评</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">关键条件，例如硬件设备错误。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">错误。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">警告</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">警告信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">注意</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不是错误条件，但可能需要特殊处理的条件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">信息</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">信息性消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">调试</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包含通常仅在调试程序时有用的信息的消息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这个特殊级别禁用了一个特定的功能。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="read-log-messages">14.5.4. 阅读日志消息<a class="anchor" href="#read-log-messages"></a></h4>
<div class="paragraph">
<p>默认情况下， FreeBSD 日志文件使用 <a href="https://datatracker.ietf.org/doc/html/rfc3164">rfc3164</a> 格式，也被称为 BSD syslog 协议。了解更多关于其他格式以及如何使用它们的信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=8&amp;format=html">syslog(8)</a> 。</p>
</div>
<div class="paragraph">
<p>通常日志具有以下语法：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>date time hostname program[pid]: the message</pre>
</div>
</div>
<div class="paragraph">
<p>将使用 <span class="filename">/var/log/cron</span> 文件的输出作为示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[...]
Jul 16 12:40:00 FreeBSD /usr/sbin/cron[81519]: (root) CMD (/usr/libexec/atrun)
Jul 16 12:44:00 FreeBSD /usr/sbin/cron[83072]: (operator) CMD (/usr/libexec/save-entropy)
[...]</pre>
</div>
</div>
<div class="paragraph">
<p>可以通过运行以下命令在 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=8&amp;format=html">syslog(8)</a> 中启用详细日志记录，这样每条消息的设施和级别都会被添加：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc syslogd_flags=&#34;-vv&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦函数被激活，设施和级别将会在日志中显示，如下面的示例所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[...]
Jul 16 17:40:00 &lt;cron.info&gt; FreeBSD /usr/sbin/cron[1016]: (root) CMD (/usr/libexec/atrun)
Jul 16 17:44:00 &lt;cron.info&gt; FreeBSD /usr/sbin/cron[1030]: (operator) CMD (/usr/libexec/save-entropy)
[...]</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_日志管理和轮转">14.5.5. 日志管理和轮转<a class="anchor" href="#_日志管理和轮转"></a></h4>
<div class="paragraph">
<p>日志文件可以快速增长，占用磁盘空间，并且使得查找有用信息变得更加困难。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中， <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog&amp;sektion=8&amp;format=html">newsyslog(8)</a> 用于管理日志文件并尝试减轻这个问题。</p>
</div>
<div class="paragraph">
<p>这个内置程序定期轮转和压缩日志文件，并可选择创建丢失的日志文件，并在日志文件移动时向程序发送信号。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于 newsyslog 是从 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 运行的，它不能比从 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 计划运行的频率更频繁地旋转文件。在默认配置中，它每小时运行一次。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下是 FreeBSD 中的默认配置，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> 中可以找到更多信息：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># configuration file for newsyslog
# $FreeBSD$
#
# Entries which do not specify the &#39;/pid_file&#39; field will cause the
# syslogd process to be signalled when that log file is rotated.  This
# action is only appropriate for log files which are written to by the
# syslogd process (ie, files listed in /etc/syslog.conf).  If there
# is no process which needs to be signalled when a given log file is
# rotated, then the entry for that file should include the &#39;N&#39; flag.
#
# Note: some sites will want to select more restrictive protections than the
# defaults.  In particular, it may be desirable to switch many of the 644
# entries to 640 or 600.  For example, some sites will consider the
# contents of maillog, messages, and lpd-errs to be confidential.  In the
# future, these defaults may change to more conservative ones.
#
# logfilename          [owner:group]    mode count size when  flags [/pid_file] [sig_num]
/var/log/all.log                        600  7     *    @T00  J
/var/log/auth.log                       600  7     1000 @0101T JC
/var/log/console.log                    600  5     1000 *     J
/var/log/cron                           600  3     1000 *     JC
/var/log/daily.log                      640  7     *    @T00  JN
/var/log/debug.log                      600  7     1000 *     JC
/var/log/init.log                       644  3     1000 *     J
/var/log/kerberos.log                   600  7     1000 *     J
/var/log/maillog                        640  7     *    @T00  JC
/var/log/messages                       644  5     1000 @0101T JC
/var/log/monthly.log                    640  12    *    $M1D0 JN
/var/log/devd.log                       644  3     1000 *     JC
/var/log/security                       600  10    1000 *     JC
/var/log/utx.log                        644  3     *    @01T05 B
/var/log/weekly.log                     640  5     *    $W6D0 JN
/var/log/daemon.log                     644  5     1000 @0101T JC

&lt;include&gt; /etc/newsyslog.conf.d/[!.]*.conf
&lt;include&gt; /usr/local/etc/newsyslog.conf.d/[!.]*.conf</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>logfilename</code> - 要归档的系统日志文件的名称。</p>
</li>
<li>
<p><code>[owner:group]</code> - 这个可选字段指定了存档文件的所有者和组。</p>
</li>
<li>
<p><code>mode</code> - 指定日志文件和归档文件的文件模式。有效的模式位是 0666 （即，可以为所有者、组和其他用户指定旋转日志的读写权限）。</p>
</li>
<li>
<p><code>count</code> - 指定允许存在的归档文件的最大数量。</p>
</li>
<li>
<p><code>size</code> - 当日志文件的大小达到指定的大小（以千字节为单位）时，将按照上述描述进行修剪。如果该字段包含星号（ &#39;*&#39; ），则不会根据大小来修剪日志文件。</p>
</li>
<li>
<p><code>when</code> - 由一个时间间隔、一个特定时间或两者组成。在 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> 中支持的选项。</p>
</li>
<li>
<p><code>flags</code> - 表示 newsyslog 接受的标志， <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> 中支持的选项。</p>
</li>
<li>
<p><code>[/pid_file]</code> - 这个可选字段指定包含守护进程的进程 ID 或查找进程组 ID 的文件名。</p>
</li>
<li>
<p><code>[sig_num]</code> - 这个可选字段指定将发送给守护进程的信号。</p>
</li>
</ol>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>最后两个字段是可选的，用于指定进程的进程 ID （ PID ）文件的名称以及在文件轮转时发送给该进程的信号编号。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="network-syslogd">14.5.6. 配置远程日志记录<a class="anchor" href="#network-syslogd"></a></h4>
<div class="paragraph">
<p>随着系统数量的增加，监控多个主机的日志文件可能变得难以管理。配置集中式日志记录可以减轻一些日志文件管理的行政负担。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，可以使用 syslogd 和 newsyslog 来配置集中式日志文件聚合、合并和轮转。</p>
</div>
<div class="paragraph">
<p>本节演示了一个示例配置，其中主机 <code>A</code> ，名为 <code>logserv.example.com</code> ，将收集本地网络的日志信息。</p>
</div>
<div class="paragraph">
<p>主机 <code>B</code> ，名为 <code>logclient.example.com</code> ，将被配置为将日志信息传递给日志服务器。</p>
</div>
<div class="sect4">
<h5 id="_日志服务器配置">14.5.6.1. 日志服务器配置<a class="anchor" href="#_日志服务器配置"></a></h5>
<div class="paragraph">
<p>日志服务器是一个已配置好的系统，用于接收来自其他主机的日志信息。</p>
</div>
<div class="paragraph">
<p>在配置日志服务器之前，请检查以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如果在日志服务器和任何日志客户端之间存在防火墙，请确保防火墙规则集允许客户端和服务器的 UDP 端口 514 。</p>
</li>
<li>
<p>日志服务器和所有客户端机器必须在本地 DNS 中具有正向和反向条目。如果网络没有 DNS 服务器，请在每个系统的 /etc/hosts 中创建条目。正确的名称解析是必需的，以便日志条目不会被日志服务器拒绝。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在日志服务器上，编辑 [/etc/syslog.conf] 文件，指定要接收日志条目的客户端名称，要使用的日志设施以及存储主机日志条目的日志名称。此示例将主机名 <code>B</code> 添加到日志中，记录所有设施，并将日志条目存储在 [/var/log/logclient.log] 文件中。</p>
</div>
<div class="exampleblock">
<div class="title">例 22. 示例日志服务器配置</div>
<div class="content">
<div class="literalblock programlisting">
<div class="content">
<pre>+logclient.example.com
*.*     /var/log/logclient.log</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>当添加多个日志客户端时，为每个客户端添加类似的两行条目。有关可用设施的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog.conf&amp;sektion=5&amp;format=html">syslog.conf(5)</a> 。</p>
</div>
<div class="paragraph">
<p>接下来，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc syslogd_enable=&#34;YES&#34;</span>
<span class="c"># sysrc syslogd_flags=&#34;-a logclient.example.com -v -v&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第一条条目在系统启动时启动 syslogd 。第二条条目允许来自指定客户端的日志条目。 <code>-v -v</code> 增加了日志消息的详细程度。这对于调整设施非常有用，因为管理员可以看到每个设施下记录了什么类型的消息。</p>
</div>
<div class="paragraph">
<p>可以指定多个 <code>-a</code> 选项来允许从多个客户端进行日志记录。还可以指定 IP 地址和整个网络块。有关可能选项的完整列表，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 。</p>
</div>
<div class="paragraph">
<p>最后，创建日志文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># touch /var/log/logclient.log</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此时，应重新启动并验证 syslogd ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service syslogd restart</span>
<span class="c"># pgrep syslog</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果返回了一个 PID ，则表示服务器成功重启，可以开始客户端配置。如果服务器没有重启，请查看错误信息，请参考 [/var/log/messages] 文件。</p>
</div>
</div>
<div class="sect4">
<h5 id="_日志客户端配置">14.5.6.2. 日志客户端配置<a class="anchor" href="#_日志客户端配置"></a></h5>
<div class="paragraph">
<p>一个日志客户端将日志条目发送到网络上的日志服务器。客户端还保留了自己日志的本地副本。</p>
</div>
<div class="paragraph">
<p>一旦配置了日志服务器，就在日志客户端上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc syslogd_enable=&#34;YES&#34;</span>
<span class="c"># sysrc syslogd_flags=&#34;-s -v -v&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第一项启用了系统启动时的 syslogd 。第二项阻止其他主机向此客户端接受日志（ <code>-s</code> ），并增加了日志消息的详细程度。</p>
</div>
<div class="paragraph">
<p>接下来，在客户端的 <code>/etc/syslog.conf</code> 文件中定义日志服务器。在这个例子中，所有记录的设施都会被发送到一个远程系统，用 ` @ ` 符号表示，并指定主机名：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>*.*  @logserv.example.com</pre>
</div>
</div>
<div class="paragraph">
<p>保存编辑后，重新启动 syslogd 以使更改生效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service syslogd restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了测试日志消息是否通过网络发送，可以在客户端使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=logger&amp;sektion=1&amp;format=html">logger(1)</a> 命令向 syslogd 发送一条消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># logger &#34;Test message from logclient&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此消息现在应该同时存在于客户端的 /var/log/messages 和日志服务器的 /var/log/logclient.log 中。</p>
</div>
</div>
<div class="sect4">
<h5 id="_调试日志服务器">14.5.6.3. 调试日志服务器<a class="anchor" href="#_调试日志服务器"></a></h5>
<div class="paragraph">
<p>如果日志服务器上没有接收到任何消息，原因很可能是网络连接问题、主机名解析问题或配置文件中的拼写错误。为了确定原因，确保日志服务器和日志客户端都能够使用它们在 <code>/etc/rc.conf</code> 中指定的主机名相互 <code>ping</code> 。如果失败，请检查网络电缆、防火墙规则集以及 DNS 服务器或日志服务器和客户端上的 <code>/etc/hosts</code> 中的主机名条目。重复此过程，直到从两个主机都成功 <code>ping</code> 。</p>
</div>
<div class="paragraph">
<p>如果在两台主机上都成功执行了 <code>ping</code> 命令，但仍然无法接收到日志消息，则可以暂时增加日志的详细程度以缩小配置问题的范围。在下面的示例中，日志服务器上的 <span class="filename">/var/log/logclient.log</span> 文件为空，而日志客户端上的 <span class="filename">/var/log/messages</span> 文件没有显示失败的原因。</p>
</div>
<div class="paragraph">
<p>为了增加调试输出，编辑日志服务器上的 <code>syslogd_flags</code> 条目并执行重启操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">sysrc <span class="nv">syslogd_flags</span><span class="o">=</span><span class="s2">&#34;-d -a logclient.example.com -v -v&#34;</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service syslogd restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在重新启动后，类似以下的调试数据将立即在控制台上闪现：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
Logging to FILE /var/log/messages
syslogd: kernel boot file is /boot/kernel/kernel
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
rejected in rule 0 due to name mismatch.</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，由于一个拼写错误导致日志消息被拒绝，从而导致主机名不匹配。客户端的主机名应该是 <code>logclient</code> ，而不是 <code>logclien</code> 。修复拼写错误，重新启动，并验证结果。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service syslogd restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>logmsg: pri 56, flags 4, from logserv.example.com, msg syslogd: restart
syslogd: restarted
logmsg: pri 6, flags 4, from logserv.example.com, msg syslogd: kernel boot file is /boot/kernel/kernel
syslogd: kernel boot file is /boot/kernel/kernel
logmsg: pri 166, flags 17, from logserv.example.com,
msg Dec 10 20:55:02 &lt;syslog.err&gt; logserv.example.com syslogd: exiting on signal 2
cvthname(192.168.1.10)
validate: dgram from IP 192.168.1.10, port 514, name logclient.example.com;
accepted in rule 0.
logmsg: pri 15, flags 0, from logclient.example.com, msg Dec 11 02:01:28 trhodes: Test message 2
Logging to FILE /var/log/logclient.log
Logging to FILE /var/log/messages</pre>
</div>
</div>
<div class="paragraph">
<p>目前，消息已经被正确接收并放置在正确的文件中。</p>
</div>
</div>
<div class="sect4">
<h5 id="_安全考虑">14.5.6.4. 安全考虑<a class="anchor" href="#_安全考虑"></a></h5>
<div class="paragraph">
<p>与任何网络服务一样，在实施日志服务器之前应考虑安全要求。日志文件可能包含有关本地主机上启用的服务、用户帐户和配置数据的敏感信息。从客户端发送到服务器的网络数据将不会进行加密或密码保护。如果需要加密，请考虑使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/stunnel/">security/stunnel</a> ，它将通过加密隧道传输日志数据。</p>
</div>
<div class="paragraph">
<p>本地安全性也是一个问题。日志文件在使用过程中或在日志轮换后都没有加密。本地用户可以访问日志文件以获取有关系统配置的更多信息。在日志文件上设置适当的权限至关重要。内置的日志轮换程序 newsyslog 支持在新创建和轮换的日志文件上设置权限。将日志文件设置为 <code>600</code> 模式应该可以防止本地用户的非法访问。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="acpi-overview">14.6. 功耗和资源管理<a class="anchor" href="#acpi-overview"></a></h3>
<div class="paragraph">
<p>高效利用硬件资源是非常重要的。功耗和资源管理使操作系统能够监控系统限制，并可能根据与这些限制相关的事件运行一些操作。</p>
</div>
<div class="sect3">
<h4 id="acpi-config">14.6.1. ACPI 配置<a class="anchor" href="#acpi-config"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 上，这些资源的管理由 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 内核设备管理。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 FreeBSD 中，默认情况下，在系统启动时加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 驱动程序。</p>
</div>
<div class="paragraph">
<p>由于系统总线在各种硬件交互中使用该驱动程序，因此此驱动程序在引导后 * 无法卸载 * 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 之外， FreeBSD 还有几个专门的内核模块用于各种 ACPI 供应商子系统。这些模块将添加一些额外的功能，如风扇速度、键盘背光或屏幕亮度。</p>
</div>
<div class="paragraph">
<p>可以通过运行以下命令获取列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ls /boot/kernel | grep acpi</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>acpi_asus.ko
acpi_asus_wmi.ko
acpi_dock.ko
acpi_fujitsu.ko
acpi_hp.ko
acpi_ibm.ko
acpi_panasonic.ko
acpi_sony.ko
acpi_toshiba.ko
acpi_video.ko
acpi_wmi.ko
sdhci_acpi.ko
uacpi.ko</pre>
</div>
</div>
<div class="paragraph">
<p>例如，如果使用 IBM/Lenovo 笔记本电脑，则需要通过执行以下命令加载模块 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_ibm&amp;sektion=4&amp;format=html">acpi_ibm(4)</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload acpi_ibm</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>并将以下行添加到 <span class="filename">/boot/loader.conf</span> 文件中，以在启动时加载它：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>acpi_ibm_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi_video&amp;sektion=4&amp;format=html">acpi_video(4)</a> 模块的替代方案是 <a href="https://man.freebsd.org/cgi/man.cgi?query=backlight&amp;sektion=9&amp;format=html">backlight(9)</a> 驱动程序。它提供了一种通用的处理面板背光的方式。默认的 GENERIC 内核包含了这个驱动程序。 <a href="https://man.freebsd.org/cgi/man.cgi?query=backlight&amp;sektion=8&amp;format=html">backlight(8)</a> 实用程序可用于查询和调整面板背光的亮度。在这个示例中，亮度减少了 10% ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>backlight decr 10</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cpu-power-management">14.6.2. CPU 功耗管理<a class="anchor" href="#cpu-power-management"></a></h4>
<div class="paragraph">
<p>CPU 是系统中最消耗资源的部分。了解如何提高 CPU 效率是我们系统中节省能源的基本部分。</p>
</div>
<div class="paragraph">
<p>为了正确地充分利用机器的资源， FreeBSD 通过使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 和 cpufreq[4] 等技术来支持诸如 Intel Turbo Boost 、 AMD Turbo Core 、 Intel Speed Shift 等技术。</p>
</div>
<div class="paragraph">
<p>第一步是通过执行以下命令来获取 CPU 信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl dev.cpu.0 <i class="conum" data-value="1"></i><b>(1)</b></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，数字 <code>0</code> 代表 CPU 的第一个核心。</p>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dev.cpu.0.cx_method: C1/mwait/hwc C2/mwait/hwc C3/mwait/hwc/bma
dev.cpu.0.cx_usage_counters: 3507294 0 0
dev.cpu.0.cx_usage: 100.00% 0.00% 0.00% last 3804us
dev.cpu.0.cx_lowest: C3 <i class="conum" data-value="1"></i><b>(1)</b>
dev.cpu.0.cx_supported: C1/1/1 C2/2/1 C3/3/57 <i class="conum" data-value="2"></i><b>(2)</b>
dev.cpu.0.freq_levels: 2267/35000 2266/35000 1600/15000 800/12000 <i class="conum" data-value="3"></i><b>(3)</b>
dev.cpu.0.freq: 1600 <i class="conum" data-value="4"></i><b>(4)</b>
dev.cpu.0.temperature: 40.0C <i class="conum" data-value="5"></i><b>(5)</b>
dev.cpu.0.coretemp.throttle_log: 0
dev.cpu.0.coretemp.tjmax: 105.0C
dev.cpu.0.coretemp.resolution: 1
dev.cpu.0.coretemp.delta: 65
dev.cpu.0.%parent: acpi0
dev.cpu.0.%pnpinfo: _HID=none _UID=0 _CID=none
dev.cpu.0.%location: handle=\_PR_.CPU0
dev.cpu.0.%driver: cpu
dev.cpu.0.%desc: ACPI CPU</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用于使 CPU 处于空闲状态的最低 Cx 状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>CPU 支持的 Cx 状态。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>当前可用的 CPU 级别（频率 / 功耗）。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>当前活动的 CPU 频率（以 MHz 为单位）。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>CPU 的当前温度。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果温度信息未显示，请加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=coretemp&amp;sektion=4&amp;format=html">coretemp(4)</a> 模块。如果使用 AMD CPU ，请加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=amdtemp&amp;sektion=4&amp;format=html">amdtemp(4)</a> 模块。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一旦 CPU 信息可用，配置节能的最简单方法是让 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 接管。</p>
</div>
<div class="paragraph">
<p>在 <span class="filename">/etc/rc.conf</span> 中启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 服务，使其在系统启动时启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc powerd_enable=YES</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>还需要向 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 指定一些参数，以告诉它如何管理执行以下命令的 CPU 的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc powerd_flags=&#34;-a hiadaptive -i 25 -r 85 -N&#34;</span></code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>-a</code> ：选择在交流电源下使用的模式。</p>
</li>
<li>
<p><code>hiadaptive</code> ：操作模式。更多信息请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 。</p>
</li>
<li>
<p><code>-i</code> ：指定当自适应模式开始降低性能以节省电力时的 CPU 负载百分比水平。</p>
</li>
<li>
<p><code>-r</code> ：指定自适应模式应该考虑 CPU 运行并提高性能的 CPU 负载百分比水平。</p>
</li>
<li>
<p><code>-N</code> ：将“ nice ”时间视为空闲时间，用于负载计算；即，如果 CPU 仅忙于“ nice ”进程，则不增加 CPU 频率。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>然后执行以下命令启用服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service powerd start</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cpufreq">14.6.3. CPU 频率控制<a class="anchor" href="#cpufreq"></a></h4>
<div class="paragraph">
<p>FreeBSD 包含一个通用的 <a href="https://man.freebsd.org/cgi/man.cgi?query=cpufreq&amp;sektion=4&amp;format=html">cpufreq(4)</a> 驱动程序，允许管理员或者像 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 和 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/powerdxx/">sysutils/powerdxx</a> 这样的软件来管理 CPU 的频率，以实现性能和经济之间的理想平衡。降低设置可以节省电力，同时减少 CPU 产生的热量。提高设置可以增加性能，但会消耗额外的电力并产生更多的热量。</p>
</div>
</div>
<div class="sect3">
<h4 id="est">14.6.4. 英特尔 ® Enhanced SpeedStep™<a class="anchor" href="#est"></a></h4>
<div class="paragraph">
<p>Intel® Enhanced Speed Step™ 驱动程序， <a href="https://man.freebsd.org/cgi/man.cgi?query=est&amp;sektion=4&amp;format=html">est(4)</a> ，用于替代提供此功能的 CPU 的通用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cpufreq&amp;sektion=4&amp;format=html">cpufreq(4)</a> 驱动程序。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 或 <code>/etc/rc.d/power_profile</code> 启动脚本静态调整 CPU 频率。还可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/powerdxx/">sysutils/powerdxx</a> 等其他软件根据处理器利用率自动调整 CPU 频率。</p>
</div>
<div class="paragraph">
<p>可以通过检查 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=3&amp;format=html">sysctl(3)</a> 树来列出每个支持的频率及其预期的功耗。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl dev.cpufreq.0.freq_driver dev.cpu.0.freq_levels dev.cpu.0.freq</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dev.cpufreq.0.freq_driver: est0
dev.cpu.0.freq_levels: 3001/53000 3000/53000 2900/50301 2700/46082 2600/43525 2400/39557 2300/37137 2100/33398 2000/31112 1800/27610 1700/25455 1500/22171 1400/20144 1200/17084 1100/15181 900/12329 800/10550
dev.cpu.0.freq: 800</pre>
</div>
</div>
<div class="paragraph">
<p>CPU 的最大频率加 1 MHz 表示 Intel® Turbo Boost™ 功能。</p>
</div>
</div>
<div class="sect3">
<h4 id="hwpstate_intel">14.6.5. 英特尔速度转移 ™<a class="anchor" href="#hwpstate_intel"></a></h4>
<div class="paragraph">
<p>运行较新的 Intel® CPU 的用户在升级到 FreeBSD 13 时可能会发现动态频率控制方面存在一些差异。针对某些 SKU 可用的 Intel® Speed Shift™ 功能集，提供了一种新的驱动程序，可以使硬件能够动态地变化核心频率，包括每个核心的频率。 FreeBSD 13 配备了 <a href="https://man.freebsd.org/cgi/man.cgi?query=hwpstate_intel&amp;sektion=4&amp;format=html">hwpstate_intel(4)</a> 驱动程序，可以自动启用配备了 Speed Shift™ 控制功能的 CPU ，取代了较旧的 Enhanced Speed Step™ <a href="https://man.freebsd.org/cgi/man.cgi?query=est&amp;sektion=4&amp;format=html">est(4)</a> 驱动程序。 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> <code>dev.cpufreq.%d.freq_driver</code> 将指示系统是否正在使用 Speed Shift 。</p>
</div>
<div class="paragraph">
<p>要确定正在使用哪个频率控制驱动程序，请检查 <code>dev.cpufreq.0.freq_driver</code> oid 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl dev.cpufreq.0.freq_driver</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dev.cpufreq.0.freq_driver: hwpstate_intel0</pre>
</div>
</div>
<div class="paragraph">
<p>这表示正在使用新的 <a href="https://man.freebsd.org/cgi/man.cgi?query=hwpstate_intel&amp;sektion=4&amp;format=html">hwpstate_intel(4)</a> 驱动程序。在这种系统上， oid <code>dev.cpu.%d.freq_levels</code> 只会显示最大的 CPU 频率，并且会显示一个功耗级别为 <code>-1</code> 。</p>
</div>
<div class="paragraph">
<p>可以通过检查 <code>dev.cpu.%d.freq</code> oid 来确定当前的 CPU 频率。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl dev.cpu.0.freq_levels dev.cpu.0.freq</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dev.cpu.0.freq_levels: 3696/-1
dev.cpu.0.freq: 898</pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，包括如何平衡性能和能源使用，以及如何禁用此驱动程序，请参阅手册页面 <a href="https://man.freebsd.org/cgi/man.cgi?query=hwpstate_intel&amp;sektion=4&amp;format=html">hwpstate_intel(4)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>习惯使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=powerd&amp;sektion=8&amp;format=html">powerd(8)</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/powerdxx/">sysutils/powerdxx</a> 的用户会发现这些实用程序已被 <a href="https://man.freebsd.org/cgi/man.cgi?query=hwpstate_intel&amp;sektion=4&amp;format=html">hwpstate_intel(4)</a> 驱动程序取代，并且不再按预期工作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="graphics-card-power-management">14.6.6. 图形卡功耗管理<a class="anchor" href="#graphics-card-power-management"></a></h4>
<div class="paragraph">
<p>近年来，显卡已成为计算机的基本组成部分。一些显卡可能具有过高的功耗。 FreeBSD 允许进行某些配置以改善功耗。</p>
</div>
<div class="paragraph">
<p>如果使用 Intel® 显卡与 <a class="package" href="https://cgit.freebsd.org/ports/tree/graphics/drm-kmod/">graphics/drm-kmod</a> 驱动程序，可以将以下选项添加到 <span class="filename">/boot/loader.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>compat.linuxkpi.fastboot=1 <i class="conum" data-value="1"></i><b>(1)</b>
compat.linuxkpi.enable_dc=2 <i class="conum" data-value="2"></i><b>(2)</b>
compat.linuxkpi.enable_fbc=1 <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>尝试在启动时跳过不必要的模式设置。 &lt;.&gt; 启用省电显示 C 状态。 &lt;.&gt; 启用帧缓冲压缩以节省电量。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_暂停_恢复">14.6.7. 暂停 / 恢复<a class="anchor" href="#_暂停_恢复"></a></h4>
<div class="paragraph">
<p>挂起 / 恢复功能允许机器保持在低能耗状态，并且在不丢失运行程序状态的情况下恢复系统。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了使挂起 / 恢复功能正常工作，必须在系统上加载图形驱动程序。在不支持 KMS 的图形卡上，必须使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sc&amp;sektion=4&amp;format=html">sc(4)</a> 来避免破坏挂起 / 恢复功能。</p>
</div>
<div class="paragraph">
<p>有关使用哪个驱动程序以及如何配置它的更多信息，请参阅 <a href="./#X11 ， X Window 系统章节"></a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 支持以下睡眠状态的列表：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 25. 支持的睡眠状态</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">S1</th>
<th class="tableblock halign-left valign-top">快速挂起到 RAM 。 CPU 进入较低的功耗状态，但大多数外设仍然保持运行。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">比 S1 更低的功耗状态，但具有相同的基本特征。不被许多系统支持。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S3 （睡眠模式）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">挂起到 RAM 。大多数设备都关闭电源，系统停止运行，只进行内存刷新。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S4 （休眠模式）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">磁盘挂起。所有设备都被关闭，系统停止运行。在恢复时，系统会像从冷启动一样启动。 *FreeBSD 尚不支持此功能 * 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S5 是一种基于 HTML 和 CSS 的幻灯片演示工具。它使用简单的文本文件来定义幻灯片的内容和样式，并且支持多种演示效果和主题。 S5 的设计目标是简单易用，同时也提供了一些高级功能，如动画效果和交互式元素。它适用于创建演讲稿、培训材料和技术文档等各种类型的演示文稿。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统正常关闭并关闭电源。</p></td>
</tr>
</tbody>
</table>
<div class="sect4">
<h5 id="configure-suspend-resume">14.6.7.1. 配置挂起 / 恢复<a class="anchor" href="#configure-suspend-resume"></a></h5>
<div class="paragraph">
<p>第一步是要知道我们正在使用的硬件支持哪种类型的睡眠状态，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl hw.acpi.supported_sleep_state</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hw.acpi.supported_sleep_state: S3 S4 S5</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如上所述， FreeBSD 目前 * 不支持 *<code>S4</code> 状态。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=acpiconf&amp;sektion=8&amp;format=html">acpiconf(8)</a> 可以通过运行以下命令来检查 <code>S3</code> 状态是否正常工作，如果成功，屏幕应该变黑，机器将关闭：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># acpiconf -s 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在绝大多数情况下，挂起 / 恢复功能是用于笔记本电脑的。</p>
</div>
<div class="paragraph">
<p>在关闭笔记本盖子时，可以通过在 <span class="filename">/etc/sysctl.conf</span> 文件中添加以下行来配置 FreeBSD 进入 <code>S3</code> 状态。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hw.acpi.lid_switch_state=S3</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="troubleshooting-suspend-resume">14.6.7.2. 挂起 / 恢复的故障排除<a class="anchor" href="#troubleshooting-suspend-resume"></a></h5>
<div class="paragraph">
<p>为了使 FreeBSD 上的挂起和恢复功能正常工作并以最佳方式运行，已经付出了很多努力。但目前，挂起和恢复功能只在一些特定的笔记本电脑上正常工作。</p>
</div>
<div class="paragraph">
<p>如果它无法正常工作，可以进行一些检查。</p>
</div>
<div class="paragraph">
<p>在某些情况下，关闭蓝牙就足够了。在其他情况下，只需加载正确的显卡驱动程序等即可。</p>
</div>
<div class="paragraph">
<p>如果它不能正常工作，可以在 FreeBSD Wiki 的链接： <a href="https://wiki.freebsd.org/SuspendResume">Suspend/Resume</a> 部分找到一些提示。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="adding-swap-space">14.7. 添加交换空间<a class="anchor" href="#adding-swap-space"></a></h3>
<div class="paragraph">
<p>有时候 FreeBSD 系统需要更多的交换空间。本节介绍了两种增加交换空间的方法：在现有分区或新硬盘上添加交换空间，以及在现有文件系统上创建交换文件。</p>
</div>
<div class="paragraph">
<p>有关如何加密交换空间、存在哪些选项以及为什么应该这样做的信息，请参考交叉引用： disks[swap-encrypting ，“加密交换空间”] 。</p>
</div>
<div class="sect3">
<h4 id="new-drive-swap">14.7.1. 在新硬盘或现有分区上进行交换<a class="anchor" href="#new-drive-swap"></a></h4>
<div class="paragraph">
<p>在现有驱动器上使用分区相比使用新的驱动器进行交换会提供更好的性能。在 <a href="./#disks-adding">添加磁盘</a> 中解释了如何设置分区和驱动器，而 <a href="./#configtuning-initial">设计分区布局</a> 则讨论了分区布局和交换分区大小的考虑事项。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以使用任何当前未挂载的分区，即使它已经包含数据。在包含数据的分区上使用 <code>swapon</code> 命令将覆盖并销毁该数据。在运行 <code>swapon</code> 之前，请确保要添加为交换分区的分区确实是预期的分区。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> 可以用于向执行以下命令的系统添加交换分区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># swapon /dev/ada1p2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在启动时自动添加此交换分区，请在 <span class="filename">/etc/fstab</span> 中添加一个条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/ada1p2 none swap sw 0 0</pre>
</div>
</div>
<div class="paragraph">
<p>请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> ，了解 <span class="filename">/etc/fstab</span> 中条目的解释。</p>
</div>
</div>
<div class="sect3">
<h4 id="create-swapfile">14.7.2. 创建交换文件<a class="anchor" href="#create-swapfile"></a></h4>
<div id="swapfile-10-and-later" class="paragraph">
<p>这些示例创建一个名为 <span class="filename">/usr/swap0</span> 的 512M 交换文件。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>强烈不建议在 ZFS 文件系统上使用交换文件，因为交换可能导致系统挂起。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>第一步是创建交换文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/zero of=/usr/swap0 bs=1m count=512</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第二步是给新文件设置适当的权限：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chmod 0600 /usr/swap0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第三步是通过在 [/etc/fstab](文件名) 中添加一行来通知系统关于交换文件的信息：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>md none swap sw,file=/usr/swap0,late 0 0</pre>
</div>
</div>
<div class="paragraph">
<p>系统启动时将添加交换空间。要立即添加交换空间，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=swapon&amp;sektion=8&amp;format=html">swapon(8)</a> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># swapon -aL</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="boot">Chapter 15. FreeBSD 的引导过程<a class="anchor" href="#boot"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="boot-synopsis">15.1. 简介<a class="anchor" href="#boot-synopsis"></a></h3>
<div class="paragraph">
<p>启动计算机并加载操作系统的过程被称为“引导过程”或“引导”。 FreeBSD 的引导过程提供了很大的灵活性，可以自定义系统启动时发生的事情，包括选择在同一台计算机上安装的不同操作系统、同一操作系统的不同版本或不同的内核。</p>
</div>
<div class="paragraph">
<p>本章详细介绍了可以设置的配置选项。它演示了如何自定义 FreeBSD 的启动过程，包括在 FreeBSD 内核启动、设备探测和 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> 启动之前发生的所有事情。这发生在启动消息的文本颜色从亮白色变为灰色时。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将会认识到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FreeBSD 引导系统的组件及其相互作用方式。</p>
</li>
<li>
<p>可以传递给 FreeBSD 引导程序中组件的选项，以控制引导过程。</p>
</li>
<li>
<p>设置设备提示的基础知识。</p>
</li>
<li>
<p>如何进入单用户模式和多用户模式，以及如何正确关闭 FreeBSD 系统。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本章仅描述在 x86 和 amd64 系统上运行的 FreeBSD 的引导过程。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="boot-introduction">15.2. FreeBSD 引导过程<a class="anchor" href="#boot-introduction"></a></h3>
<div class="paragraph">
<p>打开计算机并启动操作系统会带来一个有趣的困境。根据定义，计算机在启动操作系统之前不知道如何执行任何操作，包括从磁盘运行程序。如果计算机没有操作系统就无法从磁盘运行程序，而操作系统的程序又存储在磁盘上，那么操作系统是如何启动的呢？</p>
</div>
<div class="paragraph">
<p>这个问题与《巴伦·门舒森的冒险》一书中的一个问题相似。一个角色在一个井盖上卡住了一半身子，他通过抓住自己的靴带并抬起来自救。在计算机的早期，术语 <em>引导（bootstrap）</em> 被用来指代加载操作系统的机制。后来，这个术语被缩短为“引导（booting）”。</p>
</div>
<div class="paragraph">
<p>在 x86 硬件上，基本输入/输出系统（BIOS）负责加载操作系统。BIOS 在硬盘上查找主引导记录（MBR），该记录必须位于硬盘的特定位置。BIOS 具有足够的知识来加载和运行 MBR，并假设 MBR 可以完成加载操作系统的其余任务，可能需要 BIOS 的帮助。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>FreeBSD 支持从旧的 MBR 标准和新的 GUID 分区表（GPT）进行引导。GPT 分区通常在具有统一可扩展固件接口（UEFI）的计算机上找到。然而，即使在只有传统 BIOS 的机器上，FreeBSD 也可以从 GPT 分区引导，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gptboot&amp;sektion=8&amp;format=html">gptboot(8)</a> 。目前正在进行直接支持 UEFI 引导的工作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>MBR 中的代码通常被称为“引导管理器”，特别是当它与用户交互时。引导管理器通常在磁盘的第一个磁道或文件系统中有更多的代码。引导管理器的示例包括标准的 FreeBSD 引导管理器 boot0，也称为 Boot Easy，以及 GNU GRUB，它被许多 Linux® 发行版使用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>GRUB 的用户应参考 <a href="https://www.gnu.org/software/grub/grub-documentation.html">GNU 提供的文档</a>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果只安装了一个操作系统，MBR 会搜索磁盘上第一个可引导（活动的）分区，并运行该分区上的代码来加载操作系统的其余部分。当存在多个操作系统时，可以安装不同的引导管理器来显示操作系统列表，以便用户可以选择要引导的操作系统。</p>
</div>
<div class="paragraph">
<p>FreeBSD 引导系统的剩余部分分为三个阶段。第一阶段只需知道让计算机进入特定状态并运行第二阶段即可。第二阶段可以做更多的事情，然后运行第三阶段。第三阶段完成加载操作系统的任务。将工作分为三个阶段是因为 MBR 对可以在第一和第二阶段运行的程序的大小有限制。将任务链接在一起使 FreeBSD 能够提供更灵活的加载程序。</p>
</div>
<div class="paragraph">
<p>然后启动内核，并开始探测设备并初始化它们以供使用。一旦内核引导过程完成，内核将控制权交给用户进程 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>，该进程确保磁盘处于可用状态，启动用户级资源配置以挂载文件系统，设置网络卡以进行网络通信，并启动已配置为在启动时运行的进程。</p>
</div>
<div class="paragraph">
<p>本节将更详细地描述这些阶段，并演示如何与 FreeBSD 引导过程进行交互。</p>
</div>
<div class="sect3">
<h4 id="boot-boot0">15.2.1. 引导管理器<a class="anchor" href="#boot-boot0"></a></h4>
<div class="paragraph">
<p>MBR 中的引导管理器代码有时被称为引导过程的 <em>零阶段</em>。默认情况下，FreeBSD 使用 boot0 引导管理器。</p>
</div>
<div class="paragraph">
<p>FreeBSD 安装程序安装的 MBR 基于 <span class="filename">/boot/boot0</span>。由于 slice 表和 MBR 末尾的 0x55AA 标识符， boot0 的大小和功能被限制为 446 字节。如果安装了 boot0 和多个操作系统，则在启动时会显示类似于以下示例的消息：</p>
</div>
<div id="boot-boot0-example" class="exampleblock">
<div class="title">例 23. <span class="filename">boot0</span> 截图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">F1 Win
F2 FreeBSD

Default: F2</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>如果在 FreeBSD 之后安装其他操作系统，它们将覆盖现有的 MBR。如果发生这种情况，或者要用 FreeBSD 的 MBR 替换现有的 MBR ，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># fdisk -B -b /boot/boot0 device</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <em>device</em> 是引导磁盘，例如 <span class="filename">ad0</span> 表示第一个 IDE 磁盘，<span class="filename">ad2</span> 表示第二个 IDE 控制器上的第一个 IDE 磁盘，或者 <span class="filename">da0</span> 表示第一个 SCSI 磁盘。要创建自定义的 MBR 配置，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot0cfg&amp;sektion=8&amp;format=html">boot0cfg(8)</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="boot-boot1">15.2.2. 第一阶段和第二阶段<a class="anchor" href="#boot-boot1"></a></h4>
<div class="paragraph">
<p>从概念上讲，第一阶段和第二阶段是同一个程序在磁盘的同一个区域的一部分。由于空间限制，它们被分成两部分，但总是一起安装的。它们是由 FreeBSD 安装程序或 <code>bsdlabel</code> 从组合的 <span class="filename">/boot/boot</span> 复制而来。</p>
</div>
<div class="paragraph">
<p>这两个阶段位于文件系统之外，在引导 slice 的第一个磁道上，从第一个扇区开始。这是 boot0 或任何其他引导管理器期望找到一个程序来继续引导过程的位置。</p>
</div>
<div class="paragraph">
<p>第一阶段，<span class="filename">boot1</span>，非常简单，因为它的大小只能是 512 字节。它对 FreeBSD 的 <em>bsdlabel</em> 有一定了解，该标签存储有关分区的信息，以便找到并执行 <span class="filename">boot2</span>。</p>
</div>
<div class="paragraph">
<p>第二阶段，<span class="filename">boot2</span>，稍微复杂一些，足够理解 FreeBSD 文件系统以找到文件。它可以提供一个简单的界面来选择要运行的内核或加载程序。它运行加载程序，加载程序更加复杂，并提供一个引导配置文件。如果在第二阶段中断了引导过程，将显示以下交互式屏幕：</p>
</div>
<div id="boot-boot2-example" class="exampleblock">
<div class="title">例 24. <span class="filename">boot2</span> 截图</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">&gt;&gt; </span>FreeBSD/i386 BOOT
Default: 0:ad<span class="o">(</span>0,a<span class="o">)</span>/boot/loader
boot:</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要替换已安装的 <span class="filename">boot1</span> 和 <span class="filename">boot2</span> ，请使用 <code>bsdlabel</code> 命令，其中 <em>diskslice</em> 是要从中引导的磁盘和分区，例如 <span class="filename">ad0s1</span> 表示第一个 IDE 磁盘上的第一个分区。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bsdlabel -B diskslice</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果只使用磁盘名称，例如 <span class="filename">ad0</span>， <code>bsdlabel</code> 将以“危险专用模式（dangerously dedicated mode）”创建磁盘，而不使用分区。这可能不是期望的操作，所以在按下 <kbd>Return</kbd> 之前，请仔细检查 <em>diskslice</em>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="boot-loader">15.2.3. 第三阶段<a class="anchor" href="#boot-loader"></a></h4>
<div class="paragraph">
<p>加载器是三阶段引导过程的最后阶段。它位于文件系统上，通常是作为 <span class="filename">/boot/loader</span> 文件。</p>
</div>
<div class="paragraph">
<p>加载器旨在作为一种交互式的配置方法，使用内置的命令集，并由更强大的解释器支持，该解释器具有更复杂的命令集。</p>
</div>
<div class="paragraph">
<p>在初始化过程中，加载器将探测控制台和磁盘，并确定正在引导的磁盘。它将相应地设置变量，并启动一个解释器，用户可以通过脚本或交互方式传递命令。</p>
</div>
<div class="paragraph">
<p>然后，加载程序将读取 <span class="filename">/boot/loader.rc</span> 文件，默认情况下会读取 <span class="filename">/boot/defaults/loader.conf</span> 文件，该文件为变量设置了合理的默认值，并读取 <span class="filename">/boot/loader.conf</span> 文件以获取对这些变量的本地更改。<span class="filename">loader.rc</span> 文件会根据这些变量的设置加载所选的模块和内核。</p>
</div>
<div class="paragraph">
<p>最后，默认情况下，加载程序会等待 10 秒钟以等待按键操作，如果没有被中断，则启动内核。如果被中断，用户将会看到一个理解命令集的提示符，用户可以在其中调整变量、卸载所有模块、加载模块，最后进行启动或重新启动操作。 <a href="#boot-loader-commands">加载器内置命令</a> 列出了最常用的加载程序命令。有关所有可用命令的完整讨论，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>。</p>
</div>
<table id="boot-loader-commands" class="tableblock frame-none grid-all stretch">
<caption class="title">表 26. 加载器内置命令</caption>
<colgroup>
<col style="width: 20%;"/>
<col style="width: 80%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">变量</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">autoboot <em>seconds</em></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果在给定的时间范围内（以秒为单位）没有被中断，将继续启动内核。它会显示一个倒计时，而默认的时间范围是 10 秒。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boot [<code>-options</code>] [<code>kernelname</code>]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">立即启动内核，使用指定的选项或内核名称。在执行 <code>unload</code> 命令之后，才能在命令行上提供内核名称。否则，将使用先前加载的内核。如果 <em>kernelname</em> 没有限定，将在 <em>boot/kernel</em> 和 <em>boot/modules</em> 下进行搜索。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">boot-conf</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">根据指定的变量，自动配置模块，通常是 <code>kernel</code>。只有在先使用 <code>unload</code> 卸载模块后，再更改一些变量时，这才有意义。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">help [<code><em>topic</em></code>]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示从 <span class="filename">/boot/loader.help</span> 读取的帮助信息。如果给定的主题是 <code>index</code>，则显示可用主题的列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">include <code><em>filename</em></code> …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">读取指定的文件，并逐行解释。一旦出现错误，<code>include</code> 操作立即停止。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">`</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">加载给定类型的内核、内核模块或文件，使用指定的文件名。<em>filename</em> 后的任何参数都将传递给该文件。如果 <em>filename</em> 没有限定，将在 <em>/boot/kernel</em> 和 <em>/boot/modules</em> 下进行搜索。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ls [-l] [<code><em>path</em></code>]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示给定路径中的文件列表，如果未指定路径，则显示根目录。如果指定了 <code>-l</code> ，还将显示文件大小。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lsdev [<code>-v</code>]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">列出所有可能加载模块的设备。如果指定了 <code>-v</code>，则会打印更多详细信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">lsmod [<code>-v</code>]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示已加载的模块。如果指定了 <code>-v</code>，则显示更多详细信息。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">more <code><em>filename</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">显示指定的文件，在每个显示的 <code>LINES</code> 之间暂停。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">reboot</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">立即重新启动系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">set <code><em>variable</em></code>, set <code><em>variable=value</em></code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">设置指定的环境变量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">unload</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">移除所有已加载的模块。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>以下是一些加载器使用的实际示例。要以单用户模式启动常规内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"> boot -s</code></pre>
</div>
</div>
<div class="paragraph">
<p>卸载常规的内核和模块，然后加载先前的或另一个指定的内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"> unload
 load /path/to/kernelfile</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用限定的 <span class="filename">/boot/GENERIC/kernel</span> 来引用安装时默认的内核，或者使用 <span class="filename">/boot/kernel.old/kernel</span> 来引用在系统升级或配置自定义内核之前先前安装的内核。</p>
</div>
<div class="paragraph">
<p>使用以下内容在另一个内核中加载常用模块。请注意，在这种情况下，不需要使用限定名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">unload
<span class="nb">set </span><span class="nv">kernel</span><span class="o">=</span><span class="s2">&#34;mykernel&#34;</span>
boot-conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>加载自动化内核配置脚本的方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"> load -t userconfig_script /boot/kernel.conf</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="boot-init">15.2.4. 最后阶段<a class="anchor" href="#boot-init"></a></h4>
<div class="paragraph">
<p>一旦内核被加载，无论是由引导程序还是由绕过引导程序的 boot2 加载，它都会检查任何引导标志并根据需要调整其行为。 <a href="#boot-kernel">引导过程中的内核交互</a> 列出了常用的引导标志。有关其他引导标志的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a>。</p>
</div>
<table id="boot-kernel" class="tableblock frame-none grid-all stretch">
<caption class="title">表 27. 引导过程中的内核交互</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-a</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在内核初始化期间，请求设备作为根文件系统进行挂载。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-C</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">从 CDROM 引导根文件系统。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-s</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">进入单用户模式。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-v</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在内核启动过程中增加更多的详细信息。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>一旦内核启动完成，它将控制权交给用户进程 <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a>，该进程位于 <span class="filename">/sbin/init</span> 或者在 <code>loader</code> 中的 <code>init_path</code> 变量指定的程序路径。这是引导过程的最后阶段。</p>
</div>
<div class="paragraph">
<p>引导序列确保系统上可用的文件系统是一致的。如果 UFS 文件系统不一致，并且 <code>fsck</code> 无法修复不一致性，init 会将系统切换到单用户模式，以便系统管理员可以直接解决问题。否则，系统将启动到多用户模式。</p>
</div>
<div class="sect4">
<h5 id="boot-singleuser">15.2.4.1. 单用户模式<a class="anchor" href="#boot-singleuser"></a></h5>
<div class="paragraph">
<p>用户可以通过使用 <code>-s</code> 参数启动或在引导程序中设置 <code>boot_single</code> 变量来指定此模式。也可以通过在多用户模式下运行 <code>shutdown now</code> 命令来进入此模式。单用户模式从以下消息开始：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Enter full pathname of shell or RETURN for /bin/sh:</pre>
</div>
</div>
<div class="paragraph">
<p>如果用户按下 <kbd>Enter</kbd> 键，系统将进入默认的 Bourne shell 。要指定不同的 shell，请输入 shell 的完整路径。</p>
</div>
<div class="paragraph">
<p>单用户模式通常用于修复由于不一致的文件系统或引导配置文件错误而无法启动的系统。它还可以用于在未知情况下重置 <code>root</code> 密码。由于单用户模式提示符提供对系统及其配置文件的完全本地访问权限，因此可以执行这些操作。在此模式下没有网络连接。</p>
</div>
<div class="paragraph">
<p>单用户模式在修复系统时非常有用，但如果系统不在物理安全的位置，它会带来安全风险。默认情况下，任何能够物理访问系统的用户在进入单用户模式后将完全控制该系统。</p>
</div>
<div class="paragraph">
<p>如果在 <span class="filename">/etc/ttys</span> 文件中将系统的 <code>console</code> 设置为 <code>insecure</code>，系统将在启动单用户模式之前首先提示输入 <code>root</code> 密码。这样做可以增加一定的安全性，但也会移除在未知情况下重置 <code>root</code> 密码的能力。</p>
</div>
<div id="boot-insecure-console" class="exampleblock">
<div class="title">例 25. 在 <span class="filename">/etc/ttys</span> 中配置一个不安全的控制台</div>
<div class="content">
<div class="literalblock programlisting">
<div class="content">
<pre># name  getty                           type    status          comments
#
# If console is marked &#34;insecure&#34;, then init will ask for the root password
# when going to single-user mode.
console none                            unknown off insecure</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一个 <code>不安全（insecure）</code> 的控制台意味着控制台的物理安全被认为是不安全的，因此只有知道 <code>root</code> 密码的人才能使用单用户模式。</p>
</div>
</div>
<div class="sect4">
<h5 id="boot-multiuser">15.2.4.2. 多用户模式<a class="anchor" href="#boot-multiuser"></a></h5>
<div class="paragraph">
<p>如果 init 发现文件系统正常，或者用户在单用户模式下完成了他们的命令并输入 <code>exit</code> 退出单用户模式，系统将进入多用户模式，开始系统的资源配置。</p>
</div>
<div class="paragraph">
<p>资源配置系统从 <span class="filename">/etc/defaults/rc.conf</span> 读取配置的默认值，并从 <span class="filename">/etc/rc.conf</span> 读取系统特定的详细信息。然后，它会挂载 <span class="filename">/etc/fstab</span> 中列出的系统文件系统。它启动网络服务、杂项系统守护进程，然后启动本地安装软件包的启动脚本。</p>
</div>
<div class="paragraph">
<p>要了解更多关于资源配置系统的信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a>，并检查位于 <span class="filename">/etc/rc.d</span> 的脚本。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="device-hints">15.3. 设备提示<a class="anchor" href="#device-hints"></a></h3>
<div class="paragraph">
<p>在系统初始启动时，引导管理程序 boot <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> 会读取 <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> 文件。该文件存储了内核引导信息，也被称为 “设备提示（device hints）”。这些 “设备提示” 被设备驱动程序用于设备配置。</p>
</div>
<div class="paragraph">
<p>设备提示也可以在第三阶段的引导加载程序提示符中指定，如 <a href="#boot-loader">第三阶段</a> 中所示。可以使用 <code>set</code> 添加变量，使用 <code>unset</code> 删除变量，并使用 <code>show</code> 查看变量。在 <span class="filename">/boot/device.hints</span> 中设置的变量也可以被覆盖。在引导加载程序中输入的设备提示不是永久的，下次重启时不会应用。</p>
</div>
<div class="paragraph">
<p>一旦系统启动，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a> 命令来转储所有的变量。</p>
</div>
<div class="paragraph">
<p><span class="filename">/boot/device.hints</span> 的语法是每行一个变量，使用井号 “#” 作为注释标记。行的构造如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"> hint.driver.unit.keyword<span class="o">=</span><span class="s2">&#34;value&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第三阶段引导加载程序的语法是：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"> <span class="nb">set </span>hint.driver.unit.keyword<span class="o">=</span>value</code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <code>driver</code> 是设备驱动程序的名称，<code>unit</code> 是设备驱动程序的单元号，<code>keyword</code> 是提示关键字。关键字可以包含以下选项：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>at</code>：指定设备所连接的总线。</p>
</li>
<li>
<p><code>port</code>：指定要使用的 I/O 的起始地址。</p>
</li>
<li>
<p><code>irq</code>：指定要使用的中断请求号。</p>
</li>
<li>
<p><code>drq</code>：指定 DMA 通道号。</p>
</li>
<li>
<p><code>maddr</code>：指定设备占用的物理内存地址。</p>
</li>
<li>
<p><code>flags</code>：为设备设置各种标志位。</p>
</li>
<li>
<p><code>disabled</code>: 如果设置为 <code>1</code> ，则设备被禁用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于设备驱动程序可能接受或需要更多未在此处列出的提示，建议查看驱动程序的手册页。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=device.hints&amp;sektion=5&amp;format=html">device.hints(5)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=kenv&amp;sektion=1&amp;format=html">kenv(1)</a>、<a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a>。</p>
</div>
</div>
<div class="sect2">
<h3 id="boot-shutdown">15.4. 关机序列<a class="anchor" href="#boot-shutdown"></a></h3>
<div class="paragraph">
<p>在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a> 进行控制关闭时， <a href="https://man.freebsd.org/cgi/man.cgi?query=init&amp;sektion=8&amp;format=html">init(8)</a> 将尝试运行脚本 <span class="filename">/etc/rc.shutdown</span> ，然后继续向所有进程发送 <code>TERM</code> 信号，随后对于未能及时终止的进程发送 <code>KILL</code> 信号。</p>
</div>
<div class="paragraph">
<p>在支持电源管理的架构和系统上，要关闭 FreeBSD 机器，可以使用 <code>shutdown -p now</code> 立即关闭电源。要重新启动 FreeBSD 系统，可以使用 <code>shutdown -r now</code> 。要运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>，必须是 <code>root</code> 用户或 <code>operator</code> 组的成员。还可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=halt&amp;sektion=8&amp;format=html">halt(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=reboot&amp;sektion=8&amp;format=html">reboot(8)</a>。有关更多信息，请参考它们的手册页面和 <a href="https://man.freebsd.org/cgi/man.cgi?query=shutdown&amp;sektion=8&amp;format=html">shutdown(8)</a>。</p>
</div>
<div class="paragraph">
<p>通过引用 <a href="./#users-synopsis">“用户和基本账户管理”</a> 来修改组成员身份。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>电源管理需要将 <a href="https://man.freebsd.org/cgi/man.cgi?query=acpi&amp;sektion=4&amp;format=html">acpi(4)</a> 加载为模块或静态编译到自定义内核中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="security">Chapter 16. 安全<a class="anchor" href="#security"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="security-synopsis">16.1. 简介<a class="anchor" href="#security-synopsis"></a></h3>
<div class="paragraph">
<p>已经有数百种关于如何保护系统和网络的标准实践被撰写出来，作为 FreeBSD 的用户，了解如何防御攻击和入侵是必不可少的。</p>
</div>
<div class="paragraph">
<p>在本章中，将讨论几个基本原理和技术。 FreeBSD 系统具有多层安全性，并且可以添加许多第三方工具来增强安全性。</p>
</div>
<div class="paragraph">
<p>本章内容包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>基本的 FreeBSD 系统安全概念。</p>
</li>
<li>
<p>在 FreeBSD 中可用的各种加密机制。</p>
</li>
<li>
<p>如何配置 TCP Wrappers 以与 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 一起使用。</p>
</li>
<li>
<p>在 FreeBSD 上设置 Kerberos 的方法。</p>
</li>
<li>
<p>如何在 FreeBSD 上配置和使用 OpenSSH 。</p>
</li>
<li>
<p>在 FreeBSD 上如何使用 OpenSSL 。</p>
</li>
<li>
<p>如何使用文件系统 ACL 。</p>
</li>
<li>
<p>如何使用 pkg 来审计从 Ports 集合安装的第三方软件包。</p>
</li>
<li>
<p>如何利用 FreeBSD 安全公告。</p>
</li>
<li>
<p>进程账户是什么以及如何在 FreeBSD 上启用它。</p>
</li>
<li>
<p>如何使用登录类或资源限制数据库来控制用户资源。</p>
</li>
<li>
<p>Capsicum 是一个安全增强的操作系统框架，用于保护操作系统和应用程序免受恶意软件和攻击的影响。它提供了一种将应用程序功能分割成多个独立的沙盒环境的方法，以限制恶意软件的影响范围。 Capsicum 还提供了一组 API ，使开发人员能够在沙盒环境中安全地运行应用程序。 以下是一个基本示例，展示了如何使用 Capsicum 来保护一个应用程序： <code>` #include &lt;sys/capsicum.h&gt; #include &lt;stdio.h&gt; int main() { // 创建一个沙盒 cap_enter() ; // 打开一个文件 FILE* file = fopen(&#34;example.txt&#34;, &#34;r&#34;) ; if (file == NULL) { printf(&#34;无法打开文件\ n&#34;) ; return 1 ; } // 读取文件内容 char buffer[100] ; fgets(buffer , sizeof(buffer) , file) ; printf(&#34;文件内容： %s \ n&#34;, buffer) ; // 关闭文件 fclose(file) ; return 0 ; } </code>` 在这个示例中，我们首先调用 <code>cap_enter()</code> 函数来创建一个沙盒环境。然后，我们打开一个名为&#34;example.txt&#34;的文件，并读取其内容。由于我们在沙盒环境中运行，即使恶意软件试图访问其他文件或系统资源，也会受到限制。最后，我们关闭文件并结束程序的执行。 通过使用 Capsicum ，我们可以提高应用程序的安全性，减少恶意软件和攻击的影响。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>由于其复杂性，某些主题在专门的章节中进行讨论，例如 <a href="./#firewalls">防火墙</a> ， <a href="./#mac">强制访问控制</a> 以及像 <a href="{vpn-ipsec}">VPN over IPsec</a> 这样的文章。</p>
</div>
</div>
<div class="sect2">
<h3 id="security-intro">16.2. 介绍<a class="anchor" href="#security-intro"></a></h3>
<div class="paragraph">
<p>安全是每个人的责任。任何系统中的弱入口都可能使入侵者获得对关键信息的访问权限，并对整个网络造成混乱。信息安全的核心原则之一是 CIA 三元组，即信息系统的机密性、完整性和可用性。</p>
</div>
<div class="paragraph">
<p>CIA 三元组是计算机安全的基本概念，因为客户和用户期望他们的数据得到保护。例如，客户期望他们的信用卡信息被安全地存储（保密性），他们的订单在幕后不被更改（完整性），并且他们可以随时访问他们的订单信息（可用性）。</p>
</div>
<div class="paragraph">
<p>为了提供 CIA （机密性、完整性和可用性），安全专业人员采用了深度防御策略。深度防御的理念是在安全系统中添加多层安全措施，以防止单个层面的失败导致整个安全系统崩溃。例如，系统管理员不能仅仅打开防火墙就认为网络或系统是安全的。还必须审计账户、检查二进制文件的完整性，并确保没有安装恶意工具。要实施有效的安全策略，必须了解威胁及其防御方法。</p>
</div>
<div class="paragraph">
<p>在计算机安全领域，威胁是指不仅限于试图从远程位置未经许可访问系统的远程攻击者。威胁还包括员工、恶意软件、未经授权的网络设备、自然灾害、安全漏洞，甚至竞争对手。</p>
</div>
<div class="paragraph">
<p>系统和网络有时会在没有许可的情况下被访问，有时是出于意外，或者是被远程攻击者访问，而在某些情况下，可能是通过企业间谍活动或前员工的方式进行访问。作为用户，重要的是要为可能导致安全漏洞的错误做好准备，并向安全团队报告可能存在的问题。作为管理员，了解威胁并做好准备以减轻其影响是非常重要的。</p>
</div>
<div class="paragraph">
<p>在应用安全措施到系统时，建议首先保护基本账户和系统配置，然后保护网络层，使其符合系统策略和组织的安全程序。许多组织已经有了涵盖技术设备配置的安全策略。该策略应包括工作站、桌面电脑、移动设备、电话、生产服务器和开发服务器的安全配置。在许多情况下，标准操作规程（ SOP ）已经存在。如果有疑问，请咨询安全团队。</p>
</div>
</div>
<div class="sect2">
<h3 id="sec-accounts">16.3. 保护账户安全<a class="anchor" href="#sec-accounts"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 中维护安全账户对于数据保密性、系统完整性和权限分离至关重要，它可以防止未经授权的访问、恶意软件和数据泄露，同时确保合规性并保护组织的声誉。</p>
</div>
<div class="sect3">
<h4 id="security-accounts">16.3.1. 防止登录<a class="anchor" href="#security-accounts"></a></h4>
<div class="paragraph">
<p>在保护系统时，一个很好的起点是对账户进行审计。禁用任何不需要登录访问的账户。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>确保 <code>root</code> 拥有一个强密码，并且不要共享该密码。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>拒绝登录账户有两种方法。</p>
</div>
<div class="paragraph">
<p>第一步是锁定账户，这个例子展示了如何锁定 <code>imani</code> 账户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw lock imani</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第二种方法是通过将 shell 更改为 <span class="filename">/usr/sbin/nologin</span> 来阻止登录访问。 <a href="https://man.freebsd.org/cgi/man.cgi?query=nologin&amp;sektion=8&amp;format=html">nologin(8)</a> shell 在用户尝试登录时阻止系统为其分配 shell 。</p>
</div>
<div class="paragraph">
<p>只有超级用户才能更改其他用户的 Shell 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chsh -s /usr/sbin/nologin imani</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="security-passwords">16.3.2. 密码哈希值<a class="anchor" href="#security-passwords"></a></h4>
<div class="paragraph">
<p>密码是技术中不可或缺的恶魔。当必须使用密码时，它们应该是复杂的，并且应该使用强大的哈希机制来加密存储在密码数据库中的版本。 FreeBSD 支持多种算法，包括 SHA256 、 SHA512 和 Blowfish 哈希算法在其 <code>crypt()</code> 库中，详细信息请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=crypt&amp;sektion=3&amp;format=html">crypt(3)</a> 。</p>
</div>
<div class="paragraph">
<p>不应将 SHA512 的默认值更改为较不安全的哈希算法，但可以更改为更安全的 Blowfish 算法。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Blowfish 不是 AES 的一部分，也不被认为符合任何联邦信息处理标准（ FIPS ）。在某些环境中可能不允许使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了确定用于加密用户密码的哈希算法，超级用户可以查看 FreeBSD 密码数据库中用户的哈希值。每个哈希值都以一个符号开头，该符号指示用于加密密码的哈希机制的类型。</p>
</div>
<div class="paragraph">
<p>如果使用 DES 加密算法，没有起始符号。对于 MD5 算法，起始符号是 ` $ ` 。对于 SHA256 和 SHA512 算法，起始符号是 ` $ 6 $ ` 。对于 Blowfish 算法，起始符号是 ` $ 2a $ ` 。在这个例子中，用户 <code>imani</code> 的密码使用默认的 SHA512 算法进行哈希处理，因为哈希值以 ` $ 6 $ ` 开头。请注意，存储在密码数据库中的是加密后的哈希值，而不是密码本身。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># grep imani /etc/master.passwd</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>imani:$6$pzIjSvCAn.PBYQBA$PXpSeWPx3g5kscj3IMiM7tUEUSPmGexxta.8Lt9TGSi2lNQqYGKszsBPuGME0:1001:1001::0:0:imani:/usr/home/imani:/bin/sh</pre>
</div>
</div>
<div class="paragraph">
<p>哈希机制是设置在用户的登录类中的。</p>
</div>
<div class="paragraph">
<p>可以运行以下命令来检查当前使用的哈希机制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># grep user /etc/master.passwd</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:passwd_format=sha512:\</pre>
</div>
</div>
<div class="paragraph">
<p>例如，要将算法更改为 Blowfish ，将该行修改为以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:passwd_format=blf:\</pre>
</div>
</div>
<div class="paragraph">
<p>然后，必须执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=cap_mkdb&amp;sektion=1&amp;format=html">cap_mkdb(1)</a> 命令来升级 login.conf 数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cap_mkdb /etc/login.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，此更改不会影响任何现有的密码哈希值。这意味着所有密码都应通过要求用户运行 <code>passwd</code> 来重新哈希，以更改他们的密码。</p>
</div>
</div>
<div class="sect3">
<h4 id="security-pwpolicy">16.3.3. 密码策略强制执行<a class="anchor" href="#security-pwpolicy"></a></h4>
<div class="paragraph">
<p>对本地账户强制执行强密码策略是系统安全的基本方面。在 FreeBSD 中，可以使用内置的可插拔认证模块（ PAM ）来实现密码长度、密码强度和密码复杂性。</p>
</div>
<div class="paragraph">
<p>本节演示了如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pam_passwdqc&amp;sektion=8&amp;format=html">pam_passwdqc(8)</a> 模块配置最小和最大密码长度以及强制使用混合字符。当用户更改密码时，将强制执行此模块。</p>
</div>
<div class="paragraph">
<p>要配置此模块，请成为超级用户，并取消注释包含 <code>pam_passwdqc.so</code> 的行，位于 <span class="filename">/etc/pam.d/passwd</span> 文件中。</p>
</div>
<div class="paragraph">
<p>然后，编辑该行以符合密码策略：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>password        requisite       pam_passwdqc.so         min=disabled,disabled,disabled,12,10 similar=deny retry=3 enforce=users</pre>
</div>
</div>
<div class="paragraph">
<p>参数的解释可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=pam_passwdqc&amp;sektion=8&amp;format=html">pam_passwdqc(8)</a> 中找到。</p>
</div>
<div class="paragraph">
<p>一旦保存了这个文件，用户更改密码时将看到类似以下的消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>passwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Changing local password for user
Old Password:

You can now choose the new password.
A valid password should be a mix of upper and lower case letters,
digits and other characters.  You can use a 12 character long
password with characters from at least 3 of these 4 classes, or
a 10 character long password containing characters from all the
classes.  Characters that form a common pattern are discarded by
the check.
Alternatively, if no one else can see your terminal now, you can
pick this as your password: &#34;trait-useful&amp;knob&#34;.
Enter new password:</pre>
</div>
</div>
<div class="paragraph">
<p>如果输入的密码不符合策略要求，系统将拒绝并发出警告，用户将有机会再次尝试，最多可以重试配置的次数。</p>
</div>
<div class="paragraph">
<p>如果您的组织政策要求密码过期， FreeBSD 支持在用户的登录类中使用 <code>passwordtime</code> 选项，该选项可以在 [/etc/login.conf](/etc/login.conf) 文件中设置。</p>
</div>
<div class="paragraph">
<p><code>default</code> 登录类包含一个示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#       :passwordtime=90d:\</pre>
</div>
</div>
<div class="paragraph">
<p>因此，要为此登录类设置 90 天的到期时间，删除注释符号（＃），保存编辑，并执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cap_mkdb /etc/login.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要为单个用户设置过期时间，请将过期日期或到期天数以及用户名传递给 <code>pw</code> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw usermod -p 30-apr-2025 -n user</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如图所示，过期日期以日、月和年的形式设置。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="security-sudo">16.3.4. 使用 sudo 进行共享管理<a class="anchor" href="#security-sudo"></a></h4>
<div class="paragraph">
<p>系统管理员经常需要能够授予用户增强的权限，以便他们可以执行特权任务。团队成员被授予访问 FreeBSD 系统以执行他们的特定任务的想法，给每个管理员带来了独特的挑战。这些团队成员只需要超出普通用户级别的一部分访问权限；然而，他们几乎总是告诉管理层，如果没有超级用户访问权限，他们无法执行任务。幸运的是，没有必要为终端用户提供这样的访问权限，因为存在可以管理这个确切需求的工具。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>即使是管理员，在不需要时也应该限制他们的权限。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>到目前为止，安全章节已经涵盖了允许授权用户访问和防止未经授权访问的内容。一旦授权用户获得系统资源的访问权限，另一个问题就出现了。在许多情况下，一些用户可能需要访问应用程序启动脚本，或者一个管理员团队需要维护系统。传统上，标准用户和组、文件权限，甚至 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 命令都可以管理这种访问权限。随着应用程序需要更多的访问权限，越来越多的用户需要使用系统资源，需要一个更好的解决方案。目前最常用的应用程序是 Sudo 。</p>
</div>
<div class="paragraph">
<p>Sudo 允许管理员对系统命令进行更严格的访问配置，并提供一些高级日志记录功能。作为一个工具，可以通过 Ports Collection 中的 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/sudo/">security/sudo</a> 包或使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 实用程序来获取。</p>
</div>
<div class="paragraph">
<p>执行以下命令进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install sudo</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>安装完成后，安装的 <code>visudo</code> 将使用文本编辑器打开配置文件。强烈建议使用 <code>visudo</code> ，因为它内置了语法检查器，可以在保存文件之前验证是否存在错误。</p>
</div>
<div class="paragraph">
<p>配置文件由几个小节组成，允许进行广泛的配置。在下面的示例中， Web 应用程序维护者 user1 需要启动、停止和重新启动名为_webservice_的 Web 应用程序。为了授予该用户执行这些任务的权限，请将以下行添加到 <span class="filename">/usr/local/etc/sudoers</span> 文件的末尾：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>user1   ALL=(ALL)       /usr/sbin/service webservice *</pre>
</div>
</div>
<div class="paragraph">
<p>用户现在可以使用以下命令启动_webservice_：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sudo /usr/sbin/service webservice start</code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这个配置允许单个用户访问 webservice 服务；然而，在大多数组织中，有一个完整的网络团队负责管理该服务。一条单独的命令也可以给整个组提供访问权限。以下步骤将创建一个网络组，将用户添加到该组，并允许该组的所有成员管理该服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupadd -g 6001 -n webteam</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用相同的 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 命令，将用户添加到 webteam 组中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupmod -m user1 -n webteam</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，这行代码在文件 [/usr/local/etc/sudoers] 中允许 webteam 组的任何成员管理_webservice_。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>%webteam   ALL=(ALL)       /usr/sbin/service webservice *</pre>
</div>
</div>
<div class="paragraph">
<p>与 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 不同， <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 只需要最终用户的密码。这样可以避免共享密码，这是一种不好的做法。</p>
</div>
<div class="paragraph">
<p>只有被允许使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 运行应用程序的用户需要输入自己的密码。这比使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 更安全，并且提供了更好的控制，因为在 <a href="https://man.freebsd.org/cgi/man.cgi?query=su&amp;sektion=1&amp;format=html">su(1)</a> 中需要输入 <code>root</code> 密码，用户将获得所有 <code>root</code> 权限。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>大多数组织正在转向或已经采用了双因素认证模型。在这些情况下，用户可能没有密码可输入。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 可以通过使用 <code>NOPASSWD</code> 变量来配置允许双因素认证模型。将其添加到上述配置中将允许_webteam_组的所有成员在不需要密码的情况下管理该服务。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>%webteam   ALL=(ALL)       NOPASSWD: /usr/sbin/service webservice *</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="security-doas">16.3.5. 使用 Doas 进行共享管理<a class="anchor" href="#security-doas"></a></h4>
<div class="paragraph">
<p>在计算机系统中，共享管理是一种允许多个用户共同管理系统的方法。 Doas 是一种用于 Unix-like 操作系统的工具，它提供了一种简单而安全的方式来实现共享管理。</p>
</div>
<div class="paragraph">
<p>使用 Doas ，管理员可以授予其他用户执行特定任务的权限，而无需将完整的管理员权限授予他们。这种方式可以有效地限制用户的权限，从而减少潜在的安全风险。</p>
</div>
<div class="literalblock">
<div class="content">
<pre>Doas 的配置非常灵活，管理员可以根据需要定义不同的规则。这些规则可以指定允许执行的命令、允许执行命令的用户以及其他限制条件。通过这种方式，管理员可以精确地控制用户的权限，确保系统的安全性。</pre>
</div>
</div>
<div class="paragraph">
<p>总之，使用 Doas 进行共享管理可以提供一种简单而有效的方式来管理计算机系统。它可以帮助管理员限制用户的权限，减少潜在的安全风险，并提高系统的安全性。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=doas&amp;sektion=1&amp;format=html">doas(1)</a> 是一个从 OpenBSD 移植过来的命令行实用程序。它作为 Unix-like 系统中广泛使用的 <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 命令的替代品。</p>
</div>
<div class="paragraph">
<p>使用 doas ，用户可以以提升的权限执行命令，通常是作为 root 用户，同时保持简化和注重安全的方法。与 <a href="https://man.freebsd.org/cgi/man.cgi?query=sudo&amp;sektion=8&amp;format=html">sudo(8)</a> 不同， doas 强调简单和极简主义，专注于简化的权限委派，而不是提供过多的配置选项。</p>
</div>
<div class="paragraph">
<p>执行以下命令进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install doas</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>安装完成后，必须配置 <span class="filename">/usr/local/etc/doas.conf</span> ，以授予用户对特定命令或角色的访问权限。</p>
</div>
<div class="paragraph">
<p>最简单的条目可以是以下内容，它在执行 doas 命令时授予用户 <code>local_user</code> 以 <code>root</code> 权限，而无需输入密码。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>permit nopass local_user as root</pre>
</div>
</div>
<div class="paragraph">
<p>在安装和配置 <code>doas</code> 实用程序之后，现在可以使用增强的权限执行命令，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">$ </span>doas vi /etc/rc.conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>要获取更多的配置示例，请阅读 <a href="https://man.freebsd.org/cgi/man.cgi?query=doas.conf&amp;sektion=5&amp;format=html">doas.conf(5)</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-ids">16.4. 入侵检测系统（ IDS ）<a class="anchor" href="#security-ids"></a></h3>
<div class="paragraph">
<p>验证系统文件和二进制文件的重要性在于为系统管理和安全团队提供有关系统变化的信息。监控系统变化的软件应用程序称为入侵检测系统（ IDS ）。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供了对一种名为 <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a> 的基本 IDS 系统的本地支持。虽然每晚的安全电子邮件会通知管理员有关系统变更的信息，但这些信息是存储在本地的，恶意用户有可能修改这些信息以隐藏对系统的更改。因此，建议创建一个单独的二进制签名集，并将其存储在只读、属于 root 的目录上，或者更好地，存储在可移动的 USB 磁盘或远程服务器上。</p>
</div>
<div class="paragraph">
<p>每次更新后，建议运行 <code>freebsd-update IDS</code> 。</p>
</div>
<div class="sect3">
<h4 id="security-ids-generate-spec-file">16.4.1. 生成规范文件<a class="anchor" href="#security-ids-generate-spec-file"></a></h4>
<div class="paragraph">
<p>内置的 <a href="https://man.freebsd.org/cgi/man.cgi?query=mtree&amp;sektion=8&amp;format=html">mtree(8)</a> 实用程序可用于生成目录内容的规范。使用种子或数字常量生成规范，并且需要使用种子来检查规范是否发生了变化。这使得可以确定文件或二进制文件是否已被修改。由于攻击者不知道种子值，因此伪造或检查文件的校验和值将变得困难或几乎不可能。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>建议为包含二进制文件和配置文件的目录以及包含敏感数据的目录创建规范。通常，会为 /bin 、 /sbin 、 /usr/bin 、 /usr/sbin 、 /usr/local/bin 、 /etc 和 /usr/local/etc 创建规范。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>以下示例生成一组 <code>sha512</code> 哈希值，每个哈希值对应于 <span class="filename">/bin</span> 目录中的系统二进制文件，并将这些值保存到用户主目录下的隐藏文件 <span class="filename">/home/user/.bin_chksum_mtree</span> 中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mtree -s 123456789 -c -K cksum,sha512 -p /bin &gt; /home/user/.bin_chksum_mtree</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>mtree: /bin checksum: 3427012225</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>123456789</code> 值代表种子，应该随机选择。这个值应该被记住， * 但不要分享 * 。</p>
</div>
<div class="paragraph">
<p>将种子值和校验和输出对恶意用户保密是很重要的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="security-ids-spec-file-structure">16.4.2. 规范文件结构<a class="anchor" href="#security-ids-spec-file-structure"></a></h4>
<div class="paragraph">
<p>mtree 格式是一种描述文件系统对象集合的文本格式。这种文件通常用于创建或验证目录层次结构。</p>
</div>
<div class="paragraph">
<p>一个 mtree 文件由一系列行组成，每行提供有关单个文件系统对象的信息。前导空格始终被忽略。</p>
</div>
<div class="paragraph">
<p>上面创建的规范文件将用于解释格式和内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#          user: root <i class="conum" data-value="1"></i><b>(1)</b>
#       machine: machinename <i class="conum" data-value="2"></i><b>(2)</b>
#          tree: /bin <i class="conum" data-value="3"></i><b>(3)</b>
#          date: Thu Aug  24 21:58:37 2023 <i class="conum" data-value="4"></i><b>(4)</b>

# .
/set type=file uid=0 gid=0 mode=0555 nlink=1 flags=uarch <i class="conum" data-value="5"></i><b>(5)</b>
.               type=dir mode=0755 nlink=2 time=1681388848.239523000 <i class="conum" data-value="6"></i><b>(6)</b>
    \133        nlink=2 size=12520 time=1685991378.688509000 \
                cksum=520880818 \
                sha512=5c1374ce0e2ba1b3bc5a41b23f4bbdc1ec89ae82fa01237f376a5eeef41822e68f1d8f75ec46b7bceb65396c122a9d837d692740fdebdcc376a05275adbd3471
    cat         size=14600 time=1685991378.694601000 cksum=3672531848 \ <i class="conum" data-value="7"></i><b>(7)</b>
                sha512=b30b96d155fdc4795432b523989a6581d71cdf69ba5f0ccb45d9b9e354b55a665899b16aee21982fffe20c4680d11da4e3ed9611232a775c69f926e5385d53a2
    chflags     size=8920 time=1685991378.700385000 cksum=1629328991 \
                sha512=289a088cbbcbeb436dd9c1f74521a89b66643976abda696b99b9cc1fbfe8b76107c5b54d4a6a9b65332386ada73fc1bbb10e43c4e3065fa2161e7be269eaf86a
    chio        size=20720 time=1685991378.706095000 cksum=1948751604 \
                sha512=46f58277ff16c3495ea51e74129c73617f31351e250315c2b878a88708c2b8a7bb060e2dc8ff92f606450dbc7dd2816da4853e465ec61ee411723e8bf52709ee
    chmod       size=9616 time=1685991378.712546000 cksum=4244658911 \
                sha512=1769313ce08cba84ecdc2b9c07ef86d2b70a4206420dd71343867be7ab59659956f6f5a458c64e2531a1c736277a8e419c633a31a8d3c7ccc43e99dd4d71d630</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>创建规范的用户。 &lt;.&gt; 机器的主机名。 &lt;.&gt; 目录路径。 &lt;.&gt; 规范创建的日期和时间。 &lt;.&gt; <code>/set</code> 特殊命令，定义从分析的文件中获取的一些设置。 &lt;.&gt; 指的是解析的目录，并指示其类型、模式、硬链接数量和自修改以来的 UNIX 格式时间。 &lt;.&gt; 指的是文件，显示大小、时间和一系列哈希值以验证完整性。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="security-ids-verify-specification-file">16.4.3. 验证规范文件<a class="anchor" href="#security-ids-verify-specification-file"></a></h4>
<div class="paragraph">
<p>为了验证二进制签名是否发生了变化，将当前目录的内容与先前生成的规范进行比较，并将结果保存到文件中。</p>
</div>
<div class="paragraph">
<p>该命令需要用于生成原始规范的种子。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mtree -s 123456789 -p /bin &lt; /home/user/.bin_chksum_mtree &gt;&gt; /home/user/.bin_chksum_output</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该会为 <span class="filename">/bin</span> 生成与创建规范时相同的校验和。如果在此目录中的二进制文件没有发生任何更改， <span class="filename">/home/user/.bin_chksum_output</span> 输出文件将为空。</p>
</div>
<div class="paragraph">
<p>为了模拟一个变化，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=touch&amp;sektion=1&amp;format=html">touch(1)</a> 命令更改 <span class="filename">/bin/cat</span> 的日期，然后再次运行验证命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># touch /bin/cat</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>再次运行验证命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mtree -s 123456789 -p /bin &lt; /home/user/.bin_chksum_mtree &gt;&gt; /home/user/.bin_chksum_output</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后检查输出文件的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat /root/.bin_chksum_output</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cat:    modification time (Fri Aug 25 13:30:17 2023, Fri Aug 25 13:34:20 2023)</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这只是一个示例，展示执行命令时将显示的元数据更改。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-secure-levels">16.5. 安全级别<a class="anchor" href="#security-secure-levels"></a></h3>
<div class="paragraph">
<p>securelevel 是内核中实现的一种安全机制。当 securelevel 为正数时，内核会限制某些任务的执行；即使是超级用户（ root ）也不被允许执行这些任务。</p>
</div>
<div class="paragraph">
<p>securelevel 机制限制了以下能力：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>取消特定文件标志，例如 <code>schg</code> （系统不可变标志）。</p>
</li>
<li>
<p>通过 <span class="filename">/dev/mem</span> 和 <span class="filename">/dev/kmem</span> 来写入内核内存。</p>
</li>
<li>
<p>加载内核模块。</p>
</li>
<li>
<p>修改防火墙规则。</p>
</li>
</ul>
</div>
<div class="sect3">
<h4 id="security-secure-levels-definitions">16.5.1. 安全级别定义<a class="anchor" href="#security-secure-levels-definitions"></a></h4>
<div class="paragraph">
<p>内核运行在五个不同的安全级别下。任何超级用户进程都可以提升级别，但没有进程可以降低级别。</p>
</div>
<div class="paragraph">
<p>安全定义如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">-1</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>永久不安全模式 * - 始终以不安全模式运行系统。
这是默认的初始值。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">0</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>不安全模式 * - 可以关闭不可变和仅追加标志。
所有设备都可以根据其权限进行读取或写入。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">1</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>安全模式 * - 系统的不可变和系统的只追加标志不能被关闭；
挂载的文件系统的磁盘、 [/dev/mem](/dev/mem) 和 [/dev/kmem](/dev/kmem) 不能被打开以进行写操作；
 [/dev/io](/dev/io) （如果您的平台有的话）不能被打开；
内核模块（参见 <a href="https://man.freebsd.org/cgi/man.cgi?query=kld&amp;sektion=4&amp;format=html">kld(4)</a> ）不能被加载或卸载。
不能使用 debug.kdb.enter sysctl 进入内核调试器。
不能使用 debug.kdb.panic 、 debug.kdb.panic_str 和其他 sysctl 来强制发生恐慌或陷阱。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">2</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>高度安全模式 * - 与安全模式相同，但是除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=2&amp;format=html">mount(2)</a> 之外，不允许打开磁盘进行写入操作，无论是否已挂载。
这个级别防止通过卸载文件系统来篡改它们，但同时也阻止在系统处于多用户状态下运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> 。</p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">3</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>网络安全模式 * - 与高度安全模式相同，还包括无法更改 IP 数据包过滤规则（参见 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfirewall&amp;sektion=4&amp;format=html">ipfirewall(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> ），以及无法调整 <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=pf&amp;sektion=4&amp;format=html">pf(4)</a> 配置。</p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>总结一下，在 FreeBSD 安全级别中，“永久不安全模式”和“不安全模式”的关键区别在于它们提供的安全程度。“永久不安全模式”完全解除了所有安全限制，而“不安全模式”放宽了一些限制，但仍保持一定的控制和安全性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="security-modify-secure-levels">16.5.2. 修改安全级别<a class="anchor" href="#security-modify-secure-levels"></a></h4>
<div class="paragraph">
<p>为了改变系统的安全级别，需要通过执行以下命令来激活 <code>kern_securelevel_enable</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kern_securelevel_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>kern_securelevel</code> 的值设置为所需的安全级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kern_securelevel=2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要检查运行中系统的安全级别状态，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl -n kern.securelevel</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出包含了当前安全级别的值。如果该值大于 0 ，则表示安全级别的一些保护功能已经启用。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>-1</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-file-flags">16.6. 文件标志<a class="anchor" href="#security-file-flags"></a></h3>
<div class="paragraph">
<p>文件标志允许用户在基本权限和所有权之外，为文件和目录附加额外的元数据或属性。这些标志提供了一种控制文件的各种行为和属性的方式，而无需创建特殊目录或使用扩展属性。</p>
</div>
<div class="paragraph">
<p>文件标志可以用于实现不同的目标，比如防止文件被删除，使文件只能追加，同步文件更新等等。在 FreeBSD 中，一些常用的文件标志包括&#34;immutable&#34;标志，它防止文件被修改或删除，以及&#34;append-only&#34;标志，它只允许在文件末尾添加数据，而不能修改或删除数据。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 命令来管理这些标志，为管理员和用户提供对其文件和目录的行为和特性具有更大的控制权。需要注意的是，文件标志通常由 root 用户或具有适当权限的用户管理，因为它们可以影响文件的访问和操作方式。一些标志可供文件所有者使用，详见 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 。</p>
</div>
<div class="sect3">
<h4 id="security-work-file-flag">16.6.1. 处理文件标志<a class="anchor" href="#security-work-file-flag"></a></h4>
<div class="paragraph">
<p>在这个例子中，用户的主目录中有一个名为 ` ~ /important.txt` 的文件，希望对其进行防删除保护。</p>
</div>
<div class="paragraph">
<p>执行以下命令来设置 <code>schg</code> 文件标志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chflags schg ~/important.txt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当任何用户，包括 <code>root</code> 用户，尝试删除该文件时，系统将显示以下消息：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rm: important.txt: Operation not permitted</pre>
</div>
</div>
<div class="paragraph">
<p>要删除该文件，需要执行以下命令来删除该文件的文件标志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chflags noschg ~/important.txt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 中找到支持的文件标志及其功能的列表。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="openssh">16.7. OpenSSH 是一个用于安全远程登录和文件传输的开源软件套件。它提供了加密的通信通道，以防止未经授权的访问和数据泄露。 OpenSSH 支持 SSH 协议，可以在不同的操作系统上运行，并且具有强大的身份验证和加密功能。它被广泛用于管理远程服务器和保护敏感数据的传输。<a class="anchor" href="#openssh"></a></h3>
<div class="paragraph">
<p>OpenSSH 是一组网络连接工具，用于提供对远程机器的安全访问。此外，可以通过 SSH 连接安全地隧道或转发 TCP/IP 连接。 OpenSSH 对所有流量进行加密，以消除窃听、连接劫持和其他网络级攻击。</p>
</div>
<div class="paragraph">
<p>OpenSSH 由 OpenBSD 项目维护，并且在 FreeBSD 中默认安装。</p>
</div>
<div class="paragraph">
<p>当数据以未加密的形式通过网络发送时，位于客户端和服务器之间的网络嗅探器可以窃取用户 / 密码信息或在会话期间传输的数据。 OpenSSH 提供了各种身份验证和加密方法，以防止这种情况发生。</p>
</div>
<div class="paragraph">
<p>有关 OpenSSH 的更多信息，请访问链接： <a href="https://www.openssh.com/">网页</a> 。</p>
</div>
<div class="paragraph">
<p>本节提供了内置的客户端工具的概述，用于安全地访问其他系统并从 FreeBSD 系统安全地传输文件。然后，它描述了如何在 FreeBSD 系统上配置 SSH 服务器。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如上所述，本章将介绍 OpenSSH 的基本系统版本。 OpenSSH 的一个版本也可以在包 security/openssh-portable[] 中找到，该版本提供了额外的配置选项，并且定期更新。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_使用_ssh_客户端工具">16.7.1. 使用 SSH 客户端工具<a class="anchor" href="#_使用_ssh_客户端工具"></a></h4>
<div class="paragraph">
<p>要登录到 SSH 服务器，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 命令，并指定存在于该服务器上的用户名以及服务器的 IP 地址或主机名。如果这是第一次连接到指定的服务器，用户将被提示首先验证服务器的指纹：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ssh user@example.com</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>The authenticity of host &#39;example.com (10.0.0.1)&#39; can&#39;t be established.
ECDSA key fingerprint is 25:cc:73:b5:b3:96:75:3d:56:19:49:d2:5c:1f:91:3b.
Are you sure you want to continue connecting (yes/no)? yes
Permanently added &#39;example.com&#39; (ECDSA) to the list of known hosts.
Password for user@example.com: user_password</pre>
</div>
</div>
<div class="paragraph">
<p>SSH 利用密钥指纹系统来验证客户端连接时服务器的真实性。当用户在首次连接时通过输入 <code>yes</code> 接受密钥的指纹时，密钥的副本将保存在用户的主目录下的 [.filename]# ~ /.ssh/known_hosts# 文件中。将来的登录尝试将根据保存的密钥进行验证，如果服务器的密钥与保存的密钥不匹配， <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 将显示警告。如果发生这种情况，用户应该首先验证密钥为何发生变化，然后再继续连接。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如何执行此检查超出了本章的范围。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> 命令可以安全地将文件从本地复制到远程机器，或者从远程机器复制到本地。</p>
</div>
<div class="paragraph">
<p>这个例子将远程系统上的 <code>COPYRIGHT</code> 文件复制到本地系统当前目录下同名的文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># scp user@example.com:/COPYRIGHT COPYRIGHT</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Password for user@example.com: *******
COPYRIGHT            100% |*****************************|  4735</pre>
</div>
</div>
<div class="paragraph">
<p>由于该主机的指纹已经验证过，因此在提示用户输入密码之前，服务器的密钥会自动进行检查。</p>
</div>
<div class="paragraph">
<p>传递给 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> 的参数与 <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a> 类似。要复制的文件或文件是第一个参数，要复制到的目标是第二个参数。由于文件是通过网络获取的，因此一个或多个文件参数采用 <code>user @ host:&lt;path_to_remote_file&gt;</code> 的形式。在递归复制目录时，请注意 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> 使用 <code>-r</code> ，而 <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a> 使用 <code>-R</code> 。</p>
</div>
<div class="paragraph">
<p>要打开一个用于复制文件的交互式会话，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> 。</p>
</div>
<div class="paragraph">
<p>在 <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> 会话中，可以参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> 获取可用命令的列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="security-ssh-keygen">16.7.2. 基于密钥的身份验证<a class="anchor" href="#security-ssh-keygen"></a></h4>
<div class="paragraph">
<p>客户端可以配置为使用密钥连接到远程机器，而不是使用密码。出于安全原因，这是首选的方法。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh-keygen&amp;sektion=1&amp;format=html">ssh-keygen(1)</a> 可以用来生成身份验证密钥。要生成公钥和私钥对，请指定密钥类型并按照提示操作。建议使用易于记住但难以猜测的密码来保护密钥。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ssh-keygen -t rsa -b 4096</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Generating public/private rsa key pair.
Enter file in which to save the key (/home/user/.ssh/id_rsa):
Created directory &#39;/home/user/.ssh/.ssh&#39;.
Enter passphrase (empty for no passphrase):
Enter same passphrase again:
Your identification has been saved in /home/user/.ssh/id_rsa.
Your public key has been saved in /home/user/.ssh/id_rsa.pub.
The key fingerprint is:
SHA256:54Xm9Uvtv6H4NOo6yjP/YCfODryvUU7yWHzMqeXwhq8 user@host.example.com
The key&#39;s randomart image is:
+---[RSA 2048]----+
|                 |
|                 |
|                 |
|        . o..    |
|       .S*+*o    |
|      . O=Oo . . |
|       = Oo= oo..|
|      .oB.* +.oo.|
|       =OE**.o..=|
+----[SHA256]-----+</pre>
</div>
</div>
<div class="paragraph">
<p>私钥存储在 [.filename]# ~ /.ssh/id_rsa# 中，公钥存储在 [.filename]# ~ /.ssh/id_rsa.pub# 中。为了使基于密钥的身份验证工作，必须将公钥复制到远程机器上的 [.filename]# ~ /.ssh/authorized_keys# 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为 OpenSSH 密钥使用密码短语是一种关键的安全实践，可以提供额外的保护层，防止未经授权的访问，并增强整体网络安全性。</p>
</div>
<div class="paragraph">
<p>在遗失或被盗的情况下，这增加了另一层安全保障。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="security-ssh-tunneling">16.7.3. SSH 隧道<a class="anchor" href="#security-ssh-tunneling"></a></h4>
<div class="paragraph">
<p>OpenSSH 具有创建隧道的能力，可以在加密会话中封装另一种协议。</p>
</div>
<div class="paragraph">
<p>以下命令告诉 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 创建一个隧道：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ssh -D 8080 user@example.com</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子使用了以下选项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">-D 是一个命令行选项，通常用于指定程序的调试模式。在计算机编程中，调试模式允许程序员在程序运行时跟踪和调试代码，以便找到和修复错误。使用 -D 选项可以启用调试模式，并提供额外的调试信息和功能。</dt>
<dd>
<p>指定了一个本地的“动态”应用层端口转发。</p>
</dd>
<dt class="hdlist1">用户@ foo.example.com</dt>
<dd>
<p>在指定的远程 SSH 服务器上使用的登录名。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>SSH 隧道通过在指定的 <code>localport</code> 上在 <code>localhost</code> 上创建一个监听套接字来工作。</p>
</div>
<div class="paragraph">
<p>这种方法可以用来包装任意数量的不安全的 TCP 协议，如 SMTP 、 POP3 和 FTP 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_启用_ssh_服务器">16.7.4. 启用 SSH 服务器<a class="anchor" href="#_启用_ssh_服务器"></a></h4>
<div class="paragraph">
<p>除了提供内置的 SSH 客户端工具外， FreeBSD 系统还可以配置为 SSH 服务器，接受来自其他 SSH 客户端的连接。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>正如所述，本章将涵盖 OpenSSH 的基本系统版本。请 * 不要 * 与 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/openssh-portable/">security/openssh-portable</a> 混淆，后者是随 FreeBSD ports 一起提供的 OpenSSH 版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了在重新启动后启用 SSH 服务器，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc sshd_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后执行以下命令以启用该服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service sshd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 FreeBSD 系统上首次启动 sshd 时，系统的主机密钥将会自动创建，并且指纹将会显示在控制台上。提供用户指纹，以便他们在首次连接服务器时进行验证。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 以获取在启动 sshd 时可用的选项列表，以及有关身份验证、登录过程和各种配置文件的更完整的讨论。</p>
</div>
<div class="paragraph">
<p>在这一点上， sshd 应该对系统上所有具有用户名和密码的用户可用。</p>
</div>
</div>
<div class="sect3">
<h4 id="config-publickey-auth">16.7.5. 配置公钥身份验证方法<a class="anchor" href="#config-publickey-auth"></a></h4>
<div class="paragraph">
<p>通过配置 OpenSSH 使用公钥身份验证，可以通过利用非对称加密进行身份验证来增强安全性。这种方法消除了与密码相关的风险，例如弱密码或在传输过程中的拦截，同时阻止了各种基于密码的攻击。然而，确保私钥受到良好保护以防止未经授权的访问非常重要。</p>
</div>
<div class="paragraph">
<p>第一步是配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 以使用所需的身份验证方法。</p>
</div>
<div class="paragraph">
<p>编辑 <span class="filename">/etc/ssh/sshd_config</span> 文件，并取消以下配置的注释：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>PubkeyAuthentication yes</pre>
</div>
</div>
<div class="paragraph">
<p>一旦配置完成，用户将需要将他们的 * 公钥 * 发送给系统管理员，这些密钥将被添加到 <span class="filename">.ssh/authorized_keys</span> 文件中。生成密钥的过程在 &lt;&lt; 基于密钥的身份验证 &gt;&gt; 中描述。</p>
</div>
<div class="paragraph">
<p>然后执行以下命令重新启动服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service sshd reload</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>强烈建议按照 <a href="#security-sshd-security-options">SSH 服务器安全选项</a> 中指示的安全改进措施进行操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="security-sshd-security-options">16.7.6. SSH 服务器安全选项<a class="anchor" href="#security-sshd-security-options"></a></h4>
<div class="paragraph">
<p>尽管 sshd 是 FreeBSD 最广泛使用的远程管理工具，但暴力破解和驱动攻击对于任何暴露在公共网络中的系统来说都是常见的。</p>
</div>
<div class="paragraph">
<p>本节将介绍几个可用的额外参数，以防止这些攻击的成功。所有配置都将在 [/etc/ssh/sshd_config] 文件中完成。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不要将 <span class="filename">/etc/ssh/sshd_config</span> 与 <span class="filename">/etc/ssh/ssh_config</span> 混淆（注意第一个文件名中多了一个 <code>d</code> ）。第一个文件配置服务器，第二个文件配置客户端。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh_config&amp;sektion=5&amp;format=html">ssh_config(5)</a> 以获取可用客户端设置的列表。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>默认情况下，可以使用公钥和密码进行身份验证。为了仅允许公钥身份验证（强烈推荐），请更改变量：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>PasswordAuthentication no</pre>
</div>
</div>
<div class="paragraph">
<p>在 OpenSSH 服务器配置文件中使用 <code>AllowUsers</code> 关键字限制哪些用户可以登录 SSH 服务器以及从哪里登录是一个好主意。例如，要仅允许 <code>user</code> 从 <code>192.168.1.32</code> 登录，将以下行添加到 <code>/etc/ssh/sshd_config</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>AllowUsers user@192.168.1.32</pre>
</div>
</div>
<div class="paragraph">
<p>为了允许 <code>user</code> 从任何地方登录，列出该用户而不指定 IP 地址：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>AllowUsers user</pre>
</div>
</div>
<div class="paragraph">
<p>多个用户应该在同一行上列出，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>AllowUsers root@192.168.1.32 user</pre>
</div>
</div>
<div class="paragraph">
<p>在进行所有更改之后，在重新启动服务之前，建议通过执行以下命令来验证所做的配置是否正确：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sshd -t</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果配置文件正确，将不会显示任何输出。如果配置文件不正确，将会显示类似以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/etc/ssh/sshd_config: line 3: Bad configuration option: sdadasdasdasads
/etc/ssh/sshd_config: terminating, 1 bad configuration options</pre>
</div>
</div>
<div class="paragraph">
<p>在进行更改并确认配置文件正确后，通过运行以下命令告诉 sshd 重新加载其配置文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service sshd reload</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="openssl">16.8. OpenSSL 是一个开源的软件库，提供了一套用于安全通信的加密工具。它支持多种加密算法和协议，包括 SSL 和 TLS 。 OpenSSL 广泛用于网络通信、数字证书管理和数据加密等领域。它是一个功能强大且可靠的工具，被广泛应用于各种计算机系统和应用程序中。<a class="anchor" href="#openssl"></a></h3>
<div class="paragraph">
<p>OpenSSL 是一个实现安全套接字层（ SSL ）和传输层安全（ TLS ）网络协议以及许多密码学例程的密码学工具包。</p>
</div>
<div class="paragraph">
<p>openssl 程序是一个命令行工具，用于在 shell 中使用 OpenSSL 的加密库的各种加密功能。它可以用于</p>
</div>
<div class="ulist">
<ul>
<li>
<p>私钥、公钥和参数的创建和管理</p>
</li>
<li>
<p>公钥加密操作</p>
</li>
<li>
<p>创建 X.509 证书、证书签名请求（ CSR ）和证书撤销列表（ CRL ）</p>
</li>
<li>
<p>消息摘要的计算</p>
</li>
<li>
<p>使用密码进行加密和解密</p>
</li>
<li>
<p>SSL/TLS 客户端和服务器测试</p>
</li>
<li>
<p>处理 S/MIME 签名或加密邮件</p>
</li>
<li>
<p>时间戳请求、生成和验证</p>
</li>
<li>
<p>对加密算法进行基准测试</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>有关 OpenSSL 的更多信息，请阅读免费的《 OpenSSL Cookbook 》（ <a href="https://www.feistyduck.com/books/openssl-cookbook/" class="bare">https://www.feistyduck.com/books/openssl-cookbook/</a> ）。</p>
</div>
<div class="sect3">
<h4 id="generating-certificates">16.8.1. 生成证书<a class="anchor" href="#generating-certificates"></a></h4>
<div class="paragraph">
<p>OpenSSL 支持生成证书，既可以由证书颁发机构（ CA ）验证，也可以供自己使用。</p>
</div>
<div class="paragraph">
<p>运行命令 <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl&amp;sektion=1&amp;format=html">openssl(1)</a> 以使用以下参数生成一个有效的证书，用于一个名为 <a href="https://en.wikipedia.org/wiki/Certificate_authority">CA</a> 的证书颁发机构。该命令将在当前目录中创建两个文件。证书请求文件 <span class="filename">req.pem</span> 可以发送给 <a href="https://en.wikipedia.org/wiki/Certificate_authority">CA</a> ，该机构将验证输入的凭据，签署请求并返回签署后的证书。第二个文件 <span class="filename">cert.key</span> 是证书的私钥，应存放在安全的位置。如果该私钥落入他人之手，可能被用来冒充用户或服务器。</p>
</div>
<div class="paragraph">
<p>执行以下命令以生成证书：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl req -new -nodes -out req.pem -keyout cert.key -sha3-512 -newkey rsa:4096</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Generating a RSA private key
..................................................................................................................................+++++
......................................+++++
writing new private key to &#39;cert.key&#39;
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [AU]:ES
State or Province Name (full name) [Some-State]:Valencian Community
Locality Name (eg, city) []:Valencia
Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Company
Organizational Unit Name (eg, section) []:Systems Administrator
Common Name (e.g. server FQDN or YOUR name) []:localhost.example.org
Email Address []:user@FreeBSD.org

Please enter the following &#39;extra&#39; attributes
to be sent with your certificate request
A challenge password []:123456789
An optional company name []:Another name</pre>
</div>
</div>
<div class="paragraph">
<p>或者，如果不需要来自 [CA](<a href="https://en.wikipedia.org/wiki/Certificate_authority" class="bare">https://en.wikipedia.org/wiki/Certificate_authority</a>) 的签名，可以创建自签名证书。这将在当前目录中创建两个新文件：私钥文件 <code>cert.key</code> 和证书本身 <code>cert.crt</code> 。这些文件应该放在一个目录中，最好是在 <code>/etc/ssl/</code> 下，该目录只能由 <code>root</code> 用户读取。对于这些文件，适当的权限是 <code>0700</code> ，可以使用 <code>chmod</code> 命令设置。</p>
</div>
<div class="paragraph">
<p>执行以下命令以生成证书：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl req -new -x509 -days 365 -sha3-512 -keyout /etc/ssl/private/cert.key -out /etc/ssl/certs/cert.crt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Generating a RSA private key
........................................+++++
...........+++++
writing new private key to &#39;/etc/ssl/private/cert.key&#39;
Enter PEM pass phrase:
Verifying - Enter PEM pass phrase:
-----
You are about to be asked to enter information that will be incorporated
into your certificate request.
What you are about to enter is what is called a Distinguished Name or a DN.
There are quite a few fields but you can leave some blank
For some fields there will be a default value,
If you enter &#39;.&#39;, the field will be left blank.
-----
Country Name (2 letter code) [AU]:ES
State or Province Name (full name) [Some-State]:Valencian Community
Locality Name (eg, city) []:Valencia
Organization Name (eg, company) [Internet Widgits Pty Ltd]:My Company
Organizational Unit Name (eg, section) []:Systems Administrator
Common Name (e.g. server FQDN or YOUR name) []:localhost.example.org
Email Address []:user@FreeBSD.org</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="fips-provider">16.8.2. 配置 FIPS 提供程序<a class="anchor" href="#fips-provider"></a></h4>
<div class="paragraph">
<p>随着 OpenSSL 3 进入基础系统（在 FreeBSD 14 及更高版本中），系统引入了其新的提供者模块概念。除了库中内置的默认提供者模块外，_legacy_模块实现了现在可选的已弃用的密码算法，而_fips_模块将 OpenSSL 实现限制为链接中存在的密码算法： <a href="https://en.wikipedia.org/wiki/Federal_Information_Processing_Standards">FIPS</a> 标准集。 OpenSSL 的这部分接受特别关注，包括一份相关安全问题的链接： <a href="https://www.openssl.org/news/fips-cve.html">列表</a> ，并定期进行 <a href="https://github.com/openssl/openssl/blob/master/README-FIPS.md">FIPS 140 验证过程</a> 。还提供了 <a href="https://www.openssl.org/source/">经 FIPS 验证的版本列表</a> 。这使得用户可以确保在使用 OpenSSL 时符合 FIPS 标准。</p>
</div>
<div class="paragraph">
<p>重要的是， <a href="https://man.freebsd.org/cgi/man.cgi?query=fips_module&amp;sektion=7&amp;format=html">fips_module(7)</a> 受到额外的安全措施保护，防止在未通过完整性检查的情况下使用。这个检查可以由本地系统管理员设置，允许 OpenSSL 3 的每个用户加载这个模块。当配置不正确时，预计 FIPS 模块将失败，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo test | openssl aes-128-cbc -a -provider fips -pbkdf2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>aes-128-cbc: unable to load provider fips
Hint: use -provider-path option or OPENSSL_MODULES environment variable.
00206124D94D0000:error:1C8000D5:Provider routines:SELF_TEST_post:missing config data:crypto/openssl/providers/fips/self_test.c:275:
00206124D94D0000:error:1C8000E0:Provider routines:ossl_set_error_state:fips module entering error state:crypto/openssl/providers/fips/self_test.c:373:
00206124D94D0000:error:1C8000D8:Provider routines:OSSL_provider_init_int:self test post failure:crypto/openssl/providers/fips/fipsprov.c:707:
00206124D94D0000:error:078C0105:common libcrypto routines:provider_init:init fail:crypto/openssl/crypto/provider_core.c:932:name=fips</pre>
</div>
</div>
<div class="paragraph">
<p>可以通过在 <span class="filename">/etc/ssl/fipsmodule.cnf</span> 中创建一个文件来配置检查，然后在 OpenSSL 的主配置文件 <span class="filename">/etc/ssl/openssl.cnf</span> 中引用该文件。 OpenSSL 提供了 <a href="https://man.freebsd.org/cgi/man.cgi?query=openssl-fipsinstall&amp;sektion=1&amp;format=html">openssl-fipsinstall(1)</a> 实用程序来帮助完成此过程，可以按照以下方式使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl fipsinstall -module /usr/lib/ossl-modules/fips.so -out /etc/ssl/fipsmodule.cnf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>INSTALL PASSED</pre>
</div>
</div>
<div class="paragraph">
<p>然后应该修改 <span class="filename">/etc/ssl/openssl.cnf</span> 文件，以便：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>包含上面生成的 <span class="filename">/etc/ssl/fipsmodule.cnf</span> 文件，</p>
</li>
<li>
<p>将 FIPS 模块暴露出来，以便可能的使用。</p>
</li>
<li>
<p>并显式激活默认模块。</p>
</li>
</ul>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[...]
# For FIPS
# Optionally include a file that is generated by the OpenSSL fipsinstall
# application. This file contains configuration data required by the OpenSSL
# fips provider. It contains a named section e.g. [fips_sect] which is
# referenced from the [provider_sect] below.
# Refer to the OpenSSL security policy for more information.
.include /etc/ssl/fipsmodule.cnf

[...]

# List of providers to load
[provider_sect]
default = default_sect
# The fips section name should match the section name inside the
# included fipsmodule.cnf.
fips = fips_sect

# If no providers are activated explicitly, the default one is activated implicitly.
# See man 7 OSSL_PROVIDER-default for more details.
#
# If you add a section explicitly activating any other provider(s), you most
# probably need to explicitly activate the default provider, otherwise it
# becomes unavailable in openssl.  As a consequence applications depending on
# OpenSSL may not work correctly which could lead to significant system
# problems including inability to remotely access the system.
[default_sect]
activate = 1</pre>
</div>
</div>
<div class="paragraph">
<p>完成这一步骤后，应该可以确认 FIPS 模块已经有效地可用并且正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo test | openssl aes-128-cbc -a -provider fips -pbkdf2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>enter AES-128-CBC encryption password:
Verifying - enter AES-128-CBC encryption password:
U2FsdGVkX18idooW6e3LqWeeiKP76kufcOUClh57j8U=</pre>
</div>
</div>
<div class="paragraph">
<p>每次修改 FIPS 模块时都必须重复执行此过程，例如在执行系统更新后或在应用影响基本系统中的 OpenSSL 的安全修复程序后。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="kerberos5">16.9. Kerberos 是一种网络身份验证协议，用于在计算机网络中验证用户的身份。它使用加密技术来确保通信的安全性，并防止身份伪造和中间人攻击。 Kerberos 还提供了单点登录功能，允许用户在一次身份验证后访问多个网络服务。它是计算机领域中常用的身份验证解决方案之一。<a class="anchor" href="#kerberos5"></a></h3>
<div class="paragraph">
<p>Kerberos 是一种网络认证协议，最初由麻省理工学院（ MIT ）创建，用于在可能存在敌对网络的情况下提供安全认证。 Kerberos 协议使用强加密技术，使得客户端和服务器可以在不发送任何未加密的秘密信息的情况下证明其身份。 Kerberos 可以被描述为一个身份验证代理系统和一个可信第三方认证系统。用户在使用 Kerberos 进行身份验证后，他们的通信可以被加密以确保隐私和数据完整性。</p>
</div>
<div class="paragraph">
<p>Kerberos 的唯一功能是在网络上提供用户和服务器的安全认证。它不提供授权或审计功能。建议将 Kerberos 与其他提供授权和审计服务的安全方法一起使用。</p>
</div>
<div class="paragraph">
<p>协议的当前版本是版本 5 ，详细描述在 RFC 4120 中。有几个免费的实现该协议的软件可供选择，覆盖了广泛的操作系统。麻省理工学院（ MIT ）继续开发他们的 Kerberos 软件包。它在美国常被用作密码学产品，并且历史上受到美国出口管制的限制。在 FreeBSD 中， MITKerberos 可作为 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/krb5/">security/krb5</a> 软件包或端口使用。 Heimdal Kerberos 实现是专门在美国以外开发的，以避免出口管制。 Heimdal Kerberos 发行版已包含在基本的 FreeBSD 安装中，还有另一个具有更多可配置选项的发行版可在 Ports Collection 中使用，即 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/heimdal/">security/heimdal</a> 。</p>
</div>
<div class="paragraph">
<p>在 Kerberos 中，用户和服务被称为“主体”，并包含在一个管理组中，称为“领域”。一个典型的用户主体的形式为 <code><em>user</em>@<em>REALM</em></code> （领域通常是大写）。</p>
</div>
<div class="paragraph">
<p>本节提供了使用 FreeBSD 中包含的 Heimdal 发行版设置 Kerberos 的指南。</p>
</div>
<div class="paragraph">
<p>为了展示 Kerberos 安装的目的，命名空间将如下所示：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DNS 域（区域）将是 <code>example.org</code> 。</p>
</li>
<li>
<p>Kerberos 领域将是 <code>EXAMPLE.ORG</code> 。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在设置 Kerberos 时，请使用真实的域名，即使它将在内部运行。这样可以避免 DNS 问题，并确保与其他 Kerberos 领域的互操作性。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_设置_heimdal_kdc">16.9.1. 设置 Heimdal KDC<a class="anchor" href="#_设置_heimdal_kdc"></a></h4>
<div class="paragraph">
<p>密钥分发中心（ KDC ）是 Kerberos 提供的集中式认证服务，也是系统的“可信第三方”。它是发放 Kerberos 票据的计算机，用于客户端对服务器进行身份验证。由于 KDC 被 Kerberos 领域中的所有其他计算机视为可信任的，因此它具有更高的安全性要求。应该限制对 KDC 的直接访问。</p>
</div>
<div class="paragraph">
<p>运行 KDC 所需的计算资源很少，但出于安全原因，建议使用专用机器作为 KDC 。</p>
</div>
<div class="paragraph">
<p>首先，按照以下方式安装 <code>security/heimdal[]</code> 软件包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install heimdal</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，使用 <code>sysrc</code> 按照以下方式更新 <code>/etc/rc.conf</code> 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kdc_enable=yes</span>
<span class="c"># sysrc kadmind_enable=yes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，按照以下方式编辑 <code>/etc/krb5.conf</code> 文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[libdefaults]
    default_realm = EXAMPLE.ORG
[realms]
    EXAMPLE.ORG = {
	kdc = kerberos.example.org
	admin_server = kerberos.example.org
    }
[domain_realm]
    .example.org = EXAMPLE.ORG</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中， KDC 将使用完全限定的主机名 <code>kerberos.example.org</code> 。 KDC 的主机名必须能够在 DNS 中解析。</p>
</div>
<div class="paragraph">
<p>Kerberos 也可以使用 DNS 来定位 KDC （ Key Distribution Center ），而不是在 <code>/etc/krb5.conf</code> 文件的 <code>[realms]</code> 部分中。对于拥有自己 DNS 服务器的大型组织，上述示例可以简化为：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[libdefaults]
      default_realm = EXAMPLE.ORG
[domain_realm]
    .example.org = EXAMPLE.ORG</pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>example.org</code> 区域文件中包含以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>_kerberos._udp      IN  SRV     01 00 88 kerberos.example.org.
_kerberos._tcp      IN  SRV     01 00 88 kerberos.example.org.
_kpasswd._udp       IN  SRV     01 00 464 kerberos.example.org.
_kerberos-adm._tcp  IN  SRV     01 00 749 kerberos.example.org.
_kerberos           IN  TXT     EXAMPLE.ORG</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了使客户端能够找到 Kerberos 服务，它们必须具有完全配置的 /etc/krb5.conf 文件或最小配置的 /etc/krb5.conf 文件和正确配置的 DNS 服务器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接下来，创建 Kerberos 数据库，其中包含使用主密码加密的所有主体（用户和主机）的密钥。不需要记住此密码，因为它将存储在 [/var/heimdal/m-key]# 中；为此目的使用一个 45 个字符的随机密码是合理的。要创建主密钥，请运行 <code>kstash</code> 并输入密码：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kstash</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Master key: xxxxxxxxxxxxxxxxxxxxxxx
Verifying password - Master key: xxxxxxxxxxxxxxxxxxxxxxx</pre>
</div>
</div>
<div class="paragraph">
<p>一旦主密钥被创建，就应该初始化数据库。可以在 KDC 上使用 Kerberos 管理工具 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> 以 <code>kadmin -l</code> 的模式直接操作数据库，而不使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a> 网络服务。这解决了在创建数据库之前尝试连接数据库的鸡生蛋问题。在 <code>kadmin</code> 提示符下，使用 <code>init</code> 命令创建领域的初始数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kadmin -l</span>
<span class="gp">kadmin&gt; </span>init EXAMPLE.ORG
Realm max ticket life <span class="o">[</span>unlimited]:</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，在 <code>kadmin</code> 中使用 <code>add</code> 命令创建第一个主体。暂时使用默认选项，因为这些选项可以在以后使用 <code>modify</code> 命令进行更改。在提示符处输入 ` ? ` 以查看可用选项。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">kadmin&gt; </span>add tillman</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Max ticket life [unlimited]:
Max renewable life [unlimited]:
Principal expiration time [never]:
Password expiration time [never]:
Attributes []:
Password: xxxxxxxx
Verifying password - Password: xxxxxxxx</pre>
</div>
</div>
<div class="paragraph">
<p>接下来，通过运行以下命令启动 KDC 服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service kdc start</span>
<span class="c"># service kadmind start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上，不会有任何运行的 Kerberized 守护程序，但可以通过获取刚刚创建的主体的票证来确认 KDC 是否正常运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>kinit tillman</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>tillman@EXAMPLE.ORG&#39;s Password:</pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>klist</code> 确认成功获取了一张票据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>klist</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Credentials cache: FILE:/tmp/krb5cc_1001
	Principal: tillman@EXAMPLE.ORG

  Issued                Expires               Principal
Aug 27 15:37:58 2013  Aug 28 01:37:58 2013  krbtgt/EXAMPLE.ORG@EXAMPLE.ORG</pre>
</div>
</div>
<div class="paragraph">
<p>测试完成后，临时票据可以被销毁。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>kdestroy</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置服务器使用_kerberos">16.9.2. 配置服务器使用 Kerberos<a class="anchor" href="#_配置服务器使用_kerberos"></a></h4>
<div class="paragraph">
<p>配置服务器以使用 Kerberos 身份验证的第一步是确保它在 /etc/krb5.conf 中具有正确的配置。可以直接使用 KDC 提供的版本，或者可以在新系统上重新生成该文件。</p>
</div>
<div class="paragraph">
<p>接下来，在服务器上创建 <code>/etc/krb5.keytab</code> 文件。这是“ Kerberizing ”服务的主要部分 - 它对应于在服务和 KDC 之间生成一个共享密钥。这个密钥是一个加密密钥，存储在一个“ keytab ”文件中。 keytab 文件包含了服务器的主机密钥，它允许服务器和 KDC 验证彼此的身份。必须以安全的方式将它传输到服务器上，因为如果密钥被公开，服务器的安全性可能会被破坏。通常， keytab 文件是在管理员信任的机器上使用 <code>kadmin</code> 生成的，然后通过安全传输方式传输到服务器上，例如使用 <code>scp</code> 命令；如果符合所需的安全策略，也可以直接在服务器上创建。非常重要的是，必须以安全的方式将 keytab 文件传输到服务器上：如果密钥被其他方知晓，该方可以冒充任何用户访问服务器！在服务器上直接使用 <code>kadmin</code> 非常方便，因为在 KDC 数据库中为主机主体创建条目也是使用 <code>kadmin</code> 完成的。</p>
</div>
<div class="paragraph">
<p>当然， <code>kadmin</code> 是一个使用 Kerberos 进行身份验证的服务；需要一个 Kerberos 票证来认证到网络服务，但为了确保运行 <code>kadmin</code> 的用户实际上存在（并且他们的会话没有被劫持）， <code>kadmin</code> 会提示输入密码以获取一个新的票证。认证到 kadmin 服务的主体必须被允许使用 <code>kadmin</code> 接口，如 <span class="filename">/var/heimdal/kadmind.acl</span> 中所指定的。有关设计访问控制列表的详细信息，请参阅 <code>info heimdal</code> 中标题为“远程管理”的部分。管理员可以通过本地控制台或 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 安全地连接到 KDC ，并使用 <code>kadmin -l</code> 在本地进行管理，而不是启用远程 <code>kadmin</code> 访问。</p>
</div>
<div class="paragraph">
<p>在安装完 <span class="filename">/etc/krb5.conf</span> 后，在 <code>kadmin</code> 中使用 <code>add --random-key</code> 命令。这将向数据库中添加服务器的主机主体，但不会将主机主体密钥提取到密钥表中。要生成密钥表，请使用 <code>ext</code> 命令将服务器的主机主体密钥提取到其自己的密钥表中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kadmin</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kadmin&gt; add --random-key host/myserver.example.org
Max ticket life [unlimited]:
Max renewable life [unlimited]:
Principal expiration time [never]:
Password expiration time [never]:
Attributes []:
kadmin&gt; ext_keytab host/myserver.example.org
kadmin&gt; exit</pre>
</div>
</div>
<div class="paragraph">
<p>请注意，默认情况下， <code>ext_keytab</code> 将提取的密钥存储在 [/etc/krb5.keytab](/etc/krb5.keytab) 中。当在进行 Kerberos 认证的服务器上运行时，这是很好的选择。但是，当密钥表在其他地方提取时，应使用 <code>--keytab <em>path/to/file</em></code> 参数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kadmin</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kadmin&gt; ext_keytab --keytab=/tmp/example.keytab host/myserver.example.org
kadmin&gt; exit</pre>
</div>
</div>
<div class="paragraph">
<p>然后，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> 或可移动介质将 keytab 安全地复制到服务器。请确保指定一个非默认的 keytab 名称，以避免将不必要的密钥插入系统的 keytab 中。</p>
</div>
<div class="paragraph">
<p>在这一点上，服务器可以使用存储在 <span class="filename">krb5.keytab</span> 中的共享密钥从 KDC 读取加密消息。现在可以启用使用 Kerberos 的服务了。其中最常见的服务之一是 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> ，它通过 GSS-API 支持 Kerberos 。在 <span class="filename">/etc/ssh/sshd_config</span> 中添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>GSSAPIAuthentication yes</pre>
</div>
</div>
<div class="paragraph">
<p>在进行此更改后，必须重新启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> 以使新的配置生效： <code>service sshd restart</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置客户端使用_kerberos">16.9.3. 配置客户端使用 Kerberos<a class="anchor" href="#_配置客户端使用_kerberos"></a></h4>
<div class="paragraph">
<p>与服务器一样，客户端需要在 [/etc/krb5.conf] 中进行配置。将文件复制到指定位置（安全地）或根据需要重新输入。</p>
</div>
<div class="paragraph">
<p>通过在客户端使用 <code>kinit</code> 、 <code>klist</code> 和 <code>kdestroy</code> 命令来获取、显示和删除现有主体的票证，来测试客户端。 Kerberos 应用程序也应该能够连接到启用了 Kerberos 的服务器。如果连接不起作用，但是获取票证可以，那么问题很可能是服务器而不是客户端或 KDC 的问题。在使用 kerberized <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> 的情况下，默认情况下禁用了 GSS-API ，因此请使用 <code>ssh -o GSSAPIAuthentication = yes <em>hostname</em></code> 命令进行测试。</p>
</div>
<div class="paragraph">
<p>在测试 Kerberized 应用程序时，尝试使用诸如 <code>tcpdump</code> 之类的数据包嗅探器来确认没有明文发送敏感信息。</p>
</div>
<div class="paragraph">
<p>有各种不同的 Kerberos 客户端应用程序可供选择。随着桥接的出现，使用 SASL 进行身份验证的应用程序也可以使用 GSS-API 机制，因此大部分客户端应用程序都可以使用 Kerberos 进行身份验证，包括 Jabber 客户端和 IMAP 客户端。</p>
</div>
<div class="paragraph">
<p>在一个领域中，通常会将用户的 Kerberos 主体映射到本地用户账户。偶尔，需要将本地用户账户的访问权限授予没有匹配的 Kerberos 主体的人。例如， <code>tillman @ EXAMPLE.ORG</code> 可能需要访问本地用户账户 <code>webdevelopers</code> 。其他主体也可能需要访问该本地账户。</p>
</div>
<div class="paragraph">
<p>放置在用户的主目录中的 <span class="filename">.k5login</span> 和 <span class="filename">.k5users</span> 文件可以用来解决这个问题。例如，如果将以下 <span class="filename">.k5login</span> 文件放置在 <code>webdevelopers</code> 的主目录中，列出的两个主体都可以访问该帐户，而无需共享密码：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>tillman@example.org
jdoe@example.org</pre>
</div>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ksu&amp;sektion=1&amp;format=html">ksu(1)</a> 获取有关 .k5users 的更多信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="_mit_的差异">16.9.4. MIT 的差异<a class="anchor" href="#_mit_的差异"></a></h4>
<div class="paragraph">
<p>MIT 和 Heimdal 实现之间的主要区别是 <code>kadmin</code> 具有不同但等效的命令集，并且使用不同的协议。如果 KDC 是 MIT 版本，则无法使用 Heimdal 版本的 <code>kadmin</code> 远程管理 KDC ，反之亦然。</p>
</div>
<div class="paragraph">
<p>客户端应用程序也可以使用稍微不同的命令行选项来完成相同的任务。建议按照 <a href="http://web.mit.edu/Kerberos/www/">http://web.mit.edu/Kerberos/www/</a> 上的说明进行操作。请注意路径问题： MIT 端口默认安装在 <span class="filename">/usr/local/</span> 中，如果 <code>PATH</code> 列表中首先列出系统目录，则 FreeBSD 系统应用程序将代替 MIT 版本运行。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 上使用 MIT Kerberos 作为 KDC 时，执行以下命令将所需的配置添加到 /etc/rc.conf 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kdc_program=&#34;/usr/local/sbin/kdc&#34;</span>
<span class="c"># sysrc kadmind_program=&#34;/usr/local/sbin/kadmind&#34;</span>
<span class="c"># sysrc kdc_flags=&#34;&#34;</span>
<span class="c"># sysrc kdc_enable=&#34;YES&#34;</span>
<span class="c"># sysrc kadmind_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_kerberos_技巧技巧和故障排除">16.9.5. Kerberos 技巧、技巧和故障排除<a class="anchor" href="#_kerberos_技巧技巧和故障排除"></a></h4>
<div class="paragraph">
<p>在配置和故障排除 Kerberos 时，请记住以下几点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在使用来自 ports 的 Heimdal 或 MITKerberos 时，请确保 <code>PATH</code> 中列出的是端口版本的客户端应用程序，而不是系统版本。</p>
</li>
<li>
<p>如果领域中的所有计算机没有同步的时间设置，认证可能会失败。 <a href="./#network-ntp">“使用 NTP 进行时钟同步”</a> 描述了如何使用 NTP 同步时钟。</p>
</li>
<li>
<p>如果主机名发生变化，则必须更改 <code>host/</code> 主体并更新 keytab 。这也适用于特殊的 keytab 条目，比如用于 Apache 的 <code>HTTP/</code> 主体，例如 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/mod_auth_kerb/">www/mod_auth_kerb</a> 。</p>
</li>
<li>
<p>领域中的所有主机必须在 DNS 中具有正向和反向解析的能力，或者至少存在于 /etc/hosts 文件中。 CNAME 记录可以使用，但 A 记录和 PTR 记录必须正确并且存在。对于无法解析的主机，错误消息并不直观：“ Kerberos5 拒绝进行身份验证，因为读取请求失败：找不到密钥表条目”。</p>
</li>
<li>
<p>一些作为 KDC 客户端的操作系统没有设置 <code>ksu</code> 的权限为 setuid <code>root</code> 。这意味着 <code>ksu</code> 无法工作。这是一个权限问题，而不是 KDC 错误。</p>
</li>
<li>
<p>使用 MITKerberos ，如果要允许一个主体拥有比默认的十小时更长的票据生命周期，可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmin&amp;sektion=8&amp;format=html">kadmin(8)</a> 提示符下使用 <code>modify_principal</code> 命令来更改相关主体和 <code>krbtgt</code> 主体的 <code>maxlife</code> 属性。然后，该主体可以使用 <code>kinit -l</code> 命令来请求一个具有更长生命周期的票据。</p>
</li>
<li>
<p>在从工作站运行 <code>kinit</code> 时，在 KDC 上运行数据包嗅探器以帮助故障排除时，票据授予票证（ TGT ）会立即发送，甚至在输入密码之前。这是因为 Kerberos 服务器会自由地向任何未经授权的请求传输 TGT 。然而，每个 TGT 都是使用用户密码派生的密钥进行加密的。当用户输入密码时，它不会被发送到 KDC ，而是用于解密 <code>kinit</code> 已经获取的 TGT 。如果解密过程产生一个带有有效时间戳的有效票证，用户就拥有有效的 Kerberos 凭证。这些凭证包括用于与 Kerberos 服务器建立安全通信的会话密钥，以及使用 Kerberos 服务器自己的密钥加密的实际 TGT 。这第二层加密允许 Kerberos 服务器验证每个 TGT 的真实性。</p>
</li>
<li>
<p>主机主体可以拥有更长的票据生命周期。如果用户主体的生命周期为一周，但连接的主机的生命周期为九小时，用户缓存将会有一个过期的主机主体，票据缓存将无法按预期工作。</p>
</li>
<li>
<p>在设置 <span class="filename">krb5.dict</span> 以防止特定的弱密码被使用，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=kadmind&amp;sektion=8&amp;format=html">kadmind(8)</a> 中所描述的那样，请记住它仅适用于已分配密码策略的主体。 <span class="filename">krb5.dict</span> 中使用的格式是每行一个字符串。创建一个符号链接到 <span class="filename">/usr/share/dict/words</span> 可能会很有用。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_缓解_kerberos_的限制">16.9.6. 缓解 Kerberos 的限制<a class="anchor" href="#_缓解_kerberos_的限制"></a></h4>
<div class="paragraph">
<p>由于 Kerberos 是一种全面的方法，网络上的每个启用的服务都必须要么被修改以与 Kerberos 一起工作，要么以其他方式进行网络攻击防护。这是为了防止用户凭据被窃取和重复使用。一个例子是当 Kerberos 在所有远程 shell 上启用时，非 Kerberos 化的 POP3 邮件服务器会以明文发送密码。</p>
</div>
<div class="paragraph">
<p>KDC 是一个单点故障。按设计， KDC 必须与其主密码数据库一样安全。 KDC 上不应该运行任何其他服务，并且应该具有物理安全性。危险性很高，因为 Kerberos 将所有密码都使用相同的主密钥进行加密，该密钥存储在 KDC 上的文件中。</p>
</div>
<div class="paragraph">
<p>一个被破坏的主密钥并不像人们可能担心的那样糟糕。主密钥仅用于加密 Kerberos 数据库和作为随机数生成器的种子。只要 KDC 的访问是安全的，攻击者无法对主密钥做太多事情。</p>
</div>
<div class="paragraph">
<p>如果 KDC 不可用，网络服务将无法使用，因为无法进行身份验证。可以通过一个主 KDC 和一个或多个从 KDC 以及对 PAM 进行细致实施的次要或备用身份验证来缓解这个问题。</p>
</div>
<div class="paragraph">
<p>Kerberos 允许用户、主机和服务之间进行身份验证。它没有机制来对用户、主机或服务进行身份验证。这意味着一个被木马程序感染的 <code>kinit</code> 可以记录所有的用户名和密码。文件系统完整性检查工具，如 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/tripwire/">security/tripwire</a> 可以缓解这个问题。</p>
</div>
</div>
<div class="sect3">
<h4 id="_资源和进一步信息">16.9.7. 资源和进一步信息<a class="anchor" href="#_资源和进一步信息"></a></h4>
<div class="ulist">
<ul>
<li>
<p>[Kerberos FAQ] （ Kerberos 常见问题解答）： <a href="http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html" class="bare">http://www.faqs.org/faqs/Kerberos-faq/general/preamble.html</a></p>
</li>
<li>
<p><a href="http://web.mit.edu/Kerberos/www/dialogue.html">设计一个认证系统：四个场景的对话</a></p>
</li>
<li>
<p>[RFC 4120 , Kerberos 网络身份验证服务（ V5 ）] 是一项关于 Kerberos 网络身份验证服务的规范，可以在 <a href="https://www.ietf.org/rfc/rfc4120.txt" class="bare">https://www.ietf.org/rfc/rfc4120.txt</a> 上找到。</p>
</li>
<li>
<p>[MIT Kerberos 主页](<a href="http://web.mit.edu/Kerberos/www/" class="bare">http://web.mit.edu/Kerberos/www/</a>)</p>
</li>
<li>
<p>[Heimdal Kerberos 项目维基页面](<a href="https://github.com/heimdal/heimdal/wiki" class="bare">https://github.com/heimdal/heimdal/wiki</a>)</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="tcpwrappers">16.10. TCP 包装器（ TCP Wrappers ）是一种网络访问控制工具，用于在 TCP/IP 网络上限制对特定服务的访问。它通过检查远程主机的 IP 地址和主机名来决定是否允许连接到受保护的服务。 TCP 包装器可以用于增强网络安全性，防止未经授权的访问和恶意活动。它通常与网络服务（如 SSH 、 FTP 和 Telnet ）一起使用，以提供对这些服务的访问控制。<a class="anchor" href="#tcpwrappers"></a></h3>
<div class="paragraph">
<p>TCP Wrappers 是一种基于主机的网络访问控制系统。通过在实际网络服务之前拦截传入的网络请求， TCP Wrappers 根据配置文件中预定义的规则评估源 IP 地址是否被允许或拒绝访问。</p>
</div>
<div class="paragraph">
<p>然而，尽管 TCP 包装器提供了基本的访问控制，但它们不应被视为更强大的安全措施的替代品。为了全面保护，建议使用像防火墙这样的先进技术，以及适当的用户身份验证实践和入侵检测系统。</p>
</div>
<div class="sect3">
<h4 id="tcpwrappers-initial-configuration">16.10.1. 初始配置<a class="anchor" href="#tcpwrappers-initial-configuration"></a></h4>
<div class="paragraph">
<p>TCP 包装器默认在 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 中启用。因此，第一步是启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> ，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc inetd_enable=&#34;YES&#34;</span>
<span class="c"># service inetd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，正确配置 [/etc/hosts.allow] 文件。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>与其他 TCP Wrappers 的实现不同，在 FreeBSD 中使用 <span class="filename">hosts.deny</span> 已被弃用。所有配置选项应放置在 <span class="filename">/etc/hosts.allow</span> 中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在最简单的配置中，守护进程连接策略根据 <span class="filename">/etc/hosts.allow</span> 中的选项设置为允许或阻止。在 FreeBSD 中，默认配置是允许所有与 inetd 启动的守护进程的连接。</p>
</div>
<div class="paragraph">
<p>基本配置通常采用 <code>daemon : address : action</code> 的形式，其中 <code>daemon</code> 是由 inetd 启动的守护进程， <code>address</code> 是有效的主机名、 IP 地址或用方括号（ [ ] ）括起来的 IPv6 地址， <code>action</code> 可以是 <code>allow</code> 或 <code>deny</code> 。 TCP Wrappers 使用首次匹配规则的语义，意味着配置文件从头开始扫描以寻找匹配的规则。当找到匹配时，规则被应用并且搜索过程停止。</p>
</div>
<div class="paragraph">
<p>例如，要允许通过 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/qpopper/">mail/qpopper</a> 守护程序进行 POP3 连接，应将以下行追加到 <span class="filename">/etc/hosts.allow</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># This line is required for POP3 connections:
qpopper : ALL : allow</pre>
</div>
</div>
<div class="paragraph">
<p>每当编辑此文件时，重新启动 inetd ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service inetd restart</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tcpwrappers-advanced-config">16.10.2. 高级配置<a class="anchor" href="#tcpwrappers-advanced-config"></a></h4>
<div class="paragraph">
<p>TCP Wrappers 提供了高级选项，可以更好地控制连接的处理方式。在某些情况下，向特定的主机或守护进程连接返回注释可能是合适的。在其他情况下，应记录日志条目或向管理员发送电子邮件。其他情况可能需要仅用于本地连接的服务。通过使用通配符、扩展字符和外部命令执行的配置选项，所有这些都是可能的。要了解有关通配符及其相关功能的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="fs-acl">16.11. 访问控制列表<a class="anchor" href="#fs-acl"></a></h3>
<div class="paragraph">
<p>访问控制列表（ ACL ）通过允许用户和组在每个文件或目录的基础上进行细粒度的访问控制，扩展了传统的 UNIX® 文件权限。每个 ACL 条目定义了一个用户或组以及相关的权限，如读取、写入和执行。 FreeBSD 提供了像 <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> 这样的命令来管理 ACL 。</p>
</div>
<div class="paragraph">
<p>访问控制列表（ ACL ）在需要比标准权限更具体的访问控制的场景中非常有用，通常在多用户环境或共享托管中使用。然而，复杂性可能是不可避免的，但需要仔细规划，以确保提供所需的安全性质。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>FreeBSD 支持在 UFS 和 OpenZFS 中实现 NFSv4 ACLs 。请注意， <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> 命令的一些参数仅适用于 POSIX ACLs ，而其他参数适用于 NFSv4 ACLs 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="acl-enabling-support-ufs">16.11.1. 在 UFS 中启用 ACL 支持<a class="anchor" href="#acl-enabling-support-ufs"></a></h4>
<div class="paragraph">
<p>ACL （访问控制列表）是通过挂载时的管理标志 <code>acls</code> 启用的，可以将其添加到 <code>/etc/fstab</code> 文件中。</p>
</div>
<div class="paragraph">
<p>因此，需要访问 <span class="filename">/etc/fstab</span> 并在选项部分添加 <code>acls</code> 标志，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device        Mountpoint        FStype    Options     Dump      Pass#
/dev/ada0s1a    /                 ufs       rw,acls     1         1</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="security-acl-info">16.11.2. 获取 ACL 信息<a class="anchor" href="#security-acl-info"></a></h4>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> 命令来检查文件或目录的 ACL 。</p>
</div>
<div class="paragraph">
<p>例如，要查看 [.filename]# ~ /test# 文件的 ACL 设置，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>getfacl <span class="nb">test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 NFSv4 ACLs ，输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># file: test
# owner: freebsduser
# group: freebsduser
            owner@:rw-p--aARWcCos:-------:allow
            group@:r-----a-R-c--s:-------:allow
         everyone@:r-----a-R-c--s:-------:allow</pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 POSIX.1e ACLs ，输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># file: test
# owner: freebsduser
# group: freebsduser
user::rw-
group::r--
other::r--</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="security-working-acls">16.11.3. 使用 ACLs 进行工作<a class="anchor" href="#security-working-acls"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> 可以用于向文件或目录添加、修改或删除 ACL 。</p>
</div>
<div class="paragraph">
<p>如上所述， <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> 的一些参数与 NFSv4 ACLs 不兼容，反之亦然。本节介绍如何执行 POSIX ACLs 和 NFSv4 ACLs 的命令，并提供了两者的示例。</p>
</div>
<div class="paragraph">
<p>例如，要设置 POSIX.1e 默认 ACL 的强制元素：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>setfacl -d -m u::rwx,g::rx,o::rx,mask::rwx directory</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个示例设置了文件所有者的 POSIX.1e ACL 条目的读取、写入和执行权限，并为文件上的邮件组设置了读取和写入权限。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>setfacl -m u::rwx,g:mail:rw file</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了在 NFSv4 ACL 中执行与前一个示例相同的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>setfacl -m owner@:rwxp::allow,g:mail:rwp::allow file</code></pre>
</div>
</div>
<div class="paragraph">
<p>从 POSIX.1e ACL 文件中删除除了三个必需的 ACL 条目之外的所有 ACL 条目。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>setfacl -bn file</code></pre>
</div>
</div>
<div class="paragraph">
<p>要删除 NFSv4 ACL 中的所有 ACL 条目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>setfacl -b file</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关这些命令可用选项的更多信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=getfacl&amp;sektion=1&amp;format=html">getfacl(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=setfacl&amp;sektion=1&amp;format=html">setfacl(1)</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="capsicum">16.12. Capsicum 是一种辣椒植物，属于茄科。它的果实通常被用作调味品和食材，具有辛辣的味道。 Capsicum 也被用于药用目的，具有抗氧化和抗炎作用。它含有丰富的维生素 C 和维生素 A ，对于保持健康非常重要。 Capsicum 在烹饪中被广泛使用，可以用于制作各种菜肴和调味品。<a class="anchor" href="#capsicum"></a></h3>
<div class="paragraph">
<p>Capsicum 是一个轻量级的操作系统能力和沙箱框架，实现了混合能力系统模型。能力是不可伪造的授权令牌，可以委派并必须在执行操作时呈现。 Capsicum 将文件描述符转换为能力。</p>
</div>
<div class="paragraph">
<p>Capsicum 可以用于应用程序和库的分隔，将较大的软件体分解为隔离（沙盒化）的组件，以实施安全策略并限制软件漏洞的影响。</p>
</div>
</div>
<div class="sect2">
<h3 id="security-accounting">16.13. 进程账户<a class="anchor" href="#security-accounting"></a></h3>
<div class="paragraph">
<p>进程账户是一种安全方法，管理员可以通过该方法跟踪系统资源的使用情况以及它们在用户之间的分配情况，提供系统监控，并最少程度地跟踪用户的命令。</p>
</div>
<div class="paragraph">
<p>进程账户有积极和消极的一面。其中一个积极的方面是可以将入侵事件追溯到入侵点。消极的一面是进程账户会生成大量的日志，并且可能需要大量的磁盘空间来存储这些日志。本节将向管理员介绍进程账户的基础知识。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果需要更细粒度的会计记录，请参考 <a href="./#audit">安全事件审计</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_启用和利用进程账户">16.13.1. 启用和利用进程账户<a class="anchor" href="#_启用和利用进程账户"></a></h4>
<div class="paragraph">
<p>在使用进程记账之前，必须使用以下命令启用它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc accounting_enable=yes</span>
<span class="c"># service accounting start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>会计信息存储在位于 <span class="filename">/var/account</span> 的文件中，如果需要，会计服务首次启动时会自动创建该文件。这些文件包含敏感信息，包括所有用户发出的所有命令。对文件的写访问权限仅限于 <code>root</code> ，读访问权限仅限于 <code>root</code> 和 <code>wheel</code> 组的成员。为了防止 <code>wheel</code> 组的成员也能读取这些文件，将 <span class="filename">/var/account</span> 目录的模式更改为仅允许 <code>root</code> 访问。</p>
</div>
<div class="paragraph">
<p>启用后，会计将开始跟踪诸如 CPU 统计和执行的命令等信息。所有的会计日志都以非人类可读的格式存储，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> 命令查看。如果不带任何选项使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> 命令，将打印与每个用户调用次数、总经过时间（以分钟为单位）、总 CPU 和用户时间（以分钟为单位）以及平均 I/O 操作次数相关的信息。有关控制输出的可用选项列表，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> 命令。</p>
</div>
<div class="paragraph">
<p>要显示用户发出的命令，请使用 <code>lastcomm</code> 命令。</p>
</div>
<div class="paragraph">
<p>例如，这个命令会打印出在 <code>ttyp1</code> 终端上由 <code>trhodes</code> 使用的 <code>ls</code> 的所有用法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># lastcomm ls trhodes ttyp1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>还有许多其他有用的选项，可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=lastcomm&amp;sektion=1&amp;format=html">lastcomm(1)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=acct&amp;sektion=5&amp;format=html">acct(5)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=8&amp;format=html">sa(8)</a> 中找到解释。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-resourcelimits">16.14. 资源限制<a class="anchor" href="#security-resourcelimits"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 中，资源限制是指控制和管理将各种系统资源分配给进程和用户的机制。这些限制旨在防止单个进程或用户消耗过多的资源，从而可能导致性能下降或系统不稳定。资源限制有助于确保系统上所有活动进程和用户之间公平分配资源。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供了几种方法，供管理员限制个人使用系统资源的数量。</p>
</div>
<div class="paragraph">
<p>传统的方法是通过编辑 [/etc/login.conf] 来定义登录类。虽然这种方法仍然受支持，但任何更改都需要多个步骤：编辑该文件、重建资源数据库、对 [/etc/master.passwd] 进行必要的更改，并重新构建密码数据库。这可能会耗费时间，具体取决于要配置的用户数量。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 可以用于提供一种更精细的方法来控制资源限制。该命令不仅支持用户限制，还可以用于在进程和 jails 上设置资源约束。</p>
</div>
<div class="paragraph">
<p>本节展示了控制资源的两种方法，首先是传统方法。</p>
</div>
<div class="sect3">
<h4 id="security-resource-limits-types">16.14.1. 资源的类型<a class="anchor" href="#security-resource-limits-types"></a></h4>
<div class="paragraph">
<p>FreeBSD 提供了各种类型资源的限制，包括：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 28. 资源类型</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类型</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CPU 时间</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">限制进程可以消耗的 CPU 时间量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">内存</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制进程可使用的物理内存量</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">打开文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">限制进程同时打开的文件数量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">进程</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制用户或进程可以创建的进程数量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件大小</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">限制进程可以创建的文件的最大大小。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">核心转储</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">控制进程是否允许生成核心转储文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络资源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">限制进程可以使用的网络资源（例如，套接字）的数量</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>有关类型的完整列表，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="users-limiting">16.14.2. 配置登录类<a class="anchor" href="#users-limiting"></a></h4>
<div class="paragraph">
<p>在传统的方法中，登录类和适用于登录类的资源限制在 <code>/etc/login.conf</code> 文件中定义。每个用户账户可以分配给一个登录类，其中 <code>default</code> 是默认的登录类。每个登录类都有一组与之关联的登录能力。登录能力是一个 <code><em>name</em>=<em>value</em></code> 对，其中_name_是一个众所周知的标识符，_value_是一个任意字符串，根据_name_的不同进行相应的处理。</p>
</div>
<div class="paragraph">
<p>配置资源限制的第一步是通过执行以下命令打开 <code>/etc/login.conf</code> 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ee /etc/login.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后找到要修改的用户类的部分。在这个例子中，假设用户类的名称是 <code>limited</code> ，如果不存在，则创建它。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>limited:\ <i class="conum" data-value="1"></i><b>(1)</b>
        :maxproc=50:\ <i class="conum" data-value="2"></i><b>(2)</b>
        :tc=default: <i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用户类的名称。 &lt;.&gt; 将 <code>limited</code> 类中的用户的最大进程数（ maxproc ）设置为 50 。 &lt;.&gt; 表示该用户类继承了“ default ”类的默认设置。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在修改 <span class="filename">/etc/login.conf</span> 文件后，运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=cap_mkdb&amp;sektion=1&amp;format=html">cap_mkdb(1)</a> 命令生成 FreeBSD 使用的数据库，以应用这些设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cap_mkdb /etc/login.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=chpass&amp;sektion=1&amp;format=html">chpass(1)</a> 可以用于更改用户的类别，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chpass username</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将打开一个文本编辑器，在其中添加新的 <code>limited</code> 类，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#Changing user information for username.
Login: username
Password: $6$2H.419USdGaiJeqK$6kgcTnDadasdasd3YnlNZsOni5AMymibkAfRCPirc7ZFjjv
DVsKyXx26daabdfqSdasdsmL/ZMUpdHiO0
Uid [#]: 1001
Gid [# or name]: 1001
Change [month day year]:
Expire [month day year]:
Class: limited
Home directory: /home/username
Shell: /bin/sh
Full Name: User &amp;
Office Location:
Office Phone:
Home Phone:
Other information:</pre>
</div>
</div>
<div class="paragraph">
<p>现在，分配给 <code>limited</code> 类的用户将具有最大进程限制为 50 。请记住，这只是使用 <span class="filename">/etc/login.conf</span> 文件设置资源限制的一个示例。</p>
</div>
<div class="paragraph">
<p>请记住，在对 <span class="filename">/etc/login.conf</span> 文件进行更改后，用户需要注销并重新登录以使更改生效。此外，在编辑系统配置文件时，特别是在使用特权访问时，始终要谨慎行事。</p>
</div>
</div>
<div class="sect3">
<h4 id="security-rctl">16.14.3. 启用和配置资源限制<a class="anchor" href="#security-rctl"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 系统提供了一种更精细的方式来设置和管理单个进程和用户的资源限制。它允许您动态地为特定的进程或用户分配资源限制，而不考虑他们的用户类别。</p>
</div>
<div class="paragraph">
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 的第一步是将以下行添加到 [/boot/loader.conf] 并重新启动系统，以启用它：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.racct.enable=1</pre>
</div>
</div>
<div class="paragraph">
<p>然后激活 <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 服务并通过以下命令启用它执行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc rctl_enable=&#34;YES&#34;</span>
<span class="c"># service rctl start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 来为系统设置规则。</p>
</div>
<div class="paragraph">
<p>规则语法（ <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl.conf&amp;sektion=5&amp;format=html">rctl.conf(5)</a> ）通过使用主题、主题 ID 、资源和操作来进行控制，如下面的示例规则所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>subject:subject-id:resource:action=amount/per</pre>
</div>
</div>
<div class="paragraph">
<p>例如，要限制用户添加的进程数量不超过 10 个，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rctl -a user:username:maxproc:deny=10/user</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要检查应用的资源限制，可以执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rctl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>user:username:maxproc:deny=10</pre>
</div>
</div>
<div class="paragraph">
<p>如果将规则添加到 [/etc/rctl.conf] 文件中，规则将在重新启动后保持不变。格式是一个规则，没有前导命令。例如，可以将上述规则添加为：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>user:username:maxproc:deny=10</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security-pkg">16.15. 监控第三方安全问题<a class="anchor" href="#security-pkg"></a></h3>
<div class="paragraph">
<p>近年来，安全领域在漏洞评估的处理方面取得了许多改进。随着第三方工具在几乎所有现有操作系统上的安装和配置，系统入侵的威胁也在增加。</p>
</div>
<div class="paragraph">
<p>漏洞评估是安全性的关键因素。虽然 FreeBSD 为基本系统发布了安全公告，但对于每个第三方实用程序都这样做超出了 FreeBSD 项目的能力范围。有一种方法可以减轻第三方漏洞并警告管理员已知的安全问题。一个名为 pkg 的 FreeBSD 附加实用程序专门包含了这个目的的选项。</p>
</div>
<div class="paragraph">
<p>pkg 轮询数据库以查找安全问题。该数据库由 FreeBSD 安全团队和端口开发人员更新和维护。</p>
</div>
<div class="paragraph">
<p>安装提供了用于维护 pkg audit 数据库的 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 配置文件，并提供了一种程序化的方法来保持其更新。</p>
</div>
<div class="paragraph">
<p>安装完成后，管理员可以选择更新数据库并查看已安装软件包的已知漏洞，以便随时审核第三方工具作为 Ports Collection 的一部分。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>pkg audit -F</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vulnxml file up-to-date
chromium-116.0.5845.96_1 is vulnerable:
  chromium -- multiple vulnerabilities
  CVE: CVE-2023-4431
  CVE: CVE-2023-4427
  CVE: CVE-2023-4428
  CVE: CVE-2023-4429
  CVE: CVE-2023-4430
  WWW: https://vuxml.FreeBSD.org/freebsd/5fa332b9-4269-11ee-8290-a8a1599412c6.html

samba413-4.13.17_5 is vulnerable:
  samba -- multiple vulnerabilities
  CVE: CVE-2023-3347
  CVE: CVE-2023-34966
  CVE: CVE-2023-34968
  CVE: CVE-2022-2127
  CVE: CVE-2023-34967
  WWW: https://vuxml.FreeBSD.org/freebsd/441e1e1a-27a5-11ee-a156-080027f5fec9.html

2 problem(s) in 2 installed package(s) found.</pre>
</div>
</div>
<div class="paragraph">
<p>通过将 Web 浏览器指向显示的 URL ，管理员可以获取有关漏洞的更多信息。</p>
</div>
<div class="paragraph">
<p>这将包括受影响的版本，按照 FreeBSD 端口版本列出，以及可能包含安全公告的其他网站。</p>
</div>
</div>
<div class="sect2">
<h3 id="security-advisories">16.16. FreeBSD 安全公告<a class="anchor" href="#security-advisories"></a></h3>
<div class="paragraph">
<p>像许多优质操作系统的生产者一样， FreeBSD 项目有一个安全团队，负责确定每个 FreeBSD 发布版本的生命周期结束（ EoL ）日期，并为尚未达到其 EoL 的受支持版本提供安全更新。有关 FreeBSD 安全团队和受支持版本的更多信息，请访问链接： <a href="https://www.FreeBSD.org/security">FreeBSD 安全页面</a> 。</p>
</div>
<div class="paragraph">
<p>安全团队的一个任务是响应 FreeBSD 操作系统中报告的安全漏洞。一旦确认了漏洞，安全团队会验证修复漏洞所需的步骤，并更新源代码进行修复。然后，它将详细信息发布为“安全公告”。安全公告会发布在 [FreeBSD 网站](<a href="https://www.FreeBSD.org/security/advisories/" class="bare">https://www.FreeBSD.org/security/advisories/</a>) 上，并发送给 {freebsd-security-notifications} 、 {freebsd-security} 和 {freebsd-announce} 。</p>
</div>
<div class="sect3">
<h4 id="_安全公告的格式">16.16.1. 安全公告的格式<a class="anchor" href="#_安全公告的格式"></a></h4>
<div class="paragraph">
<p>这是一个 FreeBSD 安全公告的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>-----BEGIN PGP SIGNED MESSAGE-----
Hash: SHA512

=============================================================================
FreeBSD-SA-23:07.bhyve                                      Security Advisory
                                                          The FreeBSD Project

Topic:          bhyve privileged guest escape via fwctl

Category:       core
Module:         bhyve
Announced:      2023-08-01
Credits:        Omri Ben Bassat and Vladimir Eli Tokarev from Microsoft
Affects:        FreeBSD 13.1 and 13.2
Corrected:      2023-08-01 19:48:53 UTC (stable/13, 13.2-STABLE)
                2023-08-01 19:50:47 UTC (releng/13.2, 13.2-RELEASE-p2)
                2023-08-01 19:48:26 UTC (releng/13.1, 13.1-RELEASE-p9)
CVE Name:       CVE-2023-3494

For general information regarding FreeBSD Security Advisories,
including descriptions of the fields above, security branches, and the
following sections, please visit &lt;URL:https://security.FreeBSD.org/&gt;.

I.   Background

bhyve(8)&#39;s fwctl interface provides a mechanism through which guest
firmware can query the hypervisor for information about the virtual
machine.  The fwctl interface is available to guests when bhyve is run
with the &#34;-l bootrom&#34; option, used for example when booting guests in
UEFI mode.

bhyve is currently only supported on the amd64 platform.

II.  Problem Description

The fwctl driver implements a state machine which is executed when the
guest accesses certain x86 I/O ports.  The interface lets the guest copy
a string into a buffer resident in the bhyve process&#39; memory.  A bug in
the state machine implementation can result in a buffer overflowing when
copying this string.

III. Impact

A malicious, privileged software running in a guest VM can exploit the
buffer overflow to achieve code execution on the host in the bhyve
userspace process, which typically runs as root.  Note that bhyve runs
in a Capsicum sandbox, so malicious code is constrained by the
capabilities available to the bhyve process.

IV.  Workaround

No workaround is available.  bhyve guests that are executed without the
&#34;-l bootrom&#34; option are unaffected.

V.   Solution

Upgrade your vulnerable system to a supported FreeBSD stable or
release / security branch (releng) dated after the correction date.

Perform one of the following:

1) To update your vulnerable system via a binary patch:

Systems running a RELEASE version of FreeBSD on the amd64, i386, or
(on FreeBSD 13 and later) arm64 platforms can be updated via the
freebsd-update(8) utility:

# freebsd-update fetch
# freebsd-update install

Restart all affected virtual machines.

2) To update your vulnerable system via a source code patch:

The following patches have been verified to apply to the applicable
FreeBSD release branches.

a) Download the relevant patch from the location below, and verify the
detached PGP signature using your PGP utility.

[FreeBSD 13.2]
# fetch https://security.FreeBSD.org/patches/SA-23:07/bhyve.13.2.patch
# fetch https://security.FreeBSD.org/patches/SA-23:07/bhyve.13.2.patch.asc
# gpg --verify bhyve.13.2.patch.asc

[FreeBSD 13.1]
# fetch https://security.FreeBSD.org/patches/SA-23:07/bhyve.13.1.patch
# fetch https://security.FreeBSD.org/patches/SA-23:07/bhyve.13.1.patch.asc
# gpg --verify bhyve.13.1.patch.asc

b) Apply the patch.  Execute the following commands as root:

# cd /usr/src
# patch &lt; /path/to/patch

c) Recompile the operating system using buildworld and installworld as
described in &lt;URL:https://www.FreeBSD.org/handbook/makeworld.html&gt;.

Restart all affected virtual machines.

VI.  Correction details

This issue is corrected by the corresponding Git commit hash or Subversion
revision number in the following stable and release branches:

Branch/path                             Hash                     Revision
- -------------------------------------------------------------------------
stable/13/                              9fe302d78109    stable/13-n255918
releng/13.2/                            2bae613e0da3  releng/13.2-n254625
releng/13.1/                            87702e38a4b4  releng/13.1-n250190
- -------------------------------------------------------------------------

Run the following command to see which files were modified by a
particular commit:

# git show --stat &lt;commit hash&gt;

Or visit the following URL, replacing NNNNNN with the hash:

&lt;URL:https://cgit.freebsd.org/src/commit/?id=NNNNNN&gt;

To determine the commit count in a working tree (for comparison against
nNNNNNN in the table above), run:

# git rev-list --count --first-parent HEAD

VII. References

&lt;URL:https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2023-3494&gt;

The latest revision of this advisory is available at
&lt;URL:https://security.FreeBSD.org/advisories/FreeBSD-SA-23:07.bhyve.asc&gt;
-----BEGIN PGP SIGNATURE-----

iQIzBAEBCgAdFiEEthUnfoEIffdcgYM7bljekB8AGu8FAmTJdsIACgkQbljekB8A
Gu8Q1Q/7BFw5Aa0cFxBzbdz+O5NAImj58MvKS6xw61bXcYr12jchyT6ENC7yiR+K
qCqbe5TssRbtZ1gg/94gSGEXccz5OcJGxW+qozhcdPUh2L2nzBPkMCrclrYJfTtM
cnmQKjg/wFZLUVr71GEM95ZFaktlZdXyXx9Z8eBzow5rXexpl1TTHQQ2kZZ41K4K
KFhup91dzGCIj02cqbl+1h5BrXJe3s/oNJt5JKIh/GBh5THQu9n6AywQYl18HtjV
fMb1qRTAS9WbiEP5QV2eEuOG86ucuhytqnEN5MnXJ2rLSjfb9izs9HzLo3ggy7yb
hN3tlbfIPjMEwYexieuoyP3rzKkLeYfLXqJU4zKCRnIbBIkMRy4mcFkfcYmI+MhF
NPh2R9kccemppKXeDhKJurH0vsetr8ti+AwOZ3pgO21+9w+mjE+EfaedIi+JWhip
hwqeFv03bAQHJdacNYGV47NsJ91CY4ZgWC3ZOzBZ2Y5SDtKFjyc0bf83WTfU9A/0
drC0z3xaJribah9e6k5d7lmZ7L6aHCbQ70+aayuAEZQLr/N1doB0smNi0IHdrtY0
JdIqmVX+d1ihVhJ05prC460AS/Kolqiaysun1igxR+ZnctE9Xdo1BlLEbYu2KjT4
LpWvSuhRMSQaYkJU72SodQc0FM5mqqNN42Vx+X4EutOfvQuRGlI=
=MlAY
-----END PGP SIGNATURE-----</pre>
</div>
</div>
<div class="paragraph">
<p>每个安全公告都使用以下格式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>每个安全公告都由安全官员的 PGP 密钥签名。可以在 <a href="./#pgpkeys">OpenPGP Keys</a> 上验证安全官员的公钥。</p>
</li>
<li>
<p>安全公告的名称始终以 <code>FreeBSD-SA-</code> （ FreeBSD 安全公告）开头，后跟两位数格式的年份（ <code>23:</code> ），后跟该年份的公告编号（ <code>07.</code> ），后跟受影响的应用程序或子系统的名称（ <code>bhyve</code> ）。</p>
</li>
<li>
<p><code>Topic</code> 字段总结了漏洞的内容。</p>
</li>
<li>
<p><code>Category</code> 指的是系统中受影响的部分，可以是 <code>core</code> 、 <code>contrib</code> 或 <code>ports</code> 之一。 <code>core</code> 类别表示漏洞影响 FreeBSD 操作系统的核心组件。 <code>contrib</code> 类别表示漏洞影响 FreeBSD 中包含的软件，如 BIND 。 <code>ports</code> 类别表示漏洞影响通过 Ports Collection 提供的软件。</p>
</li>
<li>
<p><code>Module</code> 字段指的是组件的位置。在这个例子中， <code>bhyve</code> 模块受到影响；因此，这个漏洞会影响安装有操作系统的应用程序。</p>
</li>
<li>
<p><code>Announced</code> 字段反映了安全公告发布的日期。这意味着安全团队已经验证了问题的存在，并且已经提交了一个补丁到 FreeBSD 源代码仓库中。</p>
</li>
<li>
<p><code>Credits</code> 字段用于给发现并报告漏洞的个人或组织提供鸣谢。</p>
</li>
<li>
<p><code>Affects</code> 字段说明了哪些版本的 FreeBSD 受到此漏洞的影响。</p>
</li>
<li>
<p><code>Corrected</code> 字段表示修正的日期、时间、时间偏移和修正的发布版本。括号中的部分显示了已合并修复的每个分支，以及该分支对应发布的版本号。发布标识符本身包括版本号和（如果适用）补丁级别。补丁级别是字母 <code>p</code> 后跟一个数字，表示补丁的序列号，允许用户跟踪已应用到系统的补丁。</p>
</li>
<li>
<p>`CVE 名称 ` 字段列出了公共 <a href="http://cve.mitre.org">cve.mitre.org</a> 安全漏洞数据库中的咨询编号（如果存在）。</p>
</li>
<li>
<p><code>Background</code> 字段提供了受影响模块的描述。</p>
</li>
<li>
<p>` 问题描述 ` 字段解释了漏洞的情况。这可能包括有关有缺陷的代码以及如何恶意使用该实用程序的信息。</p>
</li>
<li>
<p><code>Impact</code> 字段描述了问题对系统可能产生的影响类型。</p>
</li>
<li>
<p><code>Workaround</code> 字段指示系统管理员是否可以立即修补系统，以及是否有可用的解决方法。</p>
</li>
<li>
<p><code>Solution</code> 字段提供了修补受影响系统的指令。这是一个经过逐步测试和验证的方法，用于修补系统并确保其安全运行。</p>
</li>
<li>
<p>` 修正详情 ` 字段显示了每个受影响的 Subversion 或 Git 分支以及包含修正代码的修订版本号。</p>
</li>
<li>
<p><code>References</code> 字段提供了有关漏洞的额外信息的来源。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="jails">Chapter 17. Jails 和容器<a class="anchor" href="#jails"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="jails-synopsis">17.1. 简介<a class="anchor" href="#jails-synopsis"></a></h3>
<div class="paragraph">
<p>由于系统管理是一项困难的任务，因此开发了许多工具来简化管理员的工作。这些工具通常可以增强系统的安装、配置和维护方式。其中一个可以用来增强 FreeBSD 系统安全性的工具是 <em>jails</em>。自 FreeBSD 4.X 以来，Jails 一直在其有用性、性能、可靠性和安全性方面得到改进。</p>
</div>
<div class="paragraph">
<p>Jails 是基于 <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> 概念构建的，该概念用于更改一组进程的根目录。这样可以创建一个与系统其余部分分离的安全环境。在 chroot 环境中创建的进程无法访问其外部的文件或资源。因此，入侵 chroot 环境中运行的服务不应允许攻击者危害整个系统。</p>
</div>
<div class="paragraph">
<p>然而，chroot 有一些限制。它适用于不需要太多灵活性或复杂高级功能的简单任务。随着时间的推移，人们发现了许多逃离 chroot 环境的方法，使其成为不太理想的保护服务的解决方案。</p>
</div>
<div class="paragraph">
<p>Jails 在多个方面改进了传统 chroot 环境的概念。</p>
</div>
<div class="paragraph">
<p>在传统的 chroot 环境中，进程只能访问文件系统的一部分。其余的系统资源、系统用户、运行中的进程和网络子系统由 chroot 进程和主机系统的进程共享。Jails 通过虚拟化对文件系统、用户集和网络子系统的访问来扩展这个模型。可以使用更精细的控制来调整被监禁环境的访问权限。Jails 可以被看作是一种操作系统级别的虚拟化。</p>
</div>
<div class="paragraph">
<p>本章内容包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 FreeBSD 安装中，jail 是什么以及它可能起到的作用。</p>
</li>
<li>
<p>不同类型的 jail。</p>
</li>
<li>
<p>配置 jail 网络的不同方法。</p>
</li>
<li>
<p>jail 配置文件。</p>
</li>
<li>
<p>如何创建不同类型的 jail。</p>
</li>
<li>
<p>如何启动、停止和重启一个 jail。</p>
</li>
<li>
<p>jail 管理的基础知识，包括 jail 内部和外部的管理。</p>
</li>
<li>
<p>如何升级不同类型的 jail。</p>
</li>
<li>
<p>一个不完整的 FreeBSD jail 管理器列表。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="jail-types">17.2. Jail 类型<a class="anchor" href="#jail-types"></a></h3>
<div class="paragraph">
<p>一些管理员将 jail 分为不同类型，尽管底层技术是相同的。每个管理员都必须根据他们需要解决的问题来评估在每种情况下创建哪种类型的 jail。</p>
</div>
<div class="paragraph">
<p>下面是不同类型的列表，包括它们的特点和使用时需要考虑的事项。</p>
</div>
<div class="sect3">
<h4 id="thick-jails">17.2.1. 厚（Thick）Jails<a class="anchor" href="#thick-jails"></a></h4>
<div class="paragraph">
<p>厚 jail 是 FreeBSD jail 的一种传统形式。在厚 jail 中，基本系统的完整副本被复制到 jail 的环境中。这意味着 jail 拥有自己独立的 FreeBSD 基本系统实例，包括库、可执行文件和配置文件。可以将 jail 视为一个几乎完整的独立 FreeBSD 安装，但在主机系统的限制下运行。这种隔离确保 jail 内的进程与主机和其他 jail 中的进程保持分离。</p>
</div>
<div class="paragraph">
<p>厚 Jails 的优势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>高度隔离性：jail 内的进程与主机系统和其他 jail 之间是隔离的。</p>
</li>
<li>
<p>独立性：厚 jail 可以拥有与主机系统或其他 jail 不同版本的库、配置和软件。</p>
</li>
<li>
<p>安全性：由于 jail 包含了自己的基本系统，影响 jail 环境的漏洞或问题不会直接影响主机或其他 jail。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>厚 Jails 的缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>资源开销：由于每个 jail 都维护着自己独立的基础系统，相比于薄 jail，厚 jail 消耗更多的资源。</p>
</li>
<li>
<p>维护：每个 jail 都需要对其基本系统组件进行维护和更新。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="thin-jails">17.2.2. 薄（Thin）Jails<a class="anchor" href="#thin-jails"></a></h4>
<div class="paragraph">
<p>薄 jail 使用 OpenZFS 快照或 NullFS 挂载从模板共享基础系统。每个薄 jail 仅复制基础系统的最小子集，与厚 jail 相比，资源消耗更少。然而，这也意味着薄 jail 与厚 jail 相比具有较少的隔离性和独立性。共享组件的更改可能会同时影响多个薄 jail。</p>
</div>
<div class="paragraph">
<p>简而言之，FreeBSD 薄 Jail 是一种 FreeBSD Jail，它在隔离环境中复制了基本系统的大部分内容，但并非全部。</p>
</div>
<div class="paragraph">
<p>薄 Jails 的优势：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>资源效率：与厚 jail 相比，薄 jail 在资源利用上更高效。由于它们共享大部分基础系统，所以占用的磁盘空间和内存较少。这使得在同一硬件上运行更多的 jail 成为可能，而不会消耗过多的资源。</p>
</li>
<li>
<p>更快的部署：创建和启动薄 jail 通常比创建和启动厚 jail 更快。当您需要快速部署多个实例时，这可能特别有优势。</p>
</li>
<li>
<p>统一维护：由于薄 jail 与主机系统共享大部分基础系统（如库和二进制文件），因此只需要在主机上进行一次更新和维护常见的基础系统组件。与为每个厚 jail 维护单独的基础系统相比，这简化了维护过程。</p>
</li>
<li>
<p>共享资源：薄 jail 可以更轻松地与主机系统共享常见的资源，如库和二进制文件。这可能会导致更高效的磁盘缓存和 jail 内应用程序的性能改善。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>薄 Jails 的缺点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>降低的隔离性：薄 jail 的主要缺点是相比于厚 jail，它们提供的隔离性较低。由于它们共享模板基础系统的大部分内容，可能会同时影响多个 jail 的漏洞或问题。</p>
</li>
<li>
<p>安全问题：薄 jail 中减少的隔离性可能会带来安全风险，因为一个 jail 的妥协可能对其他 jail 或主机系统产生更大的影响潜力。</p>
</li>
<li>
<p>依赖冲突：如果多个独立的容器需要不同版本的相同库或软件，管理依赖关系可能会变得复杂。在某些情况下，这可能需要额外的努力来确保兼容性。</p>
</li>
<li>
<p>兼容性挑战：在一个薄 jail 中，应用程序可能会遇到兼容性问题，如果它们假设某个基本系统环境与模板提供的共享组件不同。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="vnet-jails">17.2.3. VNET Jails<a class="anchor" href="#vnet-jails"></a></h4>
<div class="paragraph">
<p>FreeBSD VNET jail 是一种虚拟化环境，允许对其中运行的进程的网络资源进行隔离和控制。它通过为 jail 内的进程创建单独的网络堆栈，确保 jail 内的网络流量与主机系统和其他 jail 隔离，从而提供了高级别的网络分割和安全性。</p>
</div>
<div class="paragraph">
<p>实质上，FreeBSD VNET jails 添加了一种网络配置机制。这意味着 VNET jail 可以创建为厚或薄 Jail。</p>
</div>
</div>
<div class="sect3">
<h4 id="linux-jails">17.2.4. Linux Jails<a class="anchor" href="#linux-jails"></a></h4>
<div class="paragraph">
<p>FreeBSD Linux Jail 是 FreeBSD 操作系统中的一个功能，它允许在 FreeBSD jail 中使用 Linux 二进制文件和应用程序。通过引入一个兼容层，该功能可以实现将某些 Linux 系统调用和库转换并在 FreeBSD 内核上执行。Linux Jail 的目的是在不需要单独的 Linux 虚拟机或环境的情况下，在 FreeBSD 系统上执行 Linux 软件。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="host-configuration">17.3. 主机配置<a class="anchor" href="#host-configuration"></a></h3>
<div class="paragraph">
<p>在主机系统上创建任何 jail 之前，需要进行一些配置并从主机系统中获取一些信息。</p>
</div>
<div class="paragraph">
<p>需要配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 实用程序，创建必要的目录来配置和安装 jails，从主机的网络获取信息，并检查主机是否使用 OpenZFS 或 UFS 作为其文件系统。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 jail 中运行的 FreeBSD 版本不能比主机中运行的版本更新。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="host-configuration-jail-utility">17.3.1. Jail 实用工具<a class="anchor" href="#host-configuration-jail-utility"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 实用程序用于管理 jails。</p>
</div>
<div class="paragraph">
<p>要在系统启动时启动 jails，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc jail_enable=&#34;YES&#34;</span>
<span class="c"># sysrc jail_parallel_start=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用 <code>jail_parallel_start</code>，所有配置的 jail 将在后台启动。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="jails-networking">17.3.2. 网络<a class="anchor" href="#jails-networking"></a></h4>
<div class="paragraph">
<p>FreeBSD jails 的网络配置有多种不同的方式：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">主机网络模式（IP 共享）</dt>
<dd>
<p>在主机网络模式下，一个 jail 与主机系统共享相同的网络堆栈。当一个 jail 在主机网络模式下创建时，它使用相同的网络接口和 IP 地址。这意味着 jail 没有单独的 IP 地址，它的网络流量与主机的 IP 地址相关联。</p>
</dd>
<dt class="hdlist1">虚拟网络（VNET）</dt>
<dd>
<p>虚拟网络是 FreeBSD jails 的一个特性，提供比主机网络等基本网络模式更高级和灵活的网络解决方案。VNET 允许为每个 jail 创建隔离的网络堆栈，为它们提供独立的 IP 地址、路由表和网络接口。这提供了更高级别的网络隔离，并允许 jails 像运行在独立的虚拟机上一样运行。</p>
</dd>
<dt class="hdlist1">netgraph 系统</dt>
<dd>
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a> 是一个多功能的内核框架，用于创建自定义的网络配置。它可以用于定义网络流量在 jails 和主机系统之间以及不同 jails 之间的流动方式。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="host-configuration-directories">17.3.3. 设置 jail 目录树<a class="anchor" href="#host-configuration-directories"></a></h4>
<div class="paragraph">
<p>没有特定的位置来放置 jail 的文件。</p>
</div>
<div class="paragraph">
<p>一些管理员使用 <code>/jail</code> ，其他人使用 <code>/usr/jail</code> ，还有一些人使用 <code>/usr/local/jails</code> 。在本章中，将使用 <code>/usr/local/jails</code> 。</p>
</div>
<div class="paragraph">
<p>除了 <span class="filename">/usr/local/jails</span> 目录之外，还会创建其他目录：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="filename">media</span> 将包含已下载用户空间的压缩文件。</p>
</li>
<li>
<p>在使用薄 Jails 时，<span class="filename">templates</span> 文件夹将包含模板。</p>
</li>
<li>
<p><span class="filename">containers</span> 将包含 jail 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在使用 OpenZFS 时，执行以下命令为这些目录创建数据集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -o mountpoint=/usr/local/jails zroot/jails</span>
<span class="c"># zfs create zroot/jails/media</span>
<span class="c"># zfs create zroot/jails/templates</span>
<span class="c"># zfs create zroot/jails/containers</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在这种情况下，<code>zroot</code> 被用作父数据集，但也可以使用其他数据集。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在使用 UFS 时，执行以下命令来创建目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /usr/local/jails/</span>
<span class="c"># mkdir /usr/local/jails/media</span>
<span class="c"># mkdir /usr/local/jails/templates</span>
<span class="c"># mkdir /usr/local/jails/containers</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jail-configuration-files">17.3.4. Jail 配置文件<a class="anchor" href="#jail-configuration-files"></a></h4>
<div class="paragraph">
<p>有两种方法来配置 jails 。</p>
</div>
<div class="paragraph">
<p>第一种方法是在文件 <span class="filename">/etc/jail.conf</span> 中为每个 jail 添加一个条目。另一种选项是在目录 <span class="filename">/etc/jail.conf.d/</span> 中为每个 jail 创建一个文件。</p>
</div>
<div class="paragraph">
<p>没有正确或错误的选择。每个管理员必须选择最适合他们需求的选项。</p>
</div>
<div class="paragraph">
<p>如果主机系统只有几个 jail，可以在文件 <span class="filename">/etc/jail.conf</span> 中为每个 jail 添加一个条目。如果主机系统有很多 jail，最好在 <span class="filename">/etc/jail.conf.d/</span> 目录中为每个 jail 拥有一个配置文件。</p>
</div>
<div class="paragraph">
<p>一个典型的 jail 入口会是这样的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>jailname { <i class="conum" data-value="1"></i><b>(1)</b>
  # STARTUP/LOGGING
  exec.start = &#34;/bin/sh /etc/rc&#34;; <i class="conum" data-value="2"></i><b>(2)</b>
  exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;; <i class="conum" data-value="3"></i><b>(3)</b>
  exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;; <i class="conum" data-value="4"></i><b>(4)</b>

  # PERMISSIONS
  allow.raw_sockets; <i class="conum" data-value="5"></i><b>(5)</b>
  exec.clean; <i class="conum" data-value="6"></i><b>(6)</b>
  mount.devfs; <i class="conum" data-value="7"></i><b>(7)</b>

  # HOSTNAME/PATH
  host.hostname = &#34;${name}&#34;; <i class="conum" data-value="8"></i><b>(8)</b>
  path = &#34;/usr/local/jails/containers/${name}&#34;; <i class="conum" data-value="9"></i><b>(9)</b>

  # NETWORK
  ip4.addr = 192.168.1.151; <i class="conum" data-value="10"></i><b>(10)</b>
  ip6.addr = ::ffff:c0a8:197 <i class="conum" data-value="11"></i><b>(11)</b>
  interface = em0; <i class="conum" data-value="12"></i><b>(12)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td><code>jailname</code> - jail 的名称。 &lt;.&gt; <code>exec.start</code> - 创建 jail 时在 jail 环境中运行的命令。通常运行的命令是 &#34;/bin/sh /etc/rc&#34;。 &lt;.&gt; <code>exec.stop</code> - 删除 jail 之前在 jail 环境中运行的命令。通常运行的命令是 &#34;/bin/sh /etc/rc.shutdown&#34;。 &lt;.&gt; <code>exec.consolelog</code> - 将命令输出（stdout 和 stderr）重定向到的文件。 &lt;.&gt; <code>allow.raw_sockets</code> - 允许在 jail 内创建原始套接字。设置此参数允许像 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> 这样的实用程序在 jail 内运行。 &lt;.&gt; <code>exec.clean</code> - 在一个干净的环境中运行命令。 &lt;.&gt; <code>mount.devfs</code> - 在 chrooted <span class="filename">/dev</span> 目录上挂载一个 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs&amp;sektion=5&amp;format=html">devfs(5)</a> 文件系统，并应用 devfs_ruleset 参数中的规则集来限制 jail 内可见的设备。 &lt;.&gt; <code>host.hostname</code> - jail 的主机名。 &lt;.&gt; <code>path</code> - jail 的根目录。在 jail 内运行的任何命令，无论是通过 jail 还是 <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> 运行，都是从此目录开始的。 &lt;.&gt; <code>ip4.addr</code> - IPv4 地址。 IPv4 有两种配置可能性。第一种是像示例中所做的那样建立一个 IP 或 IP 列表。另一种是使用 <code>ip4</code> 替代，并将 <code>inherit</code> 值设置为继承主机的 IP 地址。 &lt;.&gt; <code>ip6.addr</code> - IPv6 地址。 IPv6 有两种配置可能性。第一种是像示例中所做的那样建立一个 IP 或 IP 列表。另一种是使用 <code>ip6</code> 替代，并将 <code>inherit</code> 值设置为继承主机的 IP 地址。 &lt;.&gt; <code>interface</code> - 添加 jail 的 IP 地址的网络接口。通常是主机接口。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>有关配置变量的更多信息可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail&amp;sektion=8&amp;format=html">jail(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=jail.conf&amp;sektion=5&amp;format=html">jail.conf(5)</a> 中找到。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="classic-jail">17.4. 经典 Jail（厚 Jail ）<a class="anchor" href="#classic-jail"></a></h3>
<div class="paragraph">
<p>这些 jail 类似于真实的 FreeBSD 系统。它们可以像普通主机系统一样进行管理，并且可以独立更新。</p>
</div>
<div class="sect3">
<h4 id="creating-classic-jail">17.4.1. 创建一个经典 Jail<a class="anchor" href="#creating-classic-jail"></a></h4>
<div class="paragraph">
<p>原则上，一个 jail 只需要一个主机名、一个根目录、一个 IP 地址和一个用户空间。</p>
</div>
<div class="paragraph">
<p>可以从官方的 FreeBSD 下载服务器获取用于 jail 的用户空间。</p>
</div>
<div class="paragraph">
<p>执行以下命令以下载用户空间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># fetch https://download.freebsd.org/ftp/releases/amd64/amd64/13.2-RELEASE/base.txz -o /usr/local/jails/media/13.2-RELEASE-base.txz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下载完成后，需要将内容解压到 jail 目录中。</p>
</div>
<div class="paragraph">
<p>执行以下命令将用户空间提取到 jail 目录中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir -p /usr/local/jails/containers/classic</span>
<span class="c"># tar -xf /usr/local/jails/media/13.2-RELEASE-base.txz -C /usr/local/jails/containers/classic --unlink</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 jail 目录中提取用户空间后，需要复制时区和 DNS 服务器文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/resolv.conf /usr/local/jails/containers/classic/etc/resolv.conf</span>
<span class="c"># cp /etc/localtime /usr/local/jails/containers/classic/etc/localtime</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在复制文件后，下一步是通过执行以下命令更新到最新的补丁级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -b /usr/local/jails/containers/classic/ fetch install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一步是配置 jail。需要在配置文件 <span class="filename">/etc/jail.conf</span> 或 <span class="filename">jail.conf.d</span> 中添加一个条目，包含 jail 的参数。</p>
</div>
<div class="paragraph">
<p>一个例子如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>classic {
  # STARTUP/LOGGING
  exec.start = &#34;/bin/sh /etc/rc&#34;;
  exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;
  exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;;

  # PERMISSIONS
  allow.raw_sockets;
  exec.clean;
  mount.devfs;

  # HOSTNAME/PATH
  host.hostname = &#34;${name}&#34;;
  path = &#34;/usr/local/jails/containers/${name}&#34;;

  # NETWORK
  ip4.addr = 192.168.1.151;
  interface = em0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>执行以下命令以启动 jail ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service jail start classic</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关如何管理 jails 的更多信息可以在 <a href="#jail-management">Jail 管理</a> 部分找到。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="thin-jail">17.5. 薄（Thin）Jails<a class="anchor" href="#thin-jail"></a></h3>
<div class="paragraph">
<p>尽管瘦 Jails 使用与胖 Jails 相同的技术，但创建过程是不同的。可以使用 OpenZFS 快照或使用模板和 NullFS 来创建瘦 jails。使用 OpenZFS 快照和使用 NullFS 的模板相比传统的 jails 具有一定的优势，例如可以更快地从快照创建它们，或者可以使用 NullFS 更新多个 jails。</p>
</div>
<div class="sect3">
<h4 id="creating-thin-jail-openzfs-snapshots">17.5.1. 使用 OpenZFS 快照创建一个瘦 Jail<a class="anchor" href="#creating-thin-jail-openzfs-snapshots"></a></h4>
<div class="paragraph">
<p>由于 FreeBSD 和 OpenZFS 之间的良好集成，使用 OpenZFS 快照创建新的瘦 Jails 非常容易。</p>
</div>
<div class="paragraph">
<p>使用 OpenZFS 快照创建瘦 Jail 的第一步是创建一个模板。</p>
</div>
<div class="paragraph">
<p>模板只用于创建新的 jail。因此，它们以“只读”模式创建，以便 jail 以不可变的基础创建。</p>
</div>
<div class="paragraph">
<p>要为模板创建数据集，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -p zroot/jails/templates/13.2-RELEASE</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后执行以下命令来下载用户空间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># fetch https://download.freebsd.org/ftp/releases/amd64/amd64/13.2-RELEASE/base.txz -o /usr/local/jails/media/13.2-RELEASE-base.txz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下载完成后，需要执行以下命令将内容解压到模板目录中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tar -xf /usr/local/jails/media/13.2-RELEASE-base.txz -C /usr/local/jails/templates/13.2-RELEASE --unlink</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在模板目录中提取用户空间后，需要通过执行以下命令将时区和 DNS 服务器文件复制到模板目录中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/resolv.conf /usr/local/jails/templates/13.2-RELEASE/etc/resolv.conf</span>
<span class="c"># cp /etc/localtime /usr/local/jails/templates/13.2-RELEASE/etc/localtime</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步要做的是通过执行以下命令更新到最新的补丁级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -b /usr/local/jails/templates/13.2-RELEASE/ fetch install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦更新完成，模板就准备好了。</p>
</div>
<div class="paragraph">
<p>要从模板创建一个 OpenZFS 快照，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot zroot/jails/templates/13.2-RELEASE@base</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦创建了 OpenZFS 快照，就可以使用 OpenZFS 克隆功能创建无限个 jail。</p>
</div>
<div class="paragraph">
<p>要创建一个名为 <code>thinjail</code> 的薄 Jail，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs clone zroot/jails/templates/13.2-RELEASE@base zroot/jails/containers/thinjail</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一步是配置 jail。需要在配置文件 <span class="filename">/etc/jail.conf</span> 或 <span class="filename">jail.conf.d</span> 中添加一个条目，包含 jail 的参数。</p>
</div>
<div class="paragraph">
<p>一个例子如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>thinjail {
  # STARTUP/LOGGING
  exec.start = &#34;/bin/sh /etc/rc&#34;;
  exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;
  exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;;

  # PERMISSIONS
  allow.raw_sockets;
  exec.clean;
  mount.devfs;

  # HOSTNAME/PATH
  host.hostname = &#34;${name}&#34;;
  path = &#34;/usr/local/jails/containers/${name}&#34;;

  # NETWORK
  ip4 = inherit;
  interface = em0;
}</pre>
</div>
</div>
<div class="paragraph">
<p>执行以下命令以启动 jail ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service jail start thinjail</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关如何管理 jails 的更多信息可以在 <a href="#jail-management">Jail 管理</a> 部分找到。</p>
</div>
</div>
<div class="sect3">
<h4 id="creating-thin-jail-nullfs">17.5.2. 使用 NullFS 创建一个薄 Jail<a class="anchor" href="#creating-thin-jail-nullfs"></a></h4>
<div class="paragraph">
<p>使用薄 Jail 技术和使用 NullFS 将特定目录从主机系统选择性地共享到 jail 中，可以减少系统文件的重复创建。</p>
</div>
<div class="paragraph">
<p>第一步是创建数据集以保存模板，如果使用 OpenZFS，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -p zroot/jails/templates/13.2-RELEASE-base</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 UFS，则使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /usr/local/jails/templates/13.2-RELEASE-base</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后执行以下命令来下载用户空间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># fetch https://download.freebsd.org/ftp/releases/amd64/amd64/13.2-RELEASE/base.txz -o /usr/local/jails/media/13.2-RELEASE-base.txz</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下载完成后，需要执行以下命令将内容解压到模板目录中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tar -xf /usr/local/jails/media/13.2-RELEASE-base.txz -C /usr/local/jails/templates/13.2-RELEASE-base --unlink</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦用户空间在模板目录中被提取出来，就需要通过执行以下命令将时区和 DNS 服务器文件复制到模板目录中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/resolv.conf /usr/local/jails/templates/13.2-RELEASE-base/etc/resolv.conf</span>
<span class="c"># cp /etc/localtime /usr/local/jails/templates/13.2-RELEASE-base/etc/localtime</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将文件移动到模板后，下一步要做的是通过执行以下命令更新到最新的补丁级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -b /usr/local/jails/templates/13.2-RELEASE-base/ fetch install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了基本模板之外，还需要创建一个目录，用于存放 <code>skeleton</code>。一些目录将从模板复制到 <code>skeleton</code> 中。</p>
</div>
<div class="paragraph">
<p>在使用 OpenZFS 的情况下，执行以下命令创建 <code>skeleton</code> 的数据集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -p zroot/jails/templates/13.2-RELEASE-skeleton</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 UFS，则使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /usr/local/jails/templates/13.2-RELEASE-skeleton</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后创建 <code>skeleton</code> 目录。 <code>skeleton</code> 目录将保存 jail 的本地目录。</p>
</div>
<div class="paragraph">
<p>执行以下命令创建目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir -p /usr/local/jails/templates/13.2-RELEASE-skeleton/home</span>
<span class="c"># mkdir -p /usr/local/jails/templates/13.2-RELEASE-skeleton/usr</span>
<span class="c"># mv /usr/local/jails/templates/13.2-RELEASE-base/etc /usr/local/jails/templates/13.2-RELEASE-skeleton/etc</span>
<span class="c"># mv /usr/local/jails/templates/13.2-RELEASE-base/usr/local /usr/local/jails/templates/13.2-RELEASE-skeleton/usr/local</span>
<span class="c"># mv /usr/local/jails/templates/13.2-RELEASE-base/tmp /usr/local/jails/templates/13.2-RELEASE-skeleton/tmp</span>
<span class="c"># mv /usr/local/jails/templates/13.2-RELEASE-base/var /usr/local/jails/templates/13.2-RELEASE-skeleton/var</span>
<span class="c"># mv /usr/local/jails/templates/13.2-RELEASE-base/root /usr/local/jails/templates/13.2-RELEASE-skeleton/root</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是通过执行以下命令创建到 <code>skeleton</code> 的符号链接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/local/jails/templates/13.2-RELEASE-base/</span>
<span class="c"># mkdir skeleton</span>
<span class="c"># ln -s skeleton/etc etc</span>
<span class="c"># ln -s skeleton/home home</span>
<span class="c"># ln -s skeleton/root root</span>
<span class="c"># ln -s skeleton/usr/local usr/local</span>
<span class="c"># ln -s skeleton/tmp tmp</span>
<span class="c"># ln -s skeleton/var var</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>准备好了 <code>skeleton</code> 之后，需要将数据复制到 jail 目录中。</p>
</div>
<div class="paragraph">
<p>如果使用 OpenZFS，可以使用 OpenZFS 快照通过执行以下命令轻松创建所需数量的 jails ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot zroot/jails/templates/13.2-RELEASE-skeleton@base</span>
<span class="c"># zfs clone zroot/jails/templates/13.2-RELEASE-skeleton@base zroot/jails/containers/thinjail</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 UFS 文件系统，可以通过执行以下命令来使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cp&amp;sektion=1&amp;format=html">cp(1)</a> 程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /usr/local/jails/containers/thinjail</span>
<span class="c"># cp -R /usr/local/jails/templates/13.2-RELEASE-skeleton /usr/local/jails/containers/thinjail</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后创建一个目录，用于挂载基本模板和 skeleton：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir -p /usr/local/jails/thinjail-nullfs-base</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <span class="filename">/etc/jail.conf</span> 中添加一个 jail 条目，或者在 <span class="filename">jail.conf.d</span> 目录中添加一个文件，内容如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>thinjail {
  # STARTUP/LOGGING
  exec.start = &#34;/bin/sh /etc/rc&#34;;
  exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;
  exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;;

  # PERMISSIONS
  allow.raw_sockets;
  exec.clean;
  mount.devfs;

  # HOSTNAME/PATH
  host.hostname = &#34;${name}&#34;;
  path = &#34;/usr/local/jails/containers/${name}&#34;;

  # NETWORK
  ip4.addr = 192.168.1.153;
  interface = em0;

  # MOUNT
  mount.fstab = &#34;/usr/local/jails/thinjail-nullfs-base.fstab&#34;;
}</pre>
</div>
</div>
<div class="paragraph">
<p>然后按照以下方式创建 <span class="filename">/usr/local/jails/thinjail-nullfs-base.fstab</span> 文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/usr/local/jails/templates/13.2-RELEASE-base  /usr/local/jails/thinjail-nullfs-base/ nullfs   ro          0 0
/usr/local/jails/containers/thinjail     /usr/local/jails/thinjail-nullfs-base/skeleton nullfs  rw  0 0</pre>
</div>
</div>
<div class="paragraph">
<p>执行以下命令以启动 jail ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service jail start thinjail</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="creating-vnet-jail">17.5.3. 创建一个 VNET Jail<a class="anchor" href="#creating-vnet-jail"></a></h4>
<div class="paragraph">
<p>FreeBSD VNET Jails 拥有独立的网络堆栈，包括接口、 IP 地址、路由表和防火墙规则。</p>
</div>
<div class="paragraph">
<p>创建 VNET jail 的第一步是通过执行以下命令创建 <a href="https://man.freebsd.org/cgi/man.cgi?query=bridge&amp;sektion=4&amp;format=html">bridge(4)</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge create</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>bridge0</pre>
</div>
</div>
<div class="paragraph">
<p>创建了 <code>bridge</code> 之后，需要通过执行以下命令将其附加到 <code>em0</code> 接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 addm em0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使此设置在重新启动后保持不变，请将以下行添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>defaultrouter=&#34;192.168.1.1&#34;
cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;inet 192.168.1.150/24 addm em0 up&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是按照上述所示创建 jail 。</p>
</div>
<div class="paragraph">
<p>可以使用 <a href="#classic-jail">经典 Jail（厚 Jail ）</a> 过程和 <a href="#thin-jail">薄（Thin）Jails</a> 过程。唯一需要更改的是 <span class="filename">/etc/jail.conf</span> 文件中的配置。</p>
</div>
<div class="paragraph">
<p>路径 <span class="filename">/usr/local/jails/containers/vnet</span> 将被用作创建的 jail 的示例。</p>
</div>
<div class="paragraph">
<p>以下是一个 VNET jail 的配置示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vnet {
  # STARTUP/LOGGING
  exec.start = &#34;/bin/sh /etc/rc&#34;;
  exec.stop  = &#34;/bin/sh /etc/rc.shutdown&#34;;
  exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;;

  # PERMISSIONS
  allow.raw_sockets;
  exec.clean;
  mount.devfs;
  devfs_ruleset = 5;

  # PATH/HOSTNAME
  path = &#34;/usr/local/jails/containers/${name}&#34;;
  host.hostname = &#34;${name}&#34;;

  # VNET/VIMAGE
  vnet;
  vnet.interface = &#34;${epair}b&#34;;

  # NETWORKS/INTERFACES
  $id = &#34;154&#34;; <i class="conum" data-value="1"></i><b>(1)</b>
  $ip = &#34;192.168.1.${id}/24&#34;;
  $gateway = &#34;192.168.1.1&#34;;
  $bridge = &#34;bridge0&#34;; <i class="conum" data-value="2"></i><b>(2)</b>
  $epair = &#34;epair${id}&#34;;

  # ADD TO bridge INTERFACE
  exec.prestart += &#34;ifconfig ${epair} create up&#34;;
  exec.prestart += &#34;ifconfig ${epair}a up descr jail:${name}&#34;;
  exec.prestart += &#34;ifconfig ${bridge} addm ${epair}a up&#34;;
  exec.start    += &#34;ifconfig ${epair}b ${ip} up&#34;;
  exec.start    += &#34;route add default ${gateway}&#34;;
  exec.poststop = &#34;ifconfig ${bridge} deletem ${epair}a&#34;;
  exec.poststop += &#34;ifconfig ${epair}a destroy&#34;;
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>表示 Jail 的 IP 地址，它必须是 <strong>唯一的</strong> 。 &lt;.&gt; 指的是之前创建的桥接。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="creating-linux-jail">17.5.4. 创建一个 Linux Jail<a class="anchor" href="#creating-linux-jail"></a></h4>
<div class="paragraph">
<p>FreeBSD 可以使用 <a href="./#linuxemu">Linux 二进制兼容性</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=debootstrap&amp;sektion=8&amp;format=html">debootstrap(8)</a> 在 jail 中运行 Linux。jail 没有内核，它们在主机的内核上运行。因此，在主机系统中启用 Linux 二进制兼容性是必要的。</p>
</div>
<div class="paragraph">
<p>要在启动时启用 Linux ABI，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc linux_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦启用，可以通过执行以下命令来启动，无需重新启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service linux start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步将是按照上述所示创建一个 jail ，例如在 <a href="#creating-thin-jail-openzfs-snapshots">使用 OpenZFS 快照创建一个瘦 Jail</a> 中，但 <strong>不要</strong> 执行配置。FreeBSD Linux jail 需要特定的配置，将在下面详细说明。</p>
</div>
<div class="paragraph">
<p>一旦按照上述说明创建了 jail，执行以下命令进行所需的 jail 配置并启动它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># jail -cm \</span>
    <span class="nv">name</span><span class="o">=</span>ubuntu <span class="se">\</span>
    host.hostname<span class="o">=</span><span class="s2">&#34;ubuntu.example.com&#34;</span> <span class="se">\</span>
    <span class="nv">path</span><span class="o">=</span><span class="s2">&#34;/usr/local/jails/ubuntu&#34;</span> <span class="se">\</span>
    <span class="nv">interface</span><span class="o">=</span><span class="s2">&#34;em0&#34;</span> <span class="se">\</span>
    ip4.addr<span class="o">=</span><span class="s2">&#34;192.168.1.150&#34;</span> <span class="se">\</span>
    exec.start<span class="o">=</span><span class="s2">&#34;/bin/sh /etc/rc&#34;</span> <span class="se">\</span>
    exec.stop<span class="o">=</span><span class="s2">&#34;/bin/sh /etc/rc.shutdown&#34;</span> <span class="se">\</span>
    mount.devfs <span class="se">\</span>
    <span class="nv">devfs_ruleset</span><span class="o">=</span>4 <span class="se">\</span>
    allow.mount <span class="se">\</span>
    allow.mount.devfs <span class="se">\</span>
    allow.mount.fdescfs <span class="se">\</span>
    allow.mount.procfs <span class="se">\</span>
    allow.mount.linprocfs <span class="se">\</span>
    allow.mount.linsysfs <span class="se">\</span>
    allow.mount.tmpfs <span class="se">\</span>
    <span class="nv">enforce_statfs</span><span class="o">=</span>1</code></pre>
</div>
</div>
<div class="paragraph">
<p>要访问 jail ，需要安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/debootstrap/">sysutils/debootstrap</a>。</p>
</div>
<div class="paragraph">
<p>执行以下命令以访问 FreeBSD Linux jail：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># jexec -u root ubuntu</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 jail 内执行以下命令来安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/debootstrap/">sysutils/debootstrap</a> 并准备 Ubuntu 环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install debootstrap</span>
<span class="c"># debootstrap jammy /compat/ubuntu</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当进程完成并在控制台上显示 <code>successfully</code> 消息时，需要通过执行以下命令在主机系统上停止 jail：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service jail ubuntu onestop</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后在 [/etc/jail.conf] 文件中添加一个 Linux jail 的条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ubuntu {
  # STARTUP/LOGGING
  exec.start = &#34;/bin/sh /etc/rc&#34;;
  exec.stop = &#34;/bin/sh /etc/rc.shutdown&#34;;
  exec.consolelog = &#34;/var/log/jail_console_${name}.log&#34;;

  # PERMISSIONS
  allow.raw_sockets;
  exec.clean;
  mount.devfs;
  devfs_ruleset=4;

  # HOSTNAME/PATH
  host.hostname = &#34;${name}&#34;;
  path = &#34;/usr/local/jails/containers/${name}&#34;;

  # NETWORK
  ip4.addr = 192.168.1.155;
  interface = em0;

  # MOUNT
  mount += &#34;devfs     $path/compat/ubuntu/dev     devfs     rw  0 0&#34;;
  mount += &#34;tmpfs     $path/compat/ubuntu/dev/shm tmpfs     rw,size=1g,mode=1777  0 0&#34;;
  mount += &#34;fdescfs   $path/compat/ubuntu/dev/fd  fdescfs   rw,linrdlnk 0 0&#34;;
  mount += &#34;linprocfs $path/compat/ubuntu/proc    linprocfs rw  0 0&#34;;
  mount += &#34;linsysfs  $path/compat/ubuntu/sys     linsysfs  rw  0 0&#34;;
  mount += &#34;/tmp      $path/compat/ubuntu/tmp     nullfs    rw  0 0&#34;;
  mount += &#34;/home     $path/compat/ubuntu/home    nullfs    rw  0 0&#34;;
}</pre>
</div>
</div>
<div class="paragraph">
<p>然后可以使用以下命令正常启动 jail：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service jail start ubuntu</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用以下命令访问 Ubuntu 环境：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># jexec ubuntu chroot /compat/ubuntu /bin/bash</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>更多信息可以在章节 <a href="./#linuxemu">Linux 二进制兼容性</a> 中找到。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jail-management">17.6. Jail 管理<a class="anchor" href="#jail-management"></a></h3>
<div class="paragraph">
<p>一旦创建了 jail，就可以执行许多操作，比如启动、重启或删除 jail，安装软件等。本节将描述可以在主机上执行的不同 jail 操作。</p>
</div>
<div class="sect3">
<h4 id="list-running-jails">17.6.1. 列出运行中的 Jails<a class="anchor" href="#list-running-jails"></a></h4>
<div class="paragraph">
<p>要列出运行在主机系统上的 jails，可以使用命令 <a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># jls</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>   JID  IP Address      Hostname                      Path
     1  192.168.250.70  classic                       /usr/local/jails/containers/classic</pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=jls&amp;sektion=8&amp;format=html">jls(8)</a> 支持 <code>--libxo</code> 参数，通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=libxo&amp;sektion=3&amp;format=html">libxo(3)</a> 库可以显示其他类型的格式，例如 <code>JSON</code>、<code>HTML</code> 等。</p>
</div>
<div class="paragraph">
<p>例如，执行以下命令以获取 <code>JSON</code> 输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># jls --libxo=json</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>{&#34;__version&#34;: &#34;2&#34;, &#34;jail-information&#34;: {&#34;jail&#34;: [{&#34;jid&#34;:1,&#34;ipv4&#34;:&#34;192.168.250.70&#34;,&#34;hostname&#34;:&#34;classic&#34;,&#34;path&#34;:&#34;/usr/local/jails/containers/classic&#34;}]}}</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="start-jail">17.6.2. 启动、重新启动和停止一个 Jail<a class="anchor" href="#start-jail"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 用于在主机上启动、重启或停止一个 jail。</p>
</div>
<div class="paragraph">
<p>例如，要启动一个 jail，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service jail start jailname</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>start</code> 参数更改为 <code>restart</code> 或 <code>stop</code> 以执行其他对 jail 的操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="destroy-jail">17.6.3. 销毁一个 jail<a class="anchor" href="#destroy-jail"></a></h4>
<div class="paragraph">
<p>销毁一个 jail 并不像使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 停止 jail 和删除 jail 目录以及 <span class="filename">/etc/jail.conf</span> 条目那样简单。</p>
</div>
<div class="paragraph">
<p>FreeBSD 非常重视系统安全。因此，有一些文件即使是 root 用户也无法删除。这种功能被称为文件标志。</p>
</div>
<div class="paragraph">
<p>第一步是停止所需的 jail 执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service jail stop jailname</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第二步是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 命令来移除这些标志，执行以下命令，其中 <code>classic</code> 是要移除的 jail 的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chflags -R 0 /usr/local/jails/classic</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>第三步是删除 jail 所在的目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rm -rf /usr/local/jails/classic</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，需要在 <span class="filename">/etc/jail.conf</span> 或 <span class="filename">jail.conf.d</span> 中删除 jail 条目。</p>
</div>
</div>
<div class="sect3">
<h4 id="handle-packages-jail">17.6.4. 在 Jail 中处理软件包<a class="anchor" href="#handle-packages-jail"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 工具支持 <code>-j</code> 参数，以处理安装在 jail 内的软件包。</p>
</div>
<div class="paragraph">
<p>例如，在 jail 中安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/nginx-lite/">nginx-lite</a>，可以从主机上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg -j classic install nginx-lite</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关在 FreeBSD 中使用软件包的更多信息，请参阅 <a href="./#ports">“安装应用程序：软件包和 Ports”</a>。</p>
</div>
</div>
<div class="sect3">
<h4 id="access-jail">17.6.5. 访问一个 Jail<a class="anchor" href="#access-jail"></a></h4>
<div class="paragraph">
<p>虽然上面已经提到最好从主机系统管理 jail，但可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> 进入 jail。</p>
</div>
<div class="paragraph">
<p>可以通过在主机上运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> 来进入 jail。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># jexec -u root jailname</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当访问 jail 时，将显示在 <a href="https://man.freebsd.org/cgi/man.cgi?query=motd&amp;sektion=5&amp;format=html">motd(5)</a> 中配置的消息。</p>
</div>
</div>
<div class="sect3">
<h4 id="execute-commands-jail">17.6.6. 在 Jail 中执行命令<a class="anchor" href="#execute-commands-jail"></a></h4>
<div class="paragraph">
<p>要在一个 jail 中从主机系统执行命令，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=jexec&amp;sektion=8&amp;format=html">jexec(8)</a> 命令。</p>
</div>
<div class="paragraph">
<p>例如，要停止在 jail 中运行的服务，将执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># jexec -l jailname service stop nginx</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jail-upgrading">17.7. Jail 升级<a class="anchor" href="#jail-upgrading"></a></h3>
<div class="paragraph">
<p>升级 FreeBSD Jails 可以确保隔离环境保持安全、最新，并与 FreeBSD 生态系统中的最新功能和改进保持一致。</p>
</div>
<div class="sect3">
<h4 id="jails-updating">17.7.1. 使用 OpenZFS 快照升级经典 Jail 或薄 Jail<a class="anchor" href="#jails-updating"></a></h4>
<div class="paragraph">
<p>Jails 必须从主机操作系统进行更新。在 FreeBSD 中，默认行为是禁止在 jail 中使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 命令。这将阻止对某些文件的更新，因此在 jail 内部进行更新将失败。</p>
</div>
<div class="paragraph">
<p>要将 jail 更新到运行的 FreeBSD 版本的最新补丁版本，请在主机上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -j classic fetch install</span>
<span class="c"># service jail restart classic</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要将 jail 升级到新的主要或次要版本，首先按照 <a href="./#freebsdupdate-upgrade">“执行主要和次要版本升级”</a> 中描述的方法升级主机系统。一旦主机升级并重新启动，就可以升级 jail。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果从一个版本升级到另一个版本，创建一个新的 jail 比完全升级更容易。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>例如，要从 13.1-RELEASE 升级到 13.2-RELEASE，请在主机上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -j classic -r 13.2-RELEASE upgrade</span>
<span class="c"># freebsd-update -j classic install</span>
<span class="c"># service jail restart classic</span>
<span class="c"># freebsd-update -j classic install</span>
<span class="c"># service jail restart classic</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>需要执行两次 <code>install</code> 步骤。第一次升级内核，第二次升级其他组件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，如果是一个主要版本的升级，重新安装所有已安装的软件包并重新启动 jail。这是必需的，因为在 FreeBSD 的主要版本之间升级时，ABI 版本会发生变化。</p>
</div>
<div class="paragraph">
<p>来自主机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg -j jailname upgrade -f</span>
<span class="c"># service jail restart jailname</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="upgrading-thin-jail">17.7.2. 使用 NullFS 升级薄 Jail<a class="anchor" href="#upgrading-thin-jail"></a></h4>
<div class="paragraph">
<p>由于使用 NullFS 的薄 Jails 共享了大部分系统目录，因此它们非常容易更新。只需更新模板即可，这样可以同时更新多个 Jail。</p>
</div>
<div class="paragraph">
<p>要将模板更新到运行的 FreeBSD 版本的最新补丁版本，请在主机上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -b /usr/local/jails/templates/13.1-RELEASE-base/ fetch install</span>
<span class="c"># service jail restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要将模板升级到新的主要或次要版本，首先按照 <a href="./#freebsdupdate-upgrade">“执行主要和次要版本升级”</a> 中描述的方式升级主机系统。一旦主机升级并重新启动，然后可以升级模板。</p>
</div>
<div class="paragraph">
<p>例如，要从 13.1-RELEASE 升级到 13.2-RELEASE ，请在主机上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -b /usr/local/jails/templates/13.1-RELEASE-base/ -r 13.2-RELEASE upgrade</span>
<span class="c"># freebsd-update -b /usr/local/jails/templates/13.1-RELEASE-base/ install</span>
<span class="c"># service jail restart</span>
<span class="c"># freebsd-update -b /usr/local/jails/templates/13.1-RELEASE-base/ install</span>
<span class="c"># service jail restart</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="jail-resource-limits">17.8. Jail 资源限制<a class="anchor" href="#jail-resource-limits"></a></h3>
<div class="paragraph">
<p>系统管理员需要考虑从主机系统控制 jail 使用的资源的任务。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=rctl&amp;sektion=8&amp;format=html">rctl(8)</a> 允许您从主机系统管理 jail 可以使用的资源。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>必须在 <code>/boot/loader.conf</code> 文件中启用 <code>tunables</code> 的 <code>kern.racct.enable</code> 选项。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>限制 jail 资源的语法如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rctl -a jail:&lt;jailname&gt;:resource:action=amount/percentage</pre>
</div>
</div>
<div class="paragraph">
<p>例如，要限制一个 jail 可以访问的最大 RAM，运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rctl -a jail:classic:memoryuse:deny=2G</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使限制在主机系统重新启动后仍然有效，需要将规则添加到 <span class="filename">/etc/rctl.conf</span> 文件中，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>jail:classic:memoryuse:deny=2G/jail</pre>
</div>
</div>
<div class="paragraph">
<p>有关资源限制的更多信息可以在安全章节中找到，具体请参考 <a href="./#security-resourcelimits">“资源限制部分”</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="jail-managers-and-containers">17.9. Jail 管理器和容器<a class="anchor" href="#jail-managers-and-containers"></a></h3>
<div class="paragraph">
<p>如前所述，每种类型的 FreeBSD Jail 都可以手动创建和配置，但 FreeBSD 还有第三方工具可以使配置和管理更加简便。</p>
</div>
<div class="paragraph">
<p>下面是一个不完整的不同 FreeBSD Jail 管理器的列表：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<caption class="title">表 29. Jail 管理器</caption>
<colgroup>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
<col style="width: 25%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">名称</th>
<th class="tableblock halign-left valign-top">许可证</th>
<th class="tableblock halign-left valign-top">包</th>
<th class="tableblock halign-left valign-top">文档</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">BastilleBSD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/bastille/">sysutils/bastille</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://bastille.readthedocs.io/en/latest/">文档</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">pot</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/pot/">sysutils/pot</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://pot.pizzamig.dev/">文档</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cbsd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/cbsd/">sysutils/cbsd</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://www.bsdstore.ru/en/docs.html">文档</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">AppJail</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/appjail/">sysutils/appjail</a>, for devel <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/appjail-devel/">sysutils/appjail-devel</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://github.com/DtxdF/AppJail#getting-started">文档</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">iocage</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">BSD-2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/iocage/">sysutils/iocage</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://iocage.readthedocs.io/en/latest/">文档</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ezjail</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://erdgeist.org/beerware.html">Beer Ware</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/ezjail/">sysutils/ezjail</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://erdgeist.org/arts/software/ezjail/">文档</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mac">Chapter 18. 强制访问控制<a class="anchor" href="#mac"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="mac-synopsis">18.1. 简介<a class="anchor" href="#mac-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 支持基于 POSIX®.1e 草案的安全扩展。这些安全机制包括文件系统访问控制列表（参见： security[fs-acl ，“访问控制列表”] ）和强制访问控制（ MAC ）。 MAC 允许加载访问控制模块以实施安全策略。一些模块为系统的一小部分提供保护，加固特定服务。其他模块提供全面的标记安全性，涵盖所有主体和对象。定义中的强制部分表示控制的执行由管理员和操作系统执行。这与默认的自主访问控制（ DAC ）安全机制形成对比，后者将执行权留给用户自行决定。</p>
</div>
<div class="paragraph">
<p>本章重点介绍 MAC 框架以及 FreeBSD 提供的一组可插拔安全策略模块，用于启用各种安全机制。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，你将会了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>与 MAC 框架相关的术语。</p>
</li>
<li>
<p>MAC 安全策略模块的功能以及标记和非标记策略之间的区别。</p>
</li>
<li>
<p>在配置系统使用 MAC 框架之前需要考虑的因素。</p>
</li>
<li>
<p>FreeBSD 中包含哪些 MAC 安全策略模块以及如何配置它们。</p>
</li>
<li>
<p>如何使用 MAC 框架实现更安全的环境。</p>
</li>
<li>
<p>如何测试 MAC 配置以确保框架已经正确实施。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，你应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 UNIX® 和 FreeBSD 基础知识（参考： basics[basics ， FreeBSD 基础知识] ）。</p>
</li>
<li>
<p>对于安全性以及它与 FreeBSD 的相关性有一定的了解（参考： security[security ,安全性] ）。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>不正确的 MAC 配置可能导致系统访问丢失，用户受到困扰，或无法访问 Xorg 提供的功能。更重要的是，不能仅依赖 MAC 来完全保护系统。 MAC 框架只是增强现有安全策略。如果没有健全的安全实践和定期的安全检查，系统将永远无法完全安全。</p>
</div>
<div class="paragraph">
<p>本章中包含的示例仅用于演示目的，示例设置 <strong> 不应 </strong> 在生产系统上实施。实施任何安全策略都需要充分理解、正确设计和彻底测试。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>尽管本章涵盖了与 MAC 框架相关的广泛安全问题，但不包括开发新的 MAC 安全策略模块。 MAC 框架附带的一些安全策略模块具有特定特性，既用于测试，也用于新模块的开发。有关这些安全策略模块及其提供的各种机制的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_test&amp;sektion=4&amp;format=html">mac_test(4)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_stub&amp;sektion=4&amp;format=html">mac_stub(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_none&amp;sektion=4&amp;format=html">mac_none(4)</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="mac-inline-glossary">18.2. 关键术语<a class="anchor" href="#mac-inline-glossary"></a></h3>
<div class="paragraph">
<p>在提到 MAC 框架时，使用以下关键术语：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>隔离区</em>：一组要进行分区或分离的程序和数据，用户被授予对系统特定组件的明确访问权限。隔离区表示一种分组，例如工作组、部门、项目或主题。隔离区使得实施需要知道的安全策略成为可能。</p>
</li>
<li>
<p>完整性：可以对数据放置的信任级别。随着数据的完整性提高，对该数据的信任能力也随之增强。</p>
</li>
<li>
<p><em>level</em>: 安全属性的增加或减少设置。随着级别的提高，其安全性也被认为提升。</p>
</li>
<li>
<p><em>label</em>：一个可以应用于系统中的文件、目录或其他项目的安全属性。它可以被视为一个机密性标记。当一个标签被放置在一个文件上时，它描述了该文件的安全属性，并且只允许具有相似安全设置的文件、用户和资源访问。标签值的含义和解释取决于策略配置。一些策略将标签视为表示对象的完整性或保密性，而其他策略可能使用标签来保存访问规则。</p>
</li>
<li>
<p><em>multilabel</em>：这个属性是一个文件系统选项，可以在单用户模式下使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> 设置，在启动时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 设置，或在创建新文件系统时设置。此选项允许管理员在不同的对象上应用不同的 MAC 标签。此选项仅适用于支持标签的安全策略模块。</p>
</li>
<li>
<p>单标签：一种策略，整个文件系统使用一个标签来强制对数据流进行访问控制。只要未设置“多标签”，所有文件都将符合相同的标签设置。</p>
</li>
<li>
<p><em>object</em>：在_subject_的指导下，信息流经过的实体。这包括目录、文件、字段、屏幕、键盘、内存、磁存储、打印机或任何其他数据存储或移动设备。对象是一个数据容器或系统资源。访问对象实际上意味着访问其数据。</p>
</li>
<li>
<p><em>subject</em>: 任何能够在对象之间传递信息的活动实体，例如用户、用户进程或系统进程。在 FreeBSD 上，这几乎总是一个代表用户的进程中的线程。</p>
</li>
<li>
<p><em>政策</em>：一系列规则的集合，定义了如何实现目标。政策通常记录了如何处理特定事项。本章将政策视为一系列控制数据和信息流动并定义谁可以访问这些数据和信息的规则。</p>
</li>
<li>
<p>高水位线：这种策略允许提高安全级别以访问更高级别的信息。在大多数情况下，完成进程后会恢复原始级别。目前， FreeBSD MAC 框架不包括这种类型的策略。</p>
</li>
<li>
<p><em>low-watermark</em>：这种类型的策略允许降低安全级别以访问较不安全的信息。在大多数情况下，完成过程后，用户的原始安全级别将恢复。在 FreeBSD 中，唯一使用此策略的安全策略模块是 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> 。</p>
</li>
<li>
<p>敏感性：通常在讨论多级安全性（ MLS ）时使用。敏感性级别描述了数据的重要性或机密性。随着敏感性级别的提高，数据的保密性或机密性的重要性也增加。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="mac-understandlabel">18.3. 理解 MAC 标签<a class="anchor" href="#mac-understandlabel"></a></h3>
<div class="paragraph">
<p>MAC 标签是一种安全属性，可以应用于系统中的主体和对象。在设置标签时，管理员必须理解其影响，以防止系统出现意外或不希望的行为。对象上可用的属性取决于加载的策略模块，因为策略模块以不同的方式解释其属性。</p>
</div>
<div class="paragraph">
<p>对象上的安全标签是安全访问控制决策中的一部分。在某些策略中，标签包含了做出决策所需的所有信息。在其他策略中，标签可能作为一个更大的规则集的一部分进行处理。</p>
</div>
<div class="paragraph">
<p>有两种类型的标签策略：单标签和多标签。默认情况下，系统将使用单标签。管理员应该了解每种类型的优缺点，以便实施符合系统安全模型要求的策略。</p>
</div>
<div class="paragraph">
<p>单标签安全策略只允许每个主体或对象使用一个标签。由于单标签策略在整个系统上强制执行一组访问权限，因此它提供了较低的管理开销，但降低了支持标记的策略的灵活性。然而，在许多环境中，单标签策略可能就是所需的全部。</p>
</div>
<div class="paragraph">
<p>单标签策略在某种程度上类似于 DAC ，因为“ root ”配置策略以便将用户放置在适当的类别和访问级别中。一个显著的区别是许多策略模块也可以限制“ root ”。然后，对对象的基本控制将释放给组，但“ root ”可以随时撤销或修改设置。</p>
</div>
<div class="paragraph">
<p>在适当的情况下，可以通过将 <code>multilabel</code> 传递给 <code>tunefs[8]</code> 在 UFS 文件系统上设置多标签策略。多标签策略允许每个主体或对象拥有自己独立的 MAC 标签。对于实现标签功能的策略（如 <code>biba</code> 、 <code>lomac</code> 和 <code>mls</code> ），只有在使用多标签或单标签策略时才需要做出决策。一些策略，如 <code>seeotheruids</code> 、 <code>portacl</code> 和 <code>partition</code> ，根本不使用标签。</p>
</div>
<div class="paragraph">
<p>在分区上使用多标签策略并建立多标签安全模型可能会增加管理开销，因为文件系统中的所有内容都有标签，包括目录、文件甚至设备节点。</p>
</div>
<div class="paragraph">
<p>以下命令将在指定的 UFS 文件系统上设置 <code>multilabel</code> 。这只能在单用户模式下执行，并且对于交换文件系统来说并不是必需的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tunefs -l enable /</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些用户在设置根分区的 <code>multilabel</code> 标志时遇到了问题。如果是这种情况，请参考 <a href="#mac-troubleshoot">解决 MAC 框架的问题</a> 进行排查。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>由于多标签策略是基于每个文件系统的设置，如果文件系统布局设计良好，则可能不需要多标签策略。以 FreeBSD Web 服务器为例，考虑一个安全的 MAC 模型。该机器在默认文件系统中使用单个标签 <code>biba/high</code> 。如果 Web 服务器需要以 <code>biba/low</code> 运行以防止写入权限，可以将其安装到一个单独的 UFS [/usr/local] 文件系统，设置为 <code>biba/low</code> 。</p>
</div>
<div class="sect3">
<h4 id="_标签配置">18.3.1. 标签配置<a class="anchor" href="#_标签配置"></a></h4>
<div class="paragraph">
<p>几乎所有标签策略模块配置的方面都可以使用基本系统工具来完成。这些命令提供了一个简单的界面，用于对象或主体的配置，或者用于配置的操作和验证。</p>
</div>
<div class="paragraph">
<p>所有的配置都可以使用 <code>setfmac</code> 来完成， <code>setfmac</code> 用于在系统对象上设置 MAC 标签，而 <code>setpmac</code> 用于在系统主体上设置标签。例如，要在 <code>test</code> 上将 <code>biba</code> MAC 标签设置为 <code>high</code> ，可以使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setfmac biba/high test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果配置成功，将返回无错误的提示。常见的错误是 <code>Permission denied</code> ，通常发生在对受限对象设置或修改标签时。其他情况可能导致不同的失败。例如，文件可能不是尝试重新标记对象的用户拥有的，对象可能不存在，或者对象可能是只读的。强制策略将不允许进程重新标记文件，可能是因为文件的属性、进程的属性或建议的新标签值的属性。例如，如果以低完整性运行的用户尝试更改高完整性文件的标签，或者以低完整性运行的用户尝试将低完整性文件的标签更改为高完整性标签，这些操作将失败。</p>
</div>
<div class="paragraph">
<p>系统管理员可以使用 <code>setpmac</code> 命令通过为调用的进程分配不同的标签来覆盖策略模块的设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setfmac biba/high test</span>
Permission denied
<span class="c"># setpmac biba/low setfmac biba/high test</span>
<span class="c"># getfmac test</span>
<span class="nb">test</span>: biba/high</code></pre>
</div>
</div>
<div class="paragraph">
<p>对于当前正在运行的进程，例如 sendmail ，通常使用 <code>getpmac</code> 命令。该命令使用进程 ID （ PID ）代替命令名称。如果用户尝试操作不在其访问权限范围内的文件，根据加载的策略模块的规则，将显示“操作不允许”的错误。</p>
</div>
</div>
<div class="sect3">
<h4 id="_预定义标签">18.3.2. 预定义标签<a class="anchor" href="#_预定义标签"></a></h4>
<div class="paragraph">
<p>一些支持标签功能的 FreeBSD 策略模块提供了三个预定义标签： <code>low</code> 、 <code>equal</code> 和 <code>high</code> ，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>low</code> 被认为是对象或主体可能具有的最低标签设置。将其设置在对象或主体上会阻止它们访问被标记为高的对象或主体。</p>
</li>
<li>
<p><code>equal</code> 将主题或对象设置为禁用或不受影响，并且只应放置在被视为豁免政策的对象上。</p>
</li>
<li>
<p><code>high</code> 在 Biba 和 MLS 策略模块中为对象或主体授予最高的设置。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些策略模块包括 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> 。每个预定义标签都建立了不同的信息流指令。请参考模块的手册页面以确定通用标签配置的特性。</p>
</div>
</div>
<div class="sect3">
<h4 id="_数字标签">18.3.3. 数字标签<a class="anchor" href="#_数字标签"></a></h4>
<div class="paragraph">
<p>Biba 和 MLS 策略模块支持一个数字标签，可以设置为指示精确的层次控制级别。这个数字级别用于将信息分区或分类到不同的分类组中，只允许访问该组或更高级别的组。例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>biba/10:2+3+6(5:2+3-20:2+3+4+5+6)</pre>
</div>
</div>
<div class="paragraph">
<p>可以解释为“ Biba 政策标签 / 等级 10 ：隔间 2 、 3 和 6 ：（等级 5 …​ ”</p>
</div>
<div class="paragraph">
<p>在这个例子中，第一等级被认为是具有有效隔间的有效等级，第二等级是低等级，最后一个是高等级。在大多数配置中，这样细粒度的设置是不需要的，因为它们被认为是高级配置。</p>
</div>
<div class="paragraph">
<p>系统对象只有当前等级和隔间。系统主体反映了系统中可用权限的范围，以及网络接口，它们用于访问控制。</p>
</div>
<div class="paragraph">
<p>在一个主体和客体对中，等级和隔间被用来构建一种被称为“优势”的关系，其中主体优势于客体，客体优势于主体，两者互不优势，或者两者互相优势。当两个标签相等时，会出现“两者互相优势”的情况。由于 Biba 的信息流特性，用户对一组可能对应于项目的隔间拥有权限，但对象也有一组隔间。用户可能需要使用 <code>su</code> 或 <code>setpmac</code> 来对其权限进行子集化，以便从受限制的隔间中访问对象。</p>
</div>
</div>
<div class="sect3">
<h4 id="_用户标签">18.3.4. 用户标签<a class="anchor" href="#_用户标签"></a></h4>
<div class="paragraph">
<p>用户需要具有标签，以便他们的文件和进程能够与系统上定义的安全策略正确交互。这是通过在 <span class="filename">/etc/login.conf</span> 中使用登录类进行配置的。每个使用标签的策略模块都会实现用户类设置。</p>
</div>
<div class="paragraph">
<p>要设置用户类的默认标签，该标签将由 MAC 强制执行，请添加一个 <code>label</code> 条目。下面显示了一个包含每个策略模块的示例 <code>label</code> 条目。请注意，在实际配置中，管理员永远不会启用每个策略模块。建议在实施任何配置之前先阅读本章的其余部分。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>default:\
	:copyright=/etc/COPYRIGHT:\
	:welcome=/etc/motd:\
	:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
	:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin:\
	:manpath=/usr/share/man /usr/local/man:\
	:nologin=/usr/sbin/nologin:\
	:cputime=1h30m:\
	:datasize=8M:\
	:vmemoryuse=100M:\
	:stacksize=2M:\
	:memorylocked=4M:\
	:memoryuse=8M:\
	:filesize=8M:\
	:coredumpsize=8M:\
	:openfiles=24:\
	:maxproc=32:\
	:priority=0:\
	:requirehome:\
	:passwordtime=91d:\
	:umask=022:\
	:ignoretime@:\
	:label=partition/13,mls/5,biba/10(5-15),lomac/10[2]:</pre>
</div>
</div>
<div class="paragraph">
<p>用户无法修改默认值，但他们可以在登录后更改标签，但必须符合策略的限制。上面的示例告诉 Biba 策略，进程的最小完整性为 <code>5</code> ，最大完整性为 <code>15</code> ，默认有效标签为 <code>10</code> 。进程将在 <code>10</code> 上运行，直到它选择更改标签，可能是由于用户使用 <code>setpmac</code> ，该操作将受到 Biba 配置范围的限制。</p>
</div>
<div class="paragraph">
<p>对于 <span class="filename">login.conf</span> 的任何更改，必须使用 <code>cap_mkdb</code> 重新构建登录类能力数据库。</p>
</div>
<div class="paragraph">
<p>许多网站拥有大量用户，需要多个不同的用户类别。这需要进行深入的规划，因为这可能变得难以管理。</p>
</div>
</div>
<div class="sect3">
<h4 id="_网络接口标签">18.3.5. 网络接口标签<a class="anchor" href="#_网络接口标签"></a></h4>
<div class="paragraph">
<p>可以在网络接口上设置标签来帮助控制数据在网络中的流动。使用网络接口标签的策略与对象相关的策略的功能相同。例如，在 Biba 中设置为高级别的用户将不被允许访问标签为“低”的网络接口。</p>
</div>
<div class="paragraph">
<p>在设置网络接口的 MAC 标签时，可以通过 <code>ifconfig</code> 传递 <code>maclabel</code> 参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bge0 maclabel biba/equal</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个示例将在 <code>bge0</code> 接口上设置 <code>biba/equal</code> 的 MAC 标签。当使用类似于 <code>biba/high(low-high)</code> 的设置时，应该将整个标签用引号括起来，以防止返回错误。</p>
</div>
<div class="paragraph">
<p>每个支持标签的策略模块都有一个可调节项，可以用来禁用网络接口上的 MAC 标签。将标签设置为 <code>equal</code> 将产生类似的效果。请查看 <code>sysctl</code> 的输出、策略手册页面以及本章节中的其他信息，以获取有关这些可调节项的更多信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mac-planning">18.4. 规划安全配置<a class="anchor" href="#mac-planning"></a></h3>
<div class="paragraph">
<p>在实施任何 MAC 策略之前，建议进行规划阶段。在规划阶段，管理员应考虑实施要求和目标，例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何对目标系统上的信息和资源进行分类。</p>
</li>
<li>
<p>应限制访问的信息或资源以及应该应用的限制类型。</p>
</li>
<li>
<p>为实现这个目标，将需要哪些 MAC 模块？</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在将 MAC 实施到生产系统之前，应进行可信系统及其配置的试运行。由于不同的环境具有不同的需求和要求，建立完整的安全配置文件将减少系统投入使用后的更改需求。</p>
</div>
<div class="paragraph">
<p>考虑 MAC 框架如何增强整个系统的安全性。 MAC 框架提供的各种安全策略模块可以用于保护网络和文件系统，或者阻止用户访问特定的端口和套接字。也许最好的使用策略模块的方式是同时加载多个安全策略模块，以提供 MLS 环境。这种方法与硬化策略不同，硬化策略通常只针对系统中仅用于特定目的的元素进行硬化。 MLS 的缺点是增加了管理开销。</p>
</div>
<div class="paragraph">
<p>与提供选择特定配置所需的策略并降低性能开销的框架相比，开销是最小的。减少对不需要的策略的支持可以提高系统的整体性能，并提供选择的灵活性。一个良好的实现应该考虑整体安全要求，并有效地实施框架提供的各种安全策略模块。</p>
</div>
<div class="paragraph">
<p>使用 MAC 的系统可以确保用户不能随意更改安全属性。所有用户工具、程序和脚本必须在所选安全策略模块提供的访问规则约束下运行，而 MAC 访问规则的控制则由系统管理员负责。</p>
</div>
<div class="paragraph">
<p>系统管理员有责任仔细选择正确的安全策略模块。对于需要限制网络访问控制的环境， <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> 策略模块是很好的起点。对于需要严格保密文件系统对象的环境，可以考虑使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> 策略模块。</p>
</div>
<div class="paragraph">
<p>基于网络配置可以做出政策决策。如果只允许特定用户访问 <a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a> ，那么 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> 策略模块是一个不错的选择。在文件系统的情况下，对于某些用户来说，对对象的访问可能被视为机密，而对其他用户来说则不是。例如，一个大型开发团队可能会被分成较小的项目，项目 A 的开发人员可能不被允许访问项目 B 的开发人员编写的对象。然而，这两个项目可能需要访问项目 C 的开发人员创建的对象。使用 MAC 框架提供的不同安全策略模块，可以将用户分成这些组，并为其提供对应对象的访问权限。</p>
</div>
<div class="paragraph">
<p>每个安全策略模块都有一种独特的处理系统整体安全的方式。模块的选择应该基于经过深思熟虑的安全策略，可能需要进行修订和重新实施。了解 MAC 框架提供的不同安全策略模块将帮助管理员为他们的情况选择最佳策略。</p>
</div>
<div class="paragraph">
<p>本章的其余部分介绍了可用的模块，描述了它们的使用和配置，并在某些情况下提供了适用情况的见解。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>实施 MAC （强制访问控制）与实施防火墙非常相似，因为必须小心防止完全被系统锁定。应考虑能够恢复到先前的配置，并且在远程连接上实施 MAC 时应极度谨慎。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="mac-policies">18.5. 可用的 MAC 策略<a class="anchor" href="#mac-policies"></a></h3>
<div class="paragraph">
<p>默认的 FreeBSD 内核包含 <code>options MAC</code> 。这意味着 MAC 框架中包含的每个模块都可以作为运行时内核模块使用 <code>kldload</code> 加载。在测试完模块后，将模块名称添加到 <span class="filename">/boot/loader.conf</span> ，以便在启动时加载。对于那些选择编译自定义内核的管理员，每个模块还提供了一个内核选项。</p>
</div>
<div class="paragraph">
<p>FreeBSD 包含一组策略，可以满足大多数安全需求。下面对每个策略进行了总结。最后三个策略支持使用整数设置替代三个默认标签。</p>
</div>
<div class="sect3">
<h4 id="mac-seeotheruids">18.5.1. MAC 查看其他 UID 策略<a class="anchor" href="#mac-seeotheruids"></a></h4>
<div class="paragraph">
<p>模块名称： <span class="filename">mac_seeotheruids.ko</span></p>
</div>
<div class="paragraph">
<p>内核配置行： <code>options MAC_SEEOTHERUIDS</code></p>
</div>
<div class="paragraph">
<p>启动选项： <code>mac_seeotheruids_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> 模块扩展了 <code>security.bsd.see_other_uids</code> 和 <code>security.bsd.see_other_gids sysctl</code> 可调整参数。该选项在配置之前不需要设置任何标签，并且可以与其他模块透明地协同工作。</p>
</div>
<div class="paragraph">
<p>加载模块后，可以使用以下 <code>sysctl</code> 可调整项来控制其功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>security.mac.seeotheruids.enabled</code> 启用该模块并实现默认设置，禁止用户查看其他用户拥有的进程和套接字。</p>
</li>
<li>
<p><code>security.mac.seeotheruids.specificgid_enabled</code> 允许指定的组免除此策略。要免除特定的组，请使用 <code>security.mac.seeotheruids.specificgid =<em>XXX</em> sysctl</code> 可调节参数，将_XXX_替换为要免除的数字组 ID 。</p>
</li>
<li>
<p><code>security.mac.seeotheruids.primarygroup_enabled</code> 用于免除特定的主要组免受此策略的影响。当使用此可调整项时，不得设置 <code>security.mac.seeotheruids.specificgid_enabled</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="mac-bsdextended">18.5.2. MAC BSD 扩展策略<a class="anchor" href="#mac-bsdextended"></a></h4>
<div class="paragraph">
<p>模块名称： <span class="filename">mac_bsdextended.ko</span></p>
</div>
<div class="paragraph">
<p>内核配置行： <code>options MAC_BSDEXTENDED</code></p>
</div>
<div class="paragraph">
<p>启动选项： <code>mac_bsdextended_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> 模块实施了一个文件系统防火墙。它为标准文件系统权限模型提供了扩展，允许管理员创建类似防火墙的规则集来保护文件系统层次结构中的文件、实用程序和目录。当尝试访问文件系统对象时，将迭代规则列表，直到找到匹配的规则或到达末尾为止。可以使用 <code>security.mac.bsdextended.firstmatch_enabled</code> 来更改此行为。与 FreeBSD 中的其他防火墙模块类似，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 变量在系统启动时创建和读取包含访问控制规则的文件。</p>
</div>
<div class="paragraph">
<p>规则列表可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ugidfw&amp;sektion=8&amp;format=html">ugidfw(8)</a> 输入，其语法类似于 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 。通过使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=libugidfw&amp;sektion=3&amp;format=html">libugidfw(3)</a> 库中的函数，可以编写更多的工具。</p>
</div>
<div class="paragraph">
<p>在加载了 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> 模块之后，可以使用以下命令列出当前的规则配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ugidfw list</span>
0 slots, 0 rules</code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，没有定义任何规则，所有内容都是完全可访问的。要创建一个规则，阻止用户的所有访问，但不影响 <code>root</code> 用户：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ugidfw add subject not uid root new object not uid root mode n</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虽然这个规则很容易实现，但它是一个非常糟糕的想法，因为它会阻止所有用户发出任何命令。一个更现实的例子是阻止 <code>user1</code> 访问 <code><em>user2</em></code> 的主目录，包括目录列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ugidfw set 2 subject uid user1 object uid user2 mode n</span>
<span class="c"># ugidfw set 3 subject uid user1 object gid user2 mode n</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code>not uid <em>user2</em></code> 来代替 <code>user1</code> ，以便为所有用户强制相同的访问限制。然而，这些规则对 <code>root</code> 用户无效。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在使用该模块时应极度谨慎，因为错误的使用可能会阻止对文件系统的某些部分的访问。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mac-ifoff">18.5.3. MAC 接口静音策略<a class="anchor" href="#mac-ifoff"></a></h4>
<div class="paragraph">
<p>模块名称： <span class="filename">mac_ifoff.ko</span></p>
</div>
<div class="paragraph">
<p>内核配置行： <code>options MAC_IFOFF</code></p>
</div>
<div class="paragraph">
<p>启动选项： <code>mac_ifoff_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> 模块用于动态禁用网络接口，并防止在系统启动期间启用网络接口。它不使用标签，也不依赖于任何其他 MAC 模块。</p>
</div>
<div class="paragraph">
<p>大部分该模块的控制是通过这些 <code>sysctl</code> 可调参数进行的：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>security.mac.ifoff.lo_enabled</code> 用于启用或禁用回环（ loopback ）接口上的所有流量，参考： <a href="https://man.freebsd.org/cgi/man.cgi?query=lo&amp;sektion=4&amp;format=html">lo(4)</a> 。</p>
</li>
<li>
<p><code>security.mac.ifoff.bpfrecv_enabled</code> 用于启用或禁用 Berkeley Packet Filter 接口上的所有流量，参见 <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> 。</p>
</li>
<li>
<p><code>security.mac.ifoff.other_enabled</code> 用于启用或禁用所有其他接口上的流量。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ifoff&amp;sektion=4&amp;format=html">mac_ifoff(4)</a> 的最常见用途之一是在启动序列期间不允许网络流量的环境中进行网络监控。另一个用途是编写一个脚本，使用类似 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/aide/">security/aide</a> 的应用程序，在受保护的目录中发现新文件或更改文件时自动阻止网络流量。</p>
</div>
</div>
<div class="sect3">
<h4 id="mac-portacl">18.5.4. MAC 端口访问控制列表策略<a class="anchor" href="#mac-portacl"></a></h4>
<div class="paragraph">
<p>模块名称： <span class="filename">mac_portacl.ko</span></p>
</div>
<div class="paragraph">
<p>内核配置行： <code>MAC_PORTACL</code></p>
</div>
<div class="paragraph">
<p>引导选项： <code>mac_portacl_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> 模块用于限制绑定到本地 TCP 和 UDP 端口，使非“ root ”用户能够绑定到指定的特权端口（低于 1024 ）。</p>
</div>
<div class="paragraph">
<p>一旦加载，该模块将在所有套接字上启用 MAC 策略。以下可调整项可用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>security.mac.portacl.enabled</code> 用于启用或禁用该策略。</p>
</li>
<li>
<p><code>security.mac.portacl.port_high</code> 设置了 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> 保护的最高端口号。</p>
</li>
<li>
<p>当 <code>security.mac.portacl.suser_exempt</code> 设置为非零值时，免除 <code>root</code> 用户遵守此策略。</p>
</li>
<li>
<p><code>security.mac.portacl.rules</code> 指定了策略，其格式为 <code>rule[, rule , …​]</code> 的文本字符串，可以包含多个规则，每个规则的格式为 <code>idtype:id:protocol:port</code> 。 <code>idtype</code> 可以是 <code>uid</code> 或 <code>gid</code> 。 <code>protocol</code> 参数可以是 <code>tcp</code> 或 <code>udp</code> 。 <code>port</code> 参数是允许指定的用户或组绑定的端口号。用户 ID 、组 ID 和端口参数只能使用数字值。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>默认情况下，只有以 <code>root</code> 身份运行的特权进程才能使用小于 1024 的端口。要允许非特权进程绑定到小于 1024 的端口，可以按照以下方式设置 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_portacl&amp;sektion=4&amp;format=html">mac_portacl(4)</a> 中的可调整参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl security.mac.portacl.port_high=1023</span>
<span class="c"># sysctl net.inet.ip.portrange.reservedlow=0</span>
<span class="c"># sysctl net.inet.ip.portrange.reservedhigh=0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了防止 <code>root</code> 用户受到此策略的影响，请将 <code>security.mac.portacl.suser_exempt</code> 设置为非零值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl security.mac.portacl.suser_exempt=1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了允许 UID 为 80 的 <code>www</code> 用户在不需要 <code>root</code> 权限的情况下绑定到端口 80 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl security.mac.portacl.rules=uid:80:tcp:80</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例允许具有 UID 为 1001 的用户绑定到 TCP 端口 110 （ POP3 ）和 995 （ POP3s ）：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl security.mac.portacl.rules=uid:1001:tcp:110,uid:1001:tcp:995</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="mac-partition">18.5.5. MAC 分区策略<a class="anchor" href="#mac-partition"></a></h4>
<div class="paragraph">
<p>模块名称： <span class="filename">mac_partition.ko</span></p>
</div>
<div class="paragraph">
<p>内核配置行： <code>options MAC_PARTITION</code></p>
</div>
<div class="paragraph">
<p>启动选项： <code>mac_partition_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_partition&amp;sektion=4&amp;format=html">mac_partition(4)</a> 策略根据进程的 MAC 标签将其分配到特定的“分区”中。大部分该策略的配置都是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> 完成的。该策略有一个可调整的 <code>sysctl</code> 参数。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>security.mac.partition.enabled</code> 启用了 MAC 进程分区的强制执行。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当启用此策略时，用户只能查看他们自己的进程以及其所在分区的其他进程，但不允许使用超出该分区范围的实用工具。例如，属于“不安全”类别的用户将无法访问“ top ”以及许多其他需要生成进程的命令。</p>
</div>
<div class="paragraph">
<p>这个例子将 <code>top</code> 添加到 <code>insecure</code> 类别中的用户标签集合中。所有由 <code>insecure</code> 类别中的用户生成的进程都将保持在 <code>partition/13</code> 标签中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setpmac partition/13 top</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令显示分区标签和进程列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ps Zax</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令显示另一个用户的进程分区标签以及该用户当前正在运行的进程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ps -ZU trhodes</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除非加载了 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> 策略，否则用户可以看到“ root ”标签下的进程。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mac-mls">18.5.6. MAC 多级安全模块<a class="anchor" href="#mac-mls"></a></h4>
<div class="paragraph">
<p>模块名称： <span class="filename">mac_mls.ko</span></p>
</div>
<div class="paragraph">
<p>内核配置行： <code>options MAC_MLS</code></p>
</div>
<div class="paragraph">
<p>启动选项： <code>mac_mls_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_mls&amp;sektion=4&amp;format=html">mac_mls(4)</a> 策略通过执行严格的信息流策略来控制系统中主体和客体之间的访问。</p>
</div>
<div class="paragraph">
<p>在 MLS 环境中，每个主体或对象的标签中都设置了一个“许可”级别，以及隔间。由于这些许可级别可以达到几千以上的数字，彻底配置每个主体或对象将是一项艰巨的任务。为了减轻这种管理负担，该策略中包括了三个标签： <code>mls/low</code> ， <code>mls/equal</code> 和 <code>mls/high</code> ，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何标记为 <code>mls/low</code> 的内容都具有低许可级别，不允许访问更高级别的信息。该标签还阻止高许可级别的对象向低级别写入或传递信息。</p>
</li>
<li>
<p><code>mls/equal</code> 应该被放置在应该被豁免政策的对象上。</p>
</li>
<li>
<p><code>mls/high</code> 是最高级别的许可级别。被分配此标签的对象将在系统中具有最高权限；然而，它们不会允许信息泄漏给较低级别的对象。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>MLS 提供以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个具有一组非层次化类别的分层安全级别。</p>
</li>
<li>
<p>固定的规则是“不可向上读取，不可向下写入”。这意味着一个主体可以对其自身级别或以下级别的对象具有读取访问权限，但不能对以上级别的对象具有读取访问权限。同样地，一个主体可以对其自身级别或以上级别的对象具有写入访问权限，但不能对以下级别的对象具有写入访问权限。</p>
</li>
<li>
<p>保密性，或者说是防止数据不适当披露的措施。</p>
</li>
<li>
<p>设计能够同时处理多个敏感级别数据的系统基础，而不会在秘密和机密之间泄露信息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下是可用的 <code>sysctl</code> 可调整参数：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>security.mac.mls.enabled</code> 用于启用或禁用 MLS 策略。</p>
</li>
<li>
<p><code>security.mac.mls.ptys_equal</code> 在创建过程中将所有 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a></code> 设备标记为 <code>mls/equal</code> 。</p>
</li>
<li>
<p><code>security.mac.mls.revocation_enabled</code> 在对象的标签变为较低等级的标签后，撤销对该对象的访问权限。</p>
</li>
<li>
<p><code>security.mac.mls.max_compartments</code> 设置系统允许的最大隔离级别数量。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要操作 MLS 标签，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=setfmac&amp;sektion=8&amp;format=html">setfmac(8)</a> 。要为对象分配一个标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setfmac mls/5 test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>获取文件 <span class="filename">test</span> 的 MLS 标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># getfmac test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是在 [/etc/] 目录下创建一个主策略文件，该文件指定了 MLS 策略信息，并将该文件提供给 <code>setfmac</code> 命令。</p>
</div>
<div class="paragraph">
<p>当使用 MLS 策略模块时，管理员计划控制敏感信息的流动。默认的 <code>block read up block write down</code> 将所有内容设置为低状态。所有内容都是可访问的，管理员会逐渐增加信息的机密性。</p>
</div>
<div class="paragraph">
<p>除了三种基本的标签选项之外，管理员还可以根据需要将用户和组进行分组，以阻止它们之间的信息流动。使用描述性词语，如“机密”、“秘密”和“绝密”来查看清除级别的信息可能更容易。一些管理员根据项目级别创建不同的组。无论分类方法如何，都必须在实施限制性政策之前制定一个经过深思熟虑的计划。</p>
</div>
<div class="paragraph">
<p>MLS 策略模块的一些示例情况包括电子商务网站服务器、存储关键公司信息的文件服务器和金融机构环境。</p>
</div>
</div>
<div class="sect3">
<h4 id="mac-biba">18.5.7. MAC Biba 模块<a class="anchor" href="#mac-biba"></a></h4>
<div class="paragraph">
<p>模块名称： mac_biba.ko</p>
</div>
<div class="paragraph">
<p>内核配置行： <code>options MAC_BIBA</code></p>
</div>
<div class="paragraph">
<p>启动选项： <code>mac_biba_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> 模块加载了 MAC Biba 策略。该策略与 MLS 策略类似，但信息流动规则略有不同。这是为了防止敏感信息的向下流动，而 MLS 策略则防止敏感信息的向上流动。</p>
</div>
<div class="paragraph">
<p>在 Biba 环境中，每个主体或对象都会设置一个&#34;完整性&#34;标签。这些标签由层次等级和非层次组成。随着等级的提升，完整性也会提高。</p>
</div>
<div class="paragraph">
<p>支持的标签有 <code>biba/low</code> 、 <code>biba/equal</code> 和 <code>biba/high</code> ，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>biba/low</code> 被认为是对象或主体可能具有的最低完整性。将其设置在对象或主体上会阻止它们对标记为 <code>biba/high</code> 的对象或主体的写访问，但不会阻止读访问。</p>
</li>
<li>
<p><code>biba/equal</code> 应该只被应用于被认为符合政策的对象上。</p>
</li>
<li>
<p><code>biba/high</code> 允许对设置在较低标签的对象进行写操作，但不允许读取该对象。建议将此标签放置在影响整个系统完整性的对象上。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Biba 提供：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>具有一组非层次化完整性类别的层次完整性级别。</p>
</li>
<li>
<p>固定规则是“不可向上写入，不可向下读取”，与 MLS 相反。主体可以对其自身级别或以下的对象具有写入访问权限，但不能对其以上的对象具有写入访问权限。同样地，主体可以对其自身级别或以上的对象具有读取访问权限，但不能对其以下的对象具有读取访问权限。</p>
</li>
<li>
<p>通过防止数据的不适当修改来保持完整性。</p>
</li>
<li>
<p>完整性级别而不是 MLS 敏感级别。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以下可调整项可用于操作 Biba 策略：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>security.mac.biba.enabled</code> 用于在目标机器上启用或禁用 Biba 策略的执行。</p>
</li>
<li>
<p><code>security.mac.biba.ptys_equal</code> 用于禁用 Biba 策略对 <a href="https://man.freebsd.org/cgi/man.cgi?query=pty&amp;sektion=4&amp;format=html">pty(4)</a> 设备的应用。</p>
</li>
<li>
<p>如果标签被更改为支配主体，则 <code>security.mac.biba.revocation_enabled</code> 强制撤销对对象的访问权限。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要访问系统对象上的 Biba 策略设置，请使用 <code>setfmac</code> 和 <code>getfmac</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setfmac biba/low test</span>
<span class="c"># getfmac test</span>
<span class="nb">test</span>: biba/low</code></pre>
</div>
</div>
<div class="paragraph">
<p>完整性与敏感性不同，用于确保信息不被不受信任的方进行篡改。这包括主体和客体之间传递的信息。它确保用户只能修改或访问他们被明确授权的信息。 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> 安全策略模块允许管理员配置用户可以查看和调用哪些文件和程序，同时确保这些程序和文件对该用户是可信的。</p>
</div>
<div class="paragraph">
<p>在初始规划阶段，管理员必须准备好将用户分成等级、级别和领域。一旦启用了该策略模块，系统将默认为高级别，并由管理员配置用户的不同等级和级别。与使用许可级别不同，一个好的规划方法可以包括主题。例如，只允许开发人员对源代码仓库、源代码编译器和其他开发工具进行修改访问。其他用户将被分组到其他类别，如测试人员、设计师或最终用户，并且只允许读取访问权限。</p>
</div>
<div class="paragraph">
<p>较低完整性的主体无法向较高完整性的主体写入，而较高完整性的主体无法列出或读取较低完整性的对象。将标签设置为最低等级可能会使主体无法访问。此安全策略模块的一些潜在环境包括受限的 Web 服务器、开发和测试机器以及源代码存储库。较少有用的实现可能是个人工作站、用作路由器的机器或网络防火墙。</p>
</div>
</div>
<div class="sect3">
<h4 id="mac-lomac">18.5.8. MAC 低水位标记模块<a class="anchor" href="#mac-lomac"></a></h4>
<div class="paragraph">
<p>模块名称： <span class="filename">mac_lomac.ko</span></p>
</div>
<div class="paragraph">
<p>内核配置行： <code>options MAC_LOMAC</code></p>
</div>
<div class="paragraph">
<p>启动选项： <code>mac_lomac_load =&#34;YES&#34;</code></p>
</div>
<div class="paragraph">
<p>与 MAC Biba 策略不同， <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_lomac&amp;sektion=4&amp;format=html">mac_lomac(4)</a> 策略允许在降低完整性级别以不破坏任何完整性规则的情况下访问较低完整性对象。</p>
</div>
<div class="paragraph">
<p>低水位完整性策略与 Biba 几乎完全相同，唯一的区别是使用浮动标签来支持通过辅助等级隔离主体。这个辅助等级隔离采用 <code>[auxgrade]</code> 的形式。当分配一个带有辅助等级的策略时，使用语法 <code>lomac/10[2]</code> ，其中 <code>2</code> 是辅助等级。</p>
</div>
<div class="paragraph">
<p>该策略依赖于对所有系统对象进行普遍标记的完整性标签，允许主体从低完整性对象读取，并通过 <code>[auxgrade]</code> 将主体的标签降级，以防止将来对高完整性对象进行写入。与 Biba 相比，该策略可能提供更高的兼容性，并且需要较少的初始配置。</p>
</div>
<div class="paragraph">
<p>与 Biba 和 MLS 策略类似， <code>setfmac</code> 和 <code>setpmac</code> 用于给系统对象打上标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setfmac /usr/home/trhodes lomac/high[low]</span>
<span class="c"># getfmac /usr/home/trhodes lomac/high[low]</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>辅助等级 <code>low</code> 是仅由 MACLOMAC 策略提供的一个特性。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mac-userlocked">18.6. 用户锁定<a class="anchor" href="#mac-userlocked"></a></h3>
<div class="paragraph">
<p>这个例子考虑了一个相对较小的存储系统，用户数量少于 50 人。用户将具有登录功能，并被允许存储数据和访问资源。</p>
</div>
<div class="paragraph">
<p>对于这种情况， <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_seeotheruids&amp;sektion=4&amp;format=html">mac_seeotheruids(4)</a> 策略模块可以共存，并且可以阻止对系统对象的访问，同时隐藏用户进程。</p>
</div>
<div class="paragraph">
<p>首先，在 <span class="filename">/boot/loader.conf</span> 文件中添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>mac_seeotheruids_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>通过将以下行添加到 [/etc/rc.conf] ，可以激活 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> 安全策略模块：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ugidfw_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>系统初始化时将加载存储在 [/etc/rc.bsdextended] 文件中的默认规则。然而，默认条目可能需要修改。由于此机器预计只为用户提供服务，因此除了最后两行外，可以将所有内容都注释掉，以便默认情况下强制加载用户拥有的系统对象。</p>
</div>
<div class="paragraph">
<p>将所需的用户添加到该机器并重新启动。为了测试目的，尝试在两个控制台上使用不同的用户登录。运行 <code>ps aux</code> 命令查看其他用户的进程是否可见。验证在另一个用户的主目录上运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=ls&amp;sektion=1&amp;format=html">ls(1)</a> 命令是否失败。</p>
</div>
<div class="paragraph">
<p>除非特定的 <code>sysctl</code> 已被修改以阻止超级用户访问，否则不要尝试使用 <code>root</code> 用户进行测试。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当添加一个新用户时，他们的 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_bsdextended&amp;sektion=4&amp;format=html">mac_bsdextended(4)</a> 规则将不会出现在规则集列表中。为了快速更新规则集，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldunload&amp;sektion=8&amp;format=html">kldunload(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=kldload&amp;sektion=8&amp;format=html">kldload(8)</a> 命令卸载和重新加载安全策略模块。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="mac-implementing">18.7. 在 MAC 监狱中的 Nagios<a class="anchor" href="#mac-implementing"></a></h3>
<div class="paragraph">
<p>本节演示了在 MAC 环境中实施 Nagios 网络监控系统所需的步骤。这仅作为一个示例，管理员在将该策略应用于生产环境之前需要测试其是否符合网络的安全要求。</p>
</div>
<div class="paragraph">
<p>在进行此示例之前，需要在每个文件系统上设置 <code>multilabel</code> 。同时，还假设在将其集成到 MAC 框架之前，已经安装、配置并正确运行了 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/net-mgmt/nagios-plugins/">net-mgmt/nagios-plugins</a></code> 、 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/net-mgmt/nagios/">net-mgmt/nagios</a></code> 和 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/www/apache22/">www/apache22</a></code> 。</p>
</div>
<div class="sect3">
<h4 id="_创建一个不安全的用户类">18.7.1. 创建一个不安全的用户类<a class="anchor" href="#_创建一个不安全的用户类"></a></h4>
<div class="paragraph">
<p>在 <span class="filename">/etc/login.conf</span> 中添加以下用户类别，开始该过程：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>insecure:\
:copyright=/etc/COPYRIGHT:\
:welcome=/etc/motd:\
:setenv=MAIL=/var/mail/$,BLOCKSIZE=K:\
:path=~/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin
:manpath=/usr/share/man /usr/local/man:\
:nologin=/usr/sbin/nologin:\
:cputime=1h30m:\
:datasize=8M:\
:vmemoryuse=100M:\
:stacksize=2M:\
:memorylocked=4M:\
:memoryuse=8M:\
:filesize=8M:\
:coredumpsize=8M:\
:openfiles=24:\
:maxproc=32:\
:priority=0:\
:requirehome:\
:passwordtime=91d:\
:umask=022:\
:ignoretime@:\
:label=biba/10(10-10):</pre>
</div>
</div>
<div class="paragraph">
<p>然后，在默认用户类部分添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>:label=biba/high:</pre>
</div>
</div>
<div class="paragraph">
<p>保存修改并执行以下命令以重建数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cap_mkdb /etc/login.conf</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置用户">18.7.2. 配置用户<a class="anchor" href="#_配置用户"></a></h4>
<div class="paragraph">
<p>使用以下命令将 <code>root</code> 用户设置为默认类：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw usermod root -L default</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>所有不是 <code>root</code> 的用户帐户现在都需要一个登录类。否则，用户将被拒绝访问常用命令。下面的 <code>sh</code> 脚本应该能解决问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># for x in `awk -F: &#39;($3 &gt;= 1001) &amp;&amp; ($3 != 65534) { print $1 }&#39; \</span>
	/etc/passwd<span class="sb">`</span>; <span class="k">do </span>pw usermod <span class="nv">$x</span> -L default; <span class="k">done</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，将 <code>nagios</code> 和 <code>www</code> 账户添加到不安全类别中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw usermod nagios -L insecure</span>
<span class="c"># pw usermod www -L insecure</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_创建上下文文件">18.7.3. 创建上下文文件<a class="anchor" href="#_创建上下文文件"></a></h4>
<div class="paragraph">
<p>现在应该创建一个上下文文件，路径为 <code>/etc/policy.contexts</code> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># This is the default BIBA policy for this system.

# System:
/var/run(/.*)?			biba/equal

/dev/(/.*)?			biba/equal

/var				biba/equal
/var/spool(/.*)?		biba/equal

/var/log(/.*)?			biba/equal

/tmp(/.*)?			biba/equal
/var/tmp(/.*)?			biba/equal

/var/spool/mqueue		biba/equal
/var/spool/clientmqueue		biba/equal

# For Nagios:
/usr/local/etc/nagios(/.*)?	biba/10

/var/spool/nagios(/.*)?		biba/10

# For apache
/usr/local/etc/apache(/.*)?	biba/10</pre>
</div>
</div>
<div class="paragraph">
<p>该策略通过对信息流动设置限制来强制执行安全性。在这个特定的配置中，包括 <code>root</code> 在内的用户不应该被允许访问 Nagios 。 Nagios 的配置文件和进程将完全自包含或被隔离。</p>
</div>
<div class="paragraph">
<p>在对每个文件系统运行 <code>setfsmac</code> 之后，将读取此文件。此示例设置了根文件系统的策略：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setfsmac -ef /etc/policy.contexts /</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，将这些编辑添加到主要部分的 <span class="filename">/etc/mac.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>default_labels file ?biba
default_labels ifnet ?biba
default_labels process ?biba
default_labels socket ?biba</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_加载器配置">18.7.4. 加载器配置<a class="anchor" href="#_加载器配置"></a></h4>
<div class="paragraph">
<p>要完成配置，请将以下行添加到 <span class="filename">/boot/loader.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>mac_biba_load=&#34;YES&#34;
mac_seeotheruids_load=&#34;YES&#34;
security.mac.biba.trust_all_interfaces=1</pre>
</div>
</div>
<div class="paragraph">
<p>将以下行添加到存储在 <span class="filename">/etc/rc.conf</span> 中的网络卡配置中。如果主要网络配置是通过 DHCP 完成的，则可能需要在每次系统启动后手动配置此项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>maclabel biba/equal</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_测试配置">18.7.5. 测试配置<a class="anchor" href="#_测试配置"></a></h4>
<div class="paragraph">
<p>首先，确保在系统初始化和重启时不会启动 Web 服务器和 Nagios 。确保 <code>root</code> 无法访问 Nagios 配置目录中的任何文件。如果 <code>root</code> 可以列出 <code>.filename</code><mark>/var/spool/nagios</mark> 的内容，则表示出现了问题。相反，应返回&#34;权限被拒绝&#34;错误。</p>
</div>
<div class="paragraph">
<p>如果一切正常，现在可以启动 Nagios 、 Apache 和 Sendmail ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /etc/mail &amp;&amp; make stop &amp;&amp; \</span>
setpmac biba/equal make start <span class="o">&amp;&amp;</span> setpmac biba/10<span class="se">\(</span>10-10<span class="se">\)</span> apachectl start <span class="o">&amp;&amp;</span> <span class="se">\</span>
setpmac biba/10<span class="se">\(</span>10-10<span class="se">\)</span> /usr/local/etc/rc.d/nagios.sh forcestart</code></pre>
</div>
</div>
<div class="paragraph">
<p>请仔细检查以确保一切正常运行。如果不正常，请检查日志文件以查找错误信息。如果需要，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 命令禁用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_biba&amp;sektion=4&amp;format=html">mac_biba(4)</a> 安全策略模块，然后尝试按照通常的方式重新启动所有内容。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>root</code> 用户仍然可以更改安全执行和编辑其配置文件。以下命令将允许将安全策略降级为新生成的 shell 的较低级别：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># setpmac biba/10 csh</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了阻止这种情况发生，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> 强制用户进入一个范围。如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=setpmac&amp;sektion=8&amp;format=html">setpmac(8)</a> 尝试在隔离区域范围之外运行命令，将返回错误并且不执行该命令。在这种情况下，将 root 设置为 <code>biba/high(high-high)</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mac-troubleshoot">18.8. 解决 MAC 框架的问题<a class="anchor" href="#mac-troubleshoot"></a></h3>
<div class="paragraph">
<p>本节讨论常见的配置错误以及如何解决它们。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>multilabel</code> 标志在根（ <span class="filename">/</span> ）分区上无法保持启用状态。</dt>
<dd>
<p>以下步骤可能解决此临时错误：</p>
</dd>
</dl>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>编辑 <span class="filename">/etc/fstab</span> 文件，并将根分区设置为 <code>ro</code> ，以实现只读模式。</p>
</li>
<li>
<p>重新启动进入单用户模式。</p>
</li>
<li>
<p>在 <span class="filename">/</span> 上运行 <code>tunefs -l enable</code> 。</p>
</li>
<li>
<p>重启系统。</p>
</li>
<li>
<p>运行 <code>mount -urw</code> 命令，并在 <code>/etc/fstab</code> 文件中将 <code>ro</code> 改回 <code>rw</code> ，然后再次重启系统。</p>
</li>
<li>
<p>请仔细检查 <code>mount</code> 命令的输出，确保根文件系统上的 <code>multilabel</code> 已正确设置。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">在使用 MAC 建立了安全环境之后， Xorg 不再启动。</dt>
<dd>
<p>这可能是由 MAC “分区”策略或 MAC 标签策略中的一个标签错误引起的。为了调试，请尝试以下操作：</p>
</dd>
</dl>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>检查错误消息。如果用户在 <code>insecure</code> 类中， <code>partition</code> 策略可能是问题的原因。尝试将用户的类设置回 <code>default</code> 类，并使用 <code>cap_mkdb</code> 重新构建数据库。如果这不能解决问题，请进行第二步。</p>
</li>
<li>
<p>请仔细检查用户、 Xorg 和 [/dev](filename) 条目的标签策略是否设置正确。</p>
</li>
<li>
<p>如果以上两种方法都不能解决问题，请将错误信息和环境描述发送到 {freebsd-questions} 。</p>
</li>
</ol>
</div>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">出现了“_secure_path: 无法统计 .login_conf ”错误。</dt>
<dd>
<p>当用户尝试从“ root ”用户切换到系统中的另一个用户时，可能会出现此错误。当用户的标签设置比他们尝试成为的用户的标签设置更高时，通常会出现此消息。例如，如果“ joe ”的默认标签是“ biba/low ”，而“ root ”的标签是“ biba/high ”，则“ root ”无法查看“ joe ”的主目录。无论“ root ”是否使用“ su ”成为“ joe ”，都会发生这种情况，因为 Biba 完整性模型不允许“ root ”查看设置在较低完整性级别的对象。</p>
</dd>
<dt class="hdlist1">系统不再识别 <code>root</code> 。</dt>
<dd>
<p>当发生这种情况时， <code>whoami</code> 返回 <code>0</code> ，而 <code>su</code> 返回 `who are you ? ` 。</p>
<div class="paragraph">
<p>如果一个标签策略被 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 禁用或者策略模块被卸载，就会发生这种情况。如果策略被禁用，登录能力数据库需要重新配置。请仔细检查 <span class="filename">/etc/login.conf</span> ，确保所有的 <code>label</code> 选项都已经被移除，并使用 <code>cap_mkdb</code> 重新构建数据库。</p>
</div>
<div class="paragraph">
<p>如果策略限制对 <span class="filename">master.passwd</span> 的访问，也可能发生这种情况。这通常是由于管理员在与系统使用的通用策略冲突的标签下更改了文件而引起的。在这些情况下，系统会读取用户信息，并且由于文件继承了新的标签，访问将被阻止。使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 禁用该策略，一切应该恢复正常。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="audit">Chapter 19. 安全事件审计<a class="anchor" href="#audit"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="audit-synopsis">19.1. 简介<a class="anchor" href="#audit-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 操作系统包含安全事件审计的支持。事件审计支持可靠、细粒度和可配置的记录各种与安全相关的系统事件，包括登录、配置更改以及文件和网络访问。这些日志记录对于实时系统监控、入侵检测和事后分析非常宝贵。 FreeBSD 实现了 Sun™ 发布的基本安全模块（ BSM ）应用程序编程接口（ API ）和文件格式，并与 Solaris™ 和 Mac OS® X 的审计实现互操作。</p>
</div>
<div class="paragraph">
<p>本章重点介绍事件审计的安装和配置。它解释了审计策略，并提供了一个示例审计配置。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>事件审计是一种记录和监控系统中发生的事件的过程。它通过跟踪和记录用户活动、系统操作和其他重要事件来提供安全性和合规性。事件审计可以帮助识别潜在的安全漏洞、检测异常行为和追踪事件的来源。 事件审计的工作原理是通过收集和分析系统生成的日志数据来创建审计记录。这些日志数据可以包括用户登录信息、文件访问记录、系统配置更改、网络通信等。审计记录通常包括事件的时间戳、事件类型、事件源、事件描述和相关的详细信息。 事件审计可以通过实时监控和离线分析来实现。实时监控可以及时检测和响应事件，而离线分析可以对历史数据进行深入分析和调查。通过使用专门的审计工具和技术，可以对事件进行筛选、过滤和报告，以便进行安全审计和合规性验证。 总之，事件审计是一种重要的安全措施，可以帮助保护系统免受潜在的威胁，并确保系统的合规性和可追溯性。</p>
</li>
<li>
<p>如何在 FreeBSD 上配置用户和进程的事件审计。</p>
</li>
<li>
<p>如何使用审计缩减和审查工具来审查审计跟踪记录。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，你应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 UNIX® 和 FreeBSD 基础知识（参见： basics[basics , FreeBSD Basics] ）。</p>
</li>
<li>
<p>熟悉内核配置 / 编译的基础知识（参考： kernelconfig[内核配置，配置 FreeBSD 内核] ）。</p>
</li>
<li>
<p>对于安全性以及它与 FreeBSD 相关的内容有一定的了解（参考： security[security , Security] ）。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>审计功能有一些已知的限制。并非所有与安全相关的系统事件都可以进行审计，而某些登录机制（例如基于 Xorg 的显示管理器和第三方守护程序）未正确配置用户登录会话的审计功能。</p>
</div>
<div class="paragraph">
<p>安全事件审计功能能够生成系统活动的非常详细的日志。在繁忙的系统上，当配置为高详细级别时，跟踪文件数据可能非常大，在某些配置下每周超过几个千兆字节。管理员应考虑与高容量审计配置相关的磁盘空间需求。例如，可以将一个文件系统专门用于 /var/audit ，这样如果审计文件系统变满，其他文件系统不会受到影响。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="audit-inline-glossary">19.2. 关键术语<a class="anchor" href="#audit-inline-glossary"></a></h3>
<div class="paragraph">
<p>以下术语与安全事件审计相关：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>事件</em>：可审计事件是指可以使用审计子系统记录的任何事件。安全相关事件的示例包括文件的创建、网络连接的建立或用户登录。事件可以是“可归因”的，意味着可以追溯到经过身份验证的用户，也可以是“不可归因”的。不可归因事件的示例是在登录过程中身份验证之前发生的任何事件，例如密码错误尝试。</p>
</li>
<li>
<p><em>class</em>：一组命名的相关事件，用于选择表达式中使用。常用的事件类包括“文件创建”（ fc ）、“执行”（ ex ）和“登录 / 注销”（ lo ）。</p>
</li>
<li>
<p><em>record</em>：描述安全事件的审计日志条目。记录包含记录事件类型、执行操作的主体（用户）的信息、日期和时间信息、任何对象或参数的信息，以及成功或失败的条件。</p>
</li>
<li>
<p><em>trail</em>：一个由一系列描述安全事件的审计记录组成的日志文件。 Trail 的顺序大致按照事件完成的时间顺序排列。只有经过授权的进程才允许向审计轨迹提交记录。</p>
</li>
<li>
<p>选择表达式：一个包含前缀和审计事件类名列表的字符串，用于匹配事件。</p>
</li>
<li>
<p><em>预选</em>：系统识别哪些事件对管理员感兴趣的过程。预选配置使用一系列选择表达式来识别哪些事件类别适用于哪些用户进行审计，以及适用于已认证和未认证进程的全局设置。</p>
</li>
<li>
<p><em>reduction</em>：从现有审计跟踪中选择记录以进行保留、打印或分析的过程。同样，也是从审计跟踪中删除不需要的审计记录的过程。通过使用减少，管理员可以实施有关保留审计数据的策略。例如，详细的审计跟踪可能会保留一个月，但之后，为了保留仅用于归档目的的登录信息，可能会进行减少。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="audit-config">19.3. 审计配置<a class="anchor" href="#audit-config"></a></h3>
<div class="paragraph">
<p>用户空间对事件审计的支持是作为基本的 FreeBSD 操作系统的一部分安装的。内核支持默认情况下在 <span class="filename">GENERIC</span> 内核中可用，并且可以通过在 <span class="filename">/etc/rc.conf</span> 中添加以下行来启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>auditd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后，启动审计守护进程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service auditd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>喜欢编译自定义内核的用户必须在其自定义内核配置文件中包含以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options	AUDIT</pre>
</div>
</div>
<div class="sect3">
<h4 id="_事件选择表达式">19.3.1. 事件选择表达式<a class="anchor" href="#_事件选择表达式"></a></h4>
<div class="paragraph">
<p>选择表达式在审计配置中的许多地方用于确定应该审计哪些事件。表达式包含要匹配的事件类别列表。选择表达式从左到右进行评估，并通过将一个表达式附加到另一个来组合两个表达式。</p>
</div>
<div class="paragraph">
<p><a href="#event-selection">默认的审计事件类别</a> 总结了默认的审计事件类别：</p>
</div>
<table id="event-selection" class="tableblock frame-none grid-all stretch">
<caption class="title">表 30. 默认的审计事件类别</caption>
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">类名</th>
<th class="tableblock halign-left valign-top">描述</th>
<th class="tableblock halign-left valign-top">行动</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">所有</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">匹配所有事件类。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">aa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">身份验证和授权</p></td>
<td class="tableblock halign-left valign-top"></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ad</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">行政的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">对整个系统执行的管理操作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ap</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程序</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">应用程序定义的操作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">cl 可以指以下几个含义：</p>
<p class="tableblock"> 1. 命令行（ Command Line ）：是计算机操作系统中通过命令行界面（ CLI ）执行命令的方式。</p>
<p class="tableblock"> 2. C 语言（ C Language ）：是一种通用的高级编程语言，广泛应用于系统软件开发和嵌入式系统领域。</p>
<p class="tableblock"> 3. OpenCL （ Open Computing Language ）：是一种开放的并行计算框架，用于利用多核处理器、图形处理器（ GPU ）和其他加速器进行高性能计算。</p>
<p class="tableblock"> 4. 信用额度（ Credit Limit ）：是指银行或信用卡公司为客户设定的最高借款或消费限额。</p>
<p class="tableblock"> 5. 中央限制（ Central Limit ）：是统计学中的概念，指在一定条件下，大量独立随机变量的均值近似服从正态分布的现象。</p>
<p class="tableblock">请根据上下文确定具体含义。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">关闭文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计对 <code>close</code> 系统调用的调用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ex</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">执行审计程序。通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=audit_control&amp;sektion=5&amp;format=html">audit_control(5)</a> 使用 <code>argv</code> 和 <code>envv</code> 参数来控制命令行参数和环境变量的审计，这是通过 <code>policy</code> 设置实现的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fa</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件属性访问</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计对象属性的访问，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=stat&amp;sektion=1&amp;format=html">stat(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=pathconf&amp;sektion=2&amp;format=html">pathconf(2)</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fc</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">创建文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计事件：文件创建的结果。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fd</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除文件</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计文件删除事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fm</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件属性修改</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计文件属性修改的事件，例如通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=chown&amp;sektion=8&amp;format=html">chown(8)</a> ， <a href="https://man.freebsd.org/cgi/man.cgi?query=chflags&amp;sektion=1&amp;format=html">chflags(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=flock&amp;sektion=2&amp;format=html">flock(2)</a> 进行的修改。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">抱歉，我只能翻译英文到中文。如果您有英文文本需要翻译，请告诉我。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件读取</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计事件中涉及数据读取或打开文件进行读取的情况。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">fw</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">文件写入</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计事件中涉及数据写入、文件写入或修改的情况。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">输入 / 输出</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ioctl 是一个用于在 UNIX 系统中进行设备控制的系统调用。它允许应用程序通过发送特定的命令和参数来与设备驱动程序进行通信，以实现对设备的控制和配置。 ioctl 的全称是 input/output control ，它可以用于各种设备，包括硬盘、串口、网络接口等。通过 ioctl ，应用程序可以读取和修改设备的状态、属性和配置信息，以及执行特定的操作。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计对 <code>ioctl</code> 系统调用的使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP （ Internet Protocol ）是一种用于在网络中传输数据的协议。它定义了数据如何在网络中进行分组、路由和传递。 IP 地址是用于标识网络中设备的唯一标识符。 IP 地址由 32 位或 128 位二进制数字组成，用于定位和识别设备在网络中的位置。 IP 地址分为 IPv4 和 IPv6 两种版本，其中 IPv4 使用 32 位地址，而 IPv6 使用 128 位地址。 IP 地址的格式通常以四个十进制数表示，每个数之间用点分隔。例如， 192.168.0.1 是一个 IPv4 地址。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IPC （ Inter-Process Communication ）是指进程间通信，是计算机科学中的一个概念。它允许不同的进程在同一台计算机上进行通信和数据交换。 IPC 可以通过多种方式实现，包括管道、消息队列、共享内存和套接字等。通过 IPC ，进程可以共享信息、协调操作和实现并发处理。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计各种形式的进程间通信，包括 POSIX 管道和 System V IPC 操作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">你好</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">登录_注销</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计 <a href="https://man.freebsd.org/cgi/man.cgi?query=login&amp;sektion=1&amp;format=html">login(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=logout&amp;sektion=1&amp;format=html">logout(1)</a> 事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">na</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不可归因的</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计不可归属事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">不需要解释。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">无效的类</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">没有匹配的审计事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nt</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">网络</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与网络操作相关的审计事件，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=connect&amp;sektion=2&amp;format=html">connect(2)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=accept&amp;sektion=2&amp;format=html">accept(2)</a> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ot</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其他</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计其他事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">个人电脑</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">过程</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计进程操作，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=exec&amp;sektion=3&amp;format=html">exec(3)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=exit&amp;sektion=3&amp;format=html">exit(3)</a> 。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>这些审计事件类可以通过修改 <span class="filename">audit_class</span> 和 <span class="filename">audit_event</span> 配置文件进行自定义。</p>
</div>
<div class="paragraph">
<p>每个审计事件类别可以与前缀组合，以指示匹配成功 / 失败的操作，并指示添加或删除该类别和类型的匹配项。 <a href="#event-prefixes">审计事件类的前缀</a> 总结了可用的前缀：</p>
</div>
<table id="event-prefixes" class="tableblock frame-none grid-all stretch">
<caption class="title">表 31. 审计事件类的前缀</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">前缀</th>
<th class="tableblock halign-left valign-top">行动</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计此类中的成功事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">翻译引擎</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">审计此类中的失败事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在这个类中，既不审计成功事件，也不审计失败事件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^+在 asciidoc 格式中表示上标。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不要对这个类中的成功事件进行审计。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">^ - 表示一个升序操作符。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">不要对该类中的失败事件进行审计。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果没有前缀，则对事件的成功和失败实例都将进行审计。</p>
</div>
<div class="paragraph">
<p>以下示例选择字符串选择成功和失败的登录 / 注销事件，但仅选择成功的执行事件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>lo,+ex</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置文件">19.3.2. 配置文件<a class="anchor" href="#_配置文件"></a></h4>
<div class="paragraph">
<p>安全事件审计的以下配置文件位于 [/etc/security] 目录中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="filename">audit_class</span>: 包含了审计类的定义。</p>
</li>
<li>
<p><span class="filename">audit_control</span>: 控制审计子系统的各个方面，如默认审计类别、在审计日志卷上保留的最小磁盘空间以及最大审计跟踪大小。</p>
</li>
<li>
<p><span class="filename">audit_event</span>: 系统审计事件的文本名称和描述，以及每个事件所属的类别列表。</p>
</li>
<li>
<p><span class="filename">audit_user</span>: 用户特定的审计要求，在登录时与全局默认值结合使用。</p>
</li>
<li>
<p><span class="filename">audit_warn</span>: 是一个可定制的 Shell 脚本，由 <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> 使用，用于在异常情况下生成警告消息，例如当审计记录的空间不足或审计跟踪文件已经轮转时。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>审计配置文件应该小心编辑和维护，因为配置错误可能导致事件记录不正确。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在大多数情况下，管理员只需要修改 <span class="filename">audit_control</span> 和 <span class="filename">audit_user</span> 这两个文件。第一个文件控制系统范围的审计属性和策略，而第二个文件可用于按用户进行细化调整审计。</p>
</div>
<div class="sect4">
<h5 id="audit-auditcontrol">19.3.2.1. <span class="filename">audit_control</span> 文件<a class="anchor" href="#audit-auditcontrol"></a></h5>
<div class="paragraph">
<p>在 <span class="filename">audit_control</span> 文件中指定了一些审计子系统的默认值：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dir:/var/audit
dist:off
flags:lo,aa
minfree:5
naflags:lo,aa
policy:cnt,argv
filesz:2M
expire-after:10M</pre>
</div>
</div>
<div class="paragraph">
<p><code>dir</code> 条目用于设置一个或多个目录，用于存储审计日志。如果出现多个 <code>dir</code> 条目，则按照它们出现的顺序进行填充。通常配置审计时，会将审计日志存储在专用的文件系统中，以防止文件系统填满时审计子系统与其他子系统之间的干扰。</p>
</div>
<div class="paragraph">
<p>如果 <code>dist</code> 字段设置为 <code>on</code> 或 <code>yes</code> ，将会在 <code>/var/audit/dist</code> 目录下创建所有审计文件的硬链接。</p>
</div>
<div class="paragraph">
<p><code>flags</code> 字段设置了系统范围内可归属事件的默认预选掩码。在上面的示例中，成功和失败的登录 / 注销事件以及身份验证和授权将为所有用户进行审计。</p>
</div>
<div class="paragraph">
<p><code>minfree</code> 条目定义了存储审计跟踪的文件系统的最小空闲空间百分比。</p>
</div>
<div class="paragraph">
<p><code>naflags</code> 条目指定了要对非归因事件进行审计的审计类别，例如登录 / 注销过程以及身份验证和授权。</p>
</div>
<div class="paragraph">
<p><code>policy</code> 条目指定了一个逗号分隔的策略标志列表，用于控制审计行为的各个方面。 <code>cnt</code> 表示系统应该在审计失败的情况下继续运行（强烈推荐使用此标志）。另一个标志 <code>argv</code> 会导致命令行参数在执行命令时作为 <a href="https://man.freebsd.org/cgi/man.cgi?query=execve&amp;sektion=2&amp;format=html">execve(2)</a> 系统调用的一部分进行审计。</p>
</div>
<div class="paragraph">
<p><code>filesz</code> 条目指定了审计跟踪文件在自动终止和轮转之前的最大大小。值为 <code>0</code> 表示禁用自动日志轮转。如果请求的文件大小低于最小值 512k ，它将被忽略并生成一条日志消息。</p>
</div>
<div class="paragraph">
<p><code>expire-after</code> 字段指定了审计日志文件何时过期并被删除。</p>
</div>
</div>
<div class="sect4">
<h5 id="audit-audituser">19.3.2.2. <span class="filename">audit_user</span> 文件<a class="anchor" href="#audit-audituser"></a></h5>
<div class="paragraph">
<p>管理员可以在 <span class="filename">audit_user</span> 中为特定用户指定进一步的审计要求。每一行通过两个字段配置用户的审计： <code>alwaysaudit</code> 字段指定应始终对用户进行审计的一组事件，而 <code>neveraudit</code> 字段指定不应对用户进行审计的一组事件。</p>
</div>
<div class="paragraph">
<p>以下示例条目审计 <code>root</code> 用户的登录 / 注销事件和成功的命令执行，以及 <code>www</code> 用户的文件创建和成功的命令执行。如果与默认的 <span class="filename">audit_control</span> 一起使用，对于 <code>root</code> 用户的 <code>lo</code> 条目是多余的，并且还将审计 <code>www</code> 用户的登录 / 注销事件。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>root:lo,+ex:no
www:fc,+ex:no</pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="audit-administration">19.4. 使用审计跟踪功能<a class="anchor" href="#audit-administration"></a></h3>
<div class="paragraph">
<p>由于审计跟踪是以 BSM 二进制格式存储的，因此有几个内置工具可用于修改或将这些跟踪转换为文本。要将跟踪文件转换为简单的文本格式，请使用 <code>praudit</code> 。要缩小审计跟踪文件以进行分析、存档或打印，请使用 <code>auditreduce</code> 。此实用程序支持各种选择参数，包括事件类型、事件类别、用户、事件的日期或时间，以及操作的文件路径或对象。</p>
</div>
<div class="paragraph">
<p>例如，要以纯文本形式转储指定审计日志的全部内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># praudit /var/audit/AUDITFILE</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>其中 <em>AUDITFILE</em> 是要转储的审计日志文件。</p>
</div>
<div class="paragraph">
<p>审计追踪由一系列由令牌组成的审计记录组成， <code>praudit</code> 按顺序逐行打印这些记录，每行一个令牌。每个令牌都是特定类型的，例如 <code>header</code> （审计记录头）或 <code>path</code> （名称查找的文件路径）。以下是一个 <code>execve</code> 事件的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>header,133,10,execve(2),0,Mon Sep 25 15:58:03 2006, + 384 msec
exec arg,finger,doug
path,/usr/bin/finger
attribute,555,root,wheel,90,24918,104944
subject,robert,root,wheel,root,wheel,38439,38032,42086,128.232.9.100
return,success,0
trailer,133</pre>
</div>
</div>
<div class="paragraph">
<p>此审计记录表示一个成功的 <code>execve</code> 调用，其中运行了命令 <code>finger doug</code> 。 <code>exec arg</code> 令牌包含由 shell 传递给内核的处理过的命令行。 <code>path</code> 令牌保存了内核查找到的可执行文件的路径。 <code>attribute</code> 令牌描述了二进制文件，并包括文件模式。 <code>subject</code> 令牌存储了审计用户 ID 、有效用户 ID 和组 ID 、真实用户 ID 和组 ID 、进程 ID 、会话 ID 、端口 ID 和登录地址。请注意，审计用户 ID 和真实用户 ID 不同，因为用户 <code>robert</code> 在运行此命令之前切换到了 <code>root</code> 账户，但是它是使用原始认证用户进行审计的。 <code>return</code> 令牌表示成功执行， <code>trailer</code> 结束了记录。</p>
</div>
<div class="paragraph">
<p>还支持 XML 输出格式，可以通过包含 <code>-x</code> 来选择。</p>
</div>
<div class="paragraph">
<p>由于审计日志可能非常庞大，可以使用 <code>auditreduce</code> 选择记录的子集。此示例选择存储在 <span class="filename">AUDITFILE</span> 中的用户 <code>trhodes</code> 生成的所有审计记录。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># auditreduce -u trhodes /var/audit/AUDITFILE | praudit</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>audit</code> 组的成员有权限读取位于 [/var/audit](#var-audit) 目录下的审计日志。默认情况下，该组为空，因此只有 <code>root</code> 用户可以读取审计日志。可以将用户添加到 <code>audit</code> 组中以委派审计审查权限。由于跟踪审计日志内容可以提供对用户和进程行为的重要见解，建议谨慎进行审计审查权限的委派。</p>
</div>
<div class="sect3">
<h4 id="_使用审计管道进行实时监控">19.4.1. 使用审计管道进行实时监控<a class="anchor" href="#_使用审计管道进行实时监控"></a></h4>
<div class="paragraph">
<p>审计管道是克隆伪设备，允许应用程序监听实时审计记录流。这主要对入侵检测和系统监控应用程序的作者感兴趣。然而，审计管道设备是管理员允许实时监控的便捷方式，可以避免审计跟踪文件所有权或日志轮换中断事件流的问题。要跟踪实时审计事件流：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># praudit /dev/auditpipe</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，审计管道设备节点只对 <code>root</code> 用户可访问。要使其对 <code>audit</code> 组的成员可访问，需要在 <code>/etc/devfs.rules</code> 文件中添加一个 <code>devfs</code> 规则。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>add path &#39;auditpipe*&#39; mode 0440 group audit</pre>
</div>
</div>
<div class="paragraph">
<p>请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> 以获取有关配置 devfs 文件系统的更多信息。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>很容易产生审计事件反馈循环，即每个审计事件的查看都会导致更多的审计事件生成。例如，如果对所有网络 I/O 进行审计，并且从一个 SSH 会话中运行 <code>praudit</code> ，将以高速生成连续的审计事件流，因为每个被打印的事件都会生成另一个事件。因此，建议在没有细粒度 I/O 审计的会话中从审计管道设备上运行 <code>praudit</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_旋转和压缩审计日志文件">19.4.2. 旋转和压缩审计日志文件<a class="anchor" href="#_旋转和压缩审计日志文件"></a></h4>
<div class="paragraph">
<p>审计日志由内核编写，并由审计守护程序（ <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> ）管理。管理员不应尝试使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=newsyslog.conf&amp;sektion=5&amp;format=html">newsyslog.conf(5)</a> 或其他工具直接轮转审计日志。相反，应使用 <code>audit</code> 来关闭审计、重新配置审计系统并执行日志轮转。以下命令会导致审计守护程序创建一个新的审计日志，并向内核发出信号以切换到使用新日志。旧日志将被终止和重命名，此时管理员可以对其进行操作。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># audit -n</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=auditd&amp;sektion=8&amp;format=html">auditd(8)</a> 当前未运行，该命令将失败并产生错误消息。</p>
</div>
<div class="paragraph">
<p>将以下行添加到 <span class="filename">/etc/crontab</span> 将会每隔十二小时安排此轮换：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>0     */12       *       *       *       root    /usr/sbin/audit -n</pre>
</div>
</div>
<div class="paragraph">
<p>更改将在保存 <span class="filename">/etc/crontab</span> 后生效。</p>
</div>
<div class="paragraph">
<p>根据 <a href="#audit-auditcontrol"><span class="filename">audit_control</span> 文件</a> 中所述，可以使用 <code>filesz</code> 在 <span class="filename">audit_control</span> 中基于文件大小自动旋转审计跟踪文件。</p>
</div>
<div class="paragraph">
<p>由于审计跟踪文件可能变得非常大，因此通常希望在审计守护程序关闭它们后对跟踪进行压缩或归档。 <span class="filename">audit_warn</span> 脚本可用于执行各种与审计相关的事件的自定义操作，包括在轮换审计跟踪时对其进行清理终止。 例如，可以将以下内容添加到 <span class="filename">/etc/security/audit_warn</span> 中以在关闭时压缩审计跟踪：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#
# Compress audit trail files on close.
#
if [ &#34;$1&#34; = closefile ]; then
        gzip -9 $2
fi</pre>
</div>
</div>
<div class="paragraph">
<p>其他归档活动可能包括将轨迹文件复制到集中服务器，删除旧的轨迹文件，或者减少审计轨迹以删除不需要的记录。此脚本仅在审计轨迹文件被正确终止时运行。它不会在因不正确的关闭而导致未终止的轨迹上运行。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="disks">Chapter 20. 存储<a class="anchor" href="#disks"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="disks-synopsis">20.1. 简介<a class="anchor" href="#disks-synopsis"></a></h3>
<div class="paragraph">
<p>本章介绍了在 FreeBSD 中使用磁盘和存储介质的方法。这包括 SCSI 和 IDE 磁盘、 CD 和 DVD 媒体、内存支持的磁盘以及 USB 存储设备。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何向 FreeBSD 系统添加额外的硬盘。</p>
</li>
<li>
<p>如何在 FreeBSD 上扩大磁盘分区的大小。</p>
</li>
<li>
<p>如何配置 FreeBSD 以使用 USB 存储设备。</p>
</li>
<li>
<p>如何在 FreeBSD 系统上使用 CD 和 DVD 媒体。</p>
</li>
<li>
<p>如何使用 FreeBSD 下可用的备份程序。</p>
</li>
<li>
<p>如何设置内存磁盘。</p>
</li>
<li>
<p>文件系统快照是什么以及如何高效使用它们。</p>
</li>
<li>
<p>如何使用配额限制磁盘空间使用。</p>
</li>
<li>
<p>如何加密磁盘和交换空间以防止攻击者的攻击。</p>
</li>
<li>
<p>如何配置高可用存储网络。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解如何交叉引用： kernelconfig[kernelconfig ，配置和安装新的 FreeBSD 内核] 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="disks-adding">20.2. 添加磁盘<a class="anchor" href="#disks-adding"></a></h3>
<div class="paragraph">
<p>本节描述了如何将一个新的 SATA 硬盘添加到目前只有一个驱动器的计算机中。首先，关闭计算机，并按照计算机、控制器和硬盘制造商的说明将硬盘安装到计算机中。重新启动系统并成为“ root ”用户。</p>
</div>
<div class="paragraph">
<p>检查 <span class="filename">/var/run/dmesg.boot</span> 确保新的磁盘被找到。在这个例子中，新添加的 SATA 驱动器将会显示为 <span class="filename">ada1</span> 。</p>
</div>
<div class="paragraph">
<p>对于这个示例，将在新磁盘上创建一个单独的大分区。优先使用 <a href="http://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a> 分区方案，而不是较旧且功能较少的 MBR 方案。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果要添加的磁盘不是空白的，则可以使用 <code>gpart delete</code> 命令删除旧的分区信息。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>创建了分区方案，然后添加了一个单独的分区。为了提高在具有更大硬件块大小的新磁盘上的性能，该分区被对齐到每个一兆字节边界。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart create -s GPT ada1</span>
<span class="c"># gpart add -t freebsd-ufs -a 1M ada1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>根据使用情况，可能需要创建几个较小的分区。有关创建小于整个磁盘的分区的选项，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>gpart show</code> 命令查看磁盘分区信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>gpart show ada1
<span class="gp">=&gt;        </span>34  1465146988  ada1  GPT  <span class="o">(</span>699G<span class="o">)</span>
          34        2014        - free -  <span class="o">(</span>1.0M<span class="o">)</span>
        2048  1465143296     1  freebsd-ufs  <span class="o">(</span>699G<span class="o">)</span>
  1465145344        1678        - free -  <span class="o">(</span>839K<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在新磁盘的新分区上创建了一个文件系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># newfs -U /dev/ada1p1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个空目录被创建为_mountpoint_，用于在原始磁盘的文件系统中挂载新的磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /newdisk</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，将一个条目添加到 [/etc/fstab] 文件中，以便新的磁盘在启动时自动挂载：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/ada1p1	/newdisk	ufs	rw	2	2</pre>
</div>
</div>
<div class="paragraph">
<p>新的磁盘可以手动挂载，无需重新启动系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /newdisk</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="disks-growing">20.3. 调整和扩展磁盘大小<a class="anchor" href="#disks-growing"></a></h3>
<div class="paragraph">
<p>磁盘的容量可以增加而不影响已有的数据。这在虚拟机中经常发生，当虚拟磁盘太小而需要扩大时。有时候，磁盘镜像被写入到 USB 存储设备中，但没有使用完整的容量。在这里，我们将描述如何调整或“增加”磁盘内容以利用增加的容量。</p>
</div>
<div class="paragraph">
<p>通过检查 [/var/run/dmesg.boot] 来确定要调整大小的磁盘的设备名称。在这个例子中，系统中只有一个 SATA 磁盘，所以该驱动器将显示为 ada0 。</p>
</div>
<div class="paragraph">
<p>列出磁盘上的分区以查看当前配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart show ada0</span>
<span class="gp">=&gt;      </span>34  83886013  ada0  GPT  <span class="o">(</span>48G<span class="o">)</span> <span class="o">[</span>CORRUPT]
        34       128     1  freebsd-boot  <span class="o">(</span>64k<span class="o">)</span>
       162  79691648     2  freebsd-ufs  <span class="o">(</span>38G<span class="o">)</span>
  79691810   4194236     3  freebsd-swap  <span class="o">(</span>2G<span class="o">)</span>
  83886046         1        - free -  <span class="o">(</span>512B<span class="o">)</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果磁盘使用 <a href="http://en.wikipedia.org/wiki/GUID_Partition_Table">GPT</a> 分区方案进行格式化，可能会显示为“损坏”，因为 GPT 备份分区表不再位于驱动器的末尾。使用 <code>gpart</code> 修复备份分区表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart recover ada0</span>
ada0 recovered</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在，磁盘上的额外空间可供新分区使用，或者可以扩展现有分区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart show ada0</span>
<span class="gp">=&gt;       </span>34  102399933  ada0  GPT  <span class="o">(</span>48G<span class="o">)</span>
         34        128     1  freebsd-boot  <span class="o">(</span>64k<span class="o">)</span>
        162   79691648     2  freebsd-ufs  <span class="o">(</span>38G<span class="o">)</span>
   79691810    4194236     3  freebsd-swap  <span class="o">(</span>2G<span class="o">)</span>
   83886046   18513921        - free -  <span class="o">(</span>8.8G<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>分区只能调整为连续的空闲空间。在这里，磁盘上的最后一个分区是交换分区，但需要调整大小的是第二个分区。交换分区只包含临时数据，因此可以安全地卸载、删除，然后在调整第二个分区大小后重新创建第三个分区。</p>
</div>
<div class="paragraph">
<p>禁用交换分区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># swapoff /dev/ada0p3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从磁盘_ada0_中删除由 <code>-i</code> 标志指定的第三个分区。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart delete -i 3 ada0</span>
ada0p3 deleted
<span class="c"># gpart show ada0</span>
<span class="gp">=&gt;       </span>34  102399933  ada0  GPT  <span class="o">(</span>48G<span class="o">)</span>
         34        128     1  freebsd-boot  <span class="o">(</span>64k<span class="o">)</span>
        162   79691648     2  freebsd-ufs  <span class="o">(</span>38G<span class="o">)</span>
   79691810   22708157        - free -  <span class="o">(</span>10G<span class="o">)</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在修改挂载文件系统的分区表时存在数据丢失的风险。最好在从 Live CD-ROM 或 USB 设备运行时，对未挂载的文件系统执行以下步骤。然而，如果绝对必要，可以在禁用 GEOM 安全功能后调整挂载的文件系统的大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl kern.geom.debugflags=16</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>调整分区大小，留出空间以重新创建所需大小的交换分区。使用 <code>-i</code> 指定要调整大小的分区，使用 <code>-s</code> 指定新的所需大小。可选地，使用 <code>-a</code> 控制分区的对齐方式。这仅修改分区的大小。分区中的文件系统将在单独的步骤中扩展。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart resize -i 2 -s 47G -a 4k ada0</span>
ada0p2 resized
<span class="c"># gpart show ada0</span>
<span class="gp">=&gt;       </span>34  102399933  ada0  GPT  <span class="o">(</span>48G<span class="o">)</span>
         34        128     1  freebsd-boot  <span class="o">(</span>64k<span class="o">)</span>
        162   98566144     2  freebsd-ufs  <span class="o">(</span>47G<span class="o">)</span>
   98566306    3833661        - free -  <span class="o">(</span>1.8G<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>重新创建交换分区并激活它。如果没有使用 <code>-s</code> 指定大小，则使用所有剩余空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart add -t freebsd-swap -a 4k ada0</span>
ada0p3 added
<span class="c"># gpart show ada0</span>
<span class="gp">=&gt;       </span>34  102399933  ada0  GPT  <span class="o">(</span>48G<span class="o">)</span>
         34        128     1  freebsd-boot  <span class="o">(</span>64k<span class="o">)</span>
        162   98566144     2  freebsd-ufs  <span class="o">(</span>47G<span class="o">)</span>
   98566306    3833661     3  freebsd-swap  <span class="o">(</span>1.8G<span class="o">)</span>
<span class="c"># swapon /dev/ada0p3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 UFS 文件系统扩展到重新调整大小的分区的新容量。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growfs /dev/ada0p2</span>
Device is mounted <span class="nb">read</span>-write; resizing will result <span class="k">in </span>temporary write suspension <span class="k">for</span> /.
It<span class="s1">&#39;s strongly recommended to make a backup before growing the file system.
OK to grow file system on /dev/ada0p2, mounted on /, from 38GB to 47GB? [Yes/No] Yes
super-block backups (for fsck -b #) at:
 80781312, 82063552, 83345792, 84628032, 85910272, 87192512, 88474752,
 89756992, 91039232, 92321472, 93603712, 94885952, 96168192, 97450432</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果文件系统是 ZFS ，则通过运行带有 <code>-e</code> 选项的 <code>online</code> 子命令来触发调整大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool online -e zroot /dev/ada0p2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>分区和其上的文件系统现在已经调整大小，以利用新可用的磁盘空间。</p>
</div>
</div>
<div class="sect2">
<h3 id="usb-disks">20.4. USB 存储设备<a class="anchor" href="#usb-disks"></a></h3>
<div class="paragraph">
<p>许多外部存储解决方案，如硬盘、 USB 闪存驱动器以及 CD 和 DVD 刻录机，使用通用串行总线（ USB ）。 FreeBSD 支持 USB 1.x 、 2.0 和 3.0 设备。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>USB 3.0 支持不兼容一些硬件，包括 Haswell （ Lynx Point ）芯片组。如果 FreeBSD 启动时出现“失败，错误代码 19 ”的消息，请在系统 BIOS 中禁用 xHCI/USB3 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>对 USB 存储设备的支持已经集成到 <span class="filename">GENERIC</span> 内核中。对于自定义内核，请确保以下行在内核配置文件中存在：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da
device cd	# needed for CD and DVD burners</pre>
</div>
</div>
<div class="paragraph">
<p>FreeBSD 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=umass&amp;sektion=4&amp;format=html">umass(4)</a> 驱动程序，该驱动程序使用 SCSI 子系统来访问 USB 存储设备。由于系统将任何 USB 设备视为 SCSI 设备，如果 USB 设备是 CD 或 DVD 刻录机，请在自定义内核配置文件中 <em>不要</em> 包含 <code>device atapicam</code> 。</p>
</div>
<div class="paragraph">
<p>本节的其余部分演示了如何验证 FreeBSD 是否识别 USB 存储设备以及如何配置设备以便使用。</p>
</div>
<div class="sect3">
<h4 id="_设备配置">20.4.1. 设备配置<a class="anchor" href="#_设备配置"></a></h4>
<div class="paragraph">
<p>为了测试 USB 配置，请插入 USB 设备。使用 <code>dmesg</code> 命令确认驱动器是否出现在系统消息缓冲区中。它应该看起来像这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">umass0: &lt;STECH Simple Drive, class 0/0, rev 2.00/1.04, addr 3&gt; on usbus0
umass0:  SCSI over Bulk-Only; quirks <span class="o">=</span> 0x0100
umass0:4:0:-1: Attached to scbus4
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; Fixed Direct Access SCSI-4 device
da0: Serial Number WD-WXE508CAN263
da0: 40.000MB/s transfers
da0: 152627MB <span class="o">(</span>312581808 512 byte sectors: 255H 63S/T 19457C<span class="o">)</span>
da0: <span class="nv">quirks</span><span class="o">=</span>0x2&lt;NO_6_BYTE&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>品牌、设备节点（ <span class="filename">da0</span> ）、速度和大小将根据设备而异。</p>
</div>
<div class="paragraph">
<p>由于 USB 设备被视为 SCSI 设备，可以使用 <code>camcontrol</code> 命令列出连接到系统的 USB 存储设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># camcontrol devlist</span>
&lt;STECH Simple Drive 1.04&gt;          at scbus4 target 0 lun 0 <span class="o">(</span>pass3,da0<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>另外，可以使用 <code>usbconfig</code> 命令列出设备。有关该命令的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># usbconfig</span>
ugen0.3: &lt;Simple Drive STECH&gt; at usbus0, <span class="nv">cfg</span><span class="o">=</span>0 <span class="nv">md</span><span class="o">=</span>HOST <span class="nv">spd</span><span class="o">=</span>HIGH <span class="o">(</span>480Mbps<span class="o">)</span> <span class="nv">pwr</span><span class="o">=</span>ON <span class="o">(</span>2mA<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果设备尚未格式化，请参考 <a href="#disks-adding">添加磁盘</a> 中的说明，了解如何对 USB 驱动器进行格式化和创建分区的操作。如果驱动器已经带有文件系统，可以使用 <a href="./#mount-unmount">“挂载和卸载文件系统”</a> 中的指示，由 <code>root</code> 用户进行挂载。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从安全角度来看，不应该认为通过启用 <code>vfs.usermount</code> 来允许不受信任的用户挂载任意媒体是安全的。大多数文件系统并不具备防范恶意设备的能力。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了使设备能够以普通用户的身份挂载，一种解决方案是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pw&amp;sektion=8&amp;format=html">pw(8)</a> 将设备的所有用户都添加到 <code>operator</code> 组中。接下来，通过将以下行添加到 <span class="filename">/etc/devfs.rules</span> 来确保 <code>operator</code> 能够读写设备：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[localrules=5]
add path &#39;da*&#39; mode 0660 group operator</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果系统中还安装了内部 SCSI 硬盘，请将第二行更改如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>add path &#39;da[3-9]*&#39; mode 0660 group operator</pre>
</div>
</div>
<div class="paragraph">
<p>这将排除前三个 SCSI 磁盘（ <span class="filename">da0</span> 到 <span class="filename">da2</span> ）不属于 <code>operator</code> 组。将_3_替换为内部 SCSI 磁盘的数量。有关此文件的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=devfs.rules&amp;sektion=5&amp;format=html">devfs.rules(5)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接下来，在 [/etc/rc.conf] 文件中启用规则集：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>devfs_system_ruleset=&#34;localrules&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后，通过将以下行添加到 <span class="filename">/etc/sysctl.conf</span> ，指示系统允许普通用户挂载文件系统：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vfs.usermount=1</pre>
</div>
</div>
<div class="paragraph">
<p>由于此设置仅在下次重新启动后生效，请使用 <code>sysctl</code> 立即设置此变量：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一步是创建一个目录，用于挂载文件系统。这个目录需要由将要挂载文件系统的用户拥有。一种方法是让 <code>root</code> 用户创建一个由该用户拥有的子目录，例如 <span class="filename">/mnt/username</span> 。在下面的示例中，将_username_替换为用户的登录名，将_usergroup_替换为用户的主要组名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /mnt/username</span>
<span class="c"># chown username:usergroup /mnt/username</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>假设插入了一个 USB 闪存驱动器，并出现了一个设备 <span class="filename">/dev/da0s1</span> 。如果该设备使用 FAT 文件系统格式化，用户可以使用以下命令挂载它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mount -t msdosfs -o -m<span class="o">=</span>644,-M<span class="o">=</span>755 /dev/da0s1 /mnt/username</code></pre>
</div>
</div>
<div class="paragraph">
<p>在设备被拔出之前，必须首先卸载设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>umount /mnt/username</code></pre>
</div>
</div>
<div class="paragraph">
<p>设备移除后，系统消息缓冲区将显示类似以下的消息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">umass0: at uhub3, port 2, addr 3 <span class="o">(</span>disconnected<span class="o">)</span>
da0 at umass-sim0 bus 0 scbus4 target 0 lun 0
da0: &lt;STECH Simple Drive 1.04&gt; s/n WD-WXE508CAN263          detached
<span class="o">(</span>da0:umass-sim0:0:0:0<span class="o">)</span>: Periph destroyed</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_自动挂载可移动介质">20.4.2. 自动挂载可移动介质<a class="anchor" href="#_自动挂载可移动介质"></a></h4>
<div class="paragraph">
<p>取消注释 [/etc/auto_master] 中的这行代码可以自动挂载 USB 设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">/media		-media		-nosuid</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后将以下行添加到 [/etc/devd.conf] 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">notify 100 <span class="o">{</span>
	match <span class="s2">&#34;system&#34;</span> <span class="s2">&#34;GEOM&#34;</span>;
	match <span class="s2">&#34;subsystem&#34;</span> <span class="s2">&#34;DEV&#34;</span>;
	action <span class="s2">&#34;/usr/sbin/automount -c&#34;</span>;
<span class="o">}</span>;</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 已经在运行，请重新加载配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service automount restart</span>
<span class="c"># service devd restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 可以通过将以下行添加到 [/etc/rc.conf] 来设置在启动时启动：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>autofs_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 要求启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> ，默认情况下它是启用的。</p>
</div>
<div class="paragraph">
<p>立即启动服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service automount start</span>
<span class="c"># service automountd start</span>
<span class="c"># service autounmountd start</span>
<span class="c"># service devd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>每个可以自动挂载的文件系统都会在 <span class="filename">/media/</span> 中以目录的形式显示。该目录的名称与文件系统的标签相同。如果标签缺失，则目录的名称与设备节点相同。</p>
</div>
<div class="paragraph">
<p>文件系统在第一次访问时透明地挂载，并在一段时间的不活动后卸载。自动挂载的驱动器也可以手动卸载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># automount -fu</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这种机制通常用于存储卡和 USB 存储设备。它可以与任何块设备一起使用，包括光驱或 iSCSI 逻辑单元。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="creating-cds">20.5. 创建和使用 CD 媒体<a class="anchor" href="#creating-cds"></a></h3>
<div class="paragraph">
<p>紧凑型光盘（ CD ）介质具有一些与传统磁盘不同的特点。它们被设计成可以连续读取，无需在轨道之间移动磁头造成延迟。虽然 CD 介质确实有轨道，但这些轨道指的是要连续读取的数据部分，而不是磁盘的物理属性。 ISO 9660 文件系统是为处理这些差异而设计的。</p>
</div>
<div class="paragraph">
<p>FreeBSD Ports Collection 提供了几个用于刻录和复制音频和数据 CD 的实用工具。本章演示了几个命令行实用程序的使用方法。如果需要带有图形界面的 CD 刻录软件，请考虑安装软件包： sysutils/xcdroast[] 或软件包： sysutils/k3b[] 。</p>
</div>
<div class="sect3">
<h4 id="atapicam">20.5.1. 支持的设备<a class="anchor" href="#atapicam"></a></h4>
<div class="paragraph">
<p><span class="filename">GENERIC</span> 内核提供了对 SCSI 、 USB 和 ATAPICD 读写器的支持。如果使用自定义内核，则需要在内核配置文件中根据设备类型添加相应的选项。</p>
</div>
<div class="paragraph">
<p>对于 SCSI 刻录机，请确保以下选项存在：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre>
</div>
</div>
<div class="paragraph">
<p>对于一个 USB 刻录机，确保以下选项存在：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device scbus	# SCSI bus (required for ATA/SCSI)
device da	# Direct Access (disks)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners
device uhci	# provides USB 1.x support
device ohci	# provides USB 1.x support
device ehci	# provides USB 2.0 support
device xhci	# provides USB 3.0 support
device usb	# USB Bus (required)
device umass	# Disks/Mass storage - Requires scbus and da</pre>
</div>
</div>
<div class="paragraph">
<p>对于一个 ATAPI 刻录机，请确保以下选项存在：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device ata	# Legacy ATA/SATA controllers
device scbus	# SCSI bus (required for ATA/SCSI)
device pass	# Passthrough device (direct ATA/SCSI access)
device cd	# needed for CD and DVD burners</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 FreeBSD 10.x 之前的版本中，如果刻录机是 ATAPI 设备，则还需要在内核配置文件中添加此行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device atapicam</pre>
</div>
</div>
<div class="paragraph">
<p>或者，可以通过在 <span class="filename">/boot/loader.conf</span> 中添加以下行来在启动时加载此驱动程序：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>atapicam_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>这将需要系统重新启动，因为这个驱动程序只能在启动时加载。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要验证 FreeBSD 是否识别设备，请运行 <code>dmesg</code> 命令并查找设备的条目。在 10.x 之前的系统中，输出的第一行中设备名称将是 <span class="filename">acd0</span> ，而不是 <span class="filename">cd0</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>dmesg | grep <span class="nb">cd
</span>cd0 at ahcich1 bus 0 scbus1 target 0 lun 0
cd0: &lt;HL-DT-ST DVDRAM GU70N LT20&gt; Removable CD-ROM SCSI-0 device
cd0: Serial Number M3OD3S34152
cd0: 150.000MB/s transfers <span class="o">(</span>SATA 1.x, UDMA6, ATAPI 12bytes, PIO 8192bytes<span class="o">)</span>
cd0: Attempt to query device size failed: NOT READY, Medium not present - tray closed</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="cdrecord">20.5.2. 刻录光盘<a class="anchor" href="#cdrecord"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 中，可以使用 <code>cdrecord</code> 来刻录光盘。这个命令是通过 <code>sysutils/cdrtools</code> 包或端口安装的。</p>
</div>
<div class="paragraph">
<p>虽然 <code>cdrecord</code> 有很多选项，但基本用法很简单。只需指定要刻录的 ISO 文件的名称，如果系统有多个刻录设备，则还需指定要使用的设备的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cdrecord dev=device imagefile.iso</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要确定刻录机的设备名称，请使用 <code>-scanbus</code> 命令，可能会产生如下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cdrecord -scanbus</span>
ProDVD-ProBD-Clone 3.00 <span class="o">(</span>amd64-unknown-freebsd10.0<span class="o">)</span> Copyright <span class="o">(</span>C<span class="o">)</span> 1995-2010 Jörg Schilling
Using libscg version <span class="s1">&#39;schily-0.9&#39;</span>
scsibus0:
        0,0,0     0<span class="o">)</span> <span class="s1">&#39;SEAGATE &#39;</span> <span class="s1">&#39;ST39236LW       &#39;</span> <span class="s1">&#39;0004&#39;</span> Disk
        0,1,0     1<span class="o">)</span> <span class="s1">&#39;SEAGATE &#39;</span> <span class="s1">&#39;ST39173W        &#39;</span> <span class="s1">&#39;5958&#39;</span> Disk
        0,2,0     2<span class="o">)</span> <span class="k">*</span>
        0,3,0     3<span class="o">)</span> <span class="s1">&#39;iomega  &#39;</span> <span class="s1">&#39;jaz 1GB         &#39;</span> <span class="s1">&#39;J.86&#39;</span> Removable Disk
        0,4,0     4<span class="o">)</span> <span class="s1">&#39;NEC     &#39;</span> <span class="s1">&#39;CD-ROM DRIVE:466&#39;</span> <span class="s1">&#39;1.26&#39;</span> Removable CD-ROM
        0,5,0     5<span class="o">)</span> <span class="k">*</span>
        0,6,0     6<span class="o">)</span> <span class="k">*</span>
        0,7,0     7<span class="o">)</span> <span class="k">*</span>
scsibus1:
        1,0,0   100<span class="o">)</span> <span class="k">*</span>
        1,1,0   101<span class="o">)</span> <span class="k">*</span>
        1,2,0   102<span class="o">)</span> <span class="k">*</span>
        1,3,0   103<span class="o">)</span> <span class="k">*</span>
        1,4,0   104<span class="o">)</span> <span class="k">*</span>
        1,5,0   105<span class="o">)</span> <span class="s1">&#39;YAMAHA  &#39;</span> <span class="s1">&#39;CRW4260         &#39;</span> <span class="s1">&#39;1.0q&#39;</span> Removable CD-ROM
        1,6,0   106<span class="o">)</span> <span class="s1">&#39;ARTEC   &#39;</span> <span class="s1">&#39;AM12S           &#39;</span> <span class="s1">&#39;1.06&#39;</span> Scanner
        1,7,0   107<span class="o">)</span> <span class="k">*</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>找到 CD 刻录机的条目，并使用逗号分隔的三个数字作为 <code>dev</code> 的值。在这种情况下， Yamaha 刻录机设备是 <code>1 , 5 , 0</code> ，因此指定该设备的适当输入是 <code>dev = 1 , 5 , 0</code> 。请参考 <code>cdrecord</code> 的手册页面，了解其他指定该值的方法以及有关写入音轨和控制写入速度的信息。</p>
</div>
<div class="paragraph">
<p>或者，运行以下命令以获取刻录机的设备地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># camcontrol devlist</span>
&lt;MATSHITA CDRW/DVD UJDA740 1.00&gt;   at scbus1 target 0 lun 0 <span class="o">(</span>cd0,pass0<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>scbus</code> 、 <code>target</code> 和 <code>lun</code> 的数值。对于这个例子， <code>1 , 0 , 0</code> 是要使用的设备名称。</p>
</div>
</div>
<div class="sect3">
<h4 id="mkisofs">20.5.3. 将数据写入 ISO 文件系统<a class="anchor" href="#mkisofs"></a></h4>
<div class="paragraph">
<p>为了制作数据光盘，必须在将数据文件刻录到光盘之前对其进行准备。在 FreeBSD 中，安装了 <code>mkisofs</code> 的 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/">sysutils/cdrtools</a></code> 可以用来生成一个 ISO 9660 文件系统，该文件系统是 UNIX® 文件系统中目录树的镜像。最简单的用法是指定要创建的 ISO 文件的名称和要放入 ISO 9660 文件系统的文件路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkisofs -o imagefile.iso /path/to/tree</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令将指定路径中的文件名映射为符合标准 ISO 9660 文件系统限制的名称，并且将排除不符合 ISO 文件系统标准的文件。</p>
</div>
<div class="paragraph">
<p>有多种选项可用于克服标准所施加的限制。特别地， <code>-R</code> 启用了在 UNIX® 系统中常见的 Rock Ridge 扩展，而 <code>-J</code> 启用了 Microsoft® 系统中使用的 Joliet 扩展。</p>
</div>
<div class="paragraph">
<p>对于仅在 FreeBSD 系统上使用的 CD ，可以使用 <code>-U</code> 来禁用所有文件名限制。当与 <code>-R</code> 一起使用时，它会生成一个文件系统镜像，即使违反 ISO 9660 标准，也与指定的 FreeBSD 树完全相同。</p>
</div>
<div class="paragraph">
<p>通用用途的最后一个选项是 <code>-b</code> 。它用于指定用于生成“ El Torito ”可引导 CD 的引导映像的位置。此选项接受一个参数，即从要写入 CD 的树的顶部到引导映像的路径。默认情况下， <code>mkisofs</code> 以“软盘仿真”模式创建 ISO 映像，因此期望引导映像的大小为 1200 、 1440 或 2880 KB 。某些引导加载程序（如 FreeBSD 发行版媒体使用的加载程序）不使用仿真模式。在这种情况下，应使用 <code>-no-emul-boot</code> 选项。因此，如果 <code>.filename</code><mark>/tmp/myboot</mark> 中包含一个可引导的 FreeBSD 系统，并且引导映像位于 <code>.filename</code><mark>/tmp/myboot/boot/cdboot</mark> 中，此命令将生成 <code>.filename</code><mark>/tmp/bootable.iso</mark> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkisofs -R -no-emul-boot -b boot/cdboot -o /tmp/bootable.iso /tmp/myboot</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>生成的 ISO 镜像可以通过以下方式挂载为内存磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mdconfig -a -t vnode -f /tmp/bootable.iso -u 0</span>
<span class="c"># mount -t cd9660 /dev/md0 /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以验证 <span class="filename">/mnt</span> 和 <span class="filename">/tmp/myboot</span> 是相同的。</p>
</div>
<div class="paragraph">
<p>有许多其他选项可用于细调 <code>mkisofs</code> 的行为。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以将数据光盘复制到一个与使用 <code>mkisofs</code> 创建的镜像文件在功能上等效的镜像文件中。要做到这一点，使用 <code>dd</code> 命令，将设备名称作为输入文件，将要创建的 ISO 文件的名称作为输出文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/cd0 of=file.iso bs=2048</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>生成的图像文件可以按照 <a href="#cdrecord">刻录光盘</a> 中描述的方式刻录到 CD 上。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mounting-cd">20.5.4. 使用数据光盘<a class="anchor" href="#mounting-cd"></a></h4>
<div class="paragraph">
<p>一旦 ISO 文件被刻录到光盘上，可以通过指定文件系统类型、包含光盘的设备名称和已存在的挂载点来挂载。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount -t cd9660 /dev/cd0 /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>mount</code> 假设文件系统的类型是 <code>ufs</code> ，如果在挂载数据光盘时没有包含 <code>-t cd9660</code> ，将会出现 <code>Incorrect super block</code> 错误。</p>
</div>
<div class="paragraph">
<p>虽然任何数据 CD 都可以通过这种方式挂载，但带有特定 ISO 9660 扩展的光盘可能会表现出奇怪的行为。例如， Joliet 光盘将所有文件名存储为两个字节的 Unicode 字符。如果一些非英文字符显示为问号，请使用“ -C ”参数指定本地字符集。有关更多信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_cd9660&amp;sektion=8&amp;format=html">mount_cd9660(8)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了使用 <code>-C</code> 选项进行字符转换，内核需要加载 <code>.filename#cd9660_iconv.ko#</code> 模块。可以通过将以下行添加到 <code>.filename#loader.conf#</code> 来实现：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cd9660_iconv_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后重新启动机器，或通过使用 <code>kldload</code> 命令直接加载模块。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在尝试挂载数据光盘时，有时会显示“设备未配置”。这通常意味着光驱没有检测到托盘中的光盘，或者该驱动器在总线上不可见。光驱可能需要几秒钟的时间来检测媒体，请耐心等待。</p>
</div>
<div class="paragraph">
<p>有时候， SCSICD 驱动器可能会被忽略，因为它没有足够的时间来回应总线复位。为了解决这个问题，可以创建一个自定义内核，增加默认的 SCSI 延迟。将以下选项添加到自定义内核配置文件中，并按照 <a href="./#kernelconfig-building">构建和安装自定义内核</a> 中的说明重新构建内核。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options SCSI_DELAY=15000</pre>
</div>
</div>
<div class="paragraph">
<p>这将在启动过程中告诉 SCSI 总线暂停 15 秒，以便给 CD 驱动器尽可能多的机会来响应总线复位。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>可以直接将文件刻录到光盘上，而无需创建 ISO 9660 文件系统。这被称为刻录原始数据光盘，有些人出于备份目的这样做。</p>
</div>
<div class="paragraph">
<p>这种类型的光盘不能像普通数据光盘一样挂载。为了获取烧录到这种光盘上的数据，必须从原始设备节点读取数据。例如，以下命令将从第二个光盘设备中提取一个压缩的 tar 文件到当前工作目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tar xzvf /dev/cd1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了挂载数据光盘，数据必须使用 <code>mkisofs</code> 进行写入。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="duplicating-audiocds">20.5.5. 复制音频 CDs<a class="anchor" href="#duplicating-audiocds"></a></h4>
<div class="paragraph">
<p>要复制音频 CD ，需要从 CD 中提取音频数据到一系列文件中，然后将这些文件写入空白 CD 。</p>
</div>
<div class="paragraph">
<p><a href="#using-cdrecord">过程：复制音频 CD</a> 描述了如何复制和刻录音频 CD 。如果 FreeBSD 版本小于 10.0 且设备为 ATAPI ，必须首先使用 <a href="#atapicam">支持的设备</a> 中的说明加载 <code>atapicam</code> 模块。</p>
</div>
<div id="using-cdrecord" class="olist arabic procedure">
<div class="title">过程：复制音频 CD</div>
<ol class="arabic">
<li>
<p>包： sysutils/cdrtools[] 包或端口安装了 <code>cdda2wav</code> 。此命令可用于提取所有音轨，每个音轨都会被写入当前工作目录中的单独的 WAV 文件中：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>cdda2wav -vall -B -Owav</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果系统上只有一个 CD 设备，则不需要指定设备名称。请参考 <code>cdda2wav</code> 手册页面，了解如何指定设备以及了解此命令的其他可用选项。</p>
</div>
</li>
<li>
<p>使用 <code>cdrecord</code> 命令来写入 <span class="filename">.wav</span> 文件：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>cdrecord -v <span class="nv">dev</span><span class="o">=</span>2,0 -dao -useinfo  <span class="k">*</span>.wav</code></pre>
</div>
</div>
<div class="paragraph">
<p>请确保按照 <a href="#cdrecord">刻录光盘</a> 中描述的方式适当设置 <em>2 , 0</em>。</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="creating-dvds">20.6. 创建和使用 DVD 媒体<a class="anchor" href="#creating-dvds"></a></h3>
<div class="paragraph">
<p>与 CD 相比， DVD 是下一代光学媒体存储技术。 DVD 可以容纳比任何 CD 更多的数据，并且是视频出版的标准。</p>
</div>
<div class="paragraph">
<p>可为可记录的 DVD 定义五种物理可记录格式：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DVD-R ：这是第一个可用的 DVD 可记录格式。 DVD-R 标准由 DVD 论坛定义。这种格式只能写入一次。</p>
</li>
<li>
<p>DVD-RW ：这是 DVD-R 标准的可重写版本。一个 DVD-RW 可以重写约 1000 次。</p>
</li>
<li>
<p>DVD-RAM ：这是一种可重写的格式，可以看作是可移动硬盘。然而，这种介质与大多数 DVD-ROM 驱动器和 DVD 视频播放器不兼容，因为只有少数 DVD 刻录机支持 DVD-RAM 格式。有关 DVD-RAM 使用的更多信息，请参阅 <a href="#creating-dvd-ram">使用 DVD-RAM</a> 。</p>
</li>
<li>
<p>DVD + RW ：这是由 DVD + RW 联盟定义的可重写格式。 DVD + RW 可以重写约 1000 次。</p>
</li>
<li>
<p>DVD + R ：这种格式是 DVD + RW 格式的一次写入变体。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>一张单层可记录的 DVD 可以容纳高达 4 , 700 , 000 , 000 字节，实际上相当于 4.38 GB 或 4485 MB ，因为 1 千字节等于 1024 字节。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>必须区分物理介质和应用程序。例如， DVD-Video 是一种特定的文件布局，可以写入任何可记录的 DVD 物理介质，如 DVD-R 、 DVD + R 或 DVD-RW 。在选择介质之前，请确保刻录机和 DVD-Video 播放器与所考虑的介质兼容。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_配置">20.6.1. 配置<a class="anchor" href="#_配置"></a></h4>
<div class="paragraph">
<p>要进行 DVD 录制，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 命令。该命令是 package:sysutils/dvd + rw-tools[] 工具包的一部分，支持所有 DVD 媒体类型。</p>
</div>
<div class="paragraph">
<p>这些工具使用 SCSI 子系统来访问设备，因此必须加载或静态编译 <a href="#atapicam ">ATAPI/CAM 支持 </a> 到内核中。如果刻录机使用 USB 接口，则不需要此支持。有关 USB 设备配置的更多详细信息，请参阅 <a href="#usb-disks">USB 存储设备</a> 。</p>
</div>
<div class="paragraph">
<p>还必须为 ATAPI 设备启用 DMA 访问，方法是在 [/boot/loader.conf] 中添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hw.ata.atapi_dma=&#34;1&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在尝试使用 dvd + rw-tools 之前，请参考 <a href="http://fy.chalmers.se/" class="bare">http://fy.chalmers.se/</a> ~ appro/linux/DVD + RW/hcn.html[硬件兼容性说明] 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于图形用户界面，请考虑使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/k3b/">sysutils/k3b</a> ，它提供了一个用户友好的界面来使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 和许多其他刻录工具。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_刻录数据_dvd">20.6.2. 刻录数据 DVD<a class="anchor" href="#_刻录数据_dvd"></a></h4>
<div class="paragraph">
<p>由于 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 是 <a href="#mkisofs ">mkisofs</a> 的前端，它将调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> 来创建文件系统布局并在 DVD 上执行写入操作。这意味着在刻录过程之前不需要创建数据的镜像。</p>
</div>
<div class="paragraph">
<p>要将位于 <span class="filename">/path/to/data</span> 的数据刻录到 DVD + R 或 DVD-R 上，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -dvd-compat -Z /dev/cd0 -J -R /path/to/data</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中， <code>-J -R</code> 被传递给 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> 以创建一个带有 Joliet 和 Rock Ridge 扩展的 ISO 9660 文件系统。更多详细信息请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> 。</p>
</div>
<div class="paragraph">
<p>对于初始会话录制， <code>-Z</code> 用于单个和多个会话。将 <em>/dev/cd0</em> 替换为 DVD 设备的名称。使用 <code>-dvd-compat</code> 表示光盘将被关闭，并且录制将无法追加。这还应该提供更好的与 DVD-ROM 驱动器的媒体兼容性。</p>
</div>
<div class="paragraph">
<p>要烧录预制的镜像，比如_imagefile.iso_，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -dvd-compat -Z /dev/cd0=imagefile.iso</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>应该检测并根据使用的媒体和驱动器自动设置写入速度。要强制设置写入速度，请使用 `-speed = ` 。有关示例用法，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了支持大于 4.38GB 的工作文件，必须通过在 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> 和所有相关程序（如 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> ）中传递&#34;-udf -iso-level 3&#34;来创建一个 UDF/ISO-9660 混合文件系统。只有在创建 ISO 映像文件或直接将文件写入磁盘时才需要这样做。由于以这种方式创建的磁盘必须以 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_udf&amp;sektion=8&amp;format=html">mount_udf(8)</a> 的 UDF 文件系统方式挂载，因此它只能在支持 UDF 的操作系统上使用。否则，它将看起来像包含损坏文件。</p>
</div>
<div class="paragraph">
<p>要创建这种类型的 ISO 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mkisofs -R -J -udf -iso-level 3 -o imagefile.iso /path/to/data</code></pre>
</div>
</div>
<div class="paragraph">
<p>直接将文件刻录到光盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -dvd-compat -udf -iso-level 3 -Z /dev/cd0 -J -R /path/to/data</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当 ISO 镜像已经包含大文件时， <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 在将该镜像刻录到光盘上时不需要额外的选项。</p>
</div>
<div class="paragraph">
<p>请确保使用最新版本的 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/cdrtools/">sysutils/cdrtools</a> ，其中包含 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> ，因为旧版本可能不支持大文件。如果最新版本无法工作，请安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/cdrtools-devel/">sysutils/cdrtools-devel</a> 并阅读其 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_刻录_dvd_视频">20.6.3. 刻录 DVD 视频<a class="anchor" href="#_刻录_dvd_视频"></a></h4>
<div class="paragraph">
<p>DVD-Video 是基于 ISO 9660 和微型 UDF （ M-UDF ）规范的特定文件布局。由于 DVD-Video 呈现了特定的数据结构层次，因此需要使用特定的程序，如 <a class="package" href="https://cgit.freebsd.org/ports/tree/multimedia/dvdauthor/">multimedia/dvdauthor</a> 来制作 DVD 。</p>
</div>
<div class="paragraph">
<p>如果已经存在 DVD-Video 文件系统的镜像，可以像其他镜像一样进行刻录。如果使用了 <code>dvdauthor</code> 制作了 DVD ，并且结果保存在 <span class="filename">/path/to/video</span> 中，应使用以下命令来刻录 DVD-Video ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -Z /dev/cd0 -dvd-video /path/to/video</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-dvd-video</code> 被传递给 <a href="https://man.freebsd.org/cgi/man.cgi?query=mkisofs&amp;sektion=8&amp;format=html">mkisofs(8)</a> ，用于指示它创建一个 DVD-Video 文件系统布局。此选项隐含了 <code>-dvd-compat</code> <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 选项。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_dvd_rw">20.6.4. 使用 DVD + RW<a class="anchor" href="#_使用_dvd_rw"></a></h4>
<div class="paragraph">
<p>与 CD-RW 不同，未使用过的 DVD + RW 需要在首次使用前进行格式化。强烈建议使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 在适当时自动处理此操作。然而，也可以使用 <code>dvd + rw-format</code> 来格式化 DVD + RW 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dvd+rw-format /dev/cd0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>只需执行此操作一次，并记住只有全新的 DVD + RW 光盘需要进行格式化。一旦格式化完成， DVD + RW 光盘可以像往常一样进行刻录。</p>
</div>
<div class="paragraph">
<p>要烧录一个全新的文件系统，而不仅仅是将一些数据追加到 DVD + RW 上，媒体不需要先进行擦除。相反，可以像这样覆盖之前的记录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -Z /dev/cd0 -J -R /path/to/newdata</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>DVD + RW 格式支持在之前的记录上追加数据。这个操作包括将新的会话合并到现有的会话中，因为它不被视为多会话写入。 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 将会“增长”媒体上存在的 ISO 9660 文件系统。</p>
</div>
<div class="paragraph">
<p>例如，要将数据追加到 DVD + RW 上，请使用以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在进行下一次写入时，应使用与烧录初始会话时相同的 mkisofs[8] 选项。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用 <code>-dvd-compat</code> 选项可以提高与 DVD-ROM 驱动器的媒体兼容性。当使用 DVD + RW 时，此选项不会阻止添加数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要清空媒体，请使用以下方法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -Z /dev/cd0=/dev/zero</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_dvd_rw_2">20.6.5. 使用 DVD-RW<a class="anchor" href="#_使用_dvd_rw_2"></a></h4>
<div class="paragraph">
<p>DVD-RW 支持两种光盘格式：增量顺序和受限覆写。默认情况下， DVD-RW 光盘采用顺序格式。</p>
</div>
<div class="paragraph">
<p>一个全新的 DVD-RW 可以直接写入而无需进行格式化。然而，一个已经使用过的顺序格式的 DVD-RW 在写入新的初始会话之前需要进行擦除。</p>
</div>
<div class="paragraph">
<p>要以顺序模式擦除 DVD-RW ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dvd+rw-format -blank=full /dev/cd0</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>使用 <code>-blank = full</code> 进行完全擦除在 1 倍速的媒体上大约需要一个小时。如果要在 Disk-At-Once （ DAO ）模式下记录 DVD-RW ，则可以使用 <code>-blank</code> 进行快速擦除。要以 DAO 模式刻录 DVD-RW ，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -use-the-force-luke=dao -Z /dev/cd0=imagefile.iso</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 会自动尝试检测快速擦除的介质并启用 DAO 写入，因此不需要使用 <code>-use-the-force-luke = dao</code> 参数。</p>
</div>
<div class="paragraph">
<p>对于任何 DVD-RW ，应该使用受限覆盖模式，而不是默认的增量顺序模式，因为受限覆盖模式更加灵活。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要在顺序 DVD-RW 上写入数据，使用与其他 DVD 格式相同的指令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -Z /dev/cd0 -J -R /path/to/data</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要将一些数据追加到先前的录制中，请使用 <code>-M</code> 参数和 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a></code> 命令。然而，如果在增量顺序模式下在 DVD-RW 上追加数据，将会在光盘上创建一个新的会话，结果将是一个多会话光盘。</p>
</div>
<div class="paragraph">
<p>在受限覆写格式的 DVD-RW 上，不需要在开始新的初始会话之前将其擦除。相反，可以使用 <code>-Z</code> 来覆盖光盘。还可以使用 <code>-M</code> 来扩展已写入光盘上的现有 ISO 9660 文件系统。结果将是一个单会话的 DVD 。</p>
</div>
<div class="paragraph">
<p>要将 DVD-RW 格式化为受限覆写格式，必须使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dvd+rw-format /dev/cd0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要切换回顺序格式，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dvd+rw-format -blank=full /dev/cd0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_多会话">20.6.6. 多会话<a class="anchor" href="#_多会话"></a></h4>
<div class="paragraph">
<p>很少有 DVD-ROM 驱动器支持多会话 DVD ，并且大多数情况下只能读取第一个会话。 DVD + R 、 DVD-R 和 DVD-RW 以顺序格式可以接受多个会话。对于 DVD + RW 和 DVD-RW 受限覆写格式，不存在多个会话的概念。</p>
</div>
<div class="paragraph">
<p>在使用 DVD + R 、 DVD-R 或 DVD-RW 顺序格式的初始非关闭会话后，使用以下命令将在光盘上添加一个新的会话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># growisofs -M /dev/cd0 -J -R /path/to/nextdata</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用此命令时，如果使用 DVD + RW 或 DVD-RW 处于受限覆写模式，将会在将新会话合并到现有会话时追加数据。结果将是一个单会话光盘。使用此方法在这些类型的介质上进行初始写入后添加数据。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于在每个会话之间使用了一些空间来标记会话的结束和开始，因此应该添加大量数据的会话以优化媒体空间。 DVD + R 的会话数量限制为 154 个， DVD-R 约为 2000 个， DVD + R 双层为 127 个。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_更多信息请参考">20.6.7. 更多信息请参考<a class="anchor" href="#_更多信息请参考"></a></h4>
<div class="paragraph">
<p>要获取有关 DVD 的更多信息，请在指定的驱动器中使用 <code>dvd + rw-mediainfo <em>/dev/cd0</em></code> 命令，同时光盘在其中。</p>
</div>
<div class="paragraph">
<p>有关 dvd + rw-tools 的更多信息可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=growisofs&amp;sektion=1&amp;format=html">growisofs(1)</a> 中找到，在 <a href="http://fy.chalmers.se/" class="bare">http://fy.chalmers.se/</a> ~ appro/linux/DVD + RW/[dvd + rw-tools 网站] 上找到，并且在 <a href="http://lists.debian.org/cdwrite/">cdwrite 邮件列表</a> 的存档中也可以找到。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>创建与使用 dvd + rw-tools 相关的问题报告时，始终包括 <code>dvd + rw-mediainfo</code> 的输出。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="creating-dvd-ram">20.6.8. 使用 DVD-RAM<a class="anchor" href="#creating-dvd-ram"></a></h4>
<div class="paragraph">
<p>DVD-RAM 写入器可以使用 SCSI 或 ATAPI 接口。对于 ATAPI 设备，必须通过在 [/boot/loader.conf] 中添加以下行来启用 DMA 访问：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hw.ata.atapi_dma=&#34;1&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>DVD-RAM 可以被视为可移动硬盘。与任何其他硬盘一样， DVD-RAM 在使用之前必须进行格式化。在这个例子中，整个磁盘空间将使用标准的 UFS2 文件系统进行格式化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/zero of=/dev/acd0 bs=2k count=1</span>
<span class="c"># bsdlabel -Bw acd0</span>
<span class="c"># newfs /dev/acd0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>DVD 设备 <span class="filename">acd0</span> 必须根据配置进行更改。</p>
</div>
<div class="paragraph">
<p>一旦 DVD-RAM 被格式化，它可以被挂载为普通硬盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /dev/acd0 /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦挂载， DVD-RAM 将可读可写。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="floppies">20.7. 创建和使用软盘<a class="anchor" href="#floppies"></a></h3>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 中格式化 3.5 英寸软盘。</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>过程：格式化软盘的步骤 *</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在使用软盘之前，需要进行低级格式化。通常由供应商完成，但格式化是检查介质完整性的好方法。在 FreeBSD 上进行软盘的低级格式化，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=fdformat&amp;sektion=1&amp;format=html">fdformat(1)</a> 命令。在使用此实用程序时，请注意任何错误消息，因为它们可以帮助确定软盘是好的还是坏的。</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>要格式化软盘，请将一个新的 3.5 英寸软盘插入第一个软盘驱动器，并输入以下命令：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /usr/sbin/fdformat -f 1440 /dev/fd0</span></code></pre>
</div>
</div>
</li>
<li>
<p>在低级格式化磁盘之后，根据系统需要创建磁盘标签，以确定磁盘的大小和几何结构。支持的几何结构值在 [/etc/disktab] 中列出。</p>
<div class="paragraph">
<p>要编写磁盘标签，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsdlabel&amp;sektion=8&amp;format=html">bsdlabel(8)</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /sbin/bsdlabel -B -w /dev/fd0 fd1440</span></code></pre>
</div>
</div>
</li>
<li>
<p>软盘现在可以进行高级格式化，并选择文件系统。软盘的文件系统可以是 UFS 或 FAT ，其中 FAT 通常是软盘的更好选择。</p>
<div class="paragraph">
<p>要使用 FAT 格式化软盘，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /sbin/newfs_msdos /dev/fd0</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>磁盘现在已经准备好供使用。要使用软盘，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> 命令进行挂载。也可以从 Ports Collection 安装和使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/emulators/mtools/">emulators/mtools</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="using-ntfs">20.8. 使用 NTFS 磁盘<a class="anchor" href="#using-ntfs"></a></h3>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 中挂载 NTFS 磁盘。</p>
</div>
<div class="paragraph">
<p>NTFS （新技术文件系统）是由微软开发的专有日志文件系统。多年来，它一直是微软 Windows 操作系统的默认文件系统。 FreeBSD 可以使用 FUSE 文件系统挂载 NTFS 卷。这些文件系统是作为用户空间程序实现的，它们通过一个明确定义的接口与 <a href="https://man.freebsd.org/cgi/man.cgi?query=fusefs&amp;sektion=5&amp;format=html">fusefs(5)</a> 内核模块进行交互。</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>过程：挂载 NTFS 磁盘的步骤 *</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>在使用 FUSE 文件系统之前，我们需要加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=fusefs&amp;sektion=5&amp;format=html">fusefs(5)</a> 内核模块：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload fusefs</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> 命令在启动时加载模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc kld_list+=fusefs</span></code></pre>
</div>
</div>
</li>
<li>
<p>按照示例中的方式（参见 <a href="./#pkgng-intro">使用 pkg 进行二进制包管理</a> ）或者从 ports （参见 <a href="./#ports-using">使用 Ports Collection</a> ）安装实际的 NTFS 文件系统。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install fusefs-ntfs</span></code></pre>
</div>
</div>
</li>
<li>
<p>最后，我们需要创建一个目录，用于挂载文件系统：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /mnt/usb</span></code></pre>
</div>
</div>
</li>
<li>
<p>假设插入了一个 USB 磁盘。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 命令查看磁盘分区信息。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart show da0</span>
<span class="o">=</span>&gt;	  63  1953525105  da0 MBR   <span class="o">(</span>932G<span class="o">)</span>
	  63  1953525105    1 ntfs  <span class="o">(</span>932G<span class="o">)</span></code></pre>
</div>
</div>
</li>
<li>
<p>我们可以使用以下命令挂载磁盘：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ntfs-3g /dev/da0s1 /mnt/usb/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>磁盘现已准备就绪，可以使用。</p>
</div>
</li>
<li>
<p>此外，还可以将条目添加到 /etc/fstab 文件中：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/da0s1  /mnt/usb	ntfs mountprog=/usr/local/bin/ntfs-3g,noauto,rw  0 0</pre>
</div>
</div>
<div class="paragraph">
<p>现在可以使用以下命令挂载磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /mnt/usb</span></code></pre>
</div>
</div>
</li>
<li>
<p>可以使用以下命令卸载磁盘：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># umount /mnt/usb/</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="backup-basics">20.9. 备份基础知识<a class="anchor" href="#backup-basics"></a></h3>
<div class="paragraph">
<p>实施备份计划是至关重要的，以便能够从磁盘故障、意外文件删除、随机文件损坏或完全机器破坏（包括现场备份的破坏）中恢复。</p>
</div>
<div class="paragraph">
<p>备份类型和计划将根据数据的重要性、文件恢复所需的粒度以及可接受的停机时间而有所不同。一些可能的备份技术包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>整个系统的归档备份存储在永久的、离线的介质上。这种方式可以提供对上述所有问题的保护，但是恢复速度慢且不方便，特别是对于非特权用户来说。</p>
</li>
<li>
<p>文件系统快照，用于恢复已删除的文件或文件的先前版本。</p>
</li>
<li>
<p>使用预定的包： net/rsync[] ，将整个文件系统或磁盘的副本与网络上的另一个系统进行同步。</p>
</li>
<li>
<p>硬件或软件 RAID ，可以在磁盘故障时最小化或避免停机时间。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通常，会使用多种备份技术的组合。例如，可以创建一个定期计划，自动进行每周一次的完整系统备份，并将其存储在离线位置，并通过每小时的 ZFS 快照来补充此备份。此外，在进行文件编辑或删除之前，还可以对单个目录或文件进行手动备份。</p>
</div>
<div class="paragraph">
<p>本节介绍了一些可用于在 FreeBSD 系统上创建和管理备份的实用工具。</p>
</div>
<div class="sect3">
<h4 id="_文件系统备份">20.9.1. 文件系统备份<a class="anchor" href="#_文件系统备份"></a></h4>
<div class="paragraph">
<p>传统的 UNIX® 文件系统备份程序是 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> ，用于创建备份，和 <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> ，用于恢复备份。这些工具在文件系统创建的文件、链接和目录的抽象层之下的磁盘块级别上工作。与其他备份软件不同， <code>dump</code> 备份整个文件系统，无法备份部分文件系统或跨多个文件系统的目录树的一部分。 <code>dump</code> 不是写入文件和目录，而是写入组成文件和目录的原始数据块。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果在根目录上使用 <code>dump</code> 命令，它将不会备份 /home 、 /usr 或许多其他目录，因为这些通常是其他文件系统的挂载点或指向这些文件系统的符号链接。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当用于恢复数据时，默认情况下， <code>restore</code> 将临时文件存储在 <span class="filename">/tmp/</span> 中。如果使用具有较小 <span class="filename">/tmp</span> 的恢复磁盘，请将 <code>TMPDIR</code> 设置为具有更多可用空间的目录，以确保恢复成功。</p>
</div>
<div class="paragraph">
<p>在使用 <code>dump</code> 命令时，请注意一些来自 AT &amp; T UNIX® 6 版本（约 1975 年）早期的怪异行为。默认参数假设备份是备份到 9 轨磁带，而不是备份到其他类型的介质或者今天可用的高密度磁带。这些默认值必须在命令行上进行覆盖。</p>
</div>
<div class="paragraph">
<p>可以通过网络将文件系统备份到另一个系统或连接到另一台计算机的磁带驱动器上。虽然可以使用 rdump[8] 和 rrestore[8] 工具来实现此目的，但它们被认为不安全。</p>
</div>
<div class="paragraph">
<p>相反，可以使用 <code>dump</code> 和 <code>restore</code> 以更安全的方式通过 SSH 连接进行操作。此示例创建了一个对 <code>/usr</code> 目录进行完整压缩备份的文件，并通过 SSH 连接将备份文件发送到指定的主机。</p>
</div>
<div class="exampleblock">
<div class="title">例 26. 通过 ssh 使用 <code>dump</code> 命令</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /sbin/dump -0uan -f - /usr | gzip -2 | ssh -c blowfish \</span>
          targetuser@targetmachine.example.com dd <span class="nv">of</span><span class="o">=</span>/mybigfiles/dump-usr-l0.gz</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>这个示例设置 <code>RSH</code> ，以便通过 SSH 连接将备份写入远程系统上的磁带驱动器：</p>
</div>
<div class="exampleblock">
<div class="title">例 27. 使用 <code>RSH</code> 设置通过 ssh 使用 <code>dump</code> 命令</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># env RSH=/usr/bin/ssh /sbin/dump -0uan -f targetuser@targetmachine.example.com:/dev/sa0 /usr</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_目录备份">20.9.2. 目录备份<a class="anchor" href="#_目录备份"></a></h4>
<div class="paragraph">
<p>可以根据需要使用几个内置实用程序来备份和恢复指定的文件和目录。</p>
</div>
<div class="paragraph">
<p>备份目录中所有文件的一个好选择是 <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> 。这个实用程序可以追溯到 AT &amp; T UNIX® 的第 6 版，并且默认情况下假定对本地磁带设备进行递归备份。可以使用开关来指定备份文件的名称。</p>
</div>
<div class="paragraph">
<p>这个例子创建了一个压缩的备份文件，将当前目录的内容保存到 [/tmp/mybackup.tgz] 文件中。在创建备份文件时，请确保备份文件不要保存在被备份的目录中。</p>
</div>
<div class="exampleblock">
<div class="title">例 28. 使用 <code>tar</code> 备份当前目录</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tar czvf /tmp/mybackup.tgz .</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>要恢复整个备份，请进入要恢复的目录并指定备份的名称。请注意，这将覆盖恢复目录中的任何更新版本的文件。如果不确定，请恢复到一个临时目录或指定要恢复的备份中的文件名称。</p>
</div>
<div class="exampleblock">
<div class="title">例 29. 使用 <code>tar</code> 命令恢复当前目录</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tar xzvf /tmp/mybackup.tgz</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>有数十个可用的开关，这些开关在 <a href="https://man.freebsd.org/cgi/man.cgi?query=tar&amp;sektion=1&amp;format=html">tar(1)</a> 中有描述。该实用程序还支持使用排除模式来指定在备份指定目录或从备份中恢复文件时不应包括哪些文件。</p>
</div>
<div class="paragraph">
<p>要使用指定的文件和目录列表创建备份， <a href="https://man.freebsd.org/cgi/man.cgi?query=cpio&amp;sektion=1&amp;format=html">cpio(1)</a> 是一个不错的选择。与 <code>tar</code> 不同， <code>cpio</code> 不知道如何遍历目录树，必须提供备份文件的列表。</p>
</div>
<div class="paragraph">
<p>例如，可以使用 <code>ls</code> 或 <code>find</code> 创建文件列表。此示例创建了当前目录的递归列表，然后将其通过管道传输给 <code>cpio</code> ，以创建一个名为 <code>/tmp/mybackup.cpio</code> 的输出备份文件。</p>
</div>
<div class="exampleblock">
<div class="title">例 30. 使用 <code>ls</code> 和 <code>cpio</code> 来对当前目录进行递归备份</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls -R | cpio -ovF /tmp/mybackup.cpio</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>一种备份工具，试图结合 <code>tar</code> 和 <code>cpio</code> 提供的功能是 <code>pax</code> 。多年来，各个版本的 <code>tar</code> 和 <code>cpio</code> 变得稍微不兼容。 POSIX® 创建了 <code>pax</code> ，它尝试读取和写入许多不同的 <code>cpio</code> 和 <code>tar</code> 格式，以及自己的新格式。</p>
</div>
<div class="paragraph">
<p>前面示例的 <code>pax</code> 等效方式如下：</p>
</div>
<div class="exampleblock">
<div class="title">例 31. 使用 <code>pax</code> 备份当前目录</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pax -wf /tmp/mybackup.pax .</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="backups-tapebackups">20.9.3. 使用数据磁带进行备份<a class="anchor" href="#backups-tapebackups"></a></h4>
<div class="paragraph">
<p>尽管磁带技术不断发展，但现代备份系统往往将离线备份与本地可移动介质相结合。 FreeBSD 支持使用 SCSI 的任何磁带驱动器，如 LTO 或 DAT 。对于 SATA 和 USB 磁带驱动器的支持有限。</p>
</div>
<div class="paragraph">
<p>对于 SCSI 磁带设备， FreeBSD 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sa&amp;sektion=4&amp;format=html">sa(4)</a> 驱动程序和 .dev/sa0 、 .dev/nsa0 和 .dev/esa0 设备。物理设备名称是 .dev/sa0 。当使用 .dev/nsa0 时，备份应用程序在写入文件后不会倒回磁带，这允许将多个文件写入磁带。使用 .dev/esa0 在设备关闭后弹出磁带。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中， <code>mt</code> 用于控制磁带驱动器的操作，例如在磁带上寻找文件或向磁带写入磁带控制标记。例如，在写入新文件之前，可以通过跳过前三个文件来保留磁带上的文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mt -f /dev/nsa0 fsf 3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该实用程序支持许多操作。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mt&amp;sektion=1&amp;format=html">mt(1)</a> 。</p>
</div>
<div class="paragraph">
<p>使用 <code>tar</code> 将单个文件写入磁带，需要指定磁带设备的名称和要备份的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tar cvf /dev/sa0 file</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将文件从磁带上的 <code>tar</code> 归档恢复到当前目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tar xvf /dev/sa0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要备份 UFS 文件系统，请使用 <code>dump</code> 命令。以下示例备份了 <code>/usr</code> 目录，备份完成后不会倒回磁带：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dump -0aL -b64 -f /dev/nsa0 /usr</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要从磁带上的 <code>dump</code> 文件交互式地恢复文件到当前目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># restore -i -f /dev/nsa0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="backups-programs-amanda">20.9.4. 第三方备份工具<a class="anchor" href="#backups-programs-amanda"></a></h4>
<div class="paragraph">
<p>FreeBSD Ports Collection 提供了许多第三方工具，可以用于安排备份的创建、简化磁带备份，并使备份更加方便。其中许多应用程序是基于客户端 / 服务器的，可以用于自动化单个系统或网络中所有计算机的备份。</p>
</div>
<div class="paragraph">
<p>常用的工具包括 Amanda 、 Bacula 、 rsync 和 duplicity 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_紧急恢复">20.9.5. 紧急恢复<a class="anchor" href="#_紧急恢复"></a></h4>
<div class="paragraph">
<p>除了定期备份外，建议在紧急应急计划中执行以下步骤。</p>
</div>
<div class="paragraph">
<p>创建以下命令的输出的打印副本：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>gpart show</code> 命令用于显示磁盘分区表的信息。</p>
</li>
<li>
<p><code>more /etc/fstab</code> 命令用于在终端中显示 <code>/etc/fstab</code> 文件的内容。</p>
</li>
<li>
<p><code>dmesg</code> 是一个 Linux 命令，用于显示内核环缓冲区的内容。它可以显示系统启动时的内核消息，包括硬件检测、设备驱动程序加载和其他内核相关的信息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>将这份打印件和安装介质的副本存放在安全的地方。如果需要进行紧急恢复操作，启动安装介质并选择“ Live CD ”以访问救援 Shell 。这个救援模式可以用来查看系统的当前状态，如果需要的话，还可以重新格式化磁盘并从备份中恢复数据。</p>
</div>
<div class="paragraph">
<p>接下来，测试救援 shell 和备份。记录下操作步骤，并将这些记录与介质、打印件和备份一起存储。这些记录可以防止在紧急恢复过程中因压力而意外破坏备份。</p>
</div>
<div class="paragraph">
<p>为了增加安全性，将最新的备份存储在与计算机和磁盘驱动器相隔一定距离的远程位置。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="disks-virtual">20.10. 内存磁盘<a class="anchor" href="#disks-virtual"></a></h3>
<div class="paragraph">
<p>除了物理磁盘外， FreeBSD 还支持创建和使用内存磁盘。内存磁盘的一个可能用途是在不先将其刻录到 CD 或 DVD 上，然后挂载 CD/DVD 媒体的情况下访问 ISO 文件系统的内容。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中， <a href="https://man.freebsd.org/cgi/man.cgi?query=md&amp;sektion=4&amp;format=html">md(4)</a> 驱动程序用于提供对内存磁盘的支持。 <span class="filename">GENERIC</span> 内核包含了这个驱动程序。当使用自定义内核配置文件时，请确保包含以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device md</pre>
</div>
</div>
<div class="sect3">
<h4 id="disks-mdconfig">20.10.1. 附加和分离现有图片<a class="anchor" href="#disks-mdconfig"></a></h4>
<div class="paragraph">
<p>要挂载现有的文件系统镜像，使用 <code>mdconfig</code> 命令指定 ISO 文件的名称和一个空闲的单元号。然后，使用该单元号将其挂载到现有的挂载点上。一旦挂载成功， ISO 中的文件将会出现在挂载点上。以下示例将_diskimage.iso_附加到内存设备 <span class="filename">/dev/md0</span> ，然后将该内存设备挂载到 <span class="filename">/mnt</span> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mdconfig -f diskimage.iso -u 0</span>
<span class="c"># mount -t cd9660 /dev/md0 /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，使用 <code>-t cd9660</code> 来挂载 ISO 格式的文件。如果没有使用 <code>-u</code> 指定单元号， <code>mdconfig</code> 将自动分配一个未使用的内存设备，并输出分配的单元号的名称，例如 <span class="filename">md4</span> 。有关此命令及其选项的更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mdconfig&amp;sektion=8&amp;format=html">mdconfig(8)</a> 。</p>
</div>
<div class="paragraph">
<p>当内存磁盘不再使用时，应该将其资源释放回系统。首先，卸载文件系统，然后使用 <code>mdconfig</code> 将磁盘从系统中分离并释放其资源。继续本示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># umount /mnt</span>
<span class="c"># mdconfig -d -u 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要确定系统是否仍连接有任何内存磁盘，请输入 <code>mdconfig -l</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="disks-md-freebsd5">20.10.2. 创建一个基于文件或内存的内存磁盘<a class="anchor" href="#disks-md-freebsd5"></a></h4>
<div class="paragraph">
<p>FreeBSD 还支持内存磁盘，其中存储空间可以从硬盘或内存区域分配。第一种方法通常称为基于文件的文件系统，第二种方法称为基于内存的文件系统。可以使用 <code>mdconfig</code> 创建这两种类型的磁盘。</p>
</div>
<div class="paragraph">
<p>要创建一个新的基于内存的文件系统，需要指定 <code>swap</code> 类型和要创建的内存磁盘的大小。然后，像通常一样，对内存磁盘进行文件系统格式化和挂载。以下示例在单位 <code>1</code> 上创建了一个大小为 5M 的内存磁盘。然后，在挂载之前，该内存磁盘将被格式化为 UFS 文件系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mdconfig -a -t swap -s 5m -u 1</span>
<span class="c"># newfs -U md1</span>
/dev/md1: 5.0MB <span class="o">(</span>10240 sectors<span class="o">)</span> block size 16384, fragment size 2048
        using 4 cylinder groups of 1.27MB, 81 blks, 192 inodes.
        with soft updates
super-block backups <span class="o">(</span><span class="k">for </span>fsck -b <span class="c">#) at:</span>
 160, 2752, 5344, 7936
<span class="c"># mount /dev/md1 /mnt</span>
<span class="c"># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md1        4718    4  4338     0%    /mnt</code></pre>
</div>
</div>
<div class="paragraph">
<p>要创建一个新的基于文件的内存磁盘，首先需要分配一个磁盘区域来使用。以下示例创建一个名为 [newimage] 的空白 5MB 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/zero of=newimage bs=1k count=5k</span>
5120+0 records <span class="k">in
</span>5120+0 records out</code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，将该文件附加到一个内存磁盘上，为内存磁盘标记名称并使用 UFS 文件系统进行格式化，挂载内存磁盘，并验证文件支持的磁盘的大小。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mdconfig -f newimage -u 0</span>
<span class="c"># bsdlabel -w md0 auto</span>
<span class="c"># newfs -U md0a</span>
/dev/md0a: 5.0MB <span class="o">(</span>10224 sectors<span class="o">)</span> block size 16384, fragment size 2048
        using 4 cylinder groups of 1.25MB, 80 blks, 192 inodes.
super-block backups <span class="o">(</span><span class="k">for </span>fsck -b <span class="c">#) at:</span>
 160, 2720, 5280, 7840
<span class="c"># mount /dev/md0a /mnt</span>
<span class="c"># df /mnt</span>
Filesystem 1K-blocks Used Avail Capacity  Mounted on
/dev/md0a       4710    4  4330     0%    /mnt</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>mdconfig</code> 命令创建一个基于文件或内存的文件系统需要多个命令。 FreeBSD 还提供了 <code>mdmfs</code> 命令，它可以自动配置一个内存磁盘，使用 UFS 文件系统进行格式化，并挂载它。例如，在使用 <code>dd</code> 命令创建了名为_newimage_的文件后，下面这个命令相当于运行上面显示的 <code>bsdlabel</code> 、 <code>newfs</code> 和 <code>mount</code> 命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mdmfs -F newimage -s 5m md0 /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用 <code>mdmfs</code> 创建一个新的基于内存的内存磁盘，只需使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mdmfs -s 5m md1 /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果未指定单元号， <code>mdmfs</code> 将自动选择一个未使用的内存设备。有关 <code>mdmfs</code> 的更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mdmfs&amp;sektion=8&amp;format=html">mdmfs(8)</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="snapshots">20.11. 文件系统快照<a class="anchor" href="#snapshots"></a></h3>
<div class="paragraph">
<p>FreeBSD 提供了一个与 <a href="./#soft-updates">Soft Updates</a> 配合使用的功能：文件系统快照。</p>
</div>
<div class="paragraph">
<p>UFS 快照允许用户创建指定文件系统的镜像，并将其视为文件。 快照文件必须在执行操作的文件系统中创建，并且用户每个文件系统最多可以创建 20 个快照。 活动快照在超级块中记录，因此它们在卸载和重新挂载操作以及系统重新启动时是持久的。 当不再需要快照时，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rm&amp;sektion=1&amp;format=html">rm(1)</a> 命令将其删除。 尽管可以以任何顺序删除快照，但可能无法获取所有已释放块的使用空间，因为另一个快照可能会占用一些已释放的块。</p>
</div>
<div class="paragraph">
<p>在创建快照文件后， <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> 会设置不可更改的 <code>snapshot</code> 文件标志。 <a href="https://man.freebsd.org/cgi/man.cgi?query=unlink&amp;sektion=1&amp;format=html">unlink(1)</a> 对于快照文件有一个例外，因为它允许将其删除。</p>
</div>
<div class="paragraph">
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> 创建快照。要将 /var 的快照放置在文件 /var/snapshot/snap 中，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount -u -o snapshot /var/snapshot/snap /var</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mksnap_ffs&amp;sektion=8&amp;format=html">mksnap_ffs(8)</a> 命令来创建快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mksnap_ffs /var /var/snapshot/snap</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=find&amp;sektion=1&amp;format=html">find(1)</a> 命令在文件系统上找到快照文件，例如 <span class="filename">/var</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># find /var -flags snapshot</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦创建了快照，它可以有多种用途：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一些管理员会使用快照文件进行备份，因为快照可以传输到光盘或磁带上。</p>
</li>
<li>
<p>文件系统完整性检查器 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 可以在快照上运行。假设文件系统在挂载时是干净的，这应该始终提供一个干净且不变的结果。</p>
</li>
<li>
<p>在快照上运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 将生成一个与文件系统和快照的时间戳一致的转储文件。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 还可以使用 <code>-L</code> 选项一次性拍摄快照、创建转储镜像并删除快照。</p>
</li>
<li>
<p>快照可以作为文件系统的冻结镜像进行挂载。要挂载快照，请运行： <a href="https://man.freebsd.org/cgi/man.cgi?query=mount&amp;sektion=8&amp;format=html">mount(8)</a> <span class="filename">/var/snapshot/snap</span> 。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mdconfig -a -t vnode -o readonly -f /var/snapshot/snap -u 4</span>
<span class="c"># mount -r /dev/md4 /mnt</span></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>冻结的文件 <code>/var</code> 现在可以通过 <code>/mnt</code> 访问。一开始，所有内容都将保持与创建快照时相同的状态。唯一的例外是，任何早期的快照将显示为长度为零的文件。要卸载快照，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># umount /mnt</span>
<span class="c"># mdconfig -d -u 4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关 <code>softupdates</code> 和文件系统快照的更多信息，包括技术论文，请访问马歇尔·柯克·麦库西克的网站： <a href="http://www.mckusick.com/" class="bare">http://www.mckusick.com/</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="quotas">20.12. 磁盘配额<a class="anchor" href="#quotas"></a></h3>
<div class="paragraph">
<p>磁盘配额可以用于限制用户或用户组在每个文件系统上分配的磁盘空间或文件数量。这可以防止某个用户或用户组占用所有可用的磁盘空间。</p>
</div>
<div class="paragraph">
<p>本节介绍了如何配置 UFS 文件系统的磁盘配额。要在 ZFS 文件系统上配置配额，请参考 <a href="./#zfs-zfs-quota">数据集、用户和组配额</a> 。</p>
</div>
<div class="sect3">
<h4 id="_启用磁盘配额">20.12.1. 启用磁盘配额<a class="anchor" href="#_启用磁盘配额"></a></h4>
<div class="paragraph">
<p>要确定 FreeBSD 内核是否支持磁盘配额，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sysctl kern.features.ufs_quota
kern.features.ufs_quota: 1</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中， <code>1</code> 表示支持配额。如果值是 <code>0</code> ，请将以下行添加到自定义内核配置文件中，并按照 <a href="./#kernelconfig">配置 FreeBSD 内核</a> 中的说明重新构建内核。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options QUOTA</pre>
</div>
</div>
<div class="paragraph">
<p>接下来，在 [/etc/rc.conf](/etc/rc.conf) 中启用磁盘配额：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>quota_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>通常在启动时，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> 检查每个文件系统的配额完整性。该程序确保配额数据库中的数据正确反映文件系统上的数据。这是一个耗时的过程，会显著影响系统启动所需的时间。要跳过此步骤，请将此变量添加到 <span class="filename">/etc/rc.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>check_quotas=&#34;NO&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>最后，编辑 [/etc/fstab] 文件以按文件系统启用磁盘配额。要在文件系统上启用每个用户的配额，请在 [/etc/fstab] 文件中的文件系统条目的选项字段中添加&#34;userquota&#34;。例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/da1s2g   /home    ufs rw,userquota 1 2</pre>
</div>
</div>
<div class="paragraph">
<p>要启用组配额，请使用 <code>groupquota</code> 。要同时启用用户和组配额，请使用逗号分隔选项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/da1s2g    /home    ufs rw,userquota,groupquota 1 2</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下，配额文件存储在文件系统的根目录中，文件名为 quota.user 和 quota.group 。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> 。不建议指定配额文件的替代位置。</p>
</div>
<div class="paragraph">
<p>配置完成后，重新启动系统， [/etc/rc] 将自动运行适当的命令，为 [/etc/fstab] 中启用的所有配额创建初始配额文件。</p>
</div>
<div class="paragraph">
<p>在正常的操作过程中，通常不需要手动运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotacheck&amp;sektion=8&amp;format=html">quotacheck(8)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaon&amp;sektion=8&amp;format=html">quotaon(8)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=quotaoff&amp;sektion=8&amp;format=html">quotaoff(8)</a> 。然而，应该阅读这些手册页以熟悉它们的操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="_设置配额限制">20.12.2. 设置配额限制<a class="anchor" href="#_设置配额限制"></a></h4>
<div class="paragraph">
<p>要验证配额是否已启用，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># quota -v</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于每个启用了配额的文件系统，应该有一个关于磁盘使用情况和当前配额限制的一行摘要。</p>
</div>
<div class="paragraph">
<p>系统现在可以使用 <code>edquota</code> 来分配配额限制。</p>
</div>
<div class="paragraph">
<p>有几种选项可用于限制用户或组分配的磁盘空间量以及他们可以创建的文件数量。分配可以基于磁盘空间（块配额）、文件数量（ inode 配额）或两者的组合进行限制。每个限制进一步分为两个类别：硬限制和软限制。</p>
</div>
<div class="paragraph">
<p>硬限制不能超过。一旦用户达到硬限制，该用户在该文件系统上将无法再进行进一步的分配。例如，如果用户在文件系统上的硬限制是 500 kbytes ，并且当前正在使用 490 kbytes ，那么用户只能再分配额外的 10 kbytes 。尝试分配额外的 11 kbytes 将失败。</p>
</div>
<div class="paragraph">
<p>软限制可以在有限的时间内超过，这被称为宽限期，默认为一周。如果用户超过限制的时间超过宽限期，软限制将变为硬限制，不再允许进一步的分配。当用户再次低于软限制时，宽限期将被重置。</p>
</div>
<div class="paragraph">
<p>在下面的示例中，正在编辑 <code>test</code> 账户的配额。当调用 <code>edquota</code> 时，会打开由 <code>EDITOR</code> 指定的编辑器，以便编辑配额限制。默认编辑器设置为 vi 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># edquota -u test</span>
Quotas <span class="k">for </span>user <span class="nb">test</span>:
/usr: kbytes <span class="k">in </span>use: 65, limits <span class="o">(</span>soft <span class="o">=</span> 50, hard <span class="o">=</span> 75<span class="o">)</span>
        inodes <span class="k">in </span>use: 7, limits <span class="o">(</span>soft <span class="o">=</span> 50, hard <span class="o">=</span> 60<span class="o">)</span>
/usr/var: kbytes <span class="k">in </span>use: 0, limits <span class="o">(</span>soft <span class="o">=</span> 50, hard <span class="o">=</span> 75<span class="o">)</span>
        inodes <span class="k">in </span>use: 0, limits <span class="o">(</span>soft <span class="o">=</span> 50, hard <span class="o">=</span> 60<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通常，每个启用了配额的文件系统通常有两行。一行表示块限制，另一行表示 inode 限制。更改值以修改配额限制。例如，要将 <span class="filename">/usr</span> 的块限制提高到软限制 <code>500</code> 和硬限制 <code>600</code> ，请按照以下方式更改该行中的值：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/usr: kbytes in use: 65, limits (soft = 500, hard = 600)</pre>
</div>
</div>
<div class="paragraph">
<p>新的配额限制在退出编辑器后生效。</p>
</div>
<div class="paragraph">
<p>有时候，对一系列用户设置配额限制是可取的。首先，将所需的配额限制分配给一个用户。然后，使用 <code>-p</code> 选项将该配额复制到指定范围的用户 ID （ UID ）。以下命令将复制 UID 为 <code>10 , 000</code> 到 <code>19 , 999</code> 的用户的配额限制：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># edquota -p test 10000-19999</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有关更多信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=edquota&amp;sektion=8&amp;format=html">edquota(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_检查配额限制和磁盘使用情况">20.12.3. 检查配额限制和磁盘使用情况<a class="anchor" href="#_检查配额限制和磁盘使用情况"></a></h4>
<div class="paragraph">
<p>要检查单个用户或组的配额和磁盘使用情况，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=quota&amp;sektion=1&amp;format=html">quota(1)</a> 。用户只能查看自己的配额和所属组的配额。只有超级用户才能查看所有用户和组的配额。要获取启用了配额的文件系统的所有配额和磁盘使用情况的摘要，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=repquota&amp;sektion=8&amp;format=html">repquota(8)</a> 。</p>
</div>
<div class="paragraph">
<p>通常情况下，用户没有使用任何磁盘空间的文件系统在 <code>quota</code> 命令的输出中不会显示，即使用户对该文件系统有配额限制。使用 <code>-v</code> 选项可以显示这些文件系统。以下是一个用户在两个文件系统上设置了配额限制时，使用 <code>quota -v</code> 命令的示例输出。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Disk quotas for user test (uid 1002):
     Filesystem  usage    quota   limit   grace   files   quota   limit   grace
           /usr      65*     50      75   5days       7      50      60
       /usr/var       0      50      75               0      50      60</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，用户当前超过了在 <code>/usr</code> 目录下的 50 kbytes 的软限制，超出了 15 kbytes ，并且还剩下 5 天的宽限期。星号 <code>*</code> 表示用户当前超过了配额限制。</p>
</div>
</div>
<div class="sect3">
<h4 id="_nfs_上的配额限制">20.12.4. NFS 上的配额限制<a class="anchor" href="#_nfs_上的配额限制"></a></h4>
<div class="paragraph">
<p>配额由 NFS 服务器上的配额子系统强制执行。 <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.rquotad&amp;sektion=8&amp;format=html">rpc.rquotad(8)</a> 守护进程将配额信息提供给 NFS 客户端上的 <code>quota</code> 命令，使得这些机器上的用户可以查看他们的配额统计信息。</p>
</div>
<div class="paragraph">
<p>在 NFS 服务器上，通过从 <strong class="filename">/etc/inetd.conf</strong> 文件中的这一行中删除 <code>#</code> 来启用 <code>rpc.rquotad</code> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rquotad/1      dgram rpc/udp wait root /usr/libexec/rpc.rquotad rpc.rquotad</pre>
</div>
</div>
<div class="paragraph">
<p>然后，重新启动 <code>inetd</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service inetd restart</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="disks-encrypting">20.13. 加密磁盘分区<a class="anchor" href="#disks-encrypting"></a></h3>
<div class="paragraph">
<p>FreeBSD 提供了出色的在线保护措施，防止未经授权的数据访问。文件权限和强制访问控制（ MAC ）可以在操作系统处于活动状态且计算机已经启动时，防止未经授权的用户访问数据。然而，如果攻击者可以物理访问计算机并将计算机的硬盘移动到另一个系统以复制和分析数据，操作系统强制执行的权限就变得无关紧要了。</p>
</div>
<div class="paragraph">
<p>无论攻击者如何获得硬盘或关闭电脑， FreeBSD 中内置的基于 GEOM 的加密子系统能够保护计算机文件系统上的数据，即使是对于拥有大量资源和高度动机的攻击者也是如此。与加密单个文件的加密方法不同，内置的 <code>gbde</code> 和 <code>geli</code> 实用程序可以用于透明地加密整个文件系统。明文永远不会接触到硬盘的盘片。</p>
</div>
<div class="paragraph">
<p>本章介绍了如何在 FreeBSD 上创建加密文件系统。首先使用 <code>gbde</code> 演示了该过程，然后使用 <code>geli</code> 演示了相同的示例。</p>
</div>
<div class="sect3">
<h4 id="_使用_gbde_进行磁盘加密">20.13.1. 使用 gbde 进行磁盘加密<a class="anchor" href="#_使用_gbde_进行磁盘加密"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> 设施的目标是为攻击者提供一个巨大的挑战，以防止其获取冷存储设备的内容。然而，如果计算机在运行时被入侵并且存储设备被主动连接，或者攻击者拥有有效的密码短语，那么它对存储设备的内容提供不了任何保护。因此，在系统运行时提供物理安全性并保护加密机制使用的密码短语非常重要。</p>
</div>
<div class="paragraph">
<p>该设施提供了几个屏障来保护存储在每个磁盘扇区中的数据。它使用 128 位 AES 在 CBC 模式下对磁盘扇区的内容进行加密。磁盘上的每个扇区都使用不同的 AES 密钥进行加密。有关加密设计的更多信息，包括如何从用户提供的密码短语派生扇区密钥，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=4&amp;format=html">gbde(4)</a> 。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供了一个用于 gbde 的内核模块，可以使用以下命令加载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload geom_bde</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用自定义内核配置文件，请确保其中包含以下行：</p>
</div>
<div class="paragraph">
<p><code>options GEOM_BDE</code> 可选项</p>
</div>
<div class="paragraph">
<p>下面的示例演示了向系统添加新的硬盘，该硬盘将容纳一个加密分区，并将其挂载为 <span class="filename">/private</span> 。</p>
</div>
<div class="olist arabic procedure">
<div class="title">过程：使用 gbde 加密分区</div>
<ol class="arabic">
<li>
<p>在计算机上安装并配置 gbde 软件。</p>
</li>
<li>
<p>打开终端或命令提示符，并使用管理员权限登录。</p>
</li>
<li>
<p>使用以下命令创建一个新的 gbde 加密容器：
<code>`
gbde init /dev/daX
</code>`
其中， /dev/daX 是要加密的分区设备名称。</p>
</li>
<li>
<p>输入一个密码来保护加密容器，并确保密码足够强大和安全。</p>
</li>
<li>
<p>使用以下命令打开加密容器：
<code>`
gbde attach /dev/daX
</code>`</p>
</li>
<li>
<p>输入之前设置的密码来解锁加密容器。</p>
</li>
<li>
<p>现在，您可以像使用普通分区一样使用加密分区了。</p>
</li>
<li>
<p>当您不再需要使用加密分区时，使用以下命令关闭加密容器：
<code>`
gbde detach /dev/daX
</code>`
这将锁定加密容器并保护您的数据。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请注意，使用 gbde 加密分区时，请确保备份重要数据，并妥善保管加密容器的密码。
. 添加新的硬盘</p>
</div>
<div class="paragraph">
<p>+
按照 <a href="#disks-adding">添加磁盘</a> 中所述的方法将新驱动器安装到系统中。对于本示例，已添加了一个新的硬盘分区，表示为 <span class="filename">/dev/ad4s1c</span> ，而 <span class="filename">/dev/ad0s1*</span> 表示现有的标准 FreeBSD 分区。</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>创建一个目录来存放 <code>gbde</code> 锁文件。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /etc/gbde</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>gbde 锁定文件包含了 gbde 访问加密分区所需的信息。如果没有访问锁定文件的权限， gbde 将无法解密加密分区中的数据，除非进行大量的手动干预，而该软件不支持此操作。每个加密分区都使用一个单独的锁定文件。</p>
</div>
</li>
<li>
<p>初始化 <code>gbde</code> 分区</p>
<div class="paragraph">
<p>在使用之前，必须初始化 gbde 分区。这个初始化只需要执行一次。该命令将打开默认编辑器，以便在模板中设置各种配置选项。对于与 UFS 文件系统一起使用，请将 sector_size 设置为 2048 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gbde init /dev/ad4s1c -i -L /etc/gbde/ad4s1c.lock</span>
<span class="c"># $FreeBSD: src/sbin/gbde/template.txt,v 1.1.36.1 2009/08/03 08:13:06 kensmith Exp $</span>
<span class="c">#</span>
<span class="c"># Sector size is the smallest unit of data which can be read or written.</span>
<span class="c"># Making it too small decreases performance and decreases available space.</span>
<span class="c"># Making it too large may prevent filesystems from working.  512 is the</span>
<span class="c"># minimum and always safe.  For UFS, use the fragment size</span>
<span class="c">#</span>
sector_size	<span class="o">=</span>	2048
<span class="o">[</span>...]</code></pre>
</div>
</div>
<div class="paragraph">
<p>编辑保存后，用户将被要求两次输入用于保护数据的密码短语。两次输入的密码短语必须相同。 Gbde 保护数据的能力完全取决于密码短语的质量。有关如何选择既安全又容易记住的密码短语的提示，请参阅 <a href="http://world.std.com/" class="bare">http://world.std.com/</a> \~ reinhold/diceware.html[<a href="http://world.std.com/" class="bare">http://world.std.com/</a> ~ reinhold/diceware.htm] 。</p>
</div>
<div class="paragraph">
<p>这个初始化操作创建了一个用于 gbde 分区的锁文件。在这个例子中，它被存储为 <span class="filename">/etc/gbde/ad4s1c.lock</span> 。锁文件必须以 &#34;.lock&#34; 结尾，以便被 <span class="filename">/etc/rc.d/gbde</span> 启动脚本正确地检测到。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>必须将锁定文件与任何加密分区的内容一起备份。如果没有锁定文件，合法的所有者将无法访问加密分区上的数据。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>将加密分区附加到内核上</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gbde attach /dev/ad4s1c -l /etc/gbde/ad4s1c.lock</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个命令会提示输入在加密分区初始化过程中选择的密码。新的加密设备将出现在 <span class="filename">/dev</span> 中，命名为 <span class="filename">/dev/device_name.bde</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls /dev/ad*</span>
/dev/ad0        /dev/ad0s1b     /dev/ad0s1e     /dev/ad4s1
/dev/ad0s1      /dev/ad0s1c     /dev/ad0s1f     /dev/ad4s1c
/dev/ad0s1a     /dev/ad0s1d     /dev/ad4        /dev/ad4s1c.bde</code></pre>
</div>
</div>
</li>
<li>
<p>在加密设备上创建文件系统</p>
<div class="paragraph">
<p>一旦加密设备已经连接到内核，就可以在设备上创建文件系统。这个示例创建了一个启用了软更新的 UFS 文件系统。请确保指定具有 <span class="filename">*.bde</span> 扩展名的分区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># newfs -U /dev/ad4s1c.bde</span></code></pre>
</div>
</div>
</li>
<li>
<p>挂载加密分区</p>
<div class="paragraph">
<p>创建一个挂载点并挂载加密文件系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /private</span>
<span class="c"># mount /dev/ad4s1c.bde /private</span></code></pre>
</div>
</div>
</li>
<li>
<p>验证加密文件系统是否可用</p>
<div class="paragraph">
<p>加密文件系统现在应该可见并可供使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>df -H
Filesystem        Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a      1037M    72M   883M     8%    /
/devfs            1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f       8.1G    55K   7.5G     0%    /home
/dev/ad0s1e      1037M   1.1M   953M     0%    /tmp
/dev/ad0s1d       6.1G   1.9G   3.7G    35%    /usr
/dev/ad4s1c.bde   150G   4.1K   138G     0%    /private</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>每次启动后，必须手动重新连接加密文件系统到内核，检查错误并挂载，然后才能使用这些文件系统。要配置这些步骤，请将以下行添加到 <code>/etc/rc.conf</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gbde_autoattach_all=&#34;YES&#34;
gbde_devices=&#34;ad4s1c&#34;
gbde_lockdir=&#34;/etc/gbde&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>这要求在启动时在控制台输入密码短语。输入正确的密码短语后，加密分区将自动挂载。还有其他可用的 gbde 启动选项，可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 中找到并列出。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>sysinstall 与 gbde 加密设备不兼容。在启动 sysinstall 之前，必须将所有的 .bde 设备从内核中分离，否则在设备的初始探测过程中， sysinstall 会崩溃。要分离示例中使用的加密设备，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gbde detach /dev/ad4s1c</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="disks-encrypting-geli">20.13.2. 使用 <code>geli</code> 进行磁盘加密<a class="anchor" href="#disks-encrypting-geli"></a></h4>
<div class="paragraph">
<p>可以使用 <code>geli</code> 来使用另一种加密 GEOM 类。这个控制工具添加了一些功能，并使用了不同的加密方案来进行加密工作。它提供以下功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>当可用时，利用 <a href="https://man.freebsd.org/cgi/man.cgi?query=crypto&amp;sektion=9&amp;format=html">crypto(9)</a> 框架并自动使用加密硬件。</p>
</li>
<li>
<p>支持多种加密算法，如 AES 、 Blowfish 和 3DES 。</p>
</li>
<li>
<p>允许对根分区进行加密。在系统启动期间，将要求输入用于访问加密根分区的密码短语。</p>
</li>
<li>
<p>允许使用两个独立的键。</p>
</li>
<li>
<p>它之所以快速，是因为它执行简单的扇区级加密。</p>
</li>
<li>
<p>允许备份和恢复主密钥。如果用户销毁了他们的密钥，仍然可以通过从备份中恢复密钥来访问数据。</p>
</li>
<li>
<p>允许磁盘使用随机的一次性密钥进行连接，这对于交换分区和临时文件系统非常有用。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>更多功能和使用示例可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> 中找到。</p>
</div>
<div class="paragraph">
<p>下面的示例描述了如何生成一个密钥文件，该文件将作为加密提供者在 <code>/private</code> 下挂载的主密钥的一部分。密钥文件将提供一些用于加密主密钥的随机数据。主密钥还将受到密码短语的保护。提供者的扇区大小将为 4kB 。该示例描述了如何连接到 <code>geli</code> 提供者，创建一个文件系统，挂载它，使用它，并最终如何卸载它。</p>
</div>
<div class="olist arabic procedure">
<div class="title">过程：使用 <code>geli</code> 加密分区</div>
<ol class="arabic">
<li>
<p>在计算机上安装并配置 <code>geli</code> 工具。</p>
</li>
<li>
<p>确保要加密的分区没有被挂载。</p>
</li>
<li>
<p>使用以下命令创建一个新的加密设备：
<code>`
# geli init -s 4096 /dev/adaXsY
</code>`
其中 <code>/dev/adaXsY</code> 是要加密的分区的路径。</p>
</li>
<li>
<p>设置加密设备的密码：
<code>`
# geli configure -b -k /boot/encryption.key /dev/adaXsY
</code>`
这将在 <code>/boot/encryption.key</code> 文件中存储加密设备的密钥。</p>
</li>
<li>
<p>使用以下命令将加密设备解锁并挂载到指定的挂载点：
<code>`
# geli attach -k /boot/encryption.key /dev/adaXsY
</code>`
这将要求您输入之前设置的密码。</p>
</li>
<li>
<p>现在，您可以将加密设备作为普通分区来使用，例如格式化它并将文件系统挂载到指定的挂载点。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请注意，加密分区的解锁只在当前会话中有效。在重新启动计算机之前，您需要重新执行步骤 5 以重新解锁和挂载加密设备。
. 加载 <code>geli</code> 支持</p>
</div>
<div class="paragraph">
<p>+
支持 <code>geli</code> 的功能作为可加载的内核模块提供。要配置系统在启动时自动加载该模块，请将以下行添加到 <span class="filename">/boot/loader.conf</span> 文件中：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>geom_eli_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>+
现在加载内核模块：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload geom_eli</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>+
对于自定义内核，请确保内核配置文件包含以下行：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options GEOM_ELI
device crypto</pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>生成主密钥</p>
<div class="paragraph">
<p>以下命令生成一个主密钥，所有数据都将使用该密钥进行加密。该密钥是不可更改的。与直接使用该密钥不同，它会被一个或多个用户密钥加密。用户密钥由来自文件 <span class="filename">/root/da2.key</span> 的可选随机字节和 / 或口令组成。在这种情况下，密钥文件的数据源是 <span class="filename">/dev/random</span> 。此命令还将提供者 (<span class="filename">/dev/da2.eli</span>) 的扇区大小配置为 4kB ，以提高性能。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/random of=/root/da2.key bs=64 count=1</span>
<span class="c"># geli init -K /root/da2.key -s 4096 /dev/da2</span>
Enter new passphrase:
Reenter new passphrase:</code></pre>
</div>
</div>
<div class="paragraph">
<p>不强制同时使用密码短语和密钥文件，因为可以单独使用其中一种方法来保护主密钥。</p>
</div>
<div class="paragraph">
<p>如果密钥文件以&#34;-&#34;表示，则使用标准输入。例如，以下命令将生成三个密钥文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat keyfile1 keyfile2 keyfile3 | geli init -K - /dev/da2</span></code></pre>
</div>
</div>
</li>
<li>
<p>将生成的密钥与提供者关联。</p>
<div class="paragraph">
<p>要附加提供者，请指定密钥文件、磁盘名称和密码短语：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># geli attach -k /root/da2.key /dev/da2</span>
Enter passphrase:</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将创建一个带有 <span class="filename">.eli</span> 扩展名的新设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls /dev/da2*</span>
/dev/da2  /dev/da2.eli</code></pre>
</div>
</div>
</li>
<li>
<p>创建新的文件系统</p>
<div class="paragraph">
<p>接下来，使用 UFS 文件系统对设备进行格式化，并将其挂载到现有的挂载点上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/random of=/dev/da2.eli bs=1m</span>
<span class="c"># newfs /dev/da2.eli</span>
<span class="c"># mount /dev/da2.eli /private</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>加密文件系统现在可以使用了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># df -H</span>
Filesystem     Size   Used  Avail Capacity  Mounted on
/dev/ad0s1a    248M    89M   139M    38%    /
/devfs         1.0K   1.0K     0B   100%    /dev
/dev/ad0s1f    7.7G   2.3G   4.9G    32%    /usr
/dev/ad0s1d    989M   1.5M   909M     0%    /tmp
/dev/ad0s1e    3.9G   1.3G   2.3G    35%    /var
/dev/da2.eli   150G   4.1K   138G     0%    /private</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>一旦加密分区的工作完成，并且不再需要 <span class="filename">/private</span> 分区，为了安全起见，应该将设备放入冷存储中，即卸载并从内核中分离 <code>geli</code> 加密分区：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># umount /private</span>
<span class="c"># geli detach da2.eli</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了简化启动时 <code>geli</code> 加密设备的挂载，提供了一个 <span class="filename">rc.d</span> 脚本。对于这个示例，请将以下行添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>geli_devices=&#34;da2&#34;
geli_da2_flags=&#34;-k /root/da2.key&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>这将 <span class="filename">/dev/da2</span> 配置为具有 <span class="filename">/root/da2.key</span> 作为主密钥的 <code>geli</code> 提供程序。系统将在关闭系统之前自动从内核中分离该提供程序。在启动过程中，脚本将在连接提供程序之前提示输入密码。在密码提示之前和之后可能会显示其他内核消息。如果启动过程似乎停滞不前，请仔细查找其他消息中的密码提示。一旦输入正确的密码，提供程序将被连接。然后文件系统通常会被挂载，通过 <span class="filename">/etc/fstab</span> 中的条目进行。有关如何配置文件系统在启动时挂载的说明，请参阅交叉引用 :basics[mount-unmount ,“挂载和卸载文件系统”] 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="swap-encrypting">20.14. 加密交换分区<a class="anchor" href="#swap-encrypting"></a></h3>
<div class="paragraph">
<p>像磁盘分区的加密一样，交换空间的加密用于保护敏感信息。考虑一个处理密码的应用程序。只要这些密码保留在物理内存中，它们不会被写入磁盘，并且在重新启动后会被清除。然而，如果 FreeBSD 开始交换内存页面以释放空间，密码可能会以未加密的形式写入磁盘。对交换空间进行加密可以解决这种情况。</p>
</div>
<div class="paragraph">
<p>本节演示如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> 加密配置交换分区。假设 <span class="filename">/dev/ada0s1b</span> 是交换分区。</p>
</div>
<div class="sect3">
<h4 id="_配置加密交换空间">20.14.1. 配置加密交换空间<a class="anchor" href="#_配置加密交换空间"></a></h4>
<div class="paragraph">
<p>默认情况下，交换分区不会被加密，应在继续之前清除其中的任何敏感数据。要用随机垃圾覆盖当前的交换分区，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dd if=/dev/random of=/dev/ada0s1b bs=1m</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> 加密交换分区，请在 <span class="filename">/etc/fstab</span> 中的交换行上添加 <code>.bde</code> 后缀。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.bde	none		swap	sw		0	0</pre>
</div>
</div>
<div class="paragraph">
<p>要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> 来加密交换分区，可以使用 <code>.eli</code> 后缀：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device		Mountpoint	FStype	Options		Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw		0	0</pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下， <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> 使用 128 位密钥长度的 AES 算法。通常情况下，默认设置就足够了。如果需要的话，可以在 <span class="filename">/etc/fstab</span> 中的选项字段中更改这些默认值。可能的标志有：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">aalgo 是一个用于算法学习和实践的在线平台。它提供了一个交互式的编程环境，让用户可以在浏览器中编写和运行算法代码。用户可以通过 aalgo 学习各种常见的算法和数据结构，并通过解决实际问题来提高他们的编程技能。 aalgo 还提供了一系列的练习题和挑战，帮助用户巩固所学的知识并提升他们的算法解决能力。无论是初学者还是有经验的开发者，都可以通过 aalgo 来提升他们的算法和编程能力。</dt>
<dd>
<p>数据完整性验证算法用于确保加密数据没有被篡改。请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> 以获取支持的算法列表。</p>
</dd>
<dt class="hdlist1">ealgo</dt>
<dd>
<p>用于保护数据的加密算法。请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> 以获取支持的算法列表。</p>
</dd>
<dt class="hdlist1">密钥长度</dt>
<dd>
<p>用于加密算法的密钥长度。请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> 以了解每个加密算法支持的密钥长度。</p>
</dd>
<dt class="hdlist1">扇区大小</dt>
<dd>
<p>在加密之前，块数据的大小会被分割。较大的扇区大小可以提高性能，但会增加存储开销。推荐的大小是 4096 字节。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>这个示例配置了一个使用 Blowfish 算法的加密交换分区，密钥长度为 128 位，扇区大小为 4 千字节。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device		Mountpoint	FStype	Options				Dump	Pass#
/dev/ada0s1b.eli	none		swap	sw,ealgo=blowfish,keylen=128,sectorsize=4096	0	0</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_加密交换验证">20.14.2. 加密交换验证<a class="anchor" href="#_加密交换验证"></a></h4>
<div class="paragraph">
<p>系统重新启动后，可以使用 <code>swapinfo</code> 命令来验证加密交换空间的正常运行。</p>
</div>
<div class="paragraph">
<p>如果正在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gbde&amp;sektion=8&amp;format=html">gbde(8)</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.bde   542720        0   542720     0</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果正在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=geli&amp;sektion=8&amp;format=html">geli(8)</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>swapinfo
Device          1K-blocks     Used    Avail Capacity
/dev/ada0s1b.eli   542720        0   542720     0</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="disks-hast">20.15. 高可用存储（ Highly Available Storage ， HAST ）<a class="anchor" href="#disks-hast"></a></h3>
<div class="paragraph">
<p>高可用性是严肃的商业应用程序的主要要求之一，而高可用性存储是这种环境中的关键组成部分。在 FreeBSD 中，高可用性存储（ HAST ）框架允许通过 TCP/IP 网络在多个物理分离的机器上透明地存储相同的数据。 HAST 可以理解为基于网络的 RAID1 （镜像），类似于在 GNU/Linux 平台上使用的 DRBD® 存储系统。结合 FreeBSD 的其他高可用性功能（如 CARP ）， HAST 使得构建一个抵抗硬件故障的高可用性存储集群成为可能。</p>
</div>
<div class="paragraph">
<p>以下是 HAST 的主要特点：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>可用于掩盖本地硬盘的 I/O 错误。</p>
</li>
<li>
<p>它与 FreeBSD 支持的任何文件系统兼容，与文件系统无关。</p>
</li>
<li>
<p>只有在节点宕机期间被修改的块才会进行同步，从而实现高效快速的重新同步。</p>
</li>
<li>
<p>可以在已部署的环境中使用，以增加额外的冗余性。</p>
</li>
<li>
<p>与 CARP 、 Heartbeat 或其他工具一起，它可以用于构建强大和耐用的存储系统。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>阅读本节后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>HAST 是什么，它是如何工作的，以及它提供了哪些功能。</p>
</li>
<li>
<p>如何在 FreeBSD 上设置和使用 HAST 。</p>
</li>
<li>
<p>如何集成 CARP 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 以构建一个强大的存储系统。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本节之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 UNIX® 和 FreeBSD 基础知识（参见： basics[basics , FreeBSD Basics] ）。</p>
</li>
<li>
<p>了解如何配置网络接口和其他核心的 FreeBSD 子系统（参见： config[config-tuning , Configuration and Tuning] ）。</p>
</li>
<li>
<p>对 FreeBSD 网络有很好的理解（参考： partiv[network-communication ,&#34;网络通信&#34;] ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>HAST 项目由 FreeBSD 基金会赞助，得到了 <a href="http://www.omc.net/">http://www.omc.net/</a> 和 <a href="http://www.transip.nl/">http://www.transip.nl/</a> 的支持。</p>
</div>
<div class="sect3">
<h4 id="_hast_操作">20.15.1. HAST 操作<a class="anchor" href="#_hast_操作"></a></h4>
<div class="paragraph">
<p>HAST 提供了两台物理机之间的同步块级复制：<em>主节点_和_备节点</em>。这两台机器一起被称为一个集群。</p>
</div>
<div class="paragraph">
<p>由于 HAST 以主 - 备配置工作，所以在任何给定的时间内只允许集群中的一个节点处于活动状态。主节点，也称为“活动节点”，负责处理所有对 HAST 管理设备的 I/O 请求。备节点会自动从主节点同步。</p>
</div>
<div class="paragraph">
<p>HAST 系统的物理组件包括主节点上的本地磁盘和远程次节点上的磁盘。</p>
</div>
<div class="paragraph">
<p>HAST 在块级别上同步操作，对文件系统和应用程序透明。 HAST 在 [/dev/hast/] 目录下提供常规的 GEOM 提供程序，供其他工具或应用程序使用。使用 HAST 提供的设备和原始磁盘或分区之间没有区别。</p>
</div>
<div class="paragraph">
<p>每个写入、删除或刷新操作都会通过 TCP/IP 同时发送到本地磁盘和远程磁盘。每个读取操作都会从本地磁盘提供，除非本地磁盘不是最新的或发生了 I/O 错误。在这种情况下，读取操作会被发送到辅助节点。</p>
</div>
<div class="paragraph">
<p>HAST 试图提供快速的故障恢复。因此，在节点故障后减少同步时间非常重要。为了提供快速同步， HAST 管理一个磁盘上的脏扩展位图，并且只在定期同步期间同步这些扩展，初始同步除外。</p>
</div>
<div class="paragraph">
<p>处理同步的方法有很多种。 HAST 实现了几种复制模式来处理不同的同步方法：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>_memsync_模式：当本地写操作完成并且远程节点确认数据到达之后，但在实际存储数据之前，该模式将报告写操作已完成。在发送确认之后，远程节点上的数据将直接存储。该模式旨在减少延迟，但仍提供良好的可靠性。该模式是默认模式。</p>
</li>
<li>
<p><em>fullsync</em>：当本地写操作和远程写操作都完成时，该模式将报告写操作已完成。这是最安全但也是最慢的复制模式。</p>
</li>
<li>
<p><em>async</em>：此模式在本地写操作完成时报告写操作完成。这是最快速和最危险的复制模式。只有在复制到远程节点时延迟过高以至于其他模式无法使用时才应使用此模式。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_hast_配置">20.15.2. HAST 配置<a class="anchor" href="#_hast_配置"></a></h4>
<div class="paragraph">
<p>HAST 框架由几个组件组成：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>这个人 :hastd[8] 守护进程提供数据同步功能。当启动这个守护进程时，它会自动加载 <code>geom_gate.ko</code> 模块。</p>
</li>
<li>
<p>用户空间管理实用程序， <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> 。</p>
</li>
<li>
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a> 配置文件。在启动 hastd 之前，此文件必须存在。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>喜欢将 <code>GEOM_GATE</code> 支持静态构建到内核中的用户应该将以下行添加到自定义内核配置文件中，然后按照 <a href="./#kernelconfig">Configuring the FreeBSD Kernel</a> 中的说明重新构建内核。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options	GEOM_GATE</pre>
</div>
</div>
<div class="paragraph">
<p>以下示例描述了如何使用 HAST 在两个节点之间配置主备操作来复制数据。节点将被称为 <code>hasta</code> ， IP 地址为 <code>172.16.0.1</code> ，以及 <code>hastb</code> ， IP 地址为 <code>172.16.0.2</code> 。两个节点都将有一个专用硬盘 <span class="filename">/dev/ad6</span> ，大小相同，用于 HAST 操作。 HAST 池，有时也称为资源或 GEOM 提供者，在 <span class="filename">/dev/hast/</span> 中将被称为 <code>test</code> 。</p>
</div>
<div class="paragraph">
<p>HAST 的配置是通过使用 [/etc/hast.conf] 文件完成的。这个文件在两个节点上应该是相同的。最简单的配置如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>resource test {
	on hasta {
		local /dev/ad6
		remote 172.16.0.2
	}
	on hastb {
		local /dev/ad6
		remote 172.16.0.1
	}
}</pre>
</div>
</div>
<div class="paragraph">
<p>有关更高级的配置，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hast.conf&amp;sektion=5&amp;format=html">hast.conf(5)</a> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果主机是可解析的，并且在 /etc/hosts 或本地 DNS 中定义了，也可以在 <code>remote</code> 语句中使用主机名。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一旦配置在两个节点上存在，就可以创建 HAST 池。在两个节点上运行以下命令，将初始元数据放置在本地磁盘上并启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hastctl create test</span>
<span class="c"># service hastd onestart</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>无法使用 GEOM 提供程序与现有文件系统一起使用，也无法将现有存储转换为 HAST 管理的池。此过程需要在提供程序上存储一些元数据，而现有提供程序上没有足够的空间可用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>HAST 节点的“ primary ”或“ secondary ”角色由管理员或像 Heartbeat 这样的软件使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=hastctl&amp;sektion=8&amp;format=html">hastctl(8)</a> 选择。在主节点上，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hastctl role primary test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在辅助节点上运行以下命令， <code>hastb</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hastctl role secondary test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在每个节点上运行 <code>hastctl</code> 来验证结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hastctl status test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>检查输出中的 <code>status</code> 行。如果它显示为 <code>degraded</code> ，则配置文件存在问题。每个节点上应该显示为 <code>complete</code> ，表示节点之间的同步已经开始。当 <code>hastctl status</code> 报告 0 字节的 <code>dirty</code> extents 时，同步完成。</p>
</div>
<div class="paragraph">
<p>下一步是在 GEOM 提供程序上创建文件系统并挂载它。这必须在“ primary ”节点上完成。根据硬盘的大小，创建文件系统可能需要几分钟的时间。此示例在 <code>/dev/hast/test</code> 上创建了一个 UFS 文件系统。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># newfs -U /dev/hast/test</span>
<span class="c"># mkdir /hast/test</span>
<span class="c"># mount /dev/hast/test /hast/test</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦 HAST 框架正确配置完成，最后一步是确保在系统启动时自动启动 HAST 。将以下行添加到 <code>/etc/rc.conf</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hastd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="sect4">
<h5 id="_故障转移配置">20.15.2.1. 故障转移配置<a class="anchor" href="#_故障转移配置"></a></h5>
<div class="paragraph">
<p>这个示例的目标是构建一个强大的存储系统，能够抵抗任何给定节点的故障。如果主节点发生故障，备用节点将无缝接管，检查和挂载文件系统，并继续工作，不会丢失任何一位数据。</p>
</div>
<div class="paragraph">
<p>为了完成这个任务，使用 Common Address Redundancy Protocol (CARP) 来提供 IP 层的自动故障转移。 CARP 允许同一网络段上的多个主机共享一个 IP 地址。根据 <a href="./#carp">“ Common Address Redundancy Protocol (CARP) ”</a> 中提供的文档，在集群的两个节点上设置 CARP 。在这个例子中，每个节点都有自己的管理 IP 地址和一个共享的 IP 地址为_172.16.0.254_。集群的主要 HAST 节点必须是主要的 CARP 节点。</p>
</div>
<div class="paragraph">
<p>在前一节中创建的 HAST 池现在已经准备好导出到网络上的其他主机。可以通过 NFS 或 Samba 将其导出，使用共享的 IP 地址_172.16.0.254_。唯一尚未解决的问题是主节点故障时的自动故障转移。</p>
</div>
<div class="paragraph">
<p>当 CARP 接口上下线时， FreeBSD 操作系统会生成一个 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 事件，这样就可以监视 CARP 接口的状态变化。 CARP 接口的状态变化表示其中一个节点失败或重新上线。这些状态变化事件使得可以运行一个脚本来自动处理 HAST 故障切换。</p>
</div>
<div class="paragraph">
<p>要捕获 CARP 接口上的状态变化，请在每个节点的 <code>/etc/devd.conf</code> 配置文件中添加以下配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_UP&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch primary&#34;;
};

notify 30 {
	match &#34;system&#34; &#34;IFNET&#34;;
	match &#34;subsystem&#34; &#34;carp0&#34;;
	match &#34;type&#34; &#34;LINK_DOWN&#34;;
	action &#34;/usr/local/sbin/carp-hast-switch secondary&#34;;
};</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果系统运行的是 FreeBSD 10 或更高版本，请将 <span class="filename">carp0</span> 替换为 CARP 配置接口的名称。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在两个节点上重新启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> ，以使新配置生效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service devd restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当指定的接口状态发生上升或下降变化时，系统会生成一个通知，允许 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 子系统运行指定的自动故障转移脚本 <span class="filename">/usr/local/sbin/carp-hast-switch</span> 。有关此配置的进一步说明，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd.conf&amp;sektion=5&amp;format=html">devd.conf(5)</a> 。</p>
</div>
<div class="paragraph">
<p>这是一个自动故障转移脚本的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh

# Original script by Freddie Cash &lt;fjwcash@gmail.com&gt;
# Modified by Michael W. Lucas &lt;mwlucas@BlackHelicopters.org&gt;
# and Viktor Petersson &lt;vpetersson@wireload.net&gt;

# The names of the HAST resources, as listed in /etc/hast.conf
resources=&#34;test&#34;

# delay in mounting HAST resource after becoming primary
# make your best guess
delay=3

# logging
log=&#34;local0.debug&#34;
name=&#34;carp-hast&#34;

# end of user configurable stuff

case &#34;$1&#34; in
	primary)
		logger -p $log -t $name &#34;Switching to primary provider for ${resources}.&#34;
		sleep ${delay}

		# Wait for any &#34;hastd secondary&#34; processes to stop
		for disk in ${resources}; do
			while $( pgrep -lf &#34;hastd: ${disk} \(secondary\)&#34; &gt; /dev/null 2&gt;&amp;1 ); do
				sleep 1
			done

			# Switch role for each disk
			hastctl role primary ${disk}
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to change role to primary for resource ${disk}.&#34;
				exit 1
			fi
		done

		# Wait for the /dev/hast/* devices to appear
		for disk in ${resources}; do
			for I in $( jot 60 ); do
				[ -c &#34;/dev/hast/${disk}&#34; ] &amp;&amp; break
				sleep 0.5
			done

			if [ ! -c &#34;/dev/hast/${disk}&#34; ]; then
				logger -p $log -t $name &#34;GEOM provider /dev/hast/${disk} did not appear.&#34;
				exit 1
			fi
		done

		logger -p $log -t $name &#34;Role for HAST resources ${resources} switched to primary.&#34;

		logger -p $log -t $name &#34;Mounting disks.&#34;
		for disk in ${resources}; do
			mkdir -p /hast/${disk}
			fsck -p -y -t ufs /dev/hast/${disk}
			mount /dev/hast/${disk} /hast/${disk}
		done

	;;

	secondary)
		logger -p $log -t $name &#34;Switching to secondary provider for ${resources}.&#34;

		# Switch roles for the HAST resources
		for disk in ${resources}; do
			if ! mount | grep -q &#34;^/dev/hast/${disk} on &#34;
			then
			else
				umount -f /hast/${disk}
			fi
			sleep $delay
			hastctl role secondary ${disk} 2&gt;&amp;1
			if [ $? -ne 0 ]; then
				logger -p $log -t $name &#34;Unable to switch role to secondary for resource ${disk}.&#34;
				exit 1
			fi
			logger -p $log -t $name &#34;Role switched to secondary for resource ${disk}.&#34;
		done
	;;
esac</pre>
</div>
</div>
<div class="paragraph">
<p>简而言之，当一个节点成为主节点时，脚本会执行以下操作：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将 HAST 池提升为另一节点上的主节点。</p>
</li>
<li>
<p>检查 HAST 池下的文件系统。</p>
</li>
<li>
<p>挂载存储池。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当一个节点变为次要节点时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>卸载 HAST 池。</p>
</li>
<li>
<p>将 HAST 池降级为辅助池。</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这只是一个作为概念验证的示例脚本。它并不能处理所有可能的情况，并且可以根据需要进行扩展或修改，例如启动或停止所需的服务。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于这个示例，使用了标准的 UFS 文件系统。为了减少恢复所需的时间，可以使用启用了日志的 UFS 或 ZFS 文件系统。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>更详细的信息和额外的示例可以在 <a href="http://wiki.FreeBSD.org/HAST">http://wiki.FreeBSD.org/HAST</a> 找到。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_故障排除">20.15.3. 故障排除<a class="anchor" href="#_故障排除"></a></h4>
<div class="paragraph">
<p>HAST 通常应该没有问题。然而，与任何其他软件产品一样，有时候它可能无法按照预期工作。问题的根源可能不同，但经验法则是确保集群节点之间的时间同步。</p>
</div>
<div class="paragraph">
<p>在排除 HAST 问题时，应通过使用 <code>-d</code> 参数启动 <code>hastd</code> 来增加 <a href="https://man.freebsd.org/cgi/man.cgi?query=hastd&amp;sektion=8&amp;format=html">hastd(8)</a> 的调试级别。可以多次指定此参数以进一步增加调试级别。还可以考虑使用 <code>-F</code> ，它会在前台启动 <code>hastd</code> 。</p>
</div>
<div class="sect4">
<h5 id="disks-hast-sb">20.15.3.1. 从分裂脑状态中恢复<a class="anchor" href="#disks-hast-sb"></a></h5>
<div class="paragraph">
<p>当集群的节点无法相互通信且都配置为主节点时，会发生“分裂脑”现象。这是一种危险的情况，因为它允许两个节点对数据进行不兼容的更改。系统管理员必须手动纠正这个问题。</p>
</div>
<div class="paragraph">
<p>管理员必须要么决定哪个节点有更重要的更改，要么手动执行合并操作。然后，让 HAST 对具有损坏数据的节点执行完全同步。为此，请在需要重新同步的节点上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hastctl role init test</span>
<span class="c"># hastctl create test</span>
<span class="c"># hastctl role secondary test</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="geom">Chapter 21. GEOM ：模块化磁盘转换框架<a class="anchor" href="#geom"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="geom-synopsis">21.1. 简介<a class="anchor" href="#geom-synopsis"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 中， GEOM 框架通过使用提供者（或者说是位于 <code>/dev</code> 目录下的磁盘设备）允许访问和控制类别，例如主引导记录和 BSD 标签。通过支持各种软件 RAID 配置， GEOM 可以透明地提供对操作系统和操作系统工具的访问。</p>
</div>
<div class="paragraph">
<p>本章介绍了在 FreeBSD 中使用 GEOM 框架下的磁盘。这包括使用该框架进行配置的主要 RAID 控制工具。本章不是关于 RAID 配置的权威指南，只讨论了 GEOM 支持的 RAID 分类。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将会了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>GEOM 提供哪种类型的 RAID 支持？</p>
</li>
<li>
<p>如何使用基本工具来配置、维护和操作各种 RAID 级别。</p>
</li>
<li>
<p>如何通过 GEOM 镜像、条带化、加密和远程连接磁盘设备。</p>
</li>
<li>
<p>如何排除与 GEOM 框架连接的磁盘问题。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 FreeBSD 如何处理磁盘设备（参考： disks[disks ,存储] ）。</p>
</li>
<li>
<p>了解如何配置和安装新的内核（参考： kernelconfig[kernelconfig ，配置 FreeBSD 内核] ）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="geom-striping">21.2. RAID0 - 条带化<a class="anchor" href="#geom-striping"></a></h3>
<div class="paragraph">
<p>条带化将多个磁盘驱动器合并为一个卷。可以通过使用硬件 RAID 控制器来执行条带化。 GEOM 磁盘子系统提供了对磁盘条带化的软件支持，也称为 RAID0 ，无需 RAID 磁盘控制器。</p>
</div>
<div class="paragraph">
<p>在 RAID0 中，数据被分割成块，并写入阵列中的所有驱动器。如下图所示， RAID0 可以同时将 64k 写入阵列中的四个驱动器，而不是等待系统将 256k 写入一个磁盘，从而提供更优异的 I/O 性能。通过使用多个磁盘控制器，可以进一步提升性能。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/geom/striping.png" alt="磁盘条带化示意图"/>
</div>
</div>
<div class="paragraph">
<p>RAID0 条带中的每个磁盘必须具有相同的大小，因为 I/O 请求会交错地并行读取或写入多个磁盘。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>RAID0 不提供任何冗余功能。这意味着如果阵列中的一个磁盘故障，所有磁盘上的数据都会丢失。如果数据很重要，请实施定期将备份保存到远程系统或设备的备份策略。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用普通磁盘在 FreeBSD 系统上创建基于 GEOM 的 RAID0 软件的过程如下。创建条带后，可以参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=gstripe&amp;sektion=8&amp;format=html">gstripe(8)</a> 了解如何控制现有的条带的更多信息。</p>
</div>
<div class="sidebarblock procedure">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>过程：创建一个未格式化的 ATA 磁盘条带 *</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>加载 <span class="filename">geom_stripe.ko</span> 模块：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload geom_stripe</span></code></pre>
</div>
</div>
</li>
<li>
<p>确保存在一个合适的挂载点。如果该卷将成为根分区，则暂时使用另一个挂载点，例如 <span class="filename">/mnt</span> 。</p>
</li>
<li>
<p>确定将要进行条带化的磁盘的设备名称，并创建新的条带设备。例如，要对两个未使用和未分区的 ATA 磁盘进行条带化，设备名称分别为 <code>/dev/ad2</code> 和 <code>/dev/ad3</code> ：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gstripe label -v st0 /dev/ad2 /dev/ad3</span>
Metadata value stored on /dev/ad2.
Metadata value stored on /dev/ad3.
Done.</code></pre>
</div>
</div>
</li>
<li>
<p>在新卷上编写一个标准标签，也称为分区表，并安装默认的引导代码：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bsdlabel -wB /dev/stripe/st0</span></code></pre>
</div>
</div>
</li>
<li>
<p>在 <span class="filename">/dev/stripe</span> 中，除了 <span class="filename">st0</span> 之外，此过程应该创建另外两个设备。它们分别是 <span class="filename">st0a</span> 和 <span class="filename">st0c</span> 。此时，可以使用 <code>newfs</code> 在 <span class="filename">st0a</span> 上创建一个 UFS 文件系统：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># newfs -U /dev/stripe/st0a</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>许多数字将在屏幕上滑动，几秒钟后，过程将完成。卷已创建并准备好挂载。</p>
</div>
</li>
<li>
<p>手动挂载创建的磁盘条带：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /dev/stripe/st0a /mnt</span></code></pre>
</div>
</div>
</li>
<li>
<p>要在引导过程中自动挂载此条带文件系统，请将卷信息放置在 [/etc/fstab] 中。在此示例中，创建了一个永久挂载点，命名为 [stripe] 。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /stripe</span>
<span class="c"># echo &#34;/dev/stripe/st0a /stripe ufs rw 2 2&#34; \</span>
<span class="gp">&gt;&gt; </span>/etc/fstab</code></pre>
</div>
</div>
</li>
<li>
<p>在系统初始化期间，还必须自动加载 <span class="filename">geom_stripe.ko</span> 模块，方法是在 <span class="filename">/boot/loader.conf</span> 文件中添加一行。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#39;geom_stripe_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="geom-mirror">21.3. RAID1 - 镜像<a class="anchor" href="#geom-mirror"></a></h3>
<div class="paragraph">
<p>RAID1 ，或者称为镜像，是一种将相同数据写入多个磁盘驱动器的技术。镜像通常用于防止由于驱动器故障而导致的数据丢失。镜像中的每个驱动器都包含数据的完全相同副本。当一个驱动器故障时，镜像仍然可以工作，从仍在运行的驱动器提供数据。计算机继续运行，管理员有时间替换故障的驱动器而不会中断用户。</p>
</div>
<div class="paragraph">
<p>这些示例中展示了两种常见情况。第一种情况是使用两个新的驱动器创建一个镜像，并将其作为现有单个驱动器的替代品。第二个示例是在一个新的驱动器上创建一个镜像，将旧驱动器的数据复制到其中，然后将旧驱动器插入到镜像中。虽然这个过程稍微复杂一些，但只需要一个新的驱动器。</p>
</div>
<div class="paragraph">
<p>传统上，镜像中的两个驱动器在型号和容量上是相同的，但是 <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> 并不要求如此。使用不同驱动器创建的镜像的容量将等于镜像中最小驱动器的容量。较大驱动器上的额外空间将不会被使用。后来插入镜像的驱动器必须至少具有与镜像中已有的最小驱动器相同的容量。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这里展示的镜像过程是非破坏性的，但是像任何重要的磁盘操作一样，请先进行完整备份。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在这些过程中，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 来复制文件系统，但它无法在使用软更新日志的文件系统上工作。请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> 以了解有关检测和禁用软更新日志的信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="geom-mirror-metadata">21.3.1. 元数据问题<a class="anchor" href="#geom-mirror-metadata"></a></h4>
<div class="paragraph">
<p>许多磁盘系统将元数据存储在每个磁盘的末尾。在将磁盘重新用于镜像之前，应该擦除旧的元数据。大多数问题是由两种特定类型的残留元数据引起的： GPT 分区表和来自先前镜像的旧元数据。</p>
</div>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 命令来擦除 GPT 元数据。这个例子会从磁盘 ada8 上擦除主 GPT 分区表和备份 GPT 分区表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart destroy -F ada8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> 命令一步完成从活动镜像中移除磁盘并擦除元数据。在这个例子中，磁盘 ada8 从活动镜像 gm4 中被移除。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror remove gm4 ada8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果镜像没有运行，但旧的镜像元数据仍然存在于磁盘上，请使用 <code>gmirror clear</code> 命令将其删除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror clear ada8</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> 在磁盘的末尾存储一个块的元数据。由于 GPT 分区方案也在磁盘末尾存储元数据，因此不建议使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> 来镜像整个 GPT 磁盘。这里使用 MBR 分区，因为它只在磁盘的开头存储分区表，不会与镜像的元数据冲突。</p>
</div>
</div>
<div class="sect3">
<h4 id="geom-mirror-two-new-disks">21.3.2. 使用两个新硬盘创建镜像<a class="anchor" href="#geom-mirror-two-new-disks"></a></h4>
<div class="paragraph">
<p>在这个例子中， FreeBSD 已经安装在一个单独的磁盘上， <span class="filename">ada0</span> 。系统已经连接了两个新的磁盘， <span class="filename">ada1</span> 和 <span class="filename">ada2</span> 。将在这两个磁盘上创建一个新的镜像，并用它来替换旧的单个磁盘。</p>
</div>
<div class="paragraph">
<p>内核模块 <span class="filename">geom_mirror.ko</span> 必须在内核中构建或在启动或运行时加载。现在手动加载内核模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror load</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用两个新的硬盘创建镜像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror label -v gm0 /dev/ada1 /dev/ada2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">gm0</span> 是用户选择的设备名称，用于指定新镜像。在镜像启动后，该设备名称将出现在 <span class="filename">/dev/mirror/</span> 中。</p>
</div>
<div class="paragraph">
<p>现在可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 在镜像上创建 MBR 和 bsdlabel 分区表。这个例子使用传统的文件系统布局，包括用于 [/] 、交换空间、 [/var] 、 [/tmp] 和 [/usr] 的分区。也可以只使用一个 [/] 和一个交换空间分区。</p>
</div>
<div class="paragraph">
<p>镜像上的分区不必与现有磁盘上的分区大小相同，但必须足够大以容纳已经存在于 ada0 上的所有数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart create -s MBR mirror/gm0</span>
<span class="c"># gpart add -t freebsd -a 4k mirror/gm0</span>
<span class="c"># gpart show mirror/gm0</span>
<span class="gp">=&gt;       </span>63  156301423  mirror/gm0  MBR  <span class="o">(</span>74G<span class="o">)</span>
         63         63                    - free -  <span class="o">(</span>31k<span class="o">)</span>
        126  156301299                 1  freebsd  <span class="o">(</span>74G<span class="o">)</span>
  156301425         61                    - free -  <span class="o">(</span>30k<span class="o">)</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart create -s BSD mirror/gm0s1</span>
<span class="c"># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class="c"># gpart add -t freebsd-swap -a 4k -s 4g mirror/gm0s1</span>
<span class="c"># gpart add -t freebsd-ufs  -a 4k -s 2g mirror/gm0s1</span>
<span class="c"># gpart add -t freebsd-ufs  -a 4k -s 1g mirror/gm0s1</span>
<span class="c"># gpart add -t freebsd-ufs  -a 4k mirror/gm0s1</span>
<span class="c"># gpart show mirror/gm0s1</span>
<span class="gp">=&gt;        </span>0  156301299  mirror/gm0s1  BSD  <span class="o">(</span>74G<span class="o">)</span>
          0          2                      - free -  <span class="o">(</span>1.0k<span class="o">)</span>
          2    4194304                   1  freebsd-ufs  <span class="o">(</span>2.0G<span class="o">)</span>
    4194306    8388608                   2  freebsd-swap <span class="o">(</span>4.0G<span class="o">)</span>
   12582914    4194304                   4  freebsd-ufs  <span class="o">(</span>2.0G<span class="o">)</span>
   16777218    2097152                   5  freebsd-ufs  <span class="o">(</span>1.0G<span class="o">)</span>
   18874370  137426928                   6  freebsd-ufs  <span class="o">(</span>65G<span class="o">)</span>
  156301298          1                      - free -  <span class="o">(</span>512B<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在 MBR 中安装引导代码和 bsdlabel ，并设置活动分区，使镜像可引导：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class="c"># gpart set -a active -i 1 mirror/gm0</span>
<span class="c"># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在新的镜像上格式化文件系统，并启用软更新。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># newfs -U /dev/mirror/gm0s1a</span>
<span class="c"># newfs -U /dev/mirror/gm0s1d</span>
<span class="c"># newfs -U /dev/mirror/gm0s1e</span>
<span class="c"># newfs -U /dev/mirror/gm0s1f</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> 将原始的 <span class="filename">ada0</span> 磁盘上的文件系统复制到镜像中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /dev/mirror/gm0s1a /mnt</span>
<span class="c"># dump -C16 -b64 -0aL -f - / | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class="c"># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class="c"># mount /dev/mirror/gm0s1e /mnt/tmp</span>
<span class="c"># mount /dev/mirror/gm0s1f /mnt/usr</span>
<span class="c"># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class="c"># dump -C16 -b64 -0aL -f - /tmp | (cd /mnt/tmp &amp;&amp; restore -rf -)</span>
<span class="c"># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编辑 <span class="filename">/mnt/etc/fstab</span> ，将其指向新的镜像文件系统：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/tmp		ufs	rw	2	2
/dev/mirror/gm0s1f	/usr		ufs	rw	2	2</pre>
</div>
</div>
<div class="paragraph">
<p>如果内核模块 <span class="filename">geom_mirror.ko</span> 没有被编译到内核中，需要编辑 <span class="filename">/mnt/boot/loader.conf</span> 文件，在启动时加载该模块：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>geom_mirror_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>重新启动系统以测试新的镜像，并验证所有数据是否已复制。 BIOS 将把镜像视为两个独立的驱动器，而不是一个镜像。由于驱动器是相同的，选择哪个来启动并不重要。</p>
</div>
<div class="paragraph">
<p>如果启动时出现问题，请参阅 <a href="#gmirror-troubleshooting">故障排除</a> 。关闭电源并断开原始的 <span class="filename">ada0</span> 磁盘，可以将其保留为离线备份。</p>
</div>
<div class="paragraph">
<p>在使用中，镜像将表现得就像原始的单个驱动器一样。</p>
</div>
</div>
<div class="sect3">
<h4 id="geom-mirror-existing-drive">21.3.3. 使用现有驱动器创建镜像<a class="anchor" href="#geom-mirror-existing-drive"></a></h4>
<div class="paragraph">
<p>在这个例子中， FreeBSD 已经安装在一个单独的磁盘上， <span class="filename">ada0</span> 。一个新的磁盘， <span class="filename">ada1</span> ，已经连接到系统上。将在新磁盘上创建一个单磁盘镜像，将现有系统复制到其中，然后将旧磁盘插入到镜像中。这个稍微复杂的过程是必需的，因为 <code>gmirror</code> 需要在每个磁盘的末尾放置一个 512 字节的元数据块，而现有的 <span class="filename">ada0</span> 通常已经分配了所有的空间。</p>
</div>
<div class="paragraph">
<p>加载 <span class="filename">geom_mirror.ko</span> 内核模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror load</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>diskinfo</code> 命令检查原始磁盘的媒体大小：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># diskinfo -v ada0 | head -n3</span>
/dev/ada0
        512             <span class="c"># sectorsize</span>
        1000204821504   <span class="c"># mediasize in bytes (931G)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在新的磁盘上创建一个镜像。为了确保镜像容量不大于原始的 ada0 驱动器，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=gnop&amp;sektion=8&amp;format=html">gnop(8)</a> 创建一个与原始驱动器大小完全相同的虚拟驱动器。这个驱动器不存储任何数据，只用于限制镜像的大小。当 <a href="https://man.freebsd.org/cgi/man.cgi?query=gmirror&amp;sektion=8&amp;format=html">gmirror(8)</a> 创建镜像时，它将限制容量为 gzero.nop 的大小，即使新的 ada1 驱动器有更多的空间。请注意，第二行中的 1000204821504 等于 ada0 的媒体大小，如上面的 diskinfo 所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># geom zero load</span>
<span class="c"># gnop create -s 1000204821504 gzero</span>
<span class="c"># gmirror label -v gm0 gzero.nop ada1</span>
<span class="c"># gmirror forget gm0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <span class="filename">gzero.nop</span> 不存储任何数据，因此镜像设备不会将其视为已连接。镜像设备被告知“忘记”未连接的组件，从而删除对 <span class="filename">gzero.nop</span> 的引用。结果是一个只包含一个磁盘 <span class="filename">ada1</span> 的镜像设备。</p>
</div>
<div class="paragraph">
<p>创建 <span class="filename">gm0</span> 后，查看 <span class="filename">ada0</span> 上的分区表。这个输出来自一个 1TB 的硬盘。如果驱动器末尾有一些未分配的空间，可以直接将内容从 <span class="filename">ada0</span> 复制到新的镜像中。</p>
</div>
<div class="paragraph">
<p>然而，如果输出显示磁盘上的所有空间都已分配，就像下面的列表中所示，那么在磁盘末尾没有可用于 512 字节镜像元数据的空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart show ada0</span>
<span class="gp">=&gt;        </span>63  1953525105        ada0  MBR  <span class="o">(</span>931G<span class="o">)</span>
          63  1953525105           1  freebsd  <span class="o">[</span>active]  <span class="o">(</span>931G<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，必须编辑分区表，将 <span class="filename">mirror/gm0</span> 的容量减少一个扇区。具体操作将在后面解释。</p>
</div>
<div class="paragraph">
<p>无论哪种情况，都应首先使用 <code>gpart backup</code> 和 <code>gpart restore</code> 命令来复制主硬盘上的分区表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart backup ada0 &gt; table.ada0</span>
<span class="c"># gpart backup ada0s1 &gt; table.ada0s1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些命令创建了两个文件， <span class="filename">table.ada0</span> 和 <span class="filename">table.ada0s1</span> 。这个例子是来自一个 1 TB 的硬盘。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525105   <span class="o">[</span>active]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640881</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果磁盘末尾没有显示可用空间，则必须将分区和最后一个分区的大小都减小一个扇区。编辑这两个文件，将分区和最后一个分区的大小都减小一个。这些是每个列表中的最后一个数字。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat table.ada0</span>
MBR 4
1 freebsd         63 1953525104   <span class="o">[</span>active]</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat table.ada0s1</span>
BSD 8
1  freebsd-ufs          0    4194304
2 freebsd-swap    4194304   33554432
4  freebsd-ufs   37748736   50331648
5  freebsd-ufs   88080384   41943040
6  freebsd-ufs  130023424  838860800
7  freebsd-ufs  968884224  984640880</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果磁盘末尾至少有一个扇区未分配，这两个文件可以直接使用，无需修改。</p>
</div>
<div class="paragraph">
<p>现在将分区表恢复到 [mirror/gm0] 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart restore mirror/gm0 &lt; table.ada0</span>
<span class="c"># gpart restore mirror/gm0s1 &lt; table.ada0s1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>gpart show</code> 命令检查分区表。此示例中，分区表如下： <span class="filename">gm0s1a</span> 用于 <span class="filename">/</span> ， <span class="filename">gm0s1d</span> 用于 <span class="filename">/var</span> ， <span class="filename">gm0s1e</span> 用于 <span class="filename">/usr</span> ， <span class="filename">gm0s1f</span> 用于 <span class="filename">/data1</span> ，以及 <span class="filename">gm0s1g</span> 用于 <span class="filename">/data2</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart show mirror/gm0</span>
<span class="gp">=&gt;        </span>63  1953525104  mirror/gm0  MBR  <span class="o">(</span>931G<span class="o">)</span>
          63  1953525042           1  freebsd  <span class="o">[</span>active]  <span class="o">(</span>931G<span class="o">)</span>
  1953525105          62              - free -  <span class="o">(</span>31k<span class="o">)</span>

<span class="c"># gpart show mirror/gm0s1</span>
<span class="gp">=&gt;         </span>0  1953525042  mirror/gm0s1  BSD  <span class="o">(</span>931G<span class="o">)</span>
           0     2097152             1  freebsd-ufs  <span class="o">(</span>1.0G<span class="o">)</span>
     2097152    16777216             2  freebsd-swap  <span class="o">(</span>8.0G<span class="o">)</span>
    18874368    41943040             4  freebsd-ufs  <span class="o">(</span>20G<span class="o">)</span>
    60817408    20971520             5  freebsd-ufs  <span class="o">(</span>10G<span class="o">)</span>
    81788928   629145600             6  freebsd-ufs  <span class="o">(</span>300G<span class="o">)</span>
   710934528  1242590514             7  freebsd-ufs  <span class="o">(</span>592G<span class="o">)</span>
  1953525042          63                - free -  <span class="o">(</span>31k<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>切片和最后一个分区都必须在磁盘末尾至少有一个空闲块。</p>
</div>
<div class="paragraph">
<p>在这些新分区上创建文件系统。分区的数量将根据原始磁盘 <span class="filename">ada0</span> 而变化。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># newfs -U /dev/mirror/gm0s1a</span>
<span class="c"># newfs -U /dev/mirror/gm0s1d</span>
<span class="c"># newfs -U /dev/mirror/gm0s1e</span>
<span class="c"># newfs -U /dev/mirror/gm0s1f</span>
<span class="c"># newfs -U /dev/mirror/gm0s1g</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在 MBR 中安装引导代码和 bsdlabel ，并设置活动分区，使镜像可引导：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart bootcode -b /boot/mbr mirror/gm0</span>
<span class="c"># gpart set -a active -i 1 mirror/gm0</span>
<span class="c"># gpart bootcode -b /boot/boot mirror/gm0s1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <span class="filename">/etc/fstab</span> 调整为使用镜像上的新分区。首先通过将其复制到 <span class="filename">/etc/fstab.orig</span> 来备份此文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/fstab /etc/fstab.orig</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编辑 [/etc/fstab] 文件，将 [/dev/ada0] 替换为 [mirror/gm0] 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device		Mountpoint	FStype	Options	Dump	Pass#
/dev/mirror/gm0s1a	/		ufs	rw	1	1
/dev/mirror/gm0s1b	none		swap	sw	0	0
/dev/mirror/gm0s1d	/var		ufs	rw	2	2
/dev/mirror/gm0s1e	/usr		ufs	rw	2	2
/dev/mirror/gm0s1f	/data1		ufs	rw	2	2
/dev/mirror/gm0s1g	/data2		ufs	rw	2	2</pre>
</div>
</div>
<div class="paragraph">
<p>如果内核中没有构建 <span class="filename">geom_mirror.ko</span> 内核模块，请编辑 <span class="filename">/boot/loader.conf</span> 文件，在启动时加载它：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>geom_mirror_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>现在可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> 将原始磁盘上的文件系统复制到镜像上。使用 <code>dump -L</code> 转储的每个文件系统都会首先创建一个快照，这可能需要一些时间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /dev/mirror/gm0s1a /mnt</span>
<span class="c"># dump -C16 -b64 -0aL -f - /    | (cd /mnt &amp;&amp; restore -rf -)</span>
<span class="c"># mount /dev/mirror/gm0s1d /mnt/var</span>
<span class="c"># mount /dev/mirror/gm0s1e /mnt/usr</span>
<span class="c"># mount /dev/mirror/gm0s1f /mnt/data1</span>
<span class="c"># mount /dev/mirror/gm0s1g /mnt/data2</span>
<span class="c"># dump -C16 -b64 -0aL -f - /usr | (cd /mnt/usr &amp;&amp; restore -rf -)</span>
<span class="c"># dump -C16 -b64 -0aL -f - /var | (cd /mnt/var &amp;&amp; restore -rf -)</span>
<span class="c"># dump -C16 -b64 -0aL -f - /data1 | (cd /mnt/data1 &amp;&amp; restore -rf -)</span>
<span class="c"># dump -C16 -b64 -0aL -f - /data2 | (cd /mnt/data2 &amp;&amp; restore -rf -)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>重新启动系统，从 <span class="filename">ada1</span> 引导。如果一切正常，系统将从 <span class="filename">mirror/gm0</span> 引导，该镜像现在包含与 <span class="filename">ada0</span> 之前相同的数据。如果启动时出现问题，请参考 <a href="#gmirror-troubleshooting">故障排除</a> 。</p>
</div>
<div class="paragraph">
<p>此时，镜像仍然只由单个 <span class="filename">ada1</span> 磁盘组成。</p>
</div>
<div class="paragraph">
<p>成功从 <span class="filename">mirror/gm0</span> 启动后，最后一步是将 <span class="filename">ada0</span> 插入到镜像中。</p>
</div>
<div class="admonitionblock important">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当 <span class="filename">ada0</span> 被插入到镜像中时，它的原始内容将被来自镜像的数据覆盖。在将 <span class="filename">ada0</span> 添加到镜像之前，请确保 <span class="filename">mirror/gm0</span> 的内容与 <span class="filename">ada0</span> 相同。如果之前使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dump&amp;sektion=8&amp;format=html">dump(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=restore&amp;sektion=8&amp;format=html">restore(8)</a> 复制的内容与 <span class="filename">ada0</span> 上的内容不一致，请将 <span class="filename">/etc/fstab</span> 恢复为挂载 <span class="filename">ada0</span> 上的文件系统，重新启动，并重新开始整个过程。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror insert gm0 ada0</span>
GEOM_MIRROR: Device gm0: rebuilding provider ada0</code></pre>
</div>
</div>
<div class="paragraph">
<p>两个磁盘之间的同步将立即开始。使用 <code>gmirror status</code> 命令查看进度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror status</span>
      Name    Status  Components
mirror/gm0  DEGRADED  ada1 <span class="o">(</span>ACTIVE<span class="o">)</span>
                      ada0 <span class="o">(</span>SYNCHRONIZING, 64%<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一段时间后，同步将完成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">GEOM_MIRROR: Device gm0: rebuilding provider ada0 finished.
<span class="c"># gmirror status</span>
      Name    Status  Components
mirror/gm0  COMPLETE  ada1 <span class="o">(</span>ACTIVE<span class="o">)</span>
                      ada0 <span class="o">(</span>ACTIVE<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">mirror/gm0</span> 现在由两个磁盘 <span class="filename">ada0</span> 和 <span class="filename">ada1</span> 组成，并且它们的内容会自动同步。在使用中， <span class="filename">mirror/gm0</span> 的行为与原始的单个驱动器相同。</p>
</div>
</div>
<div class="sect3">
<h4 id="gmirror-troubleshooting">21.3.4. 故障排除<a class="anchor" href="#gmirror-troubleshooting"></a></h4>
<div class="paragraph">
<p>如果系统无法启动，可能需要更改 BIOS 设置以从新镜像驱动器中启动。可以使用任何一个镜像驱动器进行引导，因为它们包含相同的数据。</p>
</div>
<div class="paragraph">
<p>如果启动停在这个消息上，说明镜像设备出现了问题：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Mounting from ufs:/dev/mirror/gm0s1a failed with error 19.

Loader variables:
  vfs.root.mountfrom<span class="o">=</span>ufs:/dev/mirror/gm0s1a
  vfs.root.mountfrom.options<span class="o">=</span>rw

Manual root filesystem specification:
  &lt;fstype&gt;:&lt;device&gt; <span class="o">[</span>options]
      Mount &lt;device&gt; using filesystem &lt;fstype&gt;
      and with the specified <span class="o">(</span>optional<span class="o">)</span> option list.

    e.g. ufs:/dev/da0s1a
        zfs:tank
        cd9660:/dev/acd0 ro
          <span class="o">(</span>which is equivalent to: mount -t cd9660 -o ro /dev/acd0 /<span class="o">)</span>

  ?               List valid disk boot devices
  .               Yield 1 second <span class="o">(</span><span class="k">for </span>background tasks<span class="o">)</span>
  &lt;empty line&gt;    Abort manual input

mountroot&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>忘记在 <code>/boot/loader.conf</code> 中加载 <code>geom_mirror.ko</code> 模块可能会导致这个问题。要修复它，从 FreeBSD 安装介质启动，并在第一个提示处选择 <code>Shell</code> 。然后加载镜像模块并挂载镜像设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror load</span>
<span class="c"># mount /dev/mirror/gm0s1a /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编辑 [/mnt/boot/loader.conf] 文件，在其中添加一行代码以加载镜像模块：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>geom_mirror_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>保存文件并重新启动。</p>
</div>
<div class="paragraph">
<p>导致“错误 19 ”的其他问题需要更多的努力来修复。虽然系统应该从 <span class="filename">ada0</span> 启动，但如果 <span class="filename">/etc/fstab</span> 不正确，将会出现选择 shell 的另一个提示。在引导加载程序提示符处输入 <code>ufs:/dev/ada0s1a</code> ，然后按下 <kbd>Enter</kbd> 。撤消 <span class="filename">/etc/fstab</span> 中的编辑，然后将文件系统从原始磁盘 (<span class="filename">ada0</span>) 挂载，而不是从镜像挂载。重新启动系统，然后再次尝试该过程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Enter full pathname of shell or RETURN <span class="k">for</span> /bin/sh:
<span class="c"># cp /etc/fstab.orig /etc/fstab</span>
<span class="c"># reboot</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_从磁盘故障中恢复">21.3.5. 从磁盘故障中恢复<a class="anchor" href="#_从磁盘故障中恢复"></a></h4>
<div class="paragraph">
<p>磁盘镜像的好处是，即使一个磁盘发生故障，镜像也不会丢失任何数据。在上面的例子中，如果 <span class="filename">ada0</span> 失效，镜像将继续工作，并从剩余的工作驱动器 <span class="filename">ada1</span> 提供数据。</p>
</div>
<div class="paragraph">
<p>要替换故障的驱动器，请关闭系统并将故障的驱动器物理上替换为容量相等或更大的新驱动器。制造商在以千兆字节为单位评估驱动器时使用了一些任意的值，唯一真正确定的方法是比较 <code>diskinfo -v</code> 显示的扇区总数。比镜像容量更大的驱动器也可以工作，尽管新驱动器上的额外空间将不会被使用。</p>
</div>
<div class="paragraph">
<p>在计算机重新启动后，镜像将以“降级”模式运行，只有一个驱动器。镜像被告知忘记当前未连接的驱动器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror forget gm0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <a href="#geom-mirror-metadata">元数据问题</a> 中的说明清除替换磁盘上的任何旧元数据。然后将替换磁盘（此示例中为 <span class="filename">ada4</span> ）插入到镜像中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gmirror insert gm0 /dev/ada4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当新驱动器插入到镜像中时，重新同步过程开始。将镜像数据复制到新驱动器可能需要一段时间。在复制过程中，镜像的性能将大大降低，因此最好在计算机需求较低时插入新驱动器。</p>
</div>
<div class="paragraph">
<p>可以使用 <code>gmirror status</code> 来监视进度，它会显示正在同步的驱动器以及完成的百分比。在重新同步期间，状态将显示为 <code>DEGRADED</code> ，当过程完成时，状态将变为 <code>COMPLETE</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="geom-raid3">21.4. RAID3 - 以字节为单位的条带化和专用奇偶校验<a class="anchor" href="#geom-raid3"></a></h3>
<div class="paragraph">
<p>RAID3 是一种将多个磁盘驱动器组合成一个具有专用奇偶校验磁盘的卷的方法。在 RAID3 系统中，数据被分割成多个字节，这些字节被写入阵列中的所有磁盘，除了一个充当专用奇偶校验磁盘的磁盘。这意味着从 RAID3 实现中读取磁盘时，会访问阵列中的所有磁盘。通过使用多个磁盘控制器，可以提高性能。 RAID3 阵列提供了 1 个驱动器的容错能力，同时提供了总容量为所有磁盘的总容量的 1-1/n 倍的容量，其中 n 是阵列中的硬盘数量。这种配置主要适用于存储较大的数据，如多媒体文件。</p>
</div>
<div class="paragraph">
<p>构建 RAID3 阵列至少需要 3 个物理硬盘。每个硬盘的大小必须相同，因为 I/O 请求会交错地并行读取或写入多个硬盘。此外，由于 RAID3 的特性，驱动器的数量必须等于 3 、 5 、 9 、 17 等，即 2 ^ n + 1 。</p>
</div>
<div class="paragraph">
<p>本节演示了如何在 FreeBSD 系统上创建一个软件 RAID3 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然理论上可以在 FreeBSD 上从 RAID3 阵列引导，但这种配置并不常见，也不建议使用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_创建一个专用的_raid3_阵列">21.4.1. 创建一个专用的 RAID3 阵列<a class="anchor" href="#_创建一个专用的_raid3_阵列"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 中，对 RAID3 的支持是通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid3&amp;sektion=8&amp;format=html">graid3(8)</a> GEOM 类实现的。在 FreeBSD 上创建一个专用的 RAID3 阵列需要以下步骤。</p>
</div>
<div class="olist arabic procedure">
<ol class="arabic">
<li>
<p>首先，通过执行以下命令之一加载内核模块 <span class="filename">geom_raid3.ko</span> ：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid3 load</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload geom_raid3</span></code></pre>
</div>
</div>
</li>
<li>
<p>确保存在一个合适的挂载点。此命令将创建一个新的目录作为挂载点使用：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /multimedia</span></code></pre>
</div>
</div>
</li>
<li>
<p>确定要添加到阵列中的磁盘的设备名称，并创建新的 RAID3 设备。最后列出的设备将作为专用奇偶校验磁盘。此示例使用三个未分区的 ATA 驱动器： <span class="filename">ada1</span> 和 <span class="filename">ada2</span> 用于数据，以及 <span class="filename">ada3</span> 用于奇偶校验。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid3 label -v gr0 /dev/ada1 /dev/ada2 /dev/ada3</span>
Metadata value stored on /dev/ada1.
Metadata value stored on /dev/ada2.
Metadata value stored on /dev/ada3.
Done.</code></pre>
</div>
</div>
</li>
<li>
<p>将新创建的 <span class="filename">gr0</span> 设备进行分区，并在其上放置一个 UFS 文件系统：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart create -s GPT /dev/raid3/gr0</span>
<span class="c"># gpart add -t freebsd-ufs /dev/raid3/gr0</span>
<span class="c"># newfs -j /dev/raid3/gr0p1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>许多数字将在屏幕上滑动，经过一段时间后，过程将完成。卷已创建并准备好挂载：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /dev/raid3/gr0p1 /multimedia/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>RAID3 阵列现在可以使用了。</p>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>需要进行额外的配置才能在系统重新启动后保留此设置。</p>
</div>
<div class="olist arabic procedure">
<ol class="arabic">
<li>
<p>在挂载阵列之前，必须加载 <span class="filename">geom_raid3.ko</span> 模块。为了在系统初始化期间自动加载内核模块，请将以下行添加到 <span class="filename">/boot/loader.conf</span> 文件中：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>geom_raid3_load=&#34;YES&#34;</pre>
</div>
</div>
</li>
<li>
<p>在系统启动过程中，必须将以下卷信息添加到 <span class="filename">/etc/fstab</span> 中，以便自动挂载阵列的文件系统：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/raid3/gr0p1	/multimedia	ufs	rw	2	2</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="geom-graid">21.5. 软件 RAID 设备<a class="anchor" href="#geom-graid"></a></h3>
<div class="paragraph">
<p>一些主板和扩展卡会添加一些简单的硬件，通常只是一个 ROM ，使得计算机可以从 RAID 阵列启动。启动后，对 RAID 阵列的访问由运行在计算机主处理器上的软件处理。这种“硬件辅助软件 RAID ”提供了不依赖于任何特定操作系统的 RAID 阵列，并且在加载操作系统之前就可以正常工作。</p>
</div>
<div class="paragraph">
<p>根据所使用的硬件，支持多个级别的 RAID 。有关完整列表，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 需要 <span class="filename">geom_raid.ko</span> 内核模块，该模块从 FreeBSD 9.1 开始包含在 <span class="filename">GENERIC</span> 内核中。如果需要，可以使用 <code>graid load</code> 命令手动加载该模块。</p>
</div>
<div class="sect3">
<h4 id="geom-graid-creating">21.5.1. 创建一个数组<a class="anchor" href="#geom-graid-creating"></a></h4>
<div class="paragraph">
<p>软件 RAID 设备通常在计算机启动时按下特殊键进入菜单。该菜单可用于创建和删除 RAID 阵列。 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 也可以直接从命令行创建阵列。</p>
</div>
<div class="paragraph">
<p><code>graid label</code> 用于创建一个新的阵列。本例中使用的主板具有 Intel 软件 RAID 芯片组，因此指定了 Intel 元数据格式。新的阵列被赋予了一个标签 <span class="filename">gm0</span> ，它是一个镜像（ RAID1 ），并使用驱动器 <span class="filename">ada0</span> 和 <span class="filename">ada1</span> 。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当将驱动器制作成新的阵列时，一些空间将被覆盖。请先备份现有数据！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid label Intel gm0 RAID1 ada0 ada1</span>
GEOM_RAID: Intel-a29ea104: Array Intel-a29ea104 created.
GEOM_RAID: Intel-a29ea104: Disk ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:0-ada0 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Array started.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from STARTING to OPTIMAL.
Intel-a29ea104 created
GEOM_RAID: Intel-a29ea104: Provider raid/r0 <span class="k">for </span>volume gm0 created.</code></pre>
</div>
</div>
<div class="paragraph">
<p>状态检查显示新的镜像已经准备就绪，可以使用了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class="o">(</span>ACTIVE <span class="o">(</span>ACTIVE<span class="o">))</span>
                  ada1 <span class="o">(</span>ACTIVE <span class="o">(</span>ACTIVE<span class="o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>数组设备出现在 [/dev/raid/]# 目录中。第一个数组被称为 [r0]# 。如果存在其他数组，它们将被称为 [r1]# 、 [r2]# 等等。</p>
</div>
<div class="paragraph">
<p>某些设备上的 BIOS 菜单可以创建带有特殊字符的数组名称。为了避免这些特殊字符带来的问题，数组被赋予简单的编号名称，例如 <span class="filename">r0</span> 。要显示实际的标签，例如上面的示例中的 <span class="filename">gm0</span> ，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl kern.geom.raid.name_format=1</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-volumes">21.5.2. 多个卷<a class="anchor" href="#geom-graid-volumes"></a></h4>
<div class="paragraph">
<p>一些软件 RAID 设备支持在阵列上创建多个卷。卷的工作方式类似于分区，允许将物理驱动器上的空间分割并以不同的方式使用。例如， Intel 软件 RAID 设备支持两个卷。此示例创建一个 40G 的镜像卷，用于安全存储操作系统，然后是一个 20G 的 RAID0 （条带）卷，用于快速临时存储。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid label -S 40G Intel gm0 RAID1 ada0 ada1</span>
<span class="c"># graid add -S 20G gm0 RAID0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>卷在 <code>/dev/raid/</code> 目录下以额外的 <code>.filename</code><mark>rX</mark> 条目显示。一个包含两个卷的阵列将显示 <code>.filename</code><mark>r0</mark> 和 <code>.filename</code><mark>r1</mark> 。</p>
</div>
<div class="paragraph">
<p>请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> ，了解不同软件 RAID 设备支持的卷数。</p>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-converting">21.5.3. 将单个驱动器转换为镜像<a class="anchor" href="#geom-graid-converting"></a></h4>
<div class="paragraph">
<p>在特定条件下，可以将现有的单个驱动器转换为 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 阵列而无需重新格式化。为了在转换过程中避免数据丢失，现有的驱动器必须满足以下最低要求：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>驱动器必须使用 MBR 分区方案进行分区。 GPT 或其他在驱动器末尾具有元数据的分区方案将被 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 元数据覆盖和损坏。</p>
</li>
<li>
<p>驱动器末尾必须有足够的未分区和未使用空间来容纳 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 元数据。这些元数据的大小各不相同，但最大的占用 64 M ，因此建议至少有这么多的可用空间。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果驱动器符合这些要求，请先进行完整备份。然后使用该驱动器创建一个单驱动器镜像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid label Intel gm0 RAID1 ada0 NONE</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 元数据被写入未使用空间的驱动器末尾。现在可以将第二个驱动器插入到镜像中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid insert raid/r0 ada1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>原始驱动器的数据将立即开始复制到第二个驱动器。在复制完成之前，镜像将以降级状态运行。</p>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-inserting">21.5.4. 将新驱动器插入阵列中<a class="anchor" href="#geom-graid-inserting"></a></h4>
<div class="paragraph">
<p>可以将驱动器插入到阵列中，作为替换已经故障或丢失的驱动器。如果没有故障或丢失的驱动器，新的驱动器将成为备用驱动器。例如，将新的驱动器插入到工作中的两个驱动器的镜像中，将得到一个带有一个备用驱动器的两个驱动器的镜像，而不是一个三个驱动器的镜像。</p>
</div>
<div class="paragraph">
<p>在镜像阵列的示例中，数据立即开始复制到新插入的驱动器上。新驱动器上的任何现有信息都将被覆盖。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid insert raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from NONE to ACTIVE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NONE to NEW.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 state changed from NEW to REBUILD.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-ada1 rebuild start at 0.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-removing">21.5.5. 从阵列中移除驱动器<a class="anchor" href="#geom-graid-removing"></a></h4>
<div class="paragraph">
<p>可以永久从阵列中移除单个驱动器，并擦除其元数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid remove raid/r0 ada1</span>
GEOM_RAID: Intel-a29ea104: Disk ada1 state changed from ACTIVE to OFFLINE.
GEOM_RAID: Intel-a29ea104: Subdisk gm0:1-[unknown] state changed from ACTIVE to NONE.
GEOM_RAID: Intel-a29ea104: Volume gm0 state changed from OPTIMAL to DEGRADED.</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-stopping">21.5.6. 停止数组<a class="anchor" href="#geom-graid-stopping"></a></h4>
<div class="paragraph">
<p>可以在不删除驱动器上的元数据的情况下停止数组。当系统启动时，数组将重新启动。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid stop raid/r0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-status">21.5.7. 检查数组状态<a class="anchor" href="#geom-graid-status"></a></h4>
<div class="paragraph">
<p>数组状态可以随时检查。在上面的示例中，当一个驱动器被添加到镜像中后，数据将从原始驱动器复制到新驱动器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid status</span>
   Name    Status  Components
raid/r0  DEGRADED  ada0 <span class="o">(</span>ACTIVE <span class="o">(</span>ACTIVE<span class="o">))</span>
                   ada1 <span class="o">(</span>ACTIVE <span class="o">(</span>REBUILD 28%<span class="o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>某些类型的阵列，例如 <code>RAID0</code> 或 <code>CONCAT</code> ，如果磁盘故障，可能不会在状态报告中显示。要查看这些部分故障的阵列，请添加 <code>-ga</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid status -ga</span>
          Name  Status  Components
Intel-e2d07d9a  BROKEN  ada6 <span class="o">(</span>ACTIVE <span class="o">(</span>ACTIVE<span class="o">))</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-deleting">21.5.8. 删除数组<a class="anchor" href="#geom-graid-deleting"></a></h4>
<div class="paragraph">
<p>通过删除数组中的所有卷，可以销毁数组。当删除最后一个存在的卷时，数组将停止，并且从驱动器中删除元数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid delete raid/r0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="geom-graid-unexpected">21.5.9. 删除意外的数组<a class="anchor" href="#geom-graid-unexpected"></a></h4>
<div class="paragraph">
<p>驱动器可能意外地包含 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 元数据，这可能是由于先前的使用或制造商的测试。 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 将检测到这些驱动器并创建一个阵列，从而干扰对单个驱动器的访问。要删除不需要的元数据：</p>
</div>
<div class="olist arabic procedure">
<ol class="arabic">
<li>
<p>启动系统。在启动菜单中，选择 <code>2</code> 进入加载器提示符。输入：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">OK <span class="nb">set </span>kern.geom.raid.enable<span class="o">=</span>0
OK boot</code></pre>
</div>
</div>
<div class="paragraph">
<p>系统将禁用 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 启动。</p>
</div>
</li>
<li>
<p>备份受影响驱动器上的所有数据。</p>
</li>
<li>
<p>作为一种解决方法，可以通过添加来禁用 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 阵列检测。</p>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.geom.raid.enable=0</pre>
</div>
</div>
<div class="paragraph">
<p>到 <span class="filename">/boot/loader.conf</span> 。</p>
</div>
<div class="paragraph">
<p>要永久删除受影响驱动器上的 <a href="https://man.freebsd.org/cgi/man.cgi?query=graid&amp;sektion=8&amp;format=html">graid(8)</a> 元数据，请启动 FreeBSD 安装 CD-ROM 或内存棒，并选择 <code>Shell</code> 。使用 <code>status</code> 命令找到阵列的名称，通常为 <code>raid/r0</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid status</span>
   Name   Status  Components
raid/r0  OPTIMAL  ada0 <span class="o">(</span>ACTIVE <span class="o">(</span>ACTIVE<span class="o">))</span>
                  ada1 <span class="o">(</span>ACTIVE <span class="o">(</span>ACTIVE<span class="o">))</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>按名称删除卷：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># graid delete raid/r0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果显示了多个卷，请为每个卷重复此过程。在删除最后一个阵列后，卷将被销毁。</p>
</div>
<div class="paragraph">
<p>重新启动并验证数据，如果需要的话，从备份中恢复。在元数据被删除后，还可以删除 <span class="filename">/boot/loader.conf</span> 中的 <code>kern.geom.raid.enable = 0</code> 条目。</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="geom-ggate">21.6. GEOM Gate Network 是一种计算机网络技术。<a class="anchor" href="#geom-ggate"></a></h3>
<div class="paragraph">
<p>GEOM 提供了一种简单的机制，通过使用 GEOM Gate 网络守护进程 ggated ，可以远程访问诸如磁盘、 CD 和文件系统等设备。拥有设备的系统运行服务器守护进程，处理客户端使用 ggatec 发出的请求。设备不应包含任何敏感数据，因为客户端和服务器之间的连接没有加密。</p>
</div>
<div class="paragraph">
<p>与 NFS 类似， ggated 也使用 exports 文件进行配置。该文件指定了哪些系统被允许访问导出的资源以及它们所提供的访问级别。例如，要给客户端 <code>192.168.1.5</code> 对第一个 SCSI 磁盘的第四个分区进行读写访问权限，可以在 <code>/etc/gg.exports</code> 文件中添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>192.168.1.5 RW /dev/da0s4d</pre>
</div>
</div>
<div class="paragraph">
<p>在导出设备之前，请确保它当前没有挂载。然后，启动 ggated ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ggated</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有几个选项可用于指定备用的监听端口或更改 exports 文件的默认位置。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ggated&amp;sektion=8&amp;format=html">ggated(8)</a> 。</p>
</div>
<div class="paragraph">
<p>要在客户端机器上访问导出的设备，首先使用 <code>ggatec</code> 指定服务器的 IP 地址和导出设备的设备名称。如果成功，该命令将显示一个要挂载的 <code>ggate</code> 设备名称。将指定的设备名称挂载到一个空闲的挂载点上。此示例连接到 <code>192.168.1.1</code> 上的 <code>/dev/da0s4d</code> 分区，然后将 <code>/dev/ggate0</code> 挂载到 <code>/mnt</code> 上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ggatec create -o rw 192.168.1.1 /dev/da0s4d</span>
ggate0
<span class="c"># mount /dev/ggate0 /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以通过客户端上的 <span class="filename">/mnt</span> 访问服务器上的设备。有关 <code>ggatec</code> 的更多详细信息和一些使用示例，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ggatec&amp;sektion=8&amp;format=html">ggatec(8)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果设备当前已在服务器或网络上的任何其他客户端上挂载，则挂载将失败。如果需要同时访问网络资源，请使用 NFS 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当设备不再需要时，使用 <code>umount</code> 命令卸载它，以便资源可以供其他客户端使用。</p>
</div>
</div>
<div class="sect2">
<h3 id="geom-glabel">21.7. 标记磁盘设备<a class="anchor" href="#geom-glabel"></a></h3>
<div class="paragraph">
<p>在系统初始化过程中， FreeBSD 内核会在发现设备时创建设备节点。这种探测设备的方法会引发一些问题。例如，如果通过 USB 添加了一个新的磁盘设备，那么很可能会将一个闪存设备分配为 <span class="filename">da0</span> 的设备名称，而原来的 <span class="filename">da0</span> 则会变成 <span class="filename">da1</span> 。这将导致挂载文件系统时出现问题，如果这些文件系统在 <span class="filename">/etc/fstab</span> 中列出，可能还会阻止系统启动。</p>
</div>
<div class="paragraph">
<p>一种解决方案是按顺序连接 SCSI 设备，这样添加到 SCSI 卡的新设备将被分配未使用的设备号。但是对于可能替换主要 SCSI 磁盘的 USB 设备怎么办？这是因为 USB 设备通常在 SCSI 卡之前进行探测。一种解决方案是在系统启动后再插入这些设备。另一种方法是只使用单个 ATA 驱动器，并且在 /etc/fstab 中不列出 SCSI 设备。</p>
</div>
<div class="paragraph">
<p>更好的解决方案是使用 <code>glabel</code> 为磁盘设备添加标签，并在 <code>/etc/fstab</code> 中使用这些标签。由于 <code>glabel</code> 将标签存储在给定提供者的最后一个扇区中，因此标签将在重新启动后保持持久。通过将此标签作为设备，文件系统可以始终被挂载，无论通过哪个设备节点进行访问。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>glabel</code> 可以创建临时标签和永久标签。只有永久标签在重新启动后保持一致。有关标签之间差异的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_标签类型和示例">21.7.1. 标签类型和示例<a class="anchor" href="#_标签类型和示例"></a></h4>
<div class="paragraph">
<p>永久标签可以是通用标签或文件系统标签。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> 创建永久文件系统标签。这些类型的标签将在 <span class="filename">/dev</span> 的子目录中创建，并根据文件系统类型进行命名。例如， UFS2 文件系统标签将在 <span class="filename">/dev/ufs</span> 中创建。可以使用 <code>glabel label</code> 创建通用永久标签。这些标签不特定于文件系统，并将在 <span class="filename">/dev/label</span> 中创建。</p>
</div>
<div class="paragraph">
<p>临时标签在下次重启时被销毁。这些标签是在 [/dev/label] 中创建的，适用于实验。可以使用 <code>glabel create</code> 命令创建临时标签。</p>
</div>
<div class="paragraph">
<p>要为 UFS2 文件系统创建一个永久标签而不破坏任何数据，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tunefs -L home /dev/da3</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在应该在 <span class="filename">/dev/ufs</span> 中存在一个标签，可以将其添加到 <span class="filename">/etc/fstab</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/ufs/home		/home            ufs     rw              2      2</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在尝试运行 <code>tunefs</code> 时，文件系统不能被挂载。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在可以挂载文件系统了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从这一点开始，只要在启动时加载了 <span class="filename">geom_label.ko</span> 内核模块，并且在 <span class="filename">/boot/loader.conf</span> 中或者存在 <code>GEOM_LABEL</code> 内核选项，设备节点可以在不对系统产生任何不良影响的情况下发生变化。</p>
</div>
<div class="paragraph">
<p>使用 <code>newfs</code> 命令和 <code>-L</code> 选项可以创建带有默认标签的文件系统。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=newfs&amp;sektion=8&amp;format=html">newfs(8)</a> 。</p>
</div>
<div class="paragraph">
<p>可以使用以下命令来销毁标签：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># glabel destroy home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下面的示例展示了如何为引导磁盘的分区添加标签。</p>
</div>
<div class="exampleblock">
<div class="title">例 32. 在引导磁盘上标记分区</div>
<div class="content">
<div class="paragraph">
<p>通过对引导磁盘上的分区进行永久标记，即使将磁盘移动到另一个控制器或转移到不同的系统，系统也应能够继续正常引导。对于本示例，假设使用单个 ATA 磁盘，系统当前将其识别为 <span class="filename">ad0</span> 。还假设使用标准的 FreeBSD 分区方案，包括 <span class="filename">/</span> 、 <span class="filename">/var</span> 、 <span class="filename">/usr</span> 和 <span class="filename">/tmp</span> ，以及一个交换分区。</p>
</div>
<div class="paragraph">
<p>重新启动系统，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> 提示符下，按下 <kbd>4</kbd> 键进入单用户模式。然后输入以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># glabel label rootfs /dev/ad0s1a</span>
GEOM_LABEL: Label <span class="k">for </span>provider /dev/ad0s1a is label/rootfs
<span class="c"># glabel label var /dev/ad0s1d</span>
GEOM_LABEL: Label <span class="k">for </span>provider /dev/ad0s1d is label/var
<span class="c"># glabel label usr /dev/ad0s1f</span>
GEOM_LABEL: Label <span class="k">for </span>provider /dev/ad0s1f is label/usr
<span class="c"># glabel label tmp /dev/ad0s1e</span>
GEOM_LABEL: Label <span class="k">for </span>provider /dev/ad0s1e is label/tmp
<span class="c"># glabel label swap /dev/ad0s1b</span>
GEOM_LABEL: Label <span class="k">for </span>provider /dev/ad0s1b is label/swap
<span class="c"># exit</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>系统将继续进行多用户引导。引导完成后，编辑 [/etc/fstab] 文件，并用相应的标签替换传统设备名称。最终的 [/etc/fstab] 文件将如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                Mountpoint      FStype  Options         Dump    Pass#
/dev/label/swap         none            swap    sw              0       0
/dev/label/rootfs       /               ufs     rw              1       1
/dev/label/tmp          /tmp            ufs     rw              2       2
/dev/label/usr          /usr            ufs     rw              2       2
/dev/label/var          /var            ufs     rw              2       2</pre>
</div>
</div>
<div class="paragraph">
<p>系统现在可以重新启动。如果一切顺利，它将正常启动，并且 <code>mount</code> 命令将显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount</span>
/dev/label/rootfs on / <span class="o">(</span>ufs, <span class="nb">local</span><span class="o">)</span>
devfs on /dev <span class="o">(</span>devfs, <span class="nb">local</span><span class="o">)</span>
/dev/label/tmp on /tmp <span class="o">(</span>ufs, <span class="nb">local</span>, soft-updates<span class="o">)</span>
/dev/label/usr on /usr <span class="o">(</span>ufs, <span class="nb">local</span>, soft-updates<span class="o">)</span>
/dev/label/var on /var <span class="o">(</span>ufs, <span class="nb">local</span>, soft-updates<span class="o">)</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=glabel&amp;sektion=8&amp;format=html">glabel(8)</a> 类支持基于唯一文件系统 id <code>ufsid</code> 的 UFS 文件系统的标签类型。这些标签可以在 <span class="filename">/dev/ufsid</span> 中找到，并在系统启动时自动创建。可以使用 <code>ufsid</code> 标签来使用 <span class="filename">/etc/fstab</span> 挂载分区。使用 <code>glabel status</code> 命令可以获取文件系统及其对应的 <code>ufsid</code> 标签列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>glabel status
                  Name  Status  Components
ufsid/486b6fc38d330916     N/A  ad4s1d
ufsid/486b6fc16926168e     N/A  ad4s1f</code></pre>
</div>
</div>
<div class="paragraph">
<p>在上面的示例中， <span class="filename">ad4s1d</span> 表示 <span class="filename">/var</span> ，而 <span class="filename">ad4s1f</span> 表示 <span class="filename">/usr</span> 。使用所示的 <code>ufsid</code> 值，可以使用以下条目在 <span class="filename">/etc/fstab</span> 中挂载这些分区：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/ufsid/486b6fc38d330916        /var        ufs        rw        2      2
/dev/ufsid/486b6fc16926168e        /usr        ufs        rw        2      2</pre>
</div>
</div>
<div class="paragraph">
<p>任何带有 <code>ufsid</code> 标签的分区都可以通过这种方式挂载，无需手动创建永久标签，同时仍然可以享受设备名称无关挂载的好处。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="geom-gjournal">21.8. 通过 GEOM 实现的 UFS 日志记录<a class="anchor" href="#geom-gjournal"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 上，支持 UFS 文件系统的日志功能。该实现通过 GEOM 子系统提供，并使用 <code>gjournal</code> 进行配置。与其他文件系统日志实现不同， <code>gjournal</code> 方法是基于块的，而不是作为文件系统的一部分实现的。它是一个 GEOM 扩展。</p>
</div>
<div class="paragraph">
<p>日志记录存储了文件系统事务的日志，例如在元数据和文件写入到磁盘之前构成完整磁盘写入操作的更改。可以通过重新播放事务日志来重做文件系统事务，以防止文件系统不一致性。</p>
</div>
<div class="paragraph">
<p>这种方法提供了另一种机制来防止文件系统的数据丢失和不一致性。与跟踪和强制执行元数据更新的软更新以及创建文件系统镜像的快照不同，日志是专门用于此任务的磁盘空间中存储的。为了提高性能，日志可以存储在另一个磁盘上。在这种配置中，应该在要启用日志记录的设备之后列出日志提供者或存储设备。</p>
</div>
<div class="paragraph">
<p><span class="filename">GENERIC</span> 内核提供对 <code>gjournal</code> 的支持。要在启动时自动加载 <span class="filename">geom_journal.ko</span> 内核模块，请将以下行添加到 <span class="filename">/boot/loader.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>geom_journal_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果使用自定义内核，请确保以下行在内核配置文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options	GEOM_JOURNAL</pre>
</div>
</div>
<div class="paragraph">
<p>一旦模块加载完成，可以按照以下步骤在新的文件系统上创建一个日志。在这个例子中， <span class="filename">da4</span> 是一个新的 SCSI 磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gjournal load</span>
<span class="c"># gjournal label /dev/da4</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将加载模块并在 /dev/da4 上创建一个设备节点 /dev/da4.journal 。</p>
</div>
<div class="paragraph">
<p>现在可以在日志设备上创建 UFS 文件系统，然后将其挂载到现有的挂载点上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># newfs -O 2 -J /dev/da4.journal</span>
<span class="c"># mount /dev/da4.journal /mnt</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在多个切片的情况下，将为每个单独的切片创建一个日志。例如，如果 <span class="filename">ad4s1</span> 和 <span class="filename">ad4s2</span> 都是切片，那么 <code>gjournal</code> 将创建 <span class="filename">ad4s1.journal</span> 和 <span class="filename">ad4s2.journal</span> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用 <code>tunefs</code> 在当前文件系统上启用日志记录。然而，在尝试更改现有文件系统之前， <strong> 一定要 </strong> 先备份数据。在大多数情况下，如果无法创建日志， <code>gjournal</code> 将失败，但这并不能保护免受错误使用 <code>tunefs</code> 导致的数据丢失。有关这些命令的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gjournal&amp;sektion=8&amp;format=html">gjournal(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=tunefs&amp;sektion=8&amp;format=html">tunefs(8)</a> 。</p>
</div>
<div class="paragraph">
<p>可以对 FreeBSD 系统的引导磁盘进行日志记录。有关详细说明，请参阅文章《在桌面 PC 上实现 UFS 日志记录》（ extref:{gjournal-desktop} ）。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="zfs">Chapter 22. Z 文件系统（ZFS）<a class="anchor" href="#zfs"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>ZFS 是一种先进的文件系统，旨在解决以前存储子系统软件中存在的主要问题。</p>
</div>
<div class="paragraph">
<p>最初由 Sun™ 开发，持续的开源 ZFS 开发已经转移到了 <a href="http://open-zfs.org">OpenZFS 项目</a>。</p>
</div>
<div class="paragraph">
<p>ZFS 有三个主要的设计目标：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>数据完整性：所有数据都包含数据的校验和。ZFS 会计算校验和并将其与数据一起写入。当以后读取该数据时，ZFS 会重新计算校验和。如果校验和不匹配，即检测到一个或多个数据错误，ZFS 将尝试在可用的副本、镜像或奇偶块时自动纠正错误。</p>
</li>
<li>
<p>汇集存储：将物理存储设备添加到一个池中，并从该共享池中分配存储空间。空间可供所有文件系统和卷使用，并通过在池中添加新的存储设备来增加空间。</p>
</li>
<li>
<p>性能：缓存机制提供了更高的性能。<a href="#zfs-term-arc">ARC</a> 是一种先进的基于内存的读取缓存。ZFS 提供了第二级基于磁盘的读取缓存 <a href="#zfs-term-l2arc">L2ARC</a> ，以及一种基于磁盘的同步写入缓存，名为 <a href="#zfs-term-zil">ZIL</a>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>完整的功能和术语列表请参见 <a href="#zfs-term">ZFS 功能和术语</a>。</p>
</div>
<div class="sect2">
<h3 id="zfs-differences">22.1. ZFS 有何不同之处<a class="anchor" href="#zfs-differences"></a></h3>
<div class="paragraph">
<p>ZFS 不仅仅是一个文件系统，它在根本上与传统的文件系统有所不同。将卷管理器和文件系统的传统分离角色结合起来，为 ZFS 提供了独特的优势。文件系统现在能够意识到底层磁盘的结构。传统的文件系统一次只能存在于单个磁盘上。如果有两个磁盘，那么就需要创建两个单独的文件系统。传统的硬件 RAID 配置通过将操作系统呈现为由物理磁盘提供的空间组成的单个逻辑磁盘来避免这个问题，操作系统在其上放置一个文件系统。即使使用像 GEOM 提供的软件 RAID 解决方案，位于 RAID 之上的 UFS 文件系统也认为它正在处理一个单一设备。 ZFS 的卷管理器和文件系统的组合解决了这个问题，并允许创建共享可用存储池的文件系统。 ZFS 意识到物理磁盘布局的一个重要优势是，当向池中添加额外的磁盘时，现有的文件系统会自动增长。然后，这个新空间就可以供文件系统使用。 ZFS 还可以为每个文件系统应用不同的属性。这使得创建单独的文件系统和数据集比创建单个的整体文件系统更有用。</p>
</div>
</div>
<div class="sect2">
<h3 id="zfs-quickstart">22.2. 快速入门指南<a class="anchor" href="#zfs-quickstart"></a></h3>
<div class="paragraph">
<p>FreeBSD 可以在系统初始化期间挂载 ZFS 池和数据集。要启用它，请将以下行添加到 <span class="filename">/etc/rc.conf</span>: 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>zfs_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后启动服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service zfs start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>本节中的示例假设有三个 SCSI 磁盘，设备名称分别为 <span class="filename">da0</span>、<span class="filename">da1</span> 和 <span class="filename">da2</span> 。使用 SATA 硬件的用户应该使用 <span class="filename">ada</span> 设备名称。</p>
</div>
<div class="sect3">
<h4 id="zfs-quickstart-single-disk-pool">22.2.1. 单磁盘池<a class="anchor" href="#zfs-quickstart-single-disk-pool"></a></h4>
<div class="paragraph">
<p>要使用单个磁盘设备创建一个简单且非冗余的池，请按以下步骤操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create example /dev/da0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要查看新的存储池，请查看 <code>df</code> 命令的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235230  1628718    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032846 48737598     2%    /usr
example      17547136       0 17547136     0%    /example</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个输出显示了创建和挂载 <code>example</code> 池，并且现在可以作为文件系统访问。为用户创建文件以供浏览：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /example</span>
<span class="c"># ls</span>
<span class="c"># touch testfile</span>
<span class="c"># ls -al</span>
total 4
drwxr-xr-x   2 root  wheel    3 Aug 29 23:15 .
drwxr-xr-x  21 root  wheel  512 Aug 29 23:12 ..
-rw-r--r--   1 root  wheel    0 Aug 29 23:15 testfile</code></pre>
</div>
</div>
<div class="paragraph">
<p>此池尚未使用任何高级的 ZFS 功能和属性。要在此池上创建启用了压缩的数据集，请执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create example/compressed</span>
<span class="c"># zfs set compression=gzip example/compressed</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>example/compressed</code> 数据集现在是一个 ZFS 压缩文件系统。尝试将一些大文件复制到 <code>/example/compressed</code>。</p>
</div>
<div class="paragraph">
<p>禁用压缩功能：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set compression=off example/compressed</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要卸载文件系统，请使用 <code>zfs umount</code> 命令，然后使用 <code>df</code> 命令进行验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs umount example/compressed</span>
<span class="c"># df</span>
Filesystem  1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a   2026030  235232  1628716    13%    /
devfs               1       1        0   100%    /dev
/dev/ad0s1d  54098308 1032864 48737580     2%    /usr
example      17547008       0 17547008     0%    /example</code></pre>
</div>
</div>
<div class="paragraph">
<p>要重新挂载文件系统以使其再次可访问，请使用 <code>zfs mount</code> 命令，并使用 <code>df</code> 命令进行验证：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs mount example/compressed</span>
<span class="c"># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed</code></pre>
</div>
</div>
<div class="paragraph">
<p>运行 <code>mount</code> 命令会显示池和文件系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount</span>
/dev/ad0s1a on / <span class="o">(</span>ufs, <span class="nb">local</span><span class="o">)</span>
devfs on /dev <span class="o">(</span>devfs, <span class="nb">local</span><span class="o">)</span>
/dev/ad0s1d on /usr <span class="o">(</span>ufs, <span class="nb">local</span>, soft-updates<span class="o">)</span>
example on /example <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span>
example/compressed on /example/compressed <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建后，可以像任何文件系统一样使用 ZFS 数据集。根据需要，可以在每个数据集上设置其他可用的功能。下面的示例创建了一个名为 <code>data</code> 的新文件系统。它假设该文件系统包含重要文件，并将其配置为存储每个数据块的两个副本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create example/data</span>
<span class="c"># zfs set copies=2 example/data</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>df</code> 命令查看数据和空间使用情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># df</span>
Filesystem         1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a          2026030  235234  1628714    13%    /
devfs                      1       1        0   100%    /dev
/dev/ad0s1d         54098308 1032864 48737580     2%    /usr
example             17547008       0 17547008     0%    /example
example/compressed  17547008       0 17547008     0%    /example/compressed
example/data        17547008       0 17547008     0%    /example/data</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，池中的所有文件系统都具有相同的可用空间。在这些示例中使用 <code>df</code> 命令显示，文件系统使用它们所需的空间，并且都从同一个池中获取。 ZFS 摒弃了卷和分区等概念，允许多个文件系统共享同一个池。</p>
</div>
<div class="paragraph">
<p>销毁不再需要的文件系统和池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs destroy example/compressed</span>
<span class="c"># zfs destroy example/data</span>
<span class="c"># zpool destroy example</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-quickstart-raid-z">22.2.2. RAID-Z<a class="anchor" href="#zfs-quickstart-raid-z"></a></h4>
<div class="paragraph">
<p>磁盘会出现故障。避免因磁盘故障导致数据丢失的一种方法是使用 RAID。ZFS 在其存储池设计中支持此功能。 RAID-Z 存储池需要三个或更多的磁盘，但提供比镜像存储池更多的可用空间。</p>
</div>
<div class="paragraph">
<p>这个示例创建了一个 RAID-Z 池，指定要添加到池中的磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create storage raidz da0 da1 da2</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Sun™ 建议在 RAID-Z 配置中使用的设备数量应在三到九之间。对于需要由 10 个或更多磁盘组成的单个池的环境，考虑将其分成较小的 RAID-Z 组。如果有两个磁盘可用，可以使用 ZFS 镜像提供冗余性（如果需要）。有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>前面的示例创建了名为 <code>storage</code> 的 <code>zpool</code> 。这个示例在该池中创建了一个名为 <code>home</code> 的新文件系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create storage/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启用压缩并存储目录和文件的额外副本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set copies=2 storage/home</span>
<span class="c"># zfs set compression=gzip storage/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要将此目录设置为用户的新家目录，请将用户数据复制到此目录并创建相应的符号链接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp -rp /home/* /storage/home</span>
<span class="c"># rm -rf /home /usr/home</span>
<span class="c"># ln -s /storage/home /home</span>
<span class="c"># ln -s /storage/home /usr/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>用户数据现在存储在新创建的 <span class="filename">/storage/home</span> 上。通过添加一个新用户并以该用户身份登录来进行测试。</p>
</div>
<div class="paragraph">
<p>创建一个文件系统快照，以便以后可以回滚：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot storage/home@08-30-08</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>ZFS 创建数据集的快照，而不是单个目录或文件。</p>
</div>
<div class="paragraph">
<p><code>@</code> 字符是文件系统名称或卷名称之间的分隔符。在删除重要目录之前，先备份文件系统，然后回滚到一个早期的快照，其中目录仍然存在：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs rollback storage/home@08-30-08</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要列出所有可用的快照，请在文件系统的 <code>.zfs/snapshot</code> 目录中运行 <code>ls</code> 命令。例如，要查看已拍摄的快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls /storage/home/.zfs/snapshot</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编写一个脚本来定期对用户数据进行快照。随着时间的推移，快照可能会占用大量的磁盘空间。使用以下命令删除先前的快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs destroy storage/home@08-30-08</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>经过测试，使用以下命令将 <span class="filename">/storage/home</span> 设置为真实的 <span class="filename">/home</span>：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set mountpoint=/home storage/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>运行 <code>df</code> 和 <code>mount</code> 命令来确认系统现在将文件系统视为真实的 <span class="filename">/home</span> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount</span>
/dev/ad0s1a on / <span class="o">(</span>ufs, <span class="nb">local</span><span class="o">)</span>
devfs on /dev <span class="o">(</span>devfs, <span class="nb">local</span><span class="o">)</span>
/dev/ad0s1d on /usr <span class="o">(</span>ufs, <span class="nb">local</span>, soft-updates<span class="o">)</span>
storage on /storage <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span>
storage/home on /home <span class="o">(</span>zfs, <span class="nb">local</span><span class="o">)</span>
<span class="c"># df</span>
Filesystem   1K-blocks    Used    Avail Capacity  Mounted on
/dev/ad0s1a    2026030  235240  1628708    13%    /
devfs                1       1        0   100%    /dev
/dev/ad0s1d   54098308 1032826 48737618     2%    /usr
storage       26320512       0 26320512     0%    /storage
storage/home  26320512       0 26320512     0%    /home</code></pre>
</div>
</div>
<div class="paragraph">
<p>这样就完成了 RAID-Z 的配置。通过将以下行添加到 <span class="filename">/etc/periodic.conf</span> ，可以将关于创建的文件系统的每日状态更新添加到夜间的 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 运行中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>daily_status_zfs_enable=&#34;YES&#34;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-quickstart-recovering-raid-z">22.2.3. 恢复 RAID-Z<a class="anchor" href="#zfs-quickstart-recovering-raid-z"></a></h4>
<div class="paragraph">
<p>每个软件 RAID 都有一种监控其 <code>state</code> 的方法。使用以下命令查看 RAID-Z 设备的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status -x</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果所有池都处于 <a href="#zfs-term-online">在线</a> 状态，并且一切正常，消息将显示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">all pools are healthy</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果出现问题，比如磁盘处于 <a href="#zfs-term-offline">离线</a> 状态，池的状态将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">  pool: storage
 state: DEGRADED
status: One or more devices has been taken offline by the administrator.
	Sufficient replicas exist <span class="k">for </span>the pool to <span class="k">continue </span>functioning <span class="k">in </span>a
	degraded state.
action: Online the device using <span class="s1">&#39;zpool online&#39;</span> or replace the device with
	<span class="s1">&#39;zpool replace&#39;</span>.
 scrub: none requested
config:

	NAME        STATE     READ WRITE CKSUM
	storage     DEGRADED     0     0     0
	  raidz1    DEGRADED     0     0     0
	    da0     ONLINE       0     0     0
	    da1     OFFLINE      0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>&#34;OFFLINE&#34;显示管理员使用以下方式将 <span class="filename">da1</span> 下线：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool offline storage da1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>立即关闭计算机并更换 <span class="filename">da1</span>。重新启动计算机并将 <span class="filename">da1</span> 返回到池中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool replace storage da1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，再次检查状态，这次不使用 <code>-x</code> 选项以显示所有的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: resilver completed with 0 errors on Sat Aug 30 19:44:11 2008
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，一切都正常。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-quickstart-data-verification">22.2.4. 数据验证<a class="anchor" href="#zfs-quickstart-data-verification"></a></h4>
<div class="paragraph">
<p>ZFS 使用校验和来验证存储数据的完整性。创建文件系统时会自动启用校验和功能。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>禁用校验和是可以的，但 <strong>不推荐</strong> ！校验和占用很少的存储空间，并提供数据完整性。大多数 ZFS 功能在禁用校验和的情况下将无法正常工作。禁用这些校验和不会明显提高性能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>验证数据校验和（称为 <em>scrubbing</em> ）可以确保 <code>storage</code> 池的完整性，具体操作如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool scrub storage</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一个 scrub 的持续时间取决于存储的数据量。数据量越大，验证所需的时间就越长。由于 scrub 是 I/O 密集型操作， ZFS 只允许同时运行一个 scrub。在 scrub 完成后，可以使用 <code>zpool status</code> 命令查看状态。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status storage</span>
 pool: storage
 state: ONLINE
 scrub: scrub completed with 0 errors on Sat Jan 26 19:57:37 2013
config:

	NAME        STATE     READ WRITE CKSUM
	storage     ONLINE       0     0     0
	  raidz1    ONLINE       0     0     0
	    da0     ONLINE       0     0     0
	    da1     ONLINE       0     0     0
	    da2     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>显示最后一次清 scrub 的完成日期有助于决定何时开始下一次 scrub。例行 scrub 有助于保护数据免受静默损坏，并确保池的完整性。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=8&amp;format=html">zfs(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a> 了解其他 ZFS 选项。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zpool">22.3. <code>zpool</code> 管理<a class="anchor" href="#zfs-zpool"></a></h3>
<div class="paragraph">
<p>ZFS 管理使用两个主要工具。 <code>zpool</code> 工具控制池的操作，允许添加、删除、替换和管理磁盘。<a href="#zfs-zfs"><code>zfs</code></a> 工具允许创建、销毁和管理数据集，包括 <a href="#zfs-term-filesystem">文件系统</a> 和 <a href="#zfs-term-volume">卷</a>。</p>
</div>
<div class="sect3">
<h4 id="zfs-zpool-create">22.3.1. 创建和销毁存储池<a class="anchor" href="#zfs-zpool-create"></a></h4>
<div class="paragraph">
<p>创建一个 ZFS 存储池需要做出永久性的决策，因为在创建后无法更改池的结构。最重要的决策是将物理磁盘分组成哪种类型的 vdev 。有关可能选项的详细信息，请参阅 <a href="#zfs-term-vdev">vdev 类型 </a> 列表。创建池后，大多数 vdev 类型不允许向 vdev 添加磁盘。例外情况是镜像，它允许向 vdev 添加新磁盘，并且条带可以通过将新磁盘附加到 vdev 来升级为镜像。虽然添加新的 vdev 可以扩展池，但池的布局在创建后无法更改。取而代之的是备份数据，销毁池，然后重新创建池。</p>
</div>
<div class="paragraph">
<p>创建一个简单的镜像池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create mypool mirror /dev/ada1 /dev/ada2</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用单个命令创建多个 vdev ，请使用以 vdev 类型关键字 <code>mirror</code> 分隔的磁盘组。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create mypool mirror /dev/ada1 /dev/ada2 mirror /dev/ada3 /dev/ada4</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada1    ONLINE       0     0     0
            ada2    ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada3    ONLINE       0     0     0
            ada4    ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>池还可以使用分区而不是整个磁盘。将 ZFS 放在单独的分区中可以使同一磁盘具有其他用途的分区。特别是，它允许添加带有引导代码和用于引导的文件系统的分区。这样就可以从同时也是池成员的磁盘启动。在 FreeBSD 上，使用分区而不是整个磁盘时， ZFS 不会带来性能损失。使用分区还允许管理员对磁盘进行“欠配置”，使用不到全部容量。如果将来替换的磁盘与原始磁盘的名义大小相同，但实际容量略小，较小的分区仍将适应替换磁盘。</p>
</div>
<div class="paragraph">
<p>使用分区创建一个 <a href="#zfs-term-vdev-raidz">RAID-Z2</a> 池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create mypool raidz2 /dev/ada0p3 /dev/ada1p3 /dev/ada2p3 /dev/ada3p3 /dev/ada4p3 /dev/ada5p3</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>销毁一个不再需要的池以重用磁盘。销毁池需要先卸载该池中的文件系统。如果有任何数据集正在使用中，卸载操作将失败，不会销毁池。可以使用 <code>-f</code> 强制销毁池。这可能会导致应用程序中对这些数据集有打开文件的未定义行为。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-attach">22.3.2. 添加和移除设备<a class="anchor" href="#zfs-zpool-attach"></a></h4>
<div class="paragraph">
<p>有两种方法可以将磁盘添加到池中：使用 <code>zpool attach</code> 将磁盘附加到现有的 vdev 上，或者使用 <code>zpool add</code> 将 vdev 添加到池中。一些 <a href="#zfs-term-vdev">vdev 类型 </a> 允许在创建后向 vdev 添加磁盘。</p>
</div>
<div class="paragraph">
<p>使用单个磁盘创建的池缺乏冗余性。它可以检测到损坏，但无法修复，因为没有其他数据的副本。 <a href="#zfs-term-copies">副本</a> 属性可以从小故障（如坏扇区）中恢复，但不提供与镜像或 RAID-Z 相同级别的保护。从由单个磁盘 vdev 组成的池开始，使用 <code>zpool attach</code> 将新磁盘添加到 vdev 中，创建镜像。还可以使用 <code>zpool attach</code> 将新磁盘添加到镜像组，增加冗余性和读取性能。在为池分区的磁盘上，将第一个磁盘的布局复制到第二个磁盘上。使用 <code>gpart backup</code> 和 <code>gpart restore</code> 可以使这个过程更容易。</p>
</div>
<div class="paragraph">
<p>通过连接 <span class="filename">ada0p3</span>，将单个磁盘（条带）vdev <span class="filename">ada1p3</span> 升级为镜像：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          ada0p3    ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool attach mypool ada0p3 ada1p3</span>
Make sure to <span class="nb">wait </span><span class="k">until </span>resilvering finishes before rebooting.

If you boot from pool <span class="s1">&#39;mypool&#39;</span>, you may need to update boot code on newly attached disk _ada1p3_.

Assuming you use GPT partitioning and _da0_ is your new boot disk you may use the following <span class="nb">command</span>:

        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span>
bootcode written to ada1
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class="k">continue </span>to <span class="k">function</span>, possibly <span class="k">in </span>a degraded state.
action: Wait <span class="k">for </span>the resilver to complete.
  scan: resilver <span class="k">in </span>progress since Fri May 30 08:19:19 2014
        527M scanned out of 781M at 47.9M/s, 0h0m to go
        527M resilvered, 67.53% <span class="k">done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0  <span class="o">(</span>resilvering<span class="o">)</span>

errors: No known data errors
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:15:58 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>当无法将磁盘添加到现有的 vdev 时，例如对于 RAID-Z ，一种替代方法是向池中添加另一个 vdev 。添加 vdev 可以通过在 vdev 之间分布写操作来提供更高的性能。每个 vdev 都提供自己的冗余性。可以混合使用 <code>mirror</code> 和 <code>RAID-Z</code> 等不同类型的 vdev ，但不建议这样做。向包含镜像或 RAID-Z vdev 的池中添加一个非冗余的 vdev 会对整个池中的数据造成风险。分布写操作意味着非冗余磁盘的故障将导致丢失对池中每个块的一部分数据。</p>
</div>
<div class="paragraph">
<p>ZFS 将数据跨越每个 vdev 进行条带化。例如，使用两个镜像 vdev ，这实际上是一个 RAID 10，将写操作跨越两组镜像。ZFS 分配空间以使每个 vdev 在同一时间达到 100 ％的使用率。如果 vdev 具有不同数量的可用空间，性能将降低，因为更多的数据写入将发送到使用率较低的 vdev。</p>
</div>
<div class="paragraph">
<p>在将新设备连接到引导池时，请记得更新引导代码。</p>
</div>
<div class="paragraph">
<p>将第二个镜像组（<span class="filename">ada2p3</span> 和 <span class="filename">ada3p3</span>）附加到现有的镜像中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:19:35 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool add mypool mirror ada2p3 ada3p3</span>
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
bootcode written to ada2
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada3</span>
bootcode written to ada3
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
          mirror-1  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>从池中删除 vdev 是不可能的，如果剩余的冗余足够，从镜像中删除磁盘是独占的。如果镜像组中只剩下一个磁盘，该组将不再是镜像，而变成条带，如果该剩余磁盘故障，将会危及整个池。</p>
</div>
<div class="paragraph">
<p>从三路镜像组中移除一个磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool detach mypool ada2p3</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>0h0m with 0 errors on Fri May 30 08:29:51 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-status">22.3.3. 检查池的状态<a class="anchor" href="#zfs-zpool-status"></a></h4>
<div class="paragraph">
<p>池状态非常重要。如果驱动器离线或 ZFS 检测到读取、写入或校验错误，相应的错误计数会增加。<code>status</code> 输出显示了池中每个设备的配置和状态，以及整个池的状态。还显示了要采取的操作和有关上次 <a href="#zfs-zpool-scrub"><code>scrub</code></a> 的详细信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub repaired 0 <span class="k">in </span>2h25m with 0 errors on Sat Sep 14 04:25:50 2013
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-clear">22.3.4. 清除错误<a class="anchor" href="#zfs-zpool-clear"></a></h4>
<div class="paragraph">
<p>当检测到错误时，ZFS 会增加读取、写入或校验和错误计数。使用 <code>zpool clear <em>mypool</em></code> 命令清除错误消息并重置计数。清除错误状态对于自动化脚本非常重要，这些脚本在池遇到错误时会通知管理员。如果不清除旧错误，这些脚本可能无法报告后续的错误。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-replace">22.3.5. 替换一个正常工作的设备<a class="anchor" href="#zfs-zpool-replace"></a></h4>
<div class="paragraph">
<p>可能需要用不同的磁盘替换一个磁盘。当替换一个工作中的磁盘时，该过程会在替换期间保持旧磁盘在线。池永远不会进入 <a href="#zfs-term-degraded">降级</a> 状态，从而降低数据丢失的风险。运行 <code>zpool replace</code> 命令将数据从旧磁盘复制到新磁盘。操作完成后， ZFS 会将旧磁盘与 vdev 断开连接。如果新磁盘比旧磁盘大，可能可以使用新空间来扩展 zpool 。请参见 <a href="#zfs-zpool-online">扩展池</a> 。</p>
</div>
<div class="paragraph">
<p>替换池中的一个正常工作设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool replace mypool ada1p3 ada2p3</span>
Make sure to <span class="nb">wait </span><span class="k">until </span>resilvering finishes before rebooting.

When booting from the pool <span class="s1">&#39;zroot&#39;</span>, update the boot code on the newly attached disk <span class="s1">&#39;ada2p3&#39;</span>.

Assuming GPT partitioning is used and <span class="o">[</span>.filename]#da0# is the new boot disk, use the following <span class="nb">command</span>:

        gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 da0
<span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada2</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: One or more devices is currently being resilvered.  The pool will
        <span class="k">continue </span>to <span class="k">function</span>, possibly <span class="k">in </span>a degraded state.
action: Wait <span class="k">for </span>the resilver to complete.
  scan: resilver <span class="k">in </span>progress since Mon Jun  2 14:21:35 2014
        604M scanned out of 781M at 46.5M/s, 0h0m to go
        604M resilvered, 77.39% <span class="k">done
</span>config:

        NAME             STATE     READ WRITE CKSUM
        mypool           ONLINE       0     0     0
          mirror-0       ONLINE       0     0     0
            ada0p3       ONLINE       0     0     0
            replacing-1  ONLINE       0     0     0
              ada1p3     ONLINE       0     0     0
              ada2p3     ONLINE       0     0     0  <span class="o">(</span>resilvering<span class="o">)</span>

errors: No known data errors
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Mon Jun  2 14:21:52 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-resilver">22.3.6. 处理故障设备<a class="anchor" href="#zfs-zpool-resilver"></a></h4>
<div class="paragraph">
<p>当池中的磁盘发生故障时，该磁盘所属的 vdev 将进入 <a href="#zfs-term-degraded">降级</a> 状态。数据仍然可用，但性能降低，因为 ZFS 会通过可用的冗余计算缺失的数据。为了将 vdev 恢复到完全功能状态，需要替换故障的物理设备。然后，ZFS 会开始 <a href="#zfs-term-resilver">重建</a> 操作。ZFS 会通过可用的冗余重新计算故障设备上的数据，并将其写入替代设备。完成后，vdev 将返回 <a href="#zfs-term-online">在线</a> 状态。</p>
</div>
<div class="paragraph">
<p>如果 vdev 没有任何冗余，或者设备已经损坏且没有足够的冗余来弥补，那么存储池将进入 <a href="#zfs-term-faulted">故障</a> 状态。除非有足够的设备重新连接存储池，否则存储池将无法运行，需要从备份中恢复数据。</p>
</div>
<div class="paragraph">
<p>当替换一个故障磁盘时，故障磁盘的名称会变为新磁盘的 GUID。如果替换设备具有相同的设备名称，则不需要为 <code>zpool replace</code> 指定新的设备名称参数。</p>
</div>
<div class="paragraph">
<p>使用 <code>zpool replace</code> 命令替换故障的磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices could not be opened.  Sufficient replicas exist <span class="k">for
        </span>the pool to <span class="k">continue </span>functioning <span class="k">in </span>a degraded state.
action: Attach the missing device and online it using <span class="s1">&#39;zpool online&#39;</span>.
   see: http://illumos.org/msg/ZFS-8000-2Q
  scan: none requested
config:

        NAME                    STATE     READ WRITE CKSUM
        mypool                  DEGRADED     0     0     0
          mirror-0              DEGRADED     0     0     0
            ada0p3              ONLINE       0     0     0
            316502962686821739  UNAVAIL      0     0     0  was /dev/ada1p3

errors: No known data errors
<span class="c"># zpool replace mypool 316502962686821739 ada2p3</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: DEGRADED
status: One or more devices is currently being resilvered.  The pool will
        <span class="k">continue </span>to <span class="k">function</span>, possibly <span class="k">in </span>a degraded state.
action: Wait <span class="k">for </span>the resilver to complete.
  scan: resilver <span class="k">in </span>progress since Mon Jun  2 14:52:21 2014
        641M scanned out of 781M at 49.3M/s, 0h0m to go
        640M resilvered, 82.04% <span class="k">done
</span>config:

        NAME                        STATE     READ WRITE CKSUM
        mypool                      DEGRADED     0     0     0
          mirror-0                  DEGRADED     0     0     0
            ada0p3                  ONLINE       0     0     0
            replacing-1             UNAVAIL      0     0     0
              15732067398082357289  UNAVAIL      0     0     0  was /dev/ada1p3/old
              ada2p3                ONLINE       0     0     0  <span class="o">(</span>resilvering<span class="o">)</span>

errors: No known data errors
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: resilvered 781M <span class="k">in </span>0h0m with 0 errors on Mon Jun  2 14:52:38 2014
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-scrub">22.3.7. Scrubbing 池<a class="anchor" href="#zfs-zpool-scrub"></a></h4>
<div class="paragraph">
<p>定期对池进行 <a href="#zfs-term-scrub">scrub</a> 操作，最好每个月至少一次。<code>scrub</code> 操作对磁盘的使用较高，运行时会降低性能。在安排 <code>scrub</code> 操作时避免高负载时段，或者使用 <a href="#zfs-advanced-tuning-scrub_delay"><code>vfs.zfs.scrub_delay</code></a> 来调整 <code>scrub</code> 操作的相对优先级，以防止其影响其他工作负载的速度。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool scrub mypool</span>
<span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
  scan: scrub <span class="k">in </span>progress since Wed Feb 19 20:52:54 2014
        116G scanned out of 8.60T at 649M/s, 3h48m to go
        0 repaired, 1.32% <span class="k">done
</span>config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          raidz2-0  ONLINE       0     0     0
            ada0p3  ONLINE       0     0     0
            ada1p3  ONLINE       0     0     0
            ada2p3  ONLINE       0     0     0
            ada3p3  ONLINE       0     0     0
            ada4p3  ONLINE       0     0     0
            ada5p3  ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要取消一个 scrub 操作，请运行 <code>zpool scrub -s <em>mypool</em></code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-selfheal">22.3.8. 自我修复<a class="anchor" href="#zfs-zpool-selfheal"></a></h4>
<div class="paragraph">
<p>存储在数据块中的校验和使文件系统能够自我修复。这个功能会自动修复数据，如果其校验和与存储池中另一个设备上记录的校验和不匹配。例如，一个具有两个磁盘的镜像配置，其中一个驱动器开始出现故障，无法正确存储数据。当数据长时间未被访问时，如长期存档存储，情况会更糟。传统的文件系统需要运行检查和修复数据的命令，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a>。这些命令需要时间，在严重情况下，管理员必须决定执行哪个修复操作。当 ZFS 检测到一个数据块的校验和不匹配时，它会尝试从镜像磁盘中读取数据。如果该磁盘能提供正确的数据， ZFS 将将其提供给应用程序，并纠正具有错误校验和的磁盘上的数据。在正常存储池操作期间，这一切都在没有任何系统管理员干预的情况下发生。</p>
</div>
<div class="paragraph">
<p>下一个示例通过创建一个镜像磁盘池来展示这种自我修复行为，其中包括 <span class="filename">/dev/ada0</span> 和 <span class="filename">/dev/ada1</span>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool create healer mirror /dev/ada0 /dev/ada1</span>
<span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: none requested
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool list</span>
NAME     SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
healer   960M  92.5K   960M         -         -     0%    0%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>将一些重要数据复制到池中，以使用自我修复功能保护免受数据错误，并为池创建校验和以备后续比较。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /some/important/data /healer</span>
<span class="c"># zfs list</span>
NAME     SIZE  ALLOC   FREE    CAP  DEDUP  HEALTH  ALTROOT
healer   960M  67.7M   892M     7%  1.00x  ONLINE  -
<span class="c"># sha1 /healer &gt; checksum.txt</span>
<span class="c"># cat checksum.txt</span>
SHA1 <span class="o">(</span>/healer<span class="o">)</span> <span class="o">=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过向镜像中的一个磁盘的开头写入随机数据来模拟数据损坏。为了防止 ZFS 在检测到数据损坏时修复数据，可以在损坏之前导出池，并在之后重新导入。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这是一个危险的操作，可能会破坏重要数据，仅用于演示目的。在存储池的正常运行期间，请 <strong>不要尝试</strong> 执行此操作。此意外损坏示例也不应在任何使用 ZFS 以外的文件系统的磁盘上运行，该磁盘上的另一个分区中也不应该有 ZFS 。请不要使用除了存储池中的设备名称之外的任何其他磁盘设备名称。确保存储池有适当的备份，并在执行命令之前对其进行测试！</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool export healer</span>
<span class="c"># dd if=/dev/random of=/dev/ada1 bs=1m count=200</span>
200+0 records <span class="k">in
</span>200+0 records out
209715200 bytes transferred <span class="k">in </span>62.992162 secs <span class="o">(</span>3329227 bytes/sec<span class="o">)</span>
<span class="c"># zpool import healer</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>池状态显示一个设备发生了错误。请注意，从池中读取数据的应用程序没有接收到任何错误数据。ZFS 从 <span class="filename">ada0</span> 设备提供了正确校验和的数据。要找到校验和错误的设备，请查找 <code>CKSUM</code> 列中包含非零值的设备。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status healer</span>
    pool: healer
   state: ONLINE
  status: One or more devices has experienced an unrecoverable error.  An
          attempt was made to correct the error.  Applications are unaffected.
  action: Determine <span class="k">if </span>the device needs to be replaced, and clear the errors
          using <span class="s1">&#39;zpool clear&#39;</span> or replace the device with <span class="s1">&#39;zpool replace&#39;</span>.
     see: http://illumos.org/msg/ZFS-8000-4J
    scan: none requested
  config:

      NAME        STATE     READ WRITE CKSUM
      healer      ONLINE       0     0     0
        mirror-0  ONLINE       0     0     0
         ada0     ONLINE       0     0     0
         ada1     ONLINE       0     0     1

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>ZFS 检测到错误，并通过使用未受影响的 <span class="filename">ada0</span> 镜像磁盘中的冗余来处理该错误。通过与原始数据进行校验比较，可以确定池是否恢复一致。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sha1 /healer &gt;&gt; checksum.txt</span>
<span class="c"># cat checksum.txt</span>
SHA1 <span class="o">(</span>/healer<span class="o">)</span> <span class="o">=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f
SHA1 <span class="o">(</span>/healer<span class="o">)</span> <span class="o">=</span> 2753eff56d77d9a536ece6694bf0a82740344d1f</code></pre>
</div>
</div>
<div class="paragraph">
<p>在故意篡改之前和之后生成校验和，同时池数据仍然匹配。这显示了当校验和不同时， ZFS 能够自动检测和纠正任何错误。请注意，这需要池中具有足够的冗余。由单个设备组成的池没有自我修复能力。这也是为什么在 ZFS 中校验和如此重要的原因；不要出于任何原因禁用它们。 ZFS 不需要 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 或类似的文件系统一致性检查程序来检测和纠正这个问题，并且在出现问题时保持池可用。现在需要进行一次 scrub 操作来覆盖在 <span class="filename">ada1</span> 上的损坏数据。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool scrub healer</span>
<span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
            attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class="k">if </span>the device needs to be replaced, and clear the errors
            using <span class="s1">&#39;zpool clear&#39;</span> or replace the device with <span class="s1">&#39;zpool replace&#39;</span>.
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub <span class="k">in </span>progress since Mon Dec 10 12:23:30 2012
        10.4M scanned out of 67.0M at 267K/s, 0h3m to go
        9.63M repaired, 15.56% <span class="k">done
</span>config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0   627  <span class="o">(</span>repairing<span class="o">)</span>

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>Scrub 操作从 <span class="filename">ada0</span> 读取数据，并将任何具有错误校验和的数据重写到 <span class="filename">ada1</span> 上，这可以通过 <code>zpool status</code> 中的 <code>(repairing)</code> 输出来显示。操作完成后，池的状态将发生变化：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
status: One or more devices has experienced an unrecoverable error.  An
        attempt was made to correct the error.  Applications are unaffected.
action: Determine <span class="k">if </span>the device needs to be replaced, and clear the errors
             using <span class="s1">&#39;zpool clear&#39;</span> or replace the device with <span class="s1">&#39;zpool replace&#39;</span>.
   see: http://illumos.org/msg/ZFS-8000-4J
  scan: scrub repaired 66.5M <span class="k">in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0 2.72K

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>在从 <span class="filename">ada0</span> 同步所有数据到 <span class="filename">ada1</span> 后，完成了 <a href="#zfs-zpool-clear">清洗</a> 操作，请通过运行 <code>zpool clear</code> 命令清除池状态中的错误消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool clear healer</span>
<span class="c"># zpool status healer</span>
  pool: healer
 state: ONLINE
  scan: scrub repaired 66.5M <span class="k">in </span>0h2m with 0 errors on Mon Dec 10 12:26:25 2012
config:

    NAME        STATE     READ WRITE CKSUM
    healer      ONLINE       0     0     0
      mirror-0  ONLINE       0     0     0
       ada0     ONLINE       0     0     0
       ada1     ONLINE       0     0     0

errors: No known data errors</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，池已经恢复到完全正常的状态，所有错误计数都为零。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-online">22.3.9. 扩展池<a class="anchor" href="#zfs-zpool-online"></a></h4>
<div class="paragraph">
<p>每个 vdev 中最小的设备限制了冗余池的可用大小。用一个更大的设备替换最小的设备。在完成 <a href="#zfs-zpool-replace">替换</a> 或 <a href="#zfs-term-resilver">重建</a> 操作后，池可以扩展到使用新设备的容量。例如，考虑一个由 1 TB 驱动器和 2 TB 驱动器组成的镜像。可用空间为 1 TB 。当用另一个 2 TB 驱动器替换 1 TB 驱动器时，重新同步过程将现有数据复制到新驱动器上。由于两个设备现在都具有 2 TB 的容量，镜像的可用空间增长到 2 TB。</p>
</div>
<div class="paragraph">
<p>通过在每个设备上使用 <code>zpool online -e</code> 来开始扩展。在扩展所有设备之后，额外的空间将可用于池。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-import">22.3.10. 导入和导出存储池<a class="anchor" href="#zfs-zpool-import"></a></h4>
<div class="paragraph">
<p>在将存储池移动到另一个系统之前，请先 <em>导出（export）</em> 它们。 ZFS 会卸载所有数据集，并将每个设备标记为已导出，但仍然锁定以防止其他磁盘使用。这使得存储池可以在其他支持 ZFS 的机器、其他操作系统甚至不同的硬件架构上导入（有一些注意事项，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=zpool&amp;sektion=8&amp;format=html">zpool(8)</a>）。当数据集有打开的文件时，请使用 <code>zpool export -f</code> 强制导出存储池。请谨慎使用此功能。数据集将被强制卸载，可能导致那些数据集上有打开文件的应用程序出现意外行为。</p>
</div>
<div class="paragraph">
<p>导出一个未使用的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool export mypool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>导入一个存储池会自动挂载数据集。如果不希望出现这种行为，请使用 <code>zpool import -N</code> 来阻止它。 <code>zpool import -o</code> 为此特定导入设置临时属性。<code>zpool import altroot=</code> 允许使用基本挂载点而不是文件系统的根来导入存储池。如果该存储池最后在另一个系统上使用并且没有正确导出，请使用 <code>zpool import -f</code> 来强制导入。<code>zpool import -a</code> 导入所有未被其他系统使用的存储池。</p>
</div>
<div class="paragraph">
<p>列出所有可导入的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool import</span>
   pool: mypool
     id: 9930174748043525076
  state: ONLINE
 action: The pool can be imported using its name or numeric identifier.
 config:

        mypool      ONLINE
          ada2p3    ONLINE</code></pre>
</div>
</div>
<div class="paragraph">
<p>导入具有替代根目录的池：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool import -o altroot=/mnt mypool</span>
<span class="c"># zfs list</span>
zfs list
NAME                 USED  AVAIL  REFER  MOUNTPOINT
mypool               110K  47.0G    31K  /mnt/mypool</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-upgrade">22.3.11. 升级存储池<a class="anchor" href="#zfs-zpool-upgrade"></a></h4>
<div class="paragraph">
<p>在升级 FreeBSD 之后，或者从使用较旧版本的系统导入池时，需要手动将池升级到最新的 ZFS 版本以支持新功能。在升级之前，请考虑池是否可能需要在较旧的系统上导入。升级是一个单向过程。升级较旧的池是可能的，但是无法降级具有较新功能的池。</p>
</div>
<div class="paragraph">
<p>将 v28 池升级以支持 <code>Feature Flags</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: The pool is formatted using a legacy on-disk format.  The pool can
        still be used, but some features are unavailable.
action: Upgrade the pool using <span class="s1">&#39;zpool upgrade&#39;</span>.  Once this is <span class="k">done</span>, the
        pool will no longer be accessible on software that does not support feat
        flags.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool upgrade</span>
This system supports ZFS pool feature flags.

The following pools are formatted with legacy version numbers and are upgraded to use feature flags.
After being upgraded, these pools will no longer be accessible by software that does not support feature flags.

VER  POOL
---  ------------
28   mypool

Use <span class="s1">&#39;zpool upgrade -v&#39;</span> <span class="k">for </span>a list of available legacy versions.
Every feature flags pool has all supported features enabled.
<span class="c"># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Successfully upgraded <span class="s1">&#39;mypool&#39;</span> from version 28 to feature flags.
Enabled the following features on <span class="s1">&#39;mypool&#39;</span>:
  async_destroy
  empty_bpobj
  lz4_compress
  multi_vdev_crash_dump</code></pre>
</div>
</div>
<div class="paragraph">
<p>只有在完成 <code>zpool upgrade</code> 之后，ZFS 的新功能才会可用。使用 <code>zpool upgrade -v</code> 命令查看升级提供的新功能，以及已经支持的功能。</p>
</div>
<div class="paragraph">
<p>升级一个池子以支持新的功能标志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool status</span>
  pool: mypool
 state: ONLINE
status: Some supported features are not enabled on the pool. The pool can
        still be used, but some features are unavailable.
action: Enable all features using <span class="s1">&#39;zpool upgrade&#39;</span>. Once this is <span class="k">done</span>,
        the pool may no longer be accessible by software that does not support
        the features. See zpool-features<span class="o">(</span>7<span class="o">)</span> <span class="k">for </span>details.
  scan: none requested
config:

        NAME        STATE     READ WRITE CKSUM
        mypool      ONLINE       0     0     0
          mirror-0  ONLINE       0     0     0
	    ada0    ONLINE       0     0     0
	    ada1    ONLINE       0     0     0

errors: No known data errors
<span class="c"># zpool upgrade</span>
This system supports ZFS pool feature flags.

All pools are formatted using feature flags.

Some supported features are not enabled on the following pools. Once a
feature is enabled the pool may become incompatible with software
that does not support the feature. See zpool-features<span class="o">(</span>7<span class="o">)</span> <span class="k">for </span>details.

POOL  FEATURE
---------------
zstore
      multi_vdev_crash_dump
      spacemap_histogram
      enabled_txg
      hole_birth
      extensible_dataset
      bookmarks
      filesystem_limits
<span class="c"># zpool upgrade mypool</span>
This system supports ZFS pool feature flags.

Enabled the following features on <span class="s1">&#39;mypool&#39;</span>:
  spacemap_histogram
  enabled_txg
  hole_birth
  extensible_dataset
  bookmarks
  filesystem_limits</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>更新从池中引导的系统的引导代码，以支持新的池版本。在包含引导代码的分区上使用 <code>gpart bootcode</code> 命令。根据系统的引导方式，有两种类型的引导代码可用：GPT（最常见的选项）和 EFI（适用于更现代的系统）。</p>
</div>
<div class="paragraph">
<p>对于使用 GPT 的传统引导，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart bootcode -b /boot/pmbr -p /boot/gptzfsboot -i 1 ada1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于使用 EFI 引导的系统，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># gpart bootcode -p /boot/boot1.efifat -i 1 ada1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将引导代码应用于池中的所有可引导磁盘。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-history">22.3.12. 显示池的历史记录<a class="anchor" href="#zfs-zpool-history"></a></h4>
<div class="paragraph">
<p>ZFS 记录更改池的命令，包括创建数据集、更改属性或替换磁盘。查看关于池创建的历史记录很有用，还可以检查哪个用户执行了特定的操作以及何时执行的。历史记录不会保存在日志文件中，而是作为池本身的一部分。用于查看这个历史记录的命令被恰当地命名为 <code>zpool history</code>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool history</span>
History <span class="k">for</span> <span class="s1">&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1
2013-02-27.18:50:58 zfs <span class="nb">set </span><span class="nv">atime</span><span class="o">=</span>off tank
2013-02-27.18:51:09 zfs <span class="nb">set </span><span class="nv">checksum</span><span class="o">=</span>fletcher4 tank
2013-02-27.18:51:18 zfs create tank/backup</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示了 <code>zpool</code> 和 <code>zfs</code> 命令以某种方式修改了池，并附带了时间戳。不包括像 <code>zfs list</code> 这样的命令。当未指定池名称时， ZFS 会显示所有池的历史记录。</p>
</div>
<div class="paragraph">
<p>当使用选项 <code>-i</code> 或 <code>-l</code> 时，<code>zpool history</code> 命令可以显示更多的信息。 <code>-i</code> 选项会显示用户发起的事件以及内部记录的 ZFS 事件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool history -i</span>
History <span class="k">for</span> <span class="s1">&#39;tank&#39;</span>:
2013-02-26.23:02:35 <span class="o">[</span>internal pool create txg:5] pool spa 28; zfs spa 28; zpl 5;uts  9.1-RELEASE 901000 amd64
2013-02-27.18:50:53 <span class="o">[</span>internal property <span class="nb">set </span>txg:50] <span class="nv">atime</span><span class="o">=</span>0 dataset <span class="o">=</span> 21
2013-02-27.18:50:58 zfs <span class="nb">set </span><span class="nv">atime</span><span class="o">=</span>off tank
2013-02-27.18:51:04 <span class="o">[</span>internal property <span class="nb">set </span>txg:53] <span class="nv">checksum</span><span class="o">=</span>7 dataset <span class="o">=</span> 21
2013-02-27.18:51:09 zfs <span class="nb">set </span><span class="nv">checksum</span><span class="o">=</span>fletcher4 tank
2013-02-27.18:51:13 <span class="o">[</span>internal create txg:55] dataset <span class="o">=</span> 39
2013-02-27.18:51:18 zfs create tank/backup</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过添加 <code>-l</code> 来显示更多详细信息。以长格式显示历史记录，包括发出命令的用户的名称和发生更改的主机名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool history -l</span>
History <span class="k">for</span> <span class="s1">&#39;tank&#39;</span>:
2013-02-26.23:02:35 zpool create tank mirror /dev/ada0 /dev/ada1 <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on :global]
2013-02-27.18:50:58 zfs <span class="nb">set </span><span class="nv">atime</span><span class="o">=</span>off tank <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on myzfsbox:global]
2013-02-27.18:51:09 zfs <span class="nb">set </span><span class="nv">checksum</span><span class="o">=</span>fletcher4 tank <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on myzfsbox:global]
2013-02-27.18:51:18 zfs create tank/backup <span class="o">[</span>user 0 <span class="o">(</span>root<span class="o">)</span> on myzfsbox:global]</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出显示 <code>root</code> 用户使用磁盘 <span class="filename">/dev/ada0</span> 和 <span class="filename">/dev/ada1</span> 创建了镜像池。在池创建后的命令中还显示了主机名 <code>myzfsbox</code> 。主机名的显示在将池从一个系统导出并在另一个系统导入时变得重要。可以通过为每个命令记录的主机名来区分在另一个系统上发出的命令。</p>
</div>
<div class="paragraph">
<p>将两个选项 <code>zpool history</code> 结合起来，以便为任何给定的池提供尽可能详细的信息。池历史记录在追踪执行的操作或需要更详细的输出进行调试时提供有价值的信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-iostat">22.3.13. 性能监控<a class="anchor" href="#zfs-zpool-iostat"></a></h4>
<div class="paragraph">
<p>内置的监控系统可以实时显示池的 I/O 统计信息。它显示池中的可用空间和已使用空间的数量，每秒执行的读写操作次数以及使用的 I/O 带宽。默认情况下， ZFS 监视并显示系统中的所有池。提供池名称以限制监控到该池。一个基本示例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool iostat</span>
               capacity     operations    bandwidth
pool        alloc   free   <span class="nb">read  </span>write   <span class="nb">read  </span>write
----------  -----  -----  -----  -----  -----  -----
data         288G  1.53T      2     11  11.3K  57.1K</code></pre>
</div>
</div>
<div class="paragraph">
<p>要持续查看 I/O 活动，请在最后一个参数中指定一个数字，表示更新之间等待的秒数间隔。每个间隔后都会打印下一个统计行。按下 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span> 停止此连续监视。在间隔之后的命令行上给出第二个数字，以指定要显示的统计总数。</p>
</div>
<div class="paragraph">
<p>使用 <code>-v</code> 参数可以显示更详细的 I/O 统计信息。池中的每个设备都会显示一行统计信息。这对于查看在每个设备上执行的读写操作非常有用，并且可以帮助确定是否有任何单个设备导致池变慢。以下示例显示了一个具有两个设备的镜像池。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool iostat -v</span>
                            capacity     operations    bandwidth
pool                     alloc   free   <span class="nb">read  </span>write   <span class="nb">read  </span>write
-----------------------  -----  -----  -----  -----  -----  -----
data                      288G  1.53T      2     12  9.23K  61.5K
  mirror                  288G  1.53T      2     12  9.23K  61.5K
    ada1                     -      -      0      4  5.61K  61.7K
    ada2                     -      -      1      4  5.04K  61.7K
-----------------------  -----  -----  -----  -----  -----  -----</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zpool-split">22.3.14. 分割存储池<a class="anchor" href="#zfs-zpool-split"></a></h4>
<div class="paragraph">
<p>ZFS 可以将由一个或多个镜像 vdev 组成的池分割成两个池。除非另有指定，ZFS 会分离每个镜像的最后一个成员，并创建一个包含相同数据的新池。请务必先使用 <code>-n</code> 进行试运行。这将显示所请求操作的详细信息，但不会实际执行操作。这有助于确认操作是否符合用户的意图。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs">22.4. <code>zfs</code> 管理<a class="anchor" href="#zfs-zfs"></a></h3>
<div class="paragraph">
<p><code>zfs</code> 实用程序可以在池中创建、销毁和管理所有现有的 ZFS 数据集。要管理池本身，请使用 <a href="#zfs-zpool"><code>zpool</code></a>。</p>
</div>
<div class="sect3">
<h4 id="zfs-zfs-create">22.4.1. 创建和销毁数据集<a class="anchor" href="#zfs-zfs-create"></a></h4>
<div class="paragraph">
<p>与传统的磁盘和卷管理器不同，ZFS 中的空间是 <em>不预分配</em> 的。在传统文件系统中，分区和分配空间后，无法在不添加新磁盘的情况下添加新的文件系统。而在 ZFS 中，可以随时创建新的文件系统。每个 <a href="#zfs-term-dataset">数据集</a> 都有属性，包括压缩、去重、缓存和配额等功能，以及其他有用的属性，如只读、大小写敏感、网络文件共享和挂载点。可以将数据集嵌套在彼此之间，并且子数据集将继承其祖先的属性。 <a href="#zfs-zfs-allow">委派</a>、<a href="#zfs-zfs-send">复制</a>、<a href="#zfs-zfs-snapshot">快照</a>、<a href="#zfs-zfs-jail">jail</a> 允许将每个数据集作为一个单元进行管理和销毁。为每种不同类型或文件集创建单独的数据集具有优势。拥有大量数据集的缺点是，某些命令（如 <code>zfs list</code>）的速度会变慢，并且挂载数百甚至数千个数据集会减慢 FreeBSD 的启动过程。</p>
</div>
<div class="paragraph">
<p>创建一个新的数据集，并在其上启用 <a href="#zfs-term-compression-lz4">LZ4 压缩</a>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.20M  93.2G   608K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp
<span class="c"># zfs create -o compress=lz4 mypool/usr/mydataset</span>
<span class="c"># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 781M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.20M  93.2G   610K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>销毁数据集比删除数据集上的文件要快得多，因为它不涉及扫描文件和更新相应的元数据。</p>
</div>
<div class="paragraph">
<p>销毁已创建的数据集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 880M  93.1G   144K  none
mypool/ROOT            777M  93.1G   144K  none
mypool/ROOT/default    777M  93.1G   777M  /
mypool/tmp             176K  93.1G   176K  /tmp
mypool/usr             101M  93.1G   144K  /usr
mypool/usr/home        184K  93.1G   184K  /usr/home
mypool/usr/mydataset   100M  93.1G   100M  /usr/mydataset
mypool/usr/ports       144K  93.1G   144K  /usr/ports
mypool/usr/src         144K  93.1G   144K  /usr/src
mypool/var            1.20M  93.1G   610K  /var
mypool/var/crash       148K  93.1G   148K  /var/crash
mypool/var/log         178K  93.1G   178K  /var/log
mypool/var/mail        144K  93.1G   144K  /var/mail
mypool/var/tmp         152K  93.1G   152K  /var/tmp
<span class="c"># zfs destroy mypool/usr/mydataset</span>
<span class="c"># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                781M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.21M  93.2G   612K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>在现代版本的 ZFS 中， <code>zfs destroy</code> 是异步的，释放的空间可能需要几分钟才会在池中显示出来。使用 <code>zpool get freeing <em>poolname</em></code> 命令来查看 <code>freeing</code> 属性，该属性显示了哪些数据集正在后台释放其块。如果存在子数据集，例如 <a href="#zfs-term-snapshot">快照</a> 或其他数据集，那么无法销毁父数据集。要销毁一个数据集及其子数据集，可以使用 <code>-r</code> 选项递归地销毁数据集及其子数据集。使用 <code>-n -v</code> 选项列出此操作销毁的数据集和快照，而不实际销毁任何内容。销毁快照释放的空间也会显示出来。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-volume">22.4.2. 创建和销毁卷<a class="anchor" href="#zfs-zfs-volume"></a></h4>
<div class="paragraph">
<p>卷是一种特殊的数据集类型。它不像文件系统那样挂载，而是在 <code>/dev/zvol/poolname/dataset</code> 下以块设备的形式公开。这使得可以将卷用于其他文件系统，用于虚拟机的磁盘备份，或者通过 iSCSI 或 HAST 等协议使其对其他网络主机可用。</p>
</div>
<div class="paragraph">
<p>使用任何文件系统或者不使用文件系统来格式化一个卷，以存储原始数据。对于用户来说，一个卷看起来就像一个普通的磁盘。在这些 <em>zvol</em> 上放置普通的文件系统提供了普通磁盘或文件系统所没有的功能。例如，使用压缩属性在一个 250MB 的卷上可以创建一个压缩的 FAT 文件系统。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -V 250m -o compression=on tank/fat32</span>
<span class="c"># zfs list tank</span>
NAME USED AVAIL REFER MOUNTPOINT
tank 258M  670M   31K /tank
<span class="c"># newfs_msdos -F32 /dev/zvol/tank/fat32</span>
<span class="c"># mount -t msdosfs /dev/zvol/tank/fat32 /mnt</span>
<span class="c"># df -h /mnt | grep fat32</span>
Filesystem           Size Used Avail Capacity Mounted on
/dev/zvol/tank/fat32 249M  24k  249M     0%   /mnt
<span class="c"># mount | grep fat32</span>
/dev/zvol/tank/fat32 on /mnt <span class="o">(</span>msdosfs, <span class="nb">local</span><span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>销毁一个卷与销毁一个常规文件系统数据集基本相同。该操作几乎是瞬时完成的，但在后台重新获取空闲空间可能需要几分钟的时间。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-rename">22.4.3. 重命名数据集<a class="anchor" href="#zfs-zfs-rename"></a></h4>
<div class="paragraph">
<p>要更改数据集的名称，请使用 <code>zfs rename</code> 命令。要更改数据集的父级，请同样使用此命令。将数据集重命名为具有不同父级的数据集将更改从父级数据集继承的属性的值。将数据集重命名为新位置（从新父级数据集继承）将卸载然后重新挂载它。要防止此行为，请使用 <code>-u</code> 选项。</p>
</div>
<div class="paragraph">
<p>重命名数据集并将其移动到不同的父数据集下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list</span>
NAME                   USED  AVAIL  REFER  MOUNTPOINT
mypool                 780M  93.2G   144K  none
mypool/ROOT            777M  93.2G   144K  none
mypool/ROOT/default    777M  93.2G   777M  /
mypool/tmp             176K  93.2G   176K  /tmp
mypool/usr             704K  93.2G   144K  /usr
mypool/usr/home        184K  93.2G   184K  /usr/home
mypool/usr/mydataset  87.5K  93.2G  87.5K  /usr/mydataset
mypool/usr/ports       144K  93.2G   144K  /usr/ports
mypool/usr/src         144K  93.2G   144K  /usr/src
mypool/var            1.21M  93.2G   614K  /var
mypool/var/crash       148K  93.2G   148K  /var/crash
mypool/var/log         178K  93.2G   178K  /var/log
mypool/var/mail        144K  93.2G   144K  /var/mail
mypool/var/tmp         152K  93.2G   152K  /var/tmp
<span class="c"># zfs rename mypool/usr/mydataset mypool/var/newname</span>
<span class="c"># zfs list</span>
NAME                  USED  AVAIL  REFER  MOUNTPOINT
mypool                780M  93.2G   144K  none
mypool/ROOT           777M  93.2G   144K  none
mypool/ROOT/default   777M  93.2G   777M  /
mypool/tmp            176K  93.2G   176K  /tmp
mypool/usr            616K  93.2G   144K  /usr
mypool/usr/home       184K  93.2G   184K  /usr/home
mypool/usr/ports      144K  93.2G   144K  /usr/ports
mypool/usr/src        144K  93.2G   144K  /usr/src
mypool/var           1.29M  93.2G   614K  /var
mypool/var/crash      148K  93.2G   148K  /var/crash
mypool/var/log        178K  93.2G   178K  /var/log
mypool/var/mail       144K  93.2G   144K  /var/mail
mypool/var/newname   87.5K  93.2G  87.5K  /var/newname
mypool/var/tmp        152K  93.2G   152K  /var/tmp</code></pre>
</div>
</div>
<div class="paragraph">
<p>重命名快照使用相同的命令。由于快照的特性，重命名不能改变它们的父数据集。要重命名递归快照，请指定 <code>-r</code> ；这也会重命名所有子数据集中具有相同名称的快照。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -t snapshot</span>
NAME                                USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@first_snapshot      0      -  87.5K  -
<span class="c"># zfs rename mypool/var/newname@first_snapshot new_snapshot_name</span>
<span class="c"># zfs list -t snapshot</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/newname@new_snapshot_name      0      -  87.5K  -</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-set">22.4.4. 设置数据集属性<a class="anchor" href="#zfs-zfs-set"></a></h4>
<div class="paragraph">
<p>每个 ZFS 数据集都有控制其行为的属性。大多数属性会自动从父数据集继承，但可以在本地进行覆盖。使用 <code>zfs set <em>property=value dataset</em></code> 在数据集上设置属性。大多数属性有一组有限的有效值，<code>zfs get</code> 将显示每个可能的属性和有效值。使用 <code>zfs inherit</code> 将大多数属性恢复为其继承的值。还可以定义用户自定义属性。它们成为数据集配置的一部分，并提供有关数据集或其内容的进一步信息。为了区分这些自定义属性和作为 ZFS 的一部分提供的属性，可以使用冒号（<code>:</code>）为属性创建自定义命名空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set custom:costcenter=1234 tank</span>
<span class="c"># zfs get custom:costcenter tank</span>
NAME PROPERTY           VALUE SOURCE
tank custom:costcenter  1234  <span class="nb">local</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要删除自定义属性，请使用 <code>zfs inherit</code> 命令并加上 <code>-r</code> 选项。如果自定义属性在任何父数据集中都没有定义，这个选项将删除它（但池的历史记录仍然会记录这个更改）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs inherit -r custom:costcenter tank</span>
<span class="c"># zfs get custom:costcenter tank</span>
NAME    PROPERTY           VALUE              SOURCE
tank    custom:costcenter  -                  -
<span class="c"># zfs get all tank | grep custom:costcenter</span>
<span class="c">#</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="zfs-zfs-set-share">22.4.4.1. 获取和设置共享属性<a class="anchor" href="#zfs-zfs-set-share"></a></h5>
<div class="paragraph">
<p>两个常用且有用的数据集属性是 NFS 和 SMB 共享选项。设置这些选项可以定义 ZFS 在网络上共享数据集的方式和方式。目前，FreeBSD 仅支持设置 NFS 共享。要获取共享的当前状态，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get sharenfs mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharenfs  on       <span class="nb">local</span>
<span class="c"># zfs get sharesmb mypool/usr/home</span>
NAME             PROPERTY  VALUE    SOURCE
mypool/usr/home  sharesmb  off      <span class="nb">local</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要启用数据集的共享，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c">#  zfs set sharenfs=on mypool/usr/home</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>设置通过 NFS 共享数据集的其他选项，例如 <code>-alldirs</code>、<code>-maproot</code> 和 <code>-network</code>。要在通过 NFS 共享的数据集上设置选项，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c">#  zfs set sharenfs=&#34;-alldirs,-maproot=root,-network=192.168.1.0/24&#34; mypool/usr/home</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-snapshot">22.4.5. 管理快照<a class="anchor" href="#zfs-zfs-snapshot"></a></h4>
<div class="paragraph">
<p><a href="#zfs-term-snapshot">快照</a> 是 ZFS 最强大的功能之一。快照提供了数据集的只读、时间点的副本。通过写时复制（COW），ZFS 通过在磁盘上保留旧版本的数据来快速创建快照。如果没有快照存在，当数据被重写或删除时，ZFS 会回收空间以供将来使用。快照通过记录当前数据集与先前版本之间的差异来保留磁盘空间。允许在整个数据集上进行快照，而不是在单个文件或目录上进行快照。数据集的快照复制其中包含的所有内容。这包括文件系统属性、文件、目录、权限等。快照在创建时不占用额外的空间，但随着它们引用的块的变化而消耗空间。使用 <code>-r</code> 进行递归快照会在数据集及其子数据集上创建具有相同名称的快照，提供文件系统的一致时刻快照。当应用程序在相关数据集上有文件或相互依赖时，这可能很重要。如果没有快照，备份将具有来自不同时间点的文件副本。</p>
</div>
<div class="paragraph">
<p>ZFS 中的快照提供了许多其他具有快照功能的文件系统所缺乏的功能。快照的典型用法是在执行风险操作（如软件安装或系统升级）时，快速备份文件系统的当前状态。如果操作失败，回滚到快照可以将系统恢复到创建快照时的相同状态。如果升级成功，可以删除快照以释放空间。如果没有快照，升级失败通常需要恢复备份，这是繁琐、耗时的，并且可能需要停机时间，期间系统无法使用。回滚到快照是快速的，即使系统在正常运行中，几乎没有停机时间。考虑到从备份中复制数据所需的时间，对于多 TB 存储系统来说，节省的时间是巨大的。快照不能替代对池的完整备份，但提供了一种快速简便的方式来存储特定时间点的数据集副本。</p>
</div>
<div class="sect4">
<h5 id="zfs-zfs-snapshot-creation">22.4.5.1. 创建快照<a class="anchor" href="#zfs-zfs-snapshot-creation"></a></h5>
<div class="paragraph">
<p>要创建快照，请使用 <code>zfs snapshot <em>dataset</em>@<em>snapshotname</em></code> 命令。添加 <code>-r</code> 选项可以递归地创建快照，并在所有子数据集上使用相同的名称。</p>
</div>
<div class="paragraph">
<p>创建整个池的递归快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -t all</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool                                 780M  93.2G   144K  none
mypool/ROOT                            777M  93.2G   144K  none
mypool/ROOT/default                    777M  93.2G   777M  /
mypool/tmp                             176K  93.2G   176K  /tmp
mypool/usr                             616K  93.2G   144K  /usr
mypool/usr/home                        184K  93.2G   184K  /usr/home
mypool/usr/ports                       144K  93.2G   144K  /usr/ports
mypool/usr/src                         144K  93.2G   144K  /usr/src
mypool/var                            1.29M  93.2G   616K  /var
mypool/var/crash                       148K  93.2G   148K  /var/crash
mypool/var/log                         178K  93.2G   178K  /var/log
mypool/var/mail                        144K  93.2G   144K  /var/mail
mypool/var/newname                    87.5K  93.2G  87.5K  /var/newname
mypool/var/newname@new_snapshot_name      0      -  87.5K  -
mypool/var/tmp                         152K  93.2G   152K  /var/tmp
<span class="c"># zfs snapshot -r mypool@my_recursive_snapshot</span>
<span class="c"># zfs list -t snapshot</span>
NAME                                        USED  AVAIL  REFER  MOUNTPOINT
mypool@my_recursive_snapshot                   0      -   144K  -
mypool/ROOT@my_recursive_snapshot              0      -   144K  -
mypool/ROOT/default@my_recursive_snapshot      0      -   777M  -
mypool/tmp@my_recursive_snapshot               0      -   176K  -
mypool/usr@my_recursive_snapshot               0      -   144K  -
mypool/usr/home@my_recursive_snapshot          0      -   184K  -
mypool/usr/ports@my_recursive_snapshot         0      -   144K  -
mypool/usr/src@my_recursive_snapshot           0      -   144K  -
mypool/var@my_recursive_snapshot               0      -   616K  -
mypool/var/crash@my_recursive_snapshot         0      -   148K  -
mypool/var/log@my_recursive_snapshot           0      -   178K  -
mypool/var/mail@my_recursive_snapshot          0      -   144K  -
mypool/var/newname@new_snapshot_name           0      -  87.5K  -
mypool/var/newname@my_recursive_snapshot       0      -  87.5K  -
mypool/var/tmp@my_recursive_snapshot           0      -   152K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>普通的 <code>zfs list</code> 操作不会显示快照。要列出快照，请在 <code>zfs list</code> 后面添加 <code>-t snapshot</code>。 <code>-t all</code> 可以同时显示文件系统和快照。</p>
</div>
<div class="paragraph">
<p>快照不会直接挂载，因此在 <code>MOUNTPOINT</code> 列中不显示路径。ZFS 在 <code>AVAIL</code> 列中不提及可用磁盘空间，因为快照在创建后是只读的。将快照与原始数据集进行比较：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all mypool/usr/home</span>
NAME                                    USED  AVAIL  REFER  MOUNTPOINT
mypool/usr/home                         184K  93.2G   184K  /usr/home
mypool/usr/home@my_recursive_snapshot      0      -   184K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>同时显示数据集和快照可以展示快照以 <a href="#zfs-term-cow">写时复制</a> 方式工作的原理。它们保存所做的更改（<em>delta</em>），而不是再次保存完整的文件系统内容。这意味着在进行更改时，快照所占用的空间很小。通过将文件复制到数据集中，然后创建第二个快照，可以更加观察空间使用情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/passwd /var/tmp</span>
<span class="c"># zfs snapshot mypool/var/tmp@after_cp</span>
<span class="c"># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>第二个快照包含了复制操作后数据集的变化。这样可以节省大量的空间。请注意，快照 <code><em>mypool/var/tmp@my_recursive_snapshot</em></code> 的大小在 <code>USED</code> 列中也发生了变化，以显示它与之后拍摄的快照之间的变化。</p>
</div>
</div>
<div class="sect4">
<h5 id="zfs-zfs-snapshot-diff">22.4.5.2. 比较快照<a class="anchor" href="#zfs-zfs-snapshot-diff"></a></h5>
<div class="paragraph">
<p>ZFS 提供了一个内置命令，用于比较两个快照之间内容的差异。当用户想要查看文件系统随时间变化的方式时，这非常有帮助，尤其是在有很多快照的情况下。例如， <code>zfs diff</code> 命令可以帮助用户找到最新的快照，其中仍然包含了意外删除的文件。对于前一节创建的两个快照，执行此命令将输出如下结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         206K  93.2G   118K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp                   0      -   118K  -
<span class="c"># zfs diff mypool/var/tmp@my_recursive_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令列出了指定快照（在本例中为 <code><em>mypool/var/tmp@my_recursive_snapshot</em></code> ）与活动文件系统之间的变化。第一列显示变化类型：</p>
</div>
<table class="tableblock frame-all grid-all stretch informaltable">
<colgroup>
<col style="width: 20%;"/>
<col style="width: 80%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">+</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">添加路径或文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">-</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">删除路径或文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">M</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">修改路径或文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">重命名路径或文件。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>将输出与表格进行比较，可以清楚地看到 ZFS 在创建快照 <code><em>mypool/var/tmp@my_recursive_snapshot</em></code> 之后添加了 <span class="filename">passwd</span> 。这也导致了挂载在 <code><em>/var/tmp</em></code> 上的父目录的修改。</p>
</div>
<div class="paragraph">
<p>当使用 ZFS 复制功能将数据集传输到不同的主机进行备份时，比较两个快照是非常有帮助的。</p>
</div>
<div class="paragraph">
<p>通过提供两个数据集的完整数据集名称和快照名称来比较两个快照：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /var/tmp/passwd /var/tmp/passwd.copy</span>
<span class="c"># zfs snapshot mypool/var/tmp@diff_snapshot</span>
<span class="c"># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@diff_snapshot</span>
M       /var/tmp/
+       /var/tmp/passwd
+       /var/tmp/passwd.copy
<span class="c"># zfs diff mypool/var/tmp@my_recursive_snapshot mypool/var/tmp@after_cp</span>
M       /var/tmp/
+       /var/tmp/passwd</code></pre>
</div>
</div>
<div class="paragraph">
<p>备份管理员可以比较从发送主机接收到的两个快照，并确定数据集中的实际更改。有关更多信息，请参阅 <a href="#zfs-zfs-send">复制</a> 部分。</p>
</div>
</div>
<div class="sect4">
<h5 id="zfs-zfs-snapshot-rollback">22.4.5.3. 快照回滚<a class="anchor" href="#zfs-zfs-snapshot-rollback"></a></h5>
<div class="paragraph">
<p>当至少有一个快照可用时，随时可以回滚到该快照。大多数情况下，当数据集的当前状态不再存在或者更喜欢旧版本时，会出现这种情况。诸如本地开发测试失败、系统更新失败导致系统功能受阻，或者需要恢复已删除的文件或目录等情况都很常见。要回滚快照，请使用 <code>zfs rollback <em>snapshotname</em></code> 命令。如果存在大量更改，操作将需要很长时间。在此期间，数据集始终保持一致的状态，就像符合 ACID 原则的数据库执行回滚操作一样。这一切都发生在数据集处于活动状态且可访问的情况下，无需停机。一旦快照回滚完成，数据集的状态与快照创建时的状态相同。回滚到快照会丢弃数据集中不属于该快照的所有其他数据。在回滚到以前的快照之前，将当前数据集的状态进行快照是一个好主意，以便稍后需要某些数据。这样，用户可以在快照之间来回切换，而不会丢失仍然有价值的数据。</p>
</div>
<div class="paragraph">
<p>在第一个示例中，由于一个粗心的 <code>rm</code> 操作删除了比预期更多的数据，因此需要回滚一个快照。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp                         262K  93.2G   120K  /var/tmp
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class="c"># ls /var/tmp</span>
passwd          passwd.copy     vi.recover
<span class="c"># rm /var/tmp/passwd*</span>
<span class="c"># ls /var/tmp</span>
vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上，用户注意到额外文件被删除了，并希望将它们恢复。 ZFS 提供了一种简单的方法来使用回滚将它们恢复，当定期对重要数据进行快照时。要将文件恢复并从最后一个快照重新开始，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs rollback mypool/var/tmp@diff_snapshot</span>
<span class="c"># ls /var/tmp</span>
passwd          passwd.copy     vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p>回滚操作将数据集恢复到最后一个快照的状态。也可以回滚到之前拍摄的快照之后拍摄的其他快照的状态。在尝试这样做时，ZFS 会发出以下警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt snapshot mypool/var/tmp</span>
AME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot    88K      -   152K  -
mypool/var/tmp@after_cp               53.5K      -   118K  -
mypool/var/tmp@diff_snapshot              0      -   120K  -
<span class="c"># zfs rollback mypool/var/tmp@my_recursive_snapshot</span>
cannot rollback to <span class="s1">&#39;mypool/var/tmp@my_recursive_snapshot&#39;</span>: more recent snapshots exist
use <span class="s1">&#39;-r&#39;</span> to force deletion of the following snapshots:
mypool/var/tmp@after_cp
mypool/var/tmp@diff_snapshot</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个警告意味着在当前数据集状态和用户想要回滚的快照之间存在快照。要完成回滚操作，请删除这些快照。由于快照是只读的，ZFS 无法跟踪数据集不同状态之间的所有更改。除非用户使用 <code>-r</code> 参数确认这是所需的操作，否则 ZFS 不会删除受影响的快照。如果这是用户的意图，并且理解丢失所有中间快照的后果，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs rollback -r mypool/var/tmp@my_recursive_snapshot</span>
<span class="c"># zfs list -rt snapshot mypool/var/tmp</span>
NAME                                   USED  AVAIL  REFER  MOUNTPOINT
mypool/var/tmp@my_recursive_snapshot     8K      -   152K  -
<span class="c"># ls /var/tmp</span>
vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>zfs list -t snapshot</code> 的输出确认了由于 <code>zfs rollback -r</code> 的结果，中间快照已被删除。</p>
</div>
</div>
<div class="sect4">
<h5 id="zfs-zfs-snapshot-snapdir">22.4.5.4. 从快照中恢复单个文件<a class="anchor" href="#zfs-zfs-snapshot-snapdir"></a></h5>
<div class="paragraph">
<p>快照存储在父数据集的隐藏目录下： <span class="filename">.zfs/snapshots/snapshotname</span> 。默认情况下，即使执行标准的 <code>ls -a</code> 命令，这些目录也不会显示出来。尽管目录不可见，但可以像访问普通目录一样访问它。名为 <code>snapdir</code> 的属性控制这些隐藏目录是否在目录列表中显示。将该属性设置为 <code>visible</code> 可以使它们出现在 <code>ls</code> 和其他处理目录内容的命令的输出中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get snapdir mypool/var/tmp</span>
NAME            PROPERTY  VALUE    SOURCE
mypool/var/tmp  snapdir   hidden   default
<span class="c"># ls -a /var/tmp</span>
.               ..              passwd          vi.recover
<span class="c"># zfs set snapdir=visible mypool/var/tmp</span>
<span class="c"># ls -a /var/tmp</span>
.               ..              .zfs            passwd          vi.recover</code></pre>
</div>
</div>
<div class="paragraph">
<p>通过将文件从快照复制回父数据集，将其恢复到先前的状态。 <span class="filename">.zfs/snapshot</span> 下的目录结构中有一个类似于先前拍摄的快照的目录，以便更容易识别它们。下一个示例显示了如何从隐藏的 <span class="filename">.zfs</span> 目录中复制文件，从包含文件最新版本的快照中恢复文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rm /var/tmp/passwd</span>
<span class="c"># ls -a /var/tmp</span>
.               ..              .zfs            vi.recover
<span class="c"># ls /var/tmp/.zfs/snapshot</span>
after_cp                my_recursive_snapshot
<span class="c"># ls /var/tmp/.zfs/snapshot/after_cp</span>
passwd          vi.recover
<span class="c"># cp /var/tmp/.zfs/snapshot/after_cp/passwd /var/tmp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>即使将 <code>snapdir</code> 属性设置为隐藏，运行 <code>ls .zfs/snapshot</code> 仍然会列出该目录的内容。管理员决定是否显示这些目录。这是每个数据集的设置。从这个隐藏的 <span class="filename">.zfs/snapshot</span> 复制文件或目录非常简单。尝试反过来操作会导致以下错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/rc.conf /var/tmp/.zfs/snapshot/after_cp/</span>
cp: /var/tmp/.zfs/snapshot/after_cp/rc.conf: Read-only file system</code></pre>
</div>
</div>
<div class="paragraph">
<p>该错误提醒用户快照是只读的，创建后不能更改。将文件复制到快照目录或从中删除文件都是不允许的，因为这会改变所表示数据集的状态。</p>
</div>
<div class="paragraph">
<p>快照占用的空间取决于父文件系统自快照以来的更改量。快照的 <code>written</code> 属性跟踪快照使用的空间。</p>
</div>
<div class="paragraph">
<p>要销毁快照并回收空间，请使用 <code>zfs destroy <em>dataset</em>@<em>snapshot</em></code> 命令。添加 <code>-r</code> 选项可以递归删除父数据集下具有相同名称的所有快照。在命令中添加 <code>-n -v</code> 选项可以显示要删除的快照列表以及执行实际销毁操作前将回收的空间的估计值。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-clones">22.4.6. 管理克隆实例<a class="anchor" href="#zfs-zfs-clones"></a></h4>
<div class="paragraph">
<p>克隆是快照的副本，更像一个常规数据集。与快照不同，克隆是可写的和可挂载的，并且具有自己的属性。使用 <code>zfs clone</code> 创建克隆后，无法销毁原始快照。要反转克隆和快照之间的子/父关系，请使用 <code>zfs promote</code> 。将克隆提升为快照成为克隆的子项，而不是原始父数据集的子项。这将改变 ZFS 对空间的计算方式，但实际上不会改变所消耗的空间量。可以在 ZFS 文件系统层次结构中的任何位置挂载克隆，不仅限于快照的原始位置下方。</p>
</div>
<div class="paragraph">
<p>要展示克隆功能，请使用以下示例数据集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs list -rt all camino/home/joe</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
camino/home/joe         108K   1.3G    87K  /usr/home/joe
camino/home/joe@plans    21K      -  85.5K  -
camino/home/joe@backup    0K      -    87K  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>克隆的典型用途是在进行特定数据集的实验时，保留快照以备不时之需。由于快照是不可更改的，因此需要创建一个可读/写的快照克隆。在克隆中获得所需的结果后，将克隆提升为数据集并删除旧的文件系统。严格来说，删除父数据集并非必需，因为克隆和数据集可以共存而不会出现问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs clone camino/home/joe@backup camino/home/joenew</span>
<span class="c"># ls /usr/home/joe*</span>
/usr/home/joe:
backup.txz     plans.txt

/usr/home/joenew:
backup.txz     plans.txt
<span class="c"># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G     31k    1.3G     0%    /usr/home/joe
usr/home/joenew     1.3G     31k    1.3G     0%    /usr/home/joenew</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建克隆会使其成为数据集在拍摄快照时的精确副本。现在可以独立地更改克隆与其源数据集之间的连接。两者之间的连接是快照。 ZFS 将此连接记录在属性 <code>origin</code> 中。使用 <code>zfs promote</code> 提升克隆将使其成为独立的数据集。这将删除 <code>origin</code> 属性的值，并断开新独立数据集与快照之间的连接。以下示例说明了这一点：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE                     SOURCE
camino/home/joenew    origin    camino/home/joe@backup    -
<span class="c"># zfs promote camino/home/joenew</span>
<span class="c"># zfs get origin camino/home/joenew</span>
NAME                  PROPERTY  VALUE   SOURCE
camino/home/joenew    origin    -       -</code></pre>
</div>
</div>
<div class="paragraph">
<p>在进行一些更改后，例如将 <span class="filename">loader.conf</span> 复制到推广的克隆中，旧目录在这种情况下变得过时。相反，推广的克隆可以替代它。为了做到这一点，首先使用 <code>zfs destroy</code> 命令销毁旧数据集，然后使用 <code>zfs rename</code> 命令将克隆重命名为旧数据集的名称（或完全不同的名称）。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /boot/defaults/loader.conf /usr/home/joenew</span>
<span class="c"># zfs destroy -f camino/home/joe</span>
<span class="c"># zfs rename camino/home/joenew camino/home/joe</span>
<span class="c"># ls /usr/home/joe</span>
backup.txz     loader.conf     plans.txt
<span class="c"># df -h /usr/home</span>
Filesystem          Size    Used   Avail Capacity  Mounted on
usr/home/joe        1.3G    128k    1.3G     0%    /usr/home/joe</code></pre>
</div>
</div>
<div class="paragraph">
<p>克隆的快照现在是一个普通的数据集。它包含了原始快照中的所有数据，以及像 <span class="filename">loader.conf</span> 这样添加到其中的文件。在不同的场景中，克隆为 ZFS 用户提供了有用的功能。例如，可以将 jails 作为包含不同安装应用程序集的快照。用户可以克隆这些快照，并根据需要添加自己的应用程序。一旦对更改满意，可以将克隆提升为完整的数据集，并将其提供给最终用户，就像使用真实数据集一样。这样可以节省提供这些监狱时的时间和管理开销。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-send">22.4.7. 复制<a class="anchor" href="#zfs-zfs-send"></a></h4>
<div class="paragraph">
<p>将数据存储在一个位置的单个池中会使其暴露于盗窃、自然灾害或人为灾害等风险。定期备份整个池是至关重要的。 ZFS 提供了一个内置的序列化功能，可以将数据的流表示发送到标准输出。使用此功能，可以将这些数据存储在连接到本地系统的另一个池中，也可以将其发送到另一个系统上的网络上。快照是复制的基础（参见 <a href="#zfs-zfs-snapshot">ZFS 快照</a> 部分）。用于复制数据的命令是 <code>zfs send</code> 和 <code>zfs receive</code>。</p>
</div>
<div class="paragraph">
<p>这些示例展示了使用这两个存储池进行 ZFS 复制的情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M    77K   896M         -         -     0%    0%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%    4%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>名为 <em>mypool</em> 的池是主要的池，数据的写入和读取在此池中定期进行。在主要池不可用时，使用第二个备用池 <em>backup</em>。请注意，ZFS 不会自动执行此故障转移，而是需要系统管理员在需要时手动执行。使用快照提供一致的文件系统版本进行复制。在创建 <em>mypool</em> 的快照后，通过复制快照将其复制到 <em>backup</em> 池中。这不包括自最近快照以来所做的更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot mypool@backup1</span>
<span class="c"># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@backup1             0      -  43.6M  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在有了一个快照，使用 <code>zfs send</code> 命令创建一个表示快照内容的流。将这个流存储为文件，或者在另一个存储池中接收它。将流写入标准输出，但要将其重定向到文件或管道，否则会出现错误。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs send mypool@backup1</span>
Error: Stream can not be written to a terminal.
You must redirect standard output.</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>zfs send</code> 命令备份数据集时，将其重定向到位于已挂载的备份池上的文件。确保备份池有足够的空间来容纳发送的快照的大小，这指的是快照中包含的数据，而不是与上一个快照的更改。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs send mypool@backup1 &gt; /backup/backup1</span>
<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>zfs send</code> 命令将名为 <em>backup1</em> 的快照中的所有数据传输到名为 <em>backup</em> 的存储池中。要自动创建和发送这些快照，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 任务。</p>
</div>
<div class="paragraph">
<p>ZFS 可以将备份存储为实时文件系统，而不是存储为归档文件，从而可以直接访问备份数据。要访问这些流中包含的实际数据，可以使用 <code>zfs receive</code> 将流转换回文件和目录。下面的示例结合了 <code>zfs send</code> 和 <code>zfs receive</code> ，使用管道将数据从一个存储池复制到另一个存储池。在传输完成后，可以直接在接收存储池上使用数据。只能将数据集复制到空数据集。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot mypool@replica1</span>
<span class="c"># zfs send -v mypool@replica1 | zfs receive backup/mypool</span>
send from @ to mypool@replica1 estimated size is 50.1M
total estimated size is 50.1M
TIME        SENT   SNAPSHOT

<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG    CAP  DEDUP  HEALTH  ALTROOT
backup  960M  63.7M   896M         -         -     0%     6%  1.00x  ONLINE  -
mypool  984M  43.7M   940M         -         -     0%     4%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="sect4">
<h5 id="zfs-send-incremental">22.4.7.1. 增量备份<a class="anchor" href="#zfs-send-incremental"></a></h5>
<div class="paragraph">
<p><code>zfs send</code> 还可以确定两个快照之间的差异，并发送两者之间的个别差异。这样可以节省磁盘空间和传输时间。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs snapshot mypool@replica2</span>
<span class="c"># zfs list -t snapshot</span>
NAME                    USED  AVAIL  REFER  MOUNTPOINT
mypool@replica1         5.72M      -  43.6M  -
mypool@replica2             0      -  44.1M  -
<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG   CAP  DEDUP  HEALTH  ALTROOT
backup  960M  61.7M   898M         -         -     0%    6%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%    5%  1.00x  ONLINE  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>创建一个名为 <em>replica2</em> 的第二个快照。这个第二个快照包含了从现在到上一个快照 <em>replica1</em> 之间对文件系统所做的更改。使用 <code>zfs send -i</code> 命令，并指定快照对，可以生成一个增量复制流，其中包含了更改的数据。如果接收端已经存在初始快照，则此操作将成功。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs send -v -i mypool@replica1 mypool@replica2 | zfs receive /backup/mypool</span>
send from @replica1 to mypool@replica2 estimated size is 5.02M
total estimated size is 5.02M
TIME        SENT   SNAPSHOT

<span class="c"># zpool list</span>
NAME    SIZE  ALLOC   FREE   CKPOINT  EXPANDSZ   FRAG  CAP  DEDUP  HEALTH  ALTROOT
backup  960M  80.8M   879M         -         -     0%   8%  1.00x  ONLINE  -
mypool  960M  50.2M   910M         -         -     0%   5%  1.00x  ONLINE  -

<span class="c"># zfs list</span>
NAME                         USED  AVAIL  REFER  MOUNTPOINT
backup                      55.4M   240G   152K  /backup
backup/mypool               55.3M   240G  55.2M  /backup/mypool
mypool                      55.6M  11.6G  55.0M  /mypool

<span class="c"># zfs list -t snapshot</span>
NAME                                         USED  AVAIL  REFER  MOUNTPOINT
backup/mypool@replica1                       104K      -  50.2M  -
backup/mypool@replica2                          0      -  55.2M  -
mypool@replica1                             29.9K      -  50.0M  -
mypool@replica2                                 0      -  55.0M  -</code></pre>
</div>
</div>
<div class="paragraph">
<p>增量流复制了变化的数据，而不是整个 <em>replica1</em>。仅发送差异所需的传输时间更短，并且通过不每次复制整个池来节省磁盘空间。这在通过慢速网络或按传输字节计费的网络上进行复制时非常有用。</p>
</div>
<div class="paragraph">
<p>一个新的文件系统，<em>backup/mypool</em>，可用于存储来自池 <em>mypool</em> 的文件和数据。使用 <code>-p</code> 参数可以复制数据集的属性，包括压缩设置、配额和挂载点。使用 <code>-R</code> 参数可以复制数据集的所有子数据集以及它们的属性。自动化发送和接收操作可以在第二个池中创建定期备份。</p>
</div>
</div>
<div class="sect4">
<h5 id="zfs-send-ssh">22.4.7.2. 通过 SSH 发送加密备份<a class="anchor" href="#zfs-send-ssh"></a></h5>
<div class="paragraph">
<p>通过网络发送流是保持远程备份的好方法，但它也有一个缺点。通过网络链路发送的数据没有加密，允许任何人在不知情的情况下拦截和转换流为数据。当将流发送到远程主机时，这是不可取的。使用 SSH 来安全地加密通过网络连接发送的数据。由于 ZFS 需要将流重定向到标准输出，所以通过 SSH 进行管道传输很容易。为了在传输和远程系统上保持文件系统的内容加密，考虑使用 <a href="https://wiki.freebsd.org/PEFS">PEFS</a>。</p>
</div>
<div class="paragraph">
<p>首先，更改一些设置并采取安全预防措施。这描述了执行 <code>zfs send</code> 操作所需的必要步骤；有关 SSH 的更多信息，请参见 <a href="./#openssh">OpenSSH</a> 。</p>
</div>
<div class="paragraph">
<p>将配置更改如下：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>使用 SSH 密钥在发送和接收主机之间实现无密码 SSH 访问</p>
</li>
<li>
<p>ZFS 需要 <code>root</code> 用户的权限来发送和接收流。这需要以 <code>root</code> 用户身份登录到接收系统。</p>
</li>
<li>
<p>出于安全原因，默认情况下禁止 <code>root</code> 用户登录。</p>
</li>
<li>
<p>使用 <a href="#zfs-zfs-allow">ZFS 委派</a> 系统，允许每个系统上的非 <code>root</code> 用户执行相应的发送和接收操作。在发送系统上：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs allow -u someuser send,snapshot mypool</span></code></pre>
</div>
</div>
</li>
<li>
<p>要挂载池，非特权用户必须拥有该目录的所有权，并且普通用户需要有挂载文件系统的权限。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在接收系统上：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl vfs.usermount=1</span>
vfs.usermount: 0 -&gt; 1
<span class="c"># echo vfs.usermount=1 &gt;&gt; /etc/sysctl.conf</span>
<span class="c"># zfs create recvpool/backup</span>
<span class="c"># zfs allow -u someuser create,mount,receive recvpool/backup</span>
<span class="c"># chown someuser /recvpool/backup</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>非特权用户现在可以接收和挂载数据集，并将 <em>home</em> 数据集复制到远程系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>zfs snapshot -r mypool/home@monday
<span class="gp">% </span>zfs send -R mypool/home@monday | ssh someuser@backuphost zfs recv -dvu recvpool/backup</code></pre>
</div>
</div>
<div class="paragraph">
<p>在池 <em>mypool</em> 上创建一个名为 <em>monday</em> 的文件系统数据集 <em>home</em> 的递归快照。然后，<code>zfs send -R</code> 命令将数据集、所有子数据集、快照、克隆和设置包含在流中。通过 SSH 将输出导向等待的远程主机 <em>backuphost</em> 上的 <code>zfs receive</code> 命令。使用 IP 地址或完全限定域名是良好的实践。接收机将数据写入 <em>recvpool</em> 池上的 <em>backup</em> 数据集。在 <code>zfs recv</code> 命令中添加 <code>-d</code> 选项会使用快照的名称覆盖接收端池的名称。 <code>-u</code> 选项会导致接收端上的文件系统不挂载。使用 <code>-v</code> 选项可以显示有关传输的更多详细信息，包括经过的时间和传输的数据量。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-quota">22.4.8. 数据集、用户和组配额<a class="anchor" href="#zfs-zfs-quota"></a></h4>
<div class="paragraph">
<p>使用 <a href="#zfs-term-quota">数据集配额 </a> 来限制特定数据集消耗的空间量。 <a href="#zfs-term-refquota">引用配额 </a> 的工作方式类似，但是计算的是数据集本身使用的空间，不包括快照和子数据集。同样地，使用 <a href="#zfs-term-userquota">用户配额 </a> 和 <a href="#zfs-term-groupquota">组配额 </a> 来防止用户或组使用完池或数据集中的所有空间。</p>
</div>
<div class="paragraph">
<p>以下示例假设用户已经存在于系统中。在将用户添加到系统之前，请确保首先创建他们的主目录数据集，并将 <code>mountpoint</code> 设置为 <code>/home/<em>bob</em></code> 。然后，创建用户并将主目录指向数据集的 <code>mountpoint</code> 位置。这将正确设置所有者和组权限，而不会遮盖可能存在的任何预先存在的主目录路径。</p>
</div>
<div class="paragraph">
<p>为了对 <span class="filename">storage/home/bob</span> 强制执行一个 10 GB 的数据集配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set quota=10G storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了强制限制 <span class="filename">storage/home/bob</span> 的引用配额为 10 GB ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set refquota=10G storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要移除 <span class="filename">storage/home/bob</span> 的 10 GB 配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set quota=none storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通用格式为 <code>userquota@<em>user</em>=<em>size</em></code> ，用户的名称必须符合以下格式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>POSIX 兼容的名称，例如 <em>joe</em>。</p>
</li>
<li>
<p>POSIX 数值 ID，例如 <em>789</em>。</p>
</li>
<li>
<p>SID 名称，例如 <em>joe.bloggs@example.com</em>。</p>
</li>
<li>
<p>SID 是一个数字 ID，例如 <em>S-1-123-456-789</em>。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>例如，要为名为 <em>joe</em> 的用户强制执行 50 GB 的用户配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set userquota@joe=50G</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要移除任何配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set userquota@joe=none</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>zfs get all</code> 命令不会显示用户配额属性。非 <code>root</code> 用户除非被授予 <code>userquota</code> 权限，否则无法查看其他用户的配额。拥有此权限的用户可以查看和设置所有人的配额。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>设置群组配额的一般格式为：<code>groupquota@<em>group</em>=<em>size</em></code> 。</p>
</div>
<div class="paragraph">
<p>要将组 <em>firstgroup</em> 的配额设置为 50 GB，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set groupquota@firstgroup=50G</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要删除组 <em>firstgroup</em> 的配额，或确保未设置配额，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set groupquota@firstgroup=none</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与用户配额属性一样，非 <code>root</code> 用户可以查看与他们所属的组相关联的配额。具有 <code>groupquota</code> 特权或 <code>root</code> 权限的用户可以查看和设置所有组的所有配额。</p>
</div>
<div class="paragraph">
<p>要显示文件系统或快照中每个用户使用的空间量以及任何配额，请使用 <code>zfs userspace</code>。要获取组信息，请使用 <code>zfs groupspace</code>。有关支持的选项或如何仅显示特定选项的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=zfs&amp;sektion=1&amp;format=html">zfs(1)</a>。</p>
</div>
<div class="paragraph">
<p>特权用户和 <code>root</code> 用户可以使用以下命令列出 <span class="filename">storage/home/bob</span> 目录的配额：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get quota storage/home/bob</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-reservation">22.4.9. 预留空间<a class="anchor" href="#zfs-zfs-reservation"></a></h4>
<div class="paragraph">
<p><a href="#zfs-term-reservation">预留空间 </a> 保证了数据集上始终可用的一定量空间。预留的空间将不会对其他数据集可用。这个有用的功能确保了重要数据集或日志文件的可用的空闲空间。</p>
</div>
<div class="paragraph">
<p><code>reservation</code> 属性的一般格式是 <code>reservation=<em>size</em></code>，因此要在 <span class="filename">storage/home/bob</span> 上设置 10 GB 的预留空间，可以使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set reservation=10G storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>取消任何预留空间：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set reservation=none storage/home/bob</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>同样的原则适用于设置 <code>refreservation</code> 属性以设置 <a href="#zfs-term-refreservation">引用预留 </a>，其一般格式为 <code>refreservation =<em>size</em></code> 。</p>
</div>
<div class="paragraph">
<p>该命令显示位于 <span class="filename">storage/home/bob</span> 目录下的任何预留空间或引用预留空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get reservation storage/home/bob</span>
<span class="c"># zfs get refreservation storage/home/bob</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-compression">22.4.10. 压缩<a class="anchor" href="#zfs-zfs-compression"></a></h4>
<div class="paragraph">
<p>ZFS 提供透明压缩功能。在块级别压缩数据可以节省空间，同时提高磁盘吞吐量。如果数据压缩率为 25% ，压缩后的数据写入磁盘的速度与未压缩版本相同，从而实现了 125% 的有效写入速度。压缩也可以作为 <a href="#zfs-zfs-deduplication">去重</a> 的一个很好的替代方案，因为它不需要额外的内存。</p>
</div>
<div class="paragraph">
<p>ZFS 提供了不同的压缩算法，每种算法都有不同的权衡。在 ZFS v5000 中引入的 LZ4 压缩算法可以在不牺牲性能的情况下对整个池进行压缩。 LZ4 的最大优势是 <em>提前中止（early abort）</em> 功能。如果 LZ4 在数据的头部部分无法达到至少 12.5% 的压缩率， ZFS 会以未压缩的方式写入该块，以避免浪费 CPU 周期尝试压缩已经压缩或无法压缩的数据。有关 ZFS 中可用的不同压缩算法的详细信息，请参阅术语部分中的 <a href="#zfs-term-compression">压缩</a> 条目。</p>
</div>
<div class="paragraph">
<p>管理员可以通过数据集属性查看压缩的有效性。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs get used,compressratio,compression,logicalused mypool/compressed_dataset</span>
NAME        PROPERTY          VALUE     SOURCE
mypool/compressed_dataset  used              449G      -
mypool/compressed_dataset  compressratio     1.11x     -
mypool/compressed_dataset  compression       lz4       <span class="nb">local
</span>mypool/compressed_dataset  logicalused       496G      -</code></pre>
</div>
</div>
<div class="paragraph">
<p>该数据集使用了 449 GB 的空间（使用的属性）。如果不进行压缩，它将占用 496 GB 的空间（逻辑使用的属性）。这导致了 1.11:1 的压缩比率。</p>
</div>
<div class="paragraph">
<p>当与 <a href="#zfs-term-userquota">用户配额 </a> 结合使用时，压缩可能会产生意想不到的副作用。用户配额限制了用户在数据集上实际消耗的空间（在压缩之后）。如果一个用户的配额是 10GB ，并写入了 10GB 的可压缩数据，他们仍然可以存储更多的数据。如果他们稍后更新一个文件，比如一个数据库，其中包含更多或更少可压缩的数据，可用空间的数量将会改变。这可能导致一个奇怪的情况，即用户没有增加实际数据量（ <code>logicalused</code> 属性），但压缩的变化导致他们达到了配额限制。</p>
</div>
<div class="paragraph">
<p>压缩可能会与备份产生类似的意外交互作用。配额通常用于限制数据存储，以确保有足够的备份空间可用。由于配额不考虑压缩，因此 ZFS 可能会写入比未压缩备份所能容纳的更多数据。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-compression-zstd">22.4.11. Zstandard 压缩<a class="anchor" href="#zfs-zfs-compression-zstd"></a></h4>
<div class="paragraph">
<p>OpenZFS 2.0 增加了一种新的压缩算法。Zstandard（Zstd）提供比默认的 LZ4 更高的压缩比，同时比替代方案 gzip 速度更快。OpenZFS 2.0 可以通过 FreeBSD 12.1-RELEASE 的 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/openzfs/">sysutils/openzfs</a> 包获得，并且自 FreeBSD 13.0-RELEASE 以来已成为默认选项。</p>
</div>
<div class="paragraph">
<p>Zstd 提供了多种压缩级别，可以对性能和压缩比进行细粒度控制。Zstd 的一个主要优势是解压速度与压缩级别无关。对于只写入一次但经常读取的数据， Zstd 允许使用最高的压缩级别而不会影响读取性能。</p>
</div>
<div class="paragraph">
<p>即使进行频繁的数据更新，启用压缩通常也能提供更高的性能。其中最大的优势之一来自于压缩的 ARC 功能。 ZFS 的自适应替换缓存（ARC）将数据的压缩版本缓存在 RAM 中，每次需要时进行解压缩。这使得相同数量的 RAM 能够存储更多的数据和元数据，从而增加了缓存命中率。</p>
</div>
<div class="paragraph">
<p>ZFS 提供 19 个级别的 Zstd 压缩，每个级别都可以在更慢的压缩速度下提供更多的空间节省。默认级别是 <code>zstd-3</code>，比 LZ4 提供更好的压缩效果，但速度不会慢太多。级别超过 10 需要大量的内存来压缩每个块，内存小于 16GB 的系统不应使用这些级别。ZFS 还使用了一系列的 Zstd_fast_ 级别，它们的压缩速度更快，但支持的压缩比较低。ZFS 支持 <code>zstd-fast-1</code> 到 <code>zstd-fast-10</code>，以及以 10 为增量的 <code>zstd-fast-20</code> 到 <code>zstd-fast-100</code>，还有 <code>zstd-fast-500</code> 和 <code>zstd-fast-1000</code>，它们提供最小的压缩效果，但具有高性能。</p>
</div>
<div class="paragraph">
<p>如果 ZFS 无法获取所需的内存来使用 Zstd 压缩块，它将退回到存储未压缩的块。除非在内存受限的系统上使用 Zstd 的最高级别，否则这种情况不太可能发生。ZFS 通过 <code>kstat.zfs.misc.zstd.compress_alloc_fail</code> 统计自加载 ZFS 模块以来发生此情况的次数。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-deduplication">22.4.12. 去重<a class="anchor" href="#zfs-zfs-deduplication"></a></h4>
<div class="paragraph">
<p>当启用时，<a href="#zfs-term-deduplication">去重 </a> 使用每个块的校验和来检测重复块。当一个新块是现有块的副本时，ZFS 会写入一个对现有数据的新引用，而不是整个重复块。如果数据包含大量重复的文件或重复的信息，则可以实现巨大的空间节省。警告：去重需要大量的内存，并且启用压缩可以在不增加额外成本的情况下提供大部分的空间节省。</p>
</div>
<div class="paragraph">
<p>要激活去重功能，请在目标池上设置 <code>dedup</code> 属性：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs set dedup=on pool</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>去重只会影响写入池中的新数据。仅仅激活此选项不会对已经写入池中的数据进行去重。一个刚刚激活去重属性的池子将会像这个例子一样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool list</span>
NAME  SIZE ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG   CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 2.19M 2.83G         -         -     0%    0%   1.00x   ONLINE   -</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DEDUP</code> 列显示了池的实际重复消除率。<code>1.00x</code> 的值表示数据尚未进行重复消除。下面的示例将一些系统二进制文件复制了三次，分别放入在上述创建的重复消除池中的不同目录中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># for d in dir1 dir2 dir3; do</span>
<span class="gp">&gt; </span>mkdir <span class="nv">$d</span> <span class="o">&amp;&amp;</span> cp -R /usr/bin <span class="nv">$d</span> &amp;
<span class="gp">&gt; </span><span class="k">done</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要观察冗余数据的去重，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zpool list</span>
NAME SIZE  ALLOC  FREE   CKPOINT  EXPANDSZ   FRAG  CAP   DEDUP   HEALTH   ALTROOT
pool 2.84G 20.9M 2.82G         -         -     0%   0%   3.00x   ONLINE   -</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>DEDUP</code> 列显示了一个 <code>3.00x</code> 的因子。检测和去重数据的副本使用了三分之一的空间。节省空间的潜力是巨大的，但需要足够的内存来跟踪去重块的成本。</p>
</div>
<div class="paragraph">
<p>当池中的数据不冗余时，去重并不总是有益的。ZFS 可以通过在现有池上模拟去重来显示潜在的节省空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zdb -S pool</span>
Simulated DDT histogram:

bucket              allocated                       referenced
______   ______________________________   ______________________________
refcnt   blocks   LSIZE   PSIZE   DSIZE   blocks   LSIZE   PSIZE   DSIZE
------   ------   -----   -----   -----   ------   -----   -----   -----
     1    2.58M    289G    264G    264G    2.58M    289G    264G    264G
     2     206K   12.6G   10.4G   10.4G     430K   26.4G   21.6G   21.6G
     4    37.6K    692M    276M    276M     170K   3.04G   1.26G   1.26G
     8    2.18K   45.2M   19.4M   19.4M    20.0K    425M    176M    176M
    16      174   2.83M   1.20M   1.20M    3.33K   48.4M   20.4M   20.4M
    32       40   2.17M    222K    222K    1.70K   97.2M   9.91M   9.91M
    64        9     56K   10.5K   10.5K      865   4.96M    948K    948K
   128        2   9.50K      2K      2K      419   2.11M    438K    438K
   256        5   61.5K     12K     12K    1.90K   23.0M   4.47M   4.47M
    1K        2      1K      1K      1K    2.98K   1.49M   1.49M   1.49M
 Total    2.82M    303G    275G    275G    3.20M    319G    287G    287G

dedup <span class="o">=</span> 1.05, compress <span class="o">=</span> 1.11, copies <span class="o">=</span> 1.00, dedup <span class="k">*</span> compress / copies <span class="o">=</span> 1.16</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>zdb -S</code> 完成分析池之后，它会显示激活去重将实现的空间减少比例。在这种情况下， <code>1.16</code> 是一个主要由压缩提供的较低的节省空间比例。在此池上激活去重将不会节省任何空间，并且不值得为启用去重所需的内存量。使用公式 <em>ratio = dedup * compress / copies</em>，系统管理员可以规划存储分配，决定工作负载是否包含足够的重复块来证明内存需求的合理性。如果数据可以合理压缩，空间节省可能会很好。良好的做法是首先启用压缩，因为压缩还可以大大提高性能。在节省可观且有足够可用内存用于 <a href="#zfs-term-deduplication">DDT</a> 的情况下启用去重。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-jail">22.4.13. ZFS 和 Jails<a class="anchor" href="#zfs-zfs-jail"></a></h4>
<div class="paragraph">
<p>使用 <code>zfs jail</code> 命令和相应的 <code>jailed</code> 属性将一个 ZFS 数据集委派给一个 <a href="./#jails">jail</a>。 <code>zfs jail <em>jailid</em></code> 命令将数据集附加到指定的 jail，<code>zfs unjail</code> 命令将其分离。要在 jails 内控制数据集，需要设置 <code>jailed</code> 属性。由于被 jailed 的数据集可能具有会危及主机安全的挂载点，ZFS 禁止在主机上挂载被 jailed 的数据集。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-zfs-allow">22.5. 委派管理<a class="anchor" href="#zfs-zfs-allow"></a></h3>
<div class="paragraph">
<p>一个全面的权限委派系统允许非特权用户执行 ZFS 管理功能。例如，如果每个用户的主目录是一个数据集，用户需要有权限创建和销毁其主目录的快照。执行备份的用户可以获得使用复制功能的权限。ZFS 允许一个使用统计脚本仅以访问所有用户的空间使用数据的方式运行。还可以委派委派权限的能力。权限委派对于每个子命令和大多数属性都是可能的。</p>
</div>
<div class="sect3">
<h4 id="zfs-zfs-allow-create">22.5.1. 委托数据集创建<a class="anchor" href="#zfs-zfs-allow-create"></a></h4>
<div class="paragraph">
<p><code>zfs allow <em>someuser</em> create <em>mydataset</em></code> 给予指定用户在选定的父数据集下创建子数据集的权限。但需要注意的是，创建新数据集需要挂载它。这要求设置 FreeBSD 的 <code>vfs.usermount</code> 系统控制变量为 <code>1</code>，以允许非 root 用户挂载文件系统。另外，为了防止滥用，非 root 用户必须拥有挂载点来进行文件系统的挂载。</p>
</div>
</div>
<div class="sect3">
<h4 id="zfs-zfs-allow-allow">22.5.2. 委派权限委派<a class="anchor" href="#zfs-zfs-allow-allow"></a></h4>
<div class="paragraph">
<p><code>zfs allow <em>someuser</em> allow <em>mydataset</em></code> 命令会赋予指定用户在目标数据集及其子数据集上分配其拥有的任何权限给其他用户的能力。如果一个用户拥有 <code>snapshot</code> 权限和 <code>allow</code> 权限，那么该用户可以将 <code>snapshot</code> 权限授予其他用户。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-advanced">22.6. 高级主题<a class="anchor" href="#zfs-advanced"></a></h3>
<div class="sect3">
<h4 id="zfs-advanced-tuning">22.6.1. 调优<a class="anchor" href="#zfs-advanced-tuning"></a></h4>
<div class="paragraph">
<p>调整可调节参数以使 ZFS 在不同的工作负载下表现最佳。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="zfs-advanced-tuning-arc_max"></a> <code><em>vfs.zfs.arc.max</em></code> 从 13.x 开始（12.x 为 <code>vfs.zfs.arc_max</code>） - <a href="#zfs-term-arc">ARC</a> 的上限大小。默认值为所有 RAM 减去 1 GB ，或所有 RAM 的 5/8 ，以较大者为准。如果系统运行其他可能需要内存的守护程序或进程，请使用较低的值。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 在运行时调整此值，并在 <span class="filename">/boot/loader.conf</span> 或 <span class="filename">/etc/sysctl.conf</span> 中设置。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-arc_meta_limit"></a> <code><em>vfs.zfs.arc.meta_limit</em></code> 从 13.x 版本开始（12.x 版本为 <code>vfs.zfs.arc_meta_limit</code>） - 限制用于存储元数据的 <a href="#zfs-term-arc">ARC</a> 的数量。默认值为 <code>vfs.zfs.arc.max</code> 的四分之一。如果工作负载涉及大量文件和目录的操作，或者频繁的元数据操作，增加此值将提高性能，但会减少适应于 <a href="#zfs-term-arc">ARC</a> 的文件数据量。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 在 <span class="filename">/boot/loader.conf</span> 或 <span class="filename">/etc/sysctl.conf</span> 中在运行时调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-arc_min"></a> <code><em>vfs.zfs.arc.min</em></code> 从 13.x 开始（12.x 为 <code>vfs.zfs.arc_min</code>） - 降低 <a href="#zfs-term-arc">ARC</a> 的大小。默认值为 <code>vfs.zfs.arc.meta_limit</code> 的一半。调整此值以防止其他应用程序将整个 <a href="#zfs-term-arc">ARC</a> 压力过大。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 在运行时调整此值，并在 <span class="filename">/boot/loader.conf</span> 或 <span class="filename">/etc/sysctl.conf</span> 中进行调整。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-vdev-cache-size"></a> <code><em>vfs.zfs.vdev.cache.size</em></code> - 在池中的每个设备上预留的用作缓存的内存的预分配量。使用的总内存量将是此值乘以设备数量。在引导时和 <span class="filename">/boot/loader.conf</span> 中设置此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-min-auto-ashift"></a> <code><em>vfs.zfs.min_auto_ashift</em></code> - 在创建池时自动使用的较低的 <code>ashift</code>（扇区大小）。该值是 2 的幂。默认值为 <code>9</code> 表示 <code>2^9 = 512</code> ，即 512 字节的扇区大小。为了避免写放大并获得最佳性能，将此值设置为池中设备使用的最大扇区大小。</p>
<div class="paragraph">
<p>普通硬盘的扇区大小为 4 KB 。在这些硬盘上使用默认的 <code>ashift</code> 值 <code>9</code> 会导致写放大。一个 4 KB 的写入数据实际上会被分成八个 512 字节的写入操作。在创建存储池时，ZFS 会尝试从所有设备中读取原生扇区大小，但是具有 4 KB 扇区的硬盘会报告它们的扇区大小为 512 字节，以保证兼容性。在创建存储池之前，将 <code>vfs.zfs.min_auto_ashift</code> 设置为 <code>12</code>（<code>2^12 = 4096</code>）可以强制 ZFS 在这些硬盘上使用 4 KB 块以获得最佳性能。</p>
</div>
<div class="paragraph">
<p>对于计划进行磁盘升级的存储池来说，强制使用 4 KB 块也是有用的。未来的磁盘使用 4 KB 扇区，并且在创建存储池后无法更改 <code>ashift</code> 值。</p>
</div>
<div class="paragraph">
<p>在某些特定情况下，较小的 512 字节块大小可能更可取。当与用于数据库或作为虚拟机存储的 512 字节磁盘一起使用时，小规模随机读取时的数据传输量较少。这可以在使用较小的 ZFS 记录大小时提供更好的性能。</p>
</div>
</li>
<li>
<p><a id="zfs-advanced-tuning-prefetch_disable"></a> <code><em>vfs.zfs.prefetch_disable</em></code> - 禁用预读取。值为 <code>0</code> 表示启用，值为 <code>1</code> 表示禁用。默认值为 <code>0</code>，除非系统内存小于 4 GB。预读取通过读取比请求的块更大的块到 <a href="#zfs-term-arc">ARC</a> 中，希望很快需要这些数据。如果工作负载有大量的随机读取，禁用预读取可能会通过减少不必要的读取来提高性能。可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-vdev-trim_on_init"></a> <code><em>vfs.zfs.vdev.trim_on_init</em></code> - 控制是否在将新设备添加到池中时对其运行 <code>TRIM</code> 命令。这可以确保 SSD 的最佳性能和寿命，但会花费额外的时间。如果设备已经进行了安全擦除，则禁用此设置将使新设备的添加更快。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-vdev-max_pending"></a> <code><em>vfs.zfs.vdev.max_pending</em></code> - 限制每个设备的待处理 I/O 请求的数量。较高的值将保持设备命令队列满，并可能提供更高的吞吐量。较低的值将减少延迟。您可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-top_maxinflight"></a> <code><em>vfs.zfs.top_maxinflight</em></code> - 每个顶级 <a href="#zfs-term-vdev">vdev</a> 的未完成 I/O 的上限。限制命令队列的深度以防止高延迟。该限制是针对每个顶级 vdev 的，意味着该限制独立应用于每个 <a href="#zfs-term-vdev-mirror">镜像</a> 、 <a href="#zfs-term-vdev-raidz">RAID-Z</a> 或其他 vdev 。可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-l2arc_write_max"></a> <code><em>vfs.zfs.l2arc_write_max</em></code> - 限制每秒写入 <a href="#zfs-term-l2arc">L2ARC</a> 的数据量。通过限制写入设备的数据量，此可调整参数可以延长固态硬盘（SSD）的使用寿命。您可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-l2arc_write_boost"></a> <code><em>vfs.zfs.l2arc_write_boost</em></code> - 将此可调整值添加到 <a href="#zfs-advanced-tuning-l2arc_write_max"><code>vfs.zfs.l2arc_write_max</code></a> 中，并增加对 SSD 的写入速度，直到从 <a href="#zfs-term-l2arc">L2ARC</a> 中驱逐第一个块。这个&#34;Turbo Warmup Phase&#34;可以减少重启后空的 <a href="#zfs-term-l2arc">L2ARC</a> 带来的性能损失。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-scrub_delay"></a> <code><em>vfs.zfs.scrub_delay</em></code> - 在进行 <a href="#zfs-term-scrub"><code>scrub</code></a> 时，每个 I/O 之间的延迟时间。为了确保 <code>scrub</code> 不会干扰池的正常操作，如果有其他 I/O 正在进行， <code>scrub</code> 会在每个命令之间进行延迟。该值控制了 <code>scrub</code> 生成的总 IOPS（每秒 I/O 数）的限制。设置的粒度由 <code>kern.hz</code> 的值确定，默认为每秒 1000 个滴答。更改此设置会导致不同的有效 IOPS 限制。默认值为 <code>4</code> ，因此限制为： 1000 个滴答/秒 ÷ 4 = 250 IOPS 。使用值为 <em>20</em> 将得到限制：1000 个滴答/秒 ÷ 20 = 50 IOPS。池上的最近活动限制了 <code>scrub</code> 的速度，由 <a href="#zfs-advanced-tuning-scan_idle"><code>vfs.zfs.scan_idle</code></a> 确定。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-resilver_delay"></a> <code><em>vfs.zfs.resilver_delay</em></code> - 在 <a href="#zfs-term-resilver">重建</a> 过程中，每个 I/O 之间插入的延迟时间，以毫秒为单位。为了确保 resilver 不会干扰池的正常操作，如果有其他 I/O 正在进行，resilver 将在每个命令之间延迟。该值控制由 resilver 生成的总 IOPS（每秒 I/O 数）的限制。ZFS 通过 <code>kern.hz</code> 的值确定设置的粒度，默认为每秒 1000 个滴答。更改此设置会导致不同的有效 IOPS 限制。默认值为 2 ，结果为：1000 个滴答/秒 ÷ 2 = 500 IOPS 。如果另一个设备故障可能导致池发生故障，从而导致数据丢失，则将池恢复到 <a href="#zfs-term-online">在线</a> 状态可能更为重要。值为 0 将使 resilver 操作与其他操作具有相同的优先级，加快修复过程。池上的其他最近活动会限制 resilver 的速度，由 <a href="#zfs-advanced-tuning-scan_idle"><code>vfs.zfs.scan_idle</code></a> 确定。随时可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><a id="zfs-advanced-tuning-scan_idle"></a> <code><em>vfs.zfs.scan_idle</em></code> - 距离上次操作的毫秒数，用于判断池是否处于空闲状态。当池处于空闲状态时， ZFS 会禁用对 <a href="#zfs-term-scrub"><code>scrub</code></a> 和 <a href="#zfs-term-resilver">重建</a> 的速率限制。您可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
<li>
<p><code><em>vfs.zfs.txg.timeout</em></code> - 两个 <a href="#zfs-term-txg">事务组 </a> 之间的最长时间间隔，以秒为单位。当前事务组将数据写入池中，并且如果自上一个事务组以来经过了这么长时间，则会启动一个新的事务组。如果写入的数据足够多，事务组可能会提前触发。默认值为 5 秒。增大该值可能会通过延迟异步写入来提高读取性能，但这可能会导致写入事务组时性能不均衡。可以随时使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 调整此值。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="zfs-advanced-i386">22.6.2. i386 上的 ZFS<a class="anchor" href="#zfs-advanced-i386"></a></h4>
<div class="paragraph">
<p>ZFS 提供的一些功能对内存要求较高，可能需要在内存有限的系统上进行调整以达到最佳效率。</p>
</div>
<div class="sect4">
<h5 id="_内存">22.6.2.1. 内存<a class="anchor" href="#_内存"></a></h5>
<div class="paragraph">
<p>作为一个较低的值，总系统内存应至少为 1GB 。推荐的 RAM 数量取决于存储池的大小和 ZFS 使用的功能。一个经验法则是每 1TB 存储空间需要 1GB 的 RAM 。如果使用去重功能，一个经验法则是每 1TB 存储空间需要 5GB 的 RAM 用于去重。虽然一些用户在较少的 RAM 下使用 ZFS，但在负载较重的系统下可能会因内存耗尽而发生崩溃。对于 RAM 低于推荐要求的系统，可能需要进一步调整 ZFS 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_内核配置">22.6.2.2. 内核配置<a class="anchor" href="#_内核配置"></a></h5>
<div class="paragraph">
<p>由于 i386™ 平台的地址空间限制， i386™ 架构上的 ZFS 用户必须将此选项添加到自定义内核配置文件中，重新构建内核并重新启动：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options        KVA_PAGES=512</pre>
</div>
</div>
<div class="paragraph">
<p>这将扩展内核地址空间，允许 <code>vm.kvm_size</code> 可调参数超过 1 GB 的限制，或者超过 PAE 的 2 GB 限制。为了找到最合适的选项值，将所需的地址空间以兆字节为单位除以四。在这个例子中，为 2 GB 选择 <code>512</code>。</p>
</div>
</div>
<div class="sect4">
<h5 id="_加载器可调参数">22.6.2.3. 加载器可调参数<a class="anchor" href="#_加载器可调参数"></a></h5>
<div class="paragraph">
<p>在所有 FreeBSD 架构上增加了 <span class="filename">kmem</span> 地址空间。一个具有 1 GB 物理内存的测试系统通过将这些选项添加到 <span class="filename">/boot/loader.conf</span> 并重新启动来受益。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vm.kmem_size=&#34;330M&#34;
vm.kmem_size_max=&#34;330M&#34;
vfs.zfs.arc.max=&#34;40M&#34;
vfs.zfs.vdev.cache.size=&#34;5M&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>有关 ZFS 相关调优的更详细建议列表，请参阅 <a href="https://wiki.freebsd.org/ZFSTuningGuide" class="bare">https://wiki.freebsd.org/ZFSTuningGuide</a> 。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="zfs-links">22.7. 进一步资源<a class="anchor" href="#zfs-links"></a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://openzfs.org/">OpenZFS</a></p>
</li>
<li>
<p><a href="https://wiki.freebsd.org/ZFSTuningGuide">FreeBSD Wiki - ZFS 调优</a></p>
</li>
<li>
<p><a href="https://calomel.org/zfs_raid_speed_capacity.html">Calomel 博客 - ZFS Raidz 性能、容量和完整性</a></p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="zfs-term">22.8. ZFS 功能和术语<a class="anchor" href="#zfs-term"></a></h3>
<div class="paragraph">
<p>ZFS 不仅仅是一个文件系统，它在根本上是不同的。ZFS 将文件系统和卷管理器的角色结合在一起，使新的存储设备能够添加到活动系统中，并且新的空间可以立即在该池中的现有文件系统上使用。通过结合传统上分开的角色， ZFS 能够克服以前阻止 RAID 组能够增长的限制。<em>vdev</em> 是池中的顶级设备，可以是简单的磁盘或 RAID 转换，如镜像或 RAID-Z 阵列。 ZFS 文件系统（称为 <em>datasets</em> ）每个都可以访问整个池的合并空闲空间。池中使用的块会减少每个文件系统可用的空间。这种方法避免了广泛分区中常见的问题，即空闲空间在分区之间变得碎片化。</p>
</div>
<table class="tableblock frame-all grid-all stretch informaltable">
<colgroup>
<col style="width: 10%;"/>
<col style="width: 90%;"/>
</colgroup>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-pool"></a> 池（pool）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">存储池是 ZFS 的最基本构建块。一个存储池由一个或多个 vdev 组成， vdev 是存储数据的底层设备。然后使用存储池来创建一个或多个文件系统（数据集）或块设备（卷）。
这些数据集和卷共享剩余的自由空间。每个存储池都有一个唯一的名称和 GUID 来进行标识。存储池上的 ZFS 版本号决定了可用的功能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-vdev"></a>vdev 类型</p></td>
<td class="tableblock halign-left valign-top"><div class="content"><div class="paragraph">
<p>一个池由一个或多个 vdev 组成，它们本身是一个单独的磁盘或一组磁盘，转换为 RAID 。当使用大量的 vdev 时， ZFS 会将数据分散在 vdev 上，以提高性能和最大化可用空间。所有的 vdev 都必须至少 128MB 大小。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a id="zfs-term-vdev-disk"></a> <em>磁盘（Disk）</em> - 最基本的 vdev 类型是标准块设备。这可以是整个磁盘（如 <span class="filename">/dev/ada0</span> 或 <span class="filename">/dev/da0</span>）或一个分区（<span class="filename">/dev/ada0p3</span>）。在 FreeBSD 上，使用分区而不是整个磁盘不会有性能损失。这与 Solaris 文档的建议不同。</p>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>强烈不建议将整个磁盘作为可引导池的一部分，因为这可能导致池无法引导。
同样，您不应将整个磁盘用作镜像或 RAID-Z vdev 的一部分。
在引导时可靠地确定未分区磁盘的大小是不可能的，也没有地方放置引导代码。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p><a id="zfs-term-vdev-file"></a> <em>文件（File）</em> - 普通文件可以组成 ZFS 池，这对于测试和实验很有用。在 <code>zpool create</code> 中，使用文件的完整路径作为设备路径。</p>
</li>
<li>
<p><a id="zfs-term-vdev-mirror"></a> <em>镜像（Mirror）</em> - 创建镜像时，使用 <code>mirror</code> 关键字后跟镜像的成员设备列表。镜像由两个或更多设备组成，将所有数据写入所有成员设备。镜像 vdev 将保存与其最小成员相同的数据量。镜像 vdev 可以承受除一个成员外的所有成员故障而不丢失任何数据。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要随时将常规单磁盘 vdev 升级为镜像 vdev，请使用 <code>zpool <a href="#zfs-zpool-attach">attach</a></code>。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p><a id="zfs-term-vdev-raidz"></a> <em>RAID-Z</em> - ZFS 使用 RAID-Z ，这是标准 RAID-5 的变种，提供更好的奇偶校验分布，并消除了“RAID-5 写入漏洞”，即在意外重启后数据和奇偶校验信息变得不一致的问题。 ZFS 支持三个级别的 RAID-Z ，它们在提供不同的冗余级别的同时降低可用存储级别。ZFS 使用基于阵列中奇偶校验设备数量和可以故障的磁盘数量的 RAID-Z1 到 RAID-Z3 。</p>
<div class="paragraph">
<p>在一个由四个 1TB 磁盘组成的 RAID-Z1 配置中，可用存储空间为 3TB ，并且池仍能在一个故障磁盘的降级模式下运行。如果在替换和重新同步故障磁盘之前另一个磁盘离线，将导致丢失所有池数据。</p>
</div>
<div class="paragraph">
<p>在一个由八个 1TB 磁盘组成的 RAID-Z3 配置中，该卷将提供 5TB 的可用空间，并且仍能在三个故障磁盘的情况下运行。 Sun™ 建议在单个 vdev 中不要使用超过九个磁盘。如果更多的磁盘组成配置，则建议将它们分成单独的 vdev ，并将池数据分布在它们之间。</p>
</div>
<div class="paragraph">
<p>由每个包含 8 个磁盘的 RAID-Z2 vdev 组成的配置将创建类似于 RAID-60 阵列的东西。 RAID-Z 组的存储容量约为最小磁盘大小乘以非奇偶校验磁盘数量。 RAID-Z1 中的四个 1TB 磁盘的有效大小约为 3TB ，而 RAID-Z3 中的八个 1TB 磁盘阵列将提供 5TB 的可用空间。</p>
</div>
</li>
<li>
<p><a id="zfs-term-vdev-spare"></a> <em>备份（Spare）</em> - ZFS 有一种特殊的伪 vdev 类型，用于跟踪可用的热备。请注意，已安装的热备不会自动部署；请使用 <code>zfs replace</code> 手动配置它们以替换故障设备。</p>
</li>
<li>
<p><a id="zfs-term-vdev-log"></a> <em>日志（Log）</em> - ZFS 日志设备，也称为 ZFS 意图日志（ <a href="#zfs-term-zil">ZIL</a> ），将意图日志从常规池设备移动到专用设备，通常是 SSD 。拥有专用的日志设备可以提高具有大量同步写入（如数据库）的应用程序的性能。日志设备的镜像是可能的，但不支持 RAID-Z 。如果使用大量日志设备，写入将在它们之间进行负载平衡。</p>
</li>
<li>
<p><a id="zfs-term-vdev-cache"></a> <em>缓存（Cache）</em> - 向池添加缓存 vdev 将将缓存的存储添加到 <a href="#zfs-term-l2arc">L2ARC</a> 中。镜像缓存设备是不可能的。由于缓存设备仅存储现有数据的新副本，不存在数据丢失的风险。</p>
</li>
</ul>
</div></div></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-txg"></a> 事务组 (TXG)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">事务组是 ZFS 将块更改分组并写入池的方式。事务组是 ZFS 用来确保一致性的原子单位。 ZFS 为每个事务组分配一个唯一的 64 位连续标识符。同时可以有最多三个活动事务组，分别处于以下三种状态之一：</p>
<p class="tableblock"> * <em>打开（Open）</em> - 新的事务组开始时处于打开状态并接受新的写入。始终有一个处于打开状态的事务组，但如果达到限制，事务组可能会拒绝新的写入。一旦打开的事务组达到限制，或达到了 <a href="#zfs-advanced-tuning-txg-timeout"><code>vfs.zfs.txg.timeout</code></a> ，事务组将进入下一个状态。
 * <em>静默（Quiescing）</em> - 一个短暂的状态，允许所有待处理的操作完成，而不会阻塞新的打开事务组的创建。一旦组中的所有事务完成，事务组将进入最终状态。
 * <em>同步（Syncing）</em> - 将事务组中的所有数据写入稳定存储。这个过程将进一步改变其他数据，如元数据和空间映射， ZFS 也会将其写入稳定存储。同步过程涉及多个步骤。首先是所有更改的数据块；接下来是元数据，可能需要多次通过才能完成。由于为数据块分配空间会生成新的元数据，因此同步状态无法完成，直到完成一个不使用任何新空间的步骤。同步状态也是 <em>synctasks</em> 完成的地方。 Synctasks 是完成超级块更改的创建或销毁快照和数据集等管理操作。一旦同步状态完成，处于静默状态的事务组将进入同步状态。所有管理功能，如 <a href="#zfs-term-snapshot"><code>快照</code></a> ，都作为事务组的一部分进行写入。 ZFS 将创建的 synctask 添加到打开的事务组中，并尽快将该组推进到同步状态，以减少管理命令的延迟。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-arc"></a> 自适应替换缓存（ARC）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 使用自适应替换缓存（ARC），而不是更传统的最近最少使用（LRU）缓存。LRU 缓存是一个简单的缓存项列表，按照对象最近使用的时间排序，将新项添加到列表的头部。当缓存已满时，从列表的尾部逐出项以为更活跃的对象腾出空间。 ARC 由四个列表组成：最近最常使用（MRU）对象和最频繁使用（MFU）对象，以及每个列表的幽灵列表。这些幽灵列表跟踪被逐出的对象，以防止将它们重新添加到缓存中。这通过避免具有偶尔使用历史的对象来提高缓存命中率。同时使用 MRU 和 MFU 的另一个优点是，扫描整个文件系统将逐出 MRU 或 LRU 缓存中的所有数据，以便为这些新访问的内容腾出空间。在 ZFS 中，还有一个跟踪最常使用对象的 MFU，并保留最常访问块的缓存。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-l2arc"></a> L2ARC</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">L2ARC 是 ZFS 缓存系统的第二级。 RAM 存储主要的 ARC 。由于可用的 RAM 数量通常有限， ZFS 还可以使用 <a href="#zfs-term-vdev-cache">缓存 vdevs</a> 。由于与传统的旋转硬盘相比，固态硬盘（SSD）具有更高的速度和更低的延迟，因此通常将其用作缓存设备。 L2ARC 是完全可选的，但拥有一个 L2ARC 将提高从 SSD 读取缓存文件的速度，而不必从常规磁盘读取。 L2ARC 还可以加速 <a href="#zfs-term-deduplication">去重</a>，因为不适合 RAM 但适合 L2ARC 的去重表（DDT）比必须从磁盘读取的 DDT 快得多。对缓存设备添加的数据速率限制可以防止额外的写入过早磨损 SSD 。在缓存填满之前（为了腾出空间而驱逐的第一个块），写入 L2ARC 的限制为写入限制和增加限制的总和，之后限制为写入限制。一对 sysctl 值控制这些速率限制。 <a href="#zfs-advanced-tuning-l2arc_write_max"><code>vfs.zfs.l2arc_write_max</code></a> 控制每秒写入缓存的字节数，而 <a href="#zfs-advanced-tuning-l2arc_write_boost"><code>vfs.zfs.l2arc_write_boost</code></a>在“Turbo Warmup Phase（写入增强）”期间增加了这个限制。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-zil"></a> ZIL</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZIL 通过使用比主存储池中使用的存储设备（如 SSD）更快的设备来加速同步事务。当应用程序请求同步写入（保证数据存储到磁盘而不仅仅是缓存以供以后写入时），将数据写入更快的 ZIL 存储，然后稍后将其刷新到常规磁盘上，大大降低了延迟并提高了性能。像数据库这样的同步工作负载将从 ZIL 中受益。而常规的异步写入（如复制文件）则根本不会使用 ZIL。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-cow"></a> 写时复制（COW）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与传统的文件系统不同，ZFS 在写入数据时不会直接覆盖旧数据，而是写入一个不同的块。完成写入后，元数据会更新以指向新的位置。当发生截断写入（系统崩溃或断电导致文件写入中断）时，文件的完整原始内容仍然可用，而 ZFS 会丢弃不完整的写入。这也意味着 ZFS 在意外关闭后不需要进行 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 操作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-dataset"></a> 数据集（Dataset）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><em>数据集</em> 是 ZFS 文件系统、卷、快照或克隆的通用术语。每个数据集都有一个唯一的名称，格式为 <em>poolname/path@snapshot</em>。池的根也是一个数据集。子数据集具有层次结构的名称，类似于目录。例如，<em>mypool/home</em>，即 home 数据集，是 mypool 的子数据集，并从其继承属性。通过创建 <em>mypool/home/user</em>，可以进一步扩展此结构。这个孙子数据集将从父级和祖父级继承属性。在子数据集上设置属性以覆盖从父级和祖父级继承的默认值。可以将数据集及其子数据集的管理 <a href="#zfs-zfs-allow">委托</a> 给其他用户。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-filesystem"></a> 文件系统</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 数据集通常用作文件系统。与大多数其他文件系统一样，ZFS 文件系统会挂载到系统目录层次结构的某个位置，并包含具有权限、标志和其他元数据的文件和目录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-volume"></a> 卷（Volume）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 还可以创建卷，它们会显示为磁盘设备。卷具有与数据集相似的许多功能，包括写时复制、快照、克隆和校验和。卷对于在 ZFS 上运行其他文件系统格式（如 UFS 虚拟化）或导出 iSCSI 扩展非常有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-snapshot"></a> 快照（Snapshot）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 的 <a href="#zfs-term-cow">写时复制 </a>（COW）设计允许几乎瞬间创建具有任意名称的一致性快照。在对数据集进行快照或对包含所有子数据集的父数据集进行递归快照之后，新数据将进入新的块，但不会将旧块回收为可用空间。快照包含原始文件系统版本，活动文件系统包含自快照以来所做的任何更改，而不使用其他空间。写入活动文件系统的新数据使用新的块来存储这些数据。随着块在活动文件系统中不再使用，快照将增长，但仅在快照中使用。将这些快照以只读方式挂载可以恢复先前的文件版本。可以将活动文件系统回滚到特定快照的 <a href="#zfs-zfs-snapshot">回滚</a> 是可能的，从而撤消在快照之后进行的任何更改。池中的每个块都有一个引用计数器，用于跟踪使用该块的快照、克隆、数据集或卷。随着文件和快照被删除，引用计数减少，当不再引用块时，回收可用空间。使用 <a href="#zfs-zfs-snapshot">保留</a> 标记快照将导致任何试图销毁它的尝试返回 <code>EBUSY</code> 错误。每个快照可以具有唯一名称的保留。 <a href="#zfs-zfs-snapshot">释放</a> 命令会移除保留，以便可以删除快照。快照、克隆和回滚适用于卷，但独立挂载不适用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-clone"></a> 克隆（Clone）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">克隆快照也是可能的。克隆是快照的可写版本，允许文件系统分叉为一个新的数据集。与快照一样，克隆最初不占用新的空间。当新数据写入克隆时，使用新的块，克隆的大小增长。当在克隆的文件系统或卷中覆盖块时，先前块的引用计数减少。删除克隆所依赖的快照是不可能的，因为克隆依赖于它。快照是父级，克隆是子级。克隆可以被 <em>提升（promoted）</em>，反转这种依赖关系，使克隆成为父级，先前的父级成为子级。此操作不需要新的空间。由于父级和子级使用的空间相互转换，可能会影响现有的配额和预留空间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-checksum"></a> 校验和（Checksum）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个块也都有校验和。所使用的校验算法是每个数据集的属性，参见 <a href="#zfs-zfs-set"><code>set</code></a> 。在读取时，每个块的校验和会被透明地验证，这使得 ZFS 能够检测到静默损坏。如果读取的数据与预期的校验和不匹配，ZFS 将尝试从任何可用的冗余中恢复数据，例如镜像或 RAID-Z。可以使用 <a href="#zfs-term-scrub"><code>scrub</code></a> 触发对所有校验和的验证。校验算法包括：</p>
<p class="tableblock"> * <code>fletcher2</code>
 * <code>fletcher4</code>
 * <code>sha256</code>
 <code>fletcher</code> 算法更快，但 <code>sha256</code> 是一种强大的加密哈希算法，具有更低的碰撞几率，但性能稍有损失。可以禁用校验和，但强烈不建议这样做。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-compression"></a> 压缩（Compression）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">每个数据集都有一个压缩属性，默认为关闭状态。将此属性设置为可用的压缩算法。这将导致对写入数据集的所有新数据进行压缩。除了减少所使用的空间外，读写吞吐量通常也会增加，因为需要读取或写入的块较少。</p>
<p class="tableblock"> <a id="zfs-term-compression-lz4"></a>
 * <em>LZ4</em> - 在 ZFS 池版本 5000（feature flags）中添加，LZ4 现在是推荐的压缩算法。当处理可压缩数据时，LZ4 的工作速度比 LZJB 快约 50 ％，处理不可压缩数据时，速度快三倍以上。LZ4 的解压速度也比 LZJB 快约 80 ％。在现代 CPU 上，LZ4 通常可以以超过 500 MB/s 的速度进行压缩，并以超过 1.5 GB/s 的速度进行解压缩（每个单独的 CPU 核心）。</p>
<p class="tableblock"> <a id="zfs-term-compression-lzjb"></a>
 * <em>LZJB</em> - 默认的压缩算法。由 Jeff Bonwick（ ZFS 的原始创建者之一）创建。与 GZIP 相比，LZJB 提供了较好的压缩效果，并且 CPU 开销较小。在将来，默认的压缩算法将更改为 LZ4 。</p>
<p class="tableblock"> <a id="zfs-term-compression-gzip"></a>
 * <em>GZIP</em> - ZFS 中提供的一种流压缩算法。使用 GZIP 的主要优势之一是其可配置的压缩级别。在设置 <code>compress</code> 属性时，管理员可以选择压缩级别，从最低级别的 <code>gzip1</code> 到最高级别的 <code>gzip9</code>。这使管理员可以控制以多少 CPU 时间来换取节省的磁盘空间。</p>
<p class="tableblock"> <a id="zfs-term-compression-zle"></a>
 * <em>ZLE</em> - 零长度编码是一种特殊的压缩算法，仅压缩连续的零。当数据集包含大块的零时，这种压缩算法非常有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-copies"></a> 副本（Copies）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当 <code>copies</code> 属性设置为大于 1 的值时，ZFS 会在 <a href="#zfs-term-filesystem">文件系统 </a> 或 <a href="#zfs-term-volume">卷 </a> 中维护每个块的副本。在重要的数据集上设置此属性可以提供额外的冗余，以便从中恢复不匹配其校验和的块。在没有冗余的存储池中，副本功能是唯一的冗余形式。副本功能可以从单个坏扇区或其他形式的轻微损坏中恢复，但它不能保护存储池免受整个磁盘的丢失。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-deduplication"></a> 去重（Deduplication）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">在写入数据时，校验和可以检测重复的数据块。通过去重，现有相同块的引用计数增加，节省存储空间。ZFS 在内存中保留一个去重表（DDT）来检测重复的数据块。该表包含一系列唯一的校验和、这些块的位置和引用计数。在写入新数据时，ZFS 计算校验和并将其与列表进行比较。当找到匹配项时，它使用现有的数据块。使用 SHA256 校验和算法进行去重提供了安全的加密哈希。去重是可调整的。如果 <code>dedup</code> 设置为 <code>on</code>，那么匹配的校验和意味着数据是相同的。将 <code>dedup</code> 设置为 <code>verify</code>，ZFS 对数据执行逐字节的检查，确保它们实际上是相同的。如果数据不相同，ZFS 将记录哈希冲突并将这两个块分别存储。由于 DDT 必须存储每个唯一块的哈希，它会消耗大量的内存。一个经验法则是每 1TB 去重数据需要 5-6GB 的 RAM。在无法实际拥有足够的 RAM 来将整个 DDT 保留在内存中的情况下，性能将大大降低，因为 DDT 必须在写入每个新块之前从磁盘读取。去重可以使用 L2ARC 来存储 DDT ，提供了快速系统内存和较慢磁盘之间的折中方案。考虑使用压缩代替，压缩通常可以提供几乎相同的空间节省效果，而不需要增加内存使用量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-scrub"></a> Scrub</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 <a href="https://man.freebsd.org/cgi/man.cgi?query=fsck&amp;sektion=8&amp;format=html">fsck(8)</a> 类似的一致性检查不同，ZFS 使用 <code>scrub</code> 命令。<code>scrub</code> 命令会读取存储在池中的所有数据块，并将它们的校验和与元数据中存储的已知良好校验和进行验证。定期检查池中存储的所有数据可以确保在需要之前恢复任何损坏的块。在非正常关闭后不需要进行 scrub ，但良好的做法是至少每三个月进行一次。 ZFS 在正常使用过程中会验证每个块的校验和，但 scrub 会确保对即使很少使用的块进行静默损坏检查。ZFS 在归档存储情况下提高了数据安全性。通过调整 <code>scrub</code> 的相对优先级，可以使用 <a href="#zfs-advanced-tuning-scrub_delay"><code>vfs.zfs.scrub_delay</code></a> 来防止 scrub 影响池上其他工作负载的性能。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-quota"></a> 数据集配额（Dataset Quota）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ZFS 提供了快速准确的数据集、用户和组空间账户，以及配额和空间预留。这使得管理员可以对空间分配进行精细控制，并允许为关键文件系统预留空间。</p>
<p class="tableblock">ZFS 支持不同类型的配额：数据集配额、<a href="#zfs-term-refquota">引用配额 (refquota)</a>、<a href="#zfs-term-userquota">用户配额</a> 和 <a href="#zfs-term-groupquota">组配额</a>。</p>
<p class="tableblock">配额限制了数据集及其后代的总大小，包括数据集的快照、子数据集和这些数据集的快照。
+
[NOTE]
====
卷不支持配额，因为 <code>volsize</code> 属性充当隐式配额。
====</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-refquota"></a> 引用配额（Reference Quota）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">引用配额限制了数据集可以消耗的空间量，通过强制执行一个硬限制。这个硬限制包括数据集本身引用的空间，但不包括后代使用的空间，比如文件系统或快照。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-userquota"></a> 用户配额（User Quota）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">用户配额对于限制指定用户使用的空间量非常有用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-groupquota"></a> 组配额（Group Quota）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">群组配额限制了指定群组可以使用的空间量。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-reservation"></a> 数据集预留空间（Dataset Reservation）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>reservation</code> 属性使得可以为特定数据集及其子数据集保证一定的空间量。这意味着在 <span class="filename">storage/home/bob</span> 上设置 10 GB 的预留空间，可以防止其他数据集使用完所有的空闲空间，至少为该数据集保留 10 GB 的空间。与常规的 <a href="#zfs-term-refreservation"><code>引用预留</code></a> 不同，快照和子数据集使用的空间不计入预留空间。例如，如果对 <span class="filename">storage/home/bob</span> 进行快照，除了 <code>refreservation</code> 的空间量之外，必须存在足够的磁盘空间才能成功进行操作。主数据集的子数据集不计入 <code>refreservation</code> 的空间量，因此不会侵占设置的空间。</p>
<p class="tableblock">任何类型的预留空间在以下情况下非常有用：在新系统中规划和测试磁盘空间分配的适用性，或确保文件系统上有足够的空间用于音频日志或系统恢复程序和文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-refreservation"></a> 引用预留（Reference Reservation）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>refreservation</code> 属性使得可以为特定数据集的使用保证一定的空间，但不包括其子数据集。这意味着在 <span class="filename">storage/home/bob</span> 上设置 10GB 的保留空间，如果另一个数据集尝试使用空闲空间，至少要保留 10GB 的空间给该数据集。与常规的 <a href="#zfs-term-reservation">预留空间</a> 不同，快照和子数据集使用的空间不计入预留空间。例如，如果对 <span class="filename">storage/home/bob</span> 进行快照，除了 <code>refreservation</code> 的空间之外，必须存在足够的磁盘空间才能成功进行操作。主数据集的子数据集不计入 <code>refreservation</code> 的空间，因此不会侵占设置的空间。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-resilver"></a> 重建（Resilver）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">当替换一个故障的磁盘时， ZFS 必须用丢失的数据填充新的磁盘。<em>重建</em> 是使用分布在剩余驱动器上的奇偶校验信息来计算并将丢失的数据写入新驱动器的过程。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-online"></a>Online</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处于 <code>在线</code> 状态的池或 vdev 具有其成员设备连接并完全运行。处于 <code>在线</code> 状态的个别设备正在正常运行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-offline"></a> 离线（Offline）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">如果存在足够的冗余以避免使存储池或虚拟设备进入 <a href="#zfs-term-faulted">故障</a> 状态，管理员会将单个设备设置为 <code>离线</code> 状态。管理员可以选择将磁盘设置为离线状态，以便准备更换它，或者为了更容易识别。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-degraded"></a> 降级（Degraded）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处于 <code>降级</code> 状态的池或 vdev 有一个或多个磁盘消失或失败。池仍然可用，但如果其他设备失败，池可能变得无法恢复。重新连接丢失的设备或替换失败的磁盘将在重新连接或新设备完成 <a href="#zfs-term-resilver">重建</a> 过程后将池恢复到 <a href="#zfs-term-online">在线</a> 状态。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a id="zfs-term-faulted"></a> 故障（Faulted）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">处于 <code>故障</code> 状态的池或 vdev 不再可操作。无法访问数据。当缺失或故障设备的数量超过 vdev 中的冗余级别时，池或 vdev 进入 <code>故障</code> 状态。如果重新连接缺失的设备，池将返回到 <a href="#zfs-term-online">在线</a> 状态。冗余不足以弥补故障磁盘数量会导致池内容丢失，并需要从备份中恢复。</p></td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div class="sect1">
<h2 id="filesystems">Chapter 23. 其他文件系统<a class="anchor" href="#filesystems"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="filesystems-synopsis">23.1. 简介<a class="anchor" href="#filesystems-synopsis"></a></h3>
<div class="paragraph">
<p>文件系统是任何操作系统的重要组成部分。它们允许用户上传和存储文件，提供对数据的访问，并使硬盘变得有用。不同的操作系统在其本机文件系统上有所不同。传统上，本机的 FreeBSD 文件系统一直是 Unix 文件系统 UFS ，现已现代化为 UFS2 。自 FreeBSD 7.0 以来， Z 文件系统（ ZFS ）也作为本机文件系统可用。有关更多信息，请参见 <a href="./#zfs ， Z 文件系统（ ZFS ）"></a> 。</p>
</div>
<div class="paragraph">
<p>除了本地文件系统之外， FreeBSD 还支持多种其他文件系统，以便可以本地访问来自其他操作系统的数据，例如存储在本地连接的 USB 存储设备、闪存驱动器和硬盘上的数据。这包括对 Linux® 扩展文件系统（ EXT ）的支持。</p>
</div>
<div class="paragraph">
<p>对于不同的文件系统， FreeBSD 提供了不同级别的支持。有些需要加载内核模块，而其他一些可能需要安装工具集。一些非本地文件系统的支持是完全读写的，而其他一些则只支持只读。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>本地文件系统和支持的文件系统之间的区别。</p>
</li>
<li>
<p>FreeBSD 支持哪些文件系统？</p>
</li>
<li>
<p>如何启用、配置、访问和使用非本机文件系统。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 UNIX® 和 <a href="./#基础知识">FreeBSD 基础知识</a> 。</p>
</li>
<li>
<p>熟悉 crossref:kernelconfig 的基础知识 [kernelconfig ，内核配置和编译] 。</p>
</li>
<li>
<p>在 FreeBSD 中，跨引用端口（ <a href="./#ports">installing software</a> ）会让您感到舒适。</p>
</li>
<li>
<p>对 FreeBSD 中的 <a href="./#disks">disks</a> 、存储和设备名称有一些了解。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="filesystems-linux">23.2. Linux® 文件系统<a class="anchor" href="#filesystems-linux"></a></h3>
<div class="paragraph">
<p>FreeBSD 提供了对多种 Linux® 文件系统的内置支持。本节介绍如何加载支持和挂载支持的 Linux® 文件系统。</p>
</div>
<div class="sect3">
<h4 id="_ext2_ext3_ext4_是一系列的文件系统类型用于在_linux_操作系统中管理磁盘上的文件和目录这些文件系统类型是为了提供更高级的功能和性能而逐步发展的_ext2_是最早的版本提供了基本的文件系统功能_ext3_在_ext2_的基础上增加了日志功能可以更好地恢复文件系统的一致性_ext4_是_ext3_的进一步改进提供了更高的性能和更大的文件系统容量支持这些文件系统类型在_linux_系统中被广泛使用">23.2.1. ext2 / ext3 / ext4 是一系列的文件系统类型，用于在 Linux 操作系统中管理磁盘上的文件和目录。这些文件系统类型是为了提供更高级的功能和性能而逐步发展的。 ext2 是最早的版本，提供了基本的文件系统功能。 ext3 在 ext2 的基础上增加了日志功能，可以更好地恢复文件系统的一致性。 ext4 是 ext3 的进一步改进，提供了更高的性能和更大的文件系统容量支持。这些文件系统类型在 Linux 系统中被广泛使用。<a class="anchor" href="#_ext2_ext3_ext4_是一系列的文件系统类型用于在_linux_操作系统中管理磁盘上的文件和目录这些文件系统类型是为了提供更高级的功能和性能而逐步发展的_ext2_是最早的版本提供了基本的文件系统功能_ext3_在_ext2_的基础上增加了日志功能可以更好地恢复文件系统的一致性_ext4_是_ext3_的进一步改进提供了更高的性能和更大的文件系统容量支持这些文件系统类型在_linux_系统中被广泛使用"></a></h4>
<div class="paragraph">
<p>自 FreeBSD 2.2 版本起，内核对 ext2 文件系统的支持已经可用。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ext2fs&amp;sektion=5&amp;format=html">ext2fs(5)</a> 驱动程序允许 FreeBSD 内核对 ext2 、 ext3 和 ext4 文件系统进行读写操作。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>目前还不支持日志记录和加密。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要访问一个 ext 文件系统，通过指定其 FreeBSD 分区名称和现有的挂载点来挂载 ext 卷。这个例子将 [/dev/ada1s1] 挂载到 [/mnt] 上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount -t ext2fs /dev/ada1s1 /mnt</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="virtualization">Chapter 24. 虚拟化<a class="anchor" href="#virtualization"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="virtualization-synopsis">24.1. 简介<a class="anchor" href="#virtualization-synopsis"></a></h3>
<div class="paragraph">
<p>虚拟化软件允许多个操作系统同时在同一台计算机上运行。这种针对个人电脑的软件系统通常包括一个主机操作系统，它运行虚拟化软件并支持任意数量的客户操作系统。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>主机操作系统和客户操作系统之间的区别。</p>
</li>
<li>
<p>如何在以下虚拟化平台上安装 FreeBSD ：</p>
<div class="ulist">
<ul>
<li>
<p>Parallels Desktop （苹果（ R ） macOS （ R ））</p>
</li>
<li>
<p>VMware Fusion （苹果（ R ） macOS （ R ））</p>
</li>
<li>
<p>VirtualBox™ （ Microsoft® Windows® 、 Intel®-based Apple® macOS® 、 Linux ）</p>
</li>
<li>
<p>bhyve （ FreeBSD ）</p>
</li>
</ul>
</div>
</li>
<li>
<p>如何调整 FreeBSD 系统以在虚拟化环境下获得最佳性能。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，你应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 <a href="./#basics">UNIX® 和 FreeBSD 的基础知识</a> 。</p>
</li>
<li>
<p>了解如何交叉引用： bsdinstall[bsdinstall ，安装 FreeBSD] 。</p>
</li>
<li>
<p>了解如何进行交叉引用：高级网络设置 [advanced-networking ，设置网络连接] 。</p>
</li>
<li>
<p>了解如何交叉引用： ports[ports ,安装额外的第三方软件] 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="virtualization-guest-parallelsdesktop">24.2. 在 Parallels Desktop for macOS® 上作为客户机的 FreeBSD<a class="anchor" href="#virtualization-guest-parallelsdesktop"></a></h3>
<div class="paragraph">
<p>Parallels Desktop for Mac （ R ）是一款商业软件产品，适用于运行 macOS （ R ） 10.14.6 或更高版本的 Apple （ R ） Mac （ R ）计算机。 FreeBSD 是一个完全支持的客户操作系统。一旦在 macOS （ R ）上安装了 Parallels ，用户必须配置一个虚拟机，然后安装所需的客户操作系统。</p>
</div>
<div class="sect3">
<h4 id="virtualization-guest-parallelsdesktop-install">24.2.1. 在 Mac 上使用 Parallels Desktop 安装 FreeBSD<a class="anchor" href="#virtualization-guest-parallelsdesktop-install"></a></h4>
<div class="paragraph">
<p>在 Parallels 上安装 FreeBSD 的第一步是创建一个新的虚拟机来安装 FreeBSD 。</p>
</div>
<div class="paragraph">
<p>选择菜单：从 DVD 或镜像文件安装 Windows 或其他操作系统 [] ，然后继续。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/parallels-freebsd1.png" alt="Parallels 安装向导显示选择从 DVD 或镜像文件安装 Windows 或其他操作系统。"/>
</div>
</div>
<div class="paragraph">
<p>选择 FreeBSD 镜像文件。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/parallels-freebsd2.png" alt="Parallels 安装向导显示已选择 FreeBSD 镜像文件。"/>
</div>
</div>
<div class="paragraph">
<p>选择菜单：其他作为操作系统 [] 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>选择 FreeBSD 会导致启动时出现引导错误。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/parallels-freebsd3.png" alt="Parallels 安装向导显示操作系统选择为“其他”。"/>
</div>
</div>
<div class="paragraph">
<p>命名虚拟机并在安装之前检查菜单：自定义设置 []</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/parallels-freebsd4.png" alt="Parallels 安装向导显示了在安装之前自定义设置的复选框已被选中。"/>
</div>
</div>
<div class="paragraph">
<p>当配置窗口弹出时，转到菜单：硬件 [] 选项卡，选择菜单：启动顺序 [] ，然后点击菜单：高级 [] 。然后，选择 *EFI 64 位 * 作为菜单： BIOS[] 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/parallels-freebsd5.png" alt="Parallels 安装向导显示选择 EFI 64 位作为 BIOS 。"/>
</div>
</div>
<div class="paragraph">
<p>点击菜单：确定 [] ，关闭配置窗口，然后点击菜单：继续 [] 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/parallels-freebsd6.png" alt="Parallels 安装向导显示新虚拟机的摘要信息。"/>
</div>
</div>
<div class="paragraph">
<p>虚拟机将自动启动。按照通用步骤安装 FreeBSD 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/parallels-freebsd7.png" alt="FreeBSD 在 Parallels 上启动成功。"/>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-guest-parallels-configure">24.2.2. 在 Parallels 上配置 FreeBSD<a class="anchor" href="#virtualization-guest-parallels-configure"></a></h4>
<div class="paragraph">
<p>在使用 Parallels 在 macOS® X 上成功安装 FreeBSD 之后，可以采取一些配置步骤来优化系统以进行虚拟化操作。</p>
</div>
<div class="olist arabic procedure">
<ol class="arabic">
<li>
<p>设置引导加载程序变量</p>
<div class="paragraph">
<p>最重要的步骤是减少在 Parallels 环境下 FreeBSD 的 CPU 利用率，方法是将 <code>kern.hz</code> 可调参数降低。通过在 <span class="filename">/boot/loader.conf</span> 文件中添加以下行来实现：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.hz=100</pre>
</div>
</div>
<div class="paragraph">
<p>如果没有这个设置，一个空闲的 FreeBSD Parallels 虚拟机将会占用大约一个处理器 iMac® 的 15% 的 CPU 。在进行这个更改后，使用率将会接近 5% 。</p>
</div>
</li>
<li>
<p>创建一个新的内核配置文件</p>
<div class="paragraph">
<p>可以从自定义内核配置文件中删除所有 SCSI 、 FireWire 和 USB 设备驱动程序。 Parallels 提供了一个虚拟网络适配器，由 <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> 驱动程序使用，因此除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=ed&amp;sektion=4&amp;format=html">ed(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=miibus&amp;sektion=4&amp;format=html">miibus(4)</a> 之外，所有网络设备都可以从内核中删除。</p>
</div>
</li>
<li>
<p>配置网络</p>
<div class="paragraph">
<p>最基本的网络设置使用 DHCP 将虚拟机连接到与主机 Mac® 相同的局域网。可以通过在 /etc/rc.conf 文件中添加 <code>ifconfig_ed0 =&#34;DHCP&#34;</code> 来实现。更高级的网络设置在 <a href="./#高级网络设置"></a> 中有描述。</p>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="virtualization-guest-vmware">24.3. 在 macOS 上使用 VMware Fusion 作为客户机的 FreeBSD<a class="anchor" href="#virtualization-guest-vmware"></a></h3>
<div class="paragraph">
<p>VMware Fusion for Mac （ R ）是一款商业软件产品，适用于运行 macOS （ R ） 12 或更高版本的 Apple （ R ） Mac （ R ）计算机。 FreeBSD 是一个完全支持的客户操作系统。一旦在 macOS （ R ）上安装了 VMware Fusion ，用户可以配置虚拟机，然后安装所需的客户操作系统。</p>
</div>
<div class="sect3">
<h4 id="virtualization-guest-vmware-install">24.3.1. 在 VMware Fusion 上安装 FreeBSD<a class="anchor" href="#virtualization-guest-vmware-install"></a></h4>
<div class="paragraph">
<p>第一步是启动 VMware Fusion ，它将加载虚拟机库。点击【+ → 新建】来创建虚拟机：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd01.png" alt="vmware freebsd01"/>
</div>
</div>
<div class="paragraph">
<p>这将加载新的虚拟机助手。选择【创建自定义虚拟机】并点击【继续】以继续：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd02.png" alt="vmware freebsd02"/>
</div>
</div>
<div class="paragraph">
<p>在提示时，选择 [.guimenuitem]# 其他 # 作为 [.guimenuitem]# 操作系统 # ，并选择 <span class="guimenuitem">FreeBSD X</span> 或 [.guimenuitem]#FreeBSD X 64 位 # 作为菜单 : 版本 [] 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd03.png" alt="vmware freebsd03"/>
</div>
</div>
<div class="paragraph">
<p>选择固件（推荐使用 UEFI ）：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd04.png" alt="vmware freebsd04"/>
</div>
</div>
<div class="paragraph">
<p>选择 [.guimenuitem]# 创建新的虚拟磁盘 # 并点击 [.guimenuitem]# 继续 # ：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd05.png" alt="vmware freebsd05"/>
</div>
</div>
<div class="paragraph">
<p>检查配置并点击 [.guimenuitem]# 完成 # 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd06.png" alt="vmware freebsd06"/>
</div>
</div>
<div class="paragraph">
<p>选择虚拟机的名称和保存的目录：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd07.png" alt="vmware freebsd07"/>
</div>
</div>
<div class="paragraph">
<p>按下 Command + E 打开虚拟机设置，然后点击 <span class="guimenuitem">CD/DVD</span> 。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd08.png" alt="vmware freebsd08"/>
</div>
</div>
<div class="paragraph">
<p>选择 FreeBSD ISO 镜像或者从 CD/DVD 中选择：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd09.png" alt="vmware freebsd09"/>
</div>
</div>
<div class="paragraph">
<p>启动虚拟机：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd10.png" alt="vmware freebsd10"/>
</div>
</div>
<div class="paragraph">
<p>按照通常的方式安装 FreeBSD ：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd11.png" alt="vmware freebsd11"/>
</div>
</div>
<div class="paragraph">
<p>安装完成后，可以修改虚拟机的设置，例如内存使用量和虚拟机可以访问的 CPU 数量。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虚拟机运行时无法修改虚拟机的系统硬件设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd12.png" alt="vmware freebsd12"/>
</div>
</div>
<div class="paragraph">
<p>CD-ROM 设备的状态。通常，当虚拟机不再需要 CD/DVD/ISO 时，它会与之断开连接。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd09.png" alt="vmware freebsd09"/>
</div>
</div>
<div class="paragraph">
<p>最后需要更改的是虚拟机如何连接到网络。为了允许虚拟机与主机以外的其他机器进行连接，选择 [.guimenuitem]# 直接连接物理网络（桥接） # 。否则，推荐选择 [.guimenuitem]# 共享主机的互联网连接（ NAT ） # ，这样虚拟机可以访问互联网，但网络无法访问虚拟机。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/virtualization/vmware-freebsd13.png" alt="vmware freebsd13"/>
</div>
</div>
<div class="paragraph">
<p>修改设置后，启动新安装的 FreeBSD 虚拟机。</p>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-guest-vmware-configure">24.3.2. 在 VMware Fusion 上配置 FreeBSD<a class="anchor" href="#virtualization-guest-vmware-configure"></a></h4>
<div class="paragraph">
<p>在使用 VMware Fusion 成功安装 FreeBSD 到 macOS® X 之后，可以采取一些配置步骤来优化系统以进行虚拟化操作。</p>
</div>
<div class="olist arabic procedure">
<ol class="arabic">
<li>
<p>设置引导加载程序变量</p>
<div class="paragraph">
<p>最重要的步骤是在 VMware Fusion 环境下减少 FreeBSD 的 CPU 利用率，方法是将 <code>kern.hz</code> 可调参数降低。通过在 [/boot/loader.conf] 文件中添加以下行来实现：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>kern.hz=100</pre>
</div>
</div>
<div class="paragraph">
<p>如果没有这个设置，一个空闲的 FreeBSD VMware Fusion 客户机将使用大约 15% 的单处理器 iMac® 的 CPU 。在进行这个更改之后，使用率将接近 5% 。</p>
</div>
</li>
<li>
<p>创建一个新的内核配置文件</p>
<div class="paragraph">
<p>可以从自定义内核配置文件中删除所有的 FireWire 和 USB 设备驱动程序。 VMware Fusion 提供了一个虚拟网络适配器，由 <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> 驱动程序使用，因此除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=em&amp;sektion=4&amp;format=html">em(4)</a> 之外的所有网络设备都可以从内核中删除。</p>
</div>
</li>
<li>
<p>配置网络</p>
<div class="paragraph">
<p>最基本的网络设置使用 DHCP 将虚拟机连接到与主机 Mac® 相同的局域网。可以通过在 <code>/etc/rc.conf</code> 文件中添加 <code>ifconfig_em0 =&#34;DHCP&#34;</code> 来实现。更高级的网络设置在《高级网络设置》中有描述。</p>
</div>
</li>
<li>
<p>安装驱动程序和 open-vm-tools</p>
<div class="paragraph">
<p>要在 VMWare 上顺畅运行 FreeBSD ，需要安装驱动程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install xf86-video-vmware xf86-input-vmmouse open-vm-tools</span></code></pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="virtualization-guest-virtualbox">24.4. 在 VirtualBox™ 上作为客户机的 FreeBSD<a class="anchor" href="#virtualization-guest-virtualbox"></a></h3>
<div class="paragraph">
<p>FreeBSD 在 VirtualBox™ 中作为客户机运行良好。这款虚拟化软件适用于大多数常见操作系统，包括 FreeBSD 本身。</p>
</div>
<div class="paragraph">
<p>VirtualBox™ 客户机附加组件提供以下支持：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>剪贴板共享。</p>
</li>
<li>
<p>鼠标指针集成。</p>
</li>
<li>
<p>主机时间同步。</p>
</li>
<li>
<p>窗口缩放。</p>
</li>
<li>
<p>无缝模式。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这些命令在 FreeBSD 虚拟机中运行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>首先，在 FreeBSD 客户机中安装包： emulators/virtualbox-ose-additions[] 。这将安装端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/emulators/virtualbox-ose-additions &amp;&amp; make install clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将以下行添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vboxguest_enable=&#34;YES&#34;
vboxservice_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpdate&amp;sektion=8&amp;format=html">ntpdate(8)</a> ，请禁用主机时间同步：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vboxservice_flags=&#34;--disable-timesync&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>Xorg 会自动识别 <code>vboxvideo</code> 驱动程序。也可以在 <code>/etc/X11/xorg.conf</code> 文件中手动输入。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;Device&#34;
	Identifier &#34;Card0&#34;
	Driver &#34;vboxvideo&#34;
	VendorName &#34;InnoTek Systemberatung GmbH&#34;
	BoardName &#34;VirtualBox Graphics Adapter&#34;
EndSection</pre>
</div>
</div>
<div class="paragraph">
<p>要使用 <code>vboxmouse</code> 驱动程序，请在 <span class="filename">/etc/X11/xorg.conf</span> 中调整鼠标部分。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Section &#34;InputDevice&#34;
	Identifier &#34;Mouse0&#34;
	Driver &#34;vboxmouse&#34;
EndSection</pre>
</div>
</div>
<div class="paragraph">
<p>通过使用 <code>mount_vboxvfs</code> 挂载，可以访问主机和虚拟机之间的共享文件夹进行文件传输。可以使用 VirtualBox GUI 或通过 <code>vboxmanage</code> 在主机上创建共享文件夹。例如，要在名为_BSDBox_的虚拟机下创建一个名为_myshare_的共享文件夹，位于 <span class="filename">/mnt/bsdboxshare</span> ，运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># vboxmanage sharedfolder add &#39;BSDBox&#39; --name myshare --hostpath /mnt/bsdboxshare</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，共享文件夹的名称不能包含空格。在虚拟机中挂载共享文件夹的方法如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount_vboxvfs -w myshare /mnt</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="virtualization-host-virtualbox">24.5. 使用 VirtualBox™ 将 FreeBSD 作为主机<a class="anchor" href="#virtualization-host-virtualbox"></a></h3>
<div class="paragraph">
<p>VirtualBox™ 是一个积极开发的完整虚拟化软件包，适用于包括 Windows® 、 macOS® 、 Linux® 和 FreeBSD 在内的大多数操作系统。它能够同样运行 Windows® 或类 UNIX® 的客户机。它以开源软件的形式发布，但也有一些闭源组件可在单独的扩展包中获取。这些组件包括对 USB 2.0 设备的支持。有关更多信息，请参阅 VirtualBox™ 维基的 <a href="http://www.virtualbox.org/wiki/Downloads">下载页面</a> 。目前，这些扩展在 FreeBSD 上不可用。</p>
</div>
<div class="sect3">
<h4 id="virtualization-virtualbox-install">24.5.1. 安装 VirtualBox™<a class="anchor" href="#virtualization-virtualbox-install"></a></h4>
<div class="paragraph">
<p>VirtualBox™ 可以作为 FreeBSD 的一个软件包或端口在 <a class="package" href="https://cgit.freebsd.org/ports/tree/emulators/virtualbox-ose/">emulators/virtualbox-ose</a> 中获得。可以使用以下命令安装该端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/emulators/virtualbox-ose</span>
<span class="c"># make install clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>端口配置菜单中的一个有用选项是“ GuestAdditions ”程序套件。这些程序在客户操作系统中提供了许多有用的功能，如鼠标指针集成（允许鼠标在主机和客户之间共享，无需按特殊的键盘快捷键切换）和更快的视频渲染，尤其是在 Windows® 客户中。在客户安装完成后，可以在菜单 : 设备 [] 菜单中找到客户附加组件。</p>
</div>
<div class="paragraph">
<p>在首次启动 VirtualBox™ 之前，需要进行一些配置更改。该端口会在 <span class="filename">/boot/modules</span> 中安装一个内核模块，必须将其加载到正在运行的内核中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload vboxdrv</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了确保模块在重新启动后始终加载，将以下行添加到 [/boot/loader.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vboxdrv_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要使用允许桥接或仅主机网络的内核模块，请将以下行添加到 [/etc/rc.conf] 文件中，并重新启动计算机：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vboxnet_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在安装 VirtualBox™ 时会创建 <code>vboxusers</code> 组。所有需要访问 VirtualBox™ 的用户都必须添加为该组的成员。可以使用 <code>pw</code> 命令来添加新成员：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupmod vboxusers -m yourusername</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">/dev/vboxnetctl</span> 的默认权限很严格，需要更改以支持桥接网络：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chown root:vboxusers /dev/vboxnetctl</span>
<span class="c"># chmod 0660 /dev/vboxnetctl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使此权限更改永久生效，请将以下行添加到 <span class="filename">/etc/devfs.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>own     vboxnetctl root:vboxusers
perm    vboxnetctl 0660</pre>
</div>
</div>
<div class="paragraph">
<p>要启动 VirtualBox™ ，请在 Xorg 会话中输入以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>VirtualBox</code></pre>
</div>
</div>
<div class="paragraph">
<p>有关配置和使用 VirtualBox™ 的更多信息，请参阅 <a href="http://www.virtualbox.org">官方网站</a> 。有关 FreeBSD 特定信息和故障排除说明，请参阅 <a href="http://wiki.FreeBSD.org/VirtualBox">FreeBSD wiki 中的相关页面</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-virtualbox-usb-support">24.5.2. VirtualBox™ USB 支持<a class="anchor" href="#virtualization-virtualbox-usb-support"></a></h4>
<div class="paragraph">
<p>VirtualBox™ 可以配置为将 USB 设备传递给客户操作系统。 OSE 版本的主机控制器仅限于模拟 USB 1.1 设备，直到支持 USB 2.0 和 3.0 设备的扩展包在 FreeBSD 上可用为止。</p>
</div>
<div class="paragraph">
<p>要使 VirtualBox™ 能够识别连接到计算机的 USB 设备，用户需要是 <code>operator</code> 组的成员。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw groupmod operator -m yourusername</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，将以下内容添加到 <span class="filename">/etc/devfs.rules</span> 中，如果该文件尚不存在，则创建该文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[system=10]
add path &#39;usb/*&#39; mode 0660 group operator</pre>
</div>
</div>
<div class="paragraph">
<p>要加载这些新规则，请将以下内容添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>devfs_system_ruleset=&#34;system&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后，重新启动 devfs ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service devfs restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>重新启动登录会话和 VirtualBox™ 以使这些更改生效，并根据需要创建 USB 过滤器。</p>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-virtualbox-host-dvd-cd-access">24.5.3. VirtualBox™ 主机 DVD/CD 访问<a class="anchor" href="#virtualization-virtualbox-host-dvd-cd-access"></a></h4>
<div class="paragraph">
<p>通过共享物理驱动器，可以实现从虚拟机访问主机的 DVD/CD 驱动器。在 VirtualBox™ 中，可以在虚拟机的设置中的存储窗口中进行设置。如果需要，首先创建一个空的 IDECD/DVD 设备。然后从弹出菜单中选择主机驱动器作为虚拟 CD/DVD 驱动器的选择。将会出现一个名为“ Passthrough ”的复选框。这允许虚拟机直接使用硬件。例如，只有在选择了此选项后，音频 CD 或刻录机才能正常工作。</p>
</div>
<div class="paragraph">
<p>为了使用户能够使用 VirtualBox™ 的 DVD/CD 功能，他们需要访问 <code>/dev/xpt0</code> 、 <code>/dev/cdN</code> 和 <code>/dev/passN</code> 。通常通过将用户添加到 <code>operator</code> 组来实现此目的。需要通过在 <code>/etc/devfs.conf</code> 中添加以下行来更正对这些设备的权限：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>perm cd* 0660
perm xpt0 0660
perm pass* 0660</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service devfs restart</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="virtualization-host-bhyve">24.6. 使用 bhyve 作为 FreeBSD 主机<a class="anchor" href="#virtualization-host-bhyve"></a></h3>
<div class="paragraph">
<p>bhyve 是一个基于 BSD 许可的虚拟机监控程序，自 FreeBSD 10.0-RELEASE 版本起成为基础系统的一部分。该虚拟机监控程序支持多种客户操作系统，包括 FreeBSD 、 OpenBSD 和许多 Linux® 发行版。默认情况下， bhyve 提供串行控制台访问，并不模拟图形控制台。它利用较新的 CPU 的虚拟化卸载功能，避免了传统的指令转换和手动管理内存映射的方法。</p>
</div>
<div class="paragraph">
<p>bhyve 设计要求处理器支持 Intel® 扩展页表 (EPT) 或 AMD® 快速虚拟化索引 (RVI) 或嵌套页表 (NPT) 。托管具有多个虚拟 CPU 的 Linux® 客户机或 FreeBSD 客户机需要 VMX 无限制模式支持 (UG) 。大多数较新的处理器，特别是 Intel® Core™ i3/i5/i7 和 Intel® Xeon™ E3/E5/E7 ，都支持这些功能。 UG 支持是在 Intel 的 Westmere 微架构中引入的。有关支持 EPT 的 Intel® 处理器的完整列表，请参阅 <a href="https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html" class="bare">https://ark.intel.com/content/www/us/en/ark/search/featurefilter.html</a> ? productType = 873 &amp; 0_ExtendedPageTables = True[] 。 RVI 出现在第三代及以后的 AMD Opteron™(Barcelona) 处理器上。判断处理器是否支持 bhyve 的最简单方法是运行 <code>dmesg</code> 命令或在 AMD® 处理器的 <code>Features2</code> 行上查找 <code>POPCNT</code> 处理器特性标志，或在 Intel® 处理器的 <code>VT-x</code> 行上查找 <code>EPT</code> 和 <code>UG</code> 。</p>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-prep">24.6.1. 准备主机<a class="anchor" href="#virtualization-bhyve-prep"></a></h4>
<div class="paragraph">
<p>在 bhyve 中创建虚拟机的第一步是配置主机系统。首先，加载 bhyve 内核模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload vmm</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，在虚拟机中为网络设备创建一个名为 <span class="filename">tap</span> 的接口，以便连接到该接口。为了使网络设备能够参与网络通信，还需创建一个桥接接口，其中包含 <span class="filename">tap</span> 接口和物理接口作为成员。在这个例子中，物理接口是 <em>igb0</em>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig tap0 create</span>
<span class="c"># sysctl net.link.tap.up_on_open=1</span>
net.link.tap.up_on_open: 0 -&gt; 1
<span class="c"># ifconfig bridge0 create</span>
<span class="c"># ifconfig bridge0 addm igb0 addm tap0</span>
<span class="c"># ifconfig bridge0 up</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-freebsd">24.6.2. 创建一个 FreeBSD 虚拟机<a class="anchor" href="#virtualization-bhyve-freebsd"></a></h4>
<div class="paragraph">
<p>创建一个文件作为虚拟磁盘用于客户机。指定虚拟磁盘的大小和名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># truncate -s 16G guest.img</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下载一个 FreeBSD 的安装镜像来进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># fetch https://download.freebsd.org/releases/ISO-IMAGES/13.1/FreeBSD-13.1-RELEASE-amd64-bootonly.iso</span>
FreeBSD-13.1-RELEASE-amd64-bootonly.iso                366 MB   16 MBps    22s</code></pre>
</div>
</div>
<div class="paragraph">
<p>FreeBSD 附带了一个示例脚本，用于在 bhyve 中运行虚拟机。该脚本将启动虚拟机并在循环中运行，因此如果虚拟机崩溃，它将自动重新启动。脚本接受多个选项来控制机器的配置： <code>-c</code> 控制虚拟 CPU 的数量， <code>-m</code> 限制可用于客户机的内存量， <code>-t</code> 定义要使用的 <span class="filename">tap</span> 设备， <code>-d</code> 指示要使用的磁盘映像， <code>-i</code> 告诉 bhyve 从 CD 映像而不是磁盘启动， <code>-I</code> 定义要使用的 CD 映像。最后一个参数是虚拟机的名称，用于跟踪正在运行的虚拟机。此示例在安装模式下启动虚拟机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sh /usr/share/examples/bhyve/vmrun.sh -c 1 -m 1024M -t tap0 -d guest.img -i -I FreeBSD-13.1-RELEASE-amd64-bootonly.iso guestname</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虚拟机将启动并开始安装程序。在虚拟机中安装系统后，当系统在安装结束时询问是否进入 shell ，请选择“是”。</p>
</div>
<div class="paragraph">
<p>重新启动虚拟机。虚拟机重新启动会导致 bhyve 退出，但是 <span class="filename">vmrun.sh</span> 脚本会在循环中运行 <code>bhyve</code> 并自动重新启动它。当这种情况发生时，选择从引导加载程序菜单中的重新启动选项以退出循环。现在可以从虚拟磁盘启动客户机。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sh /usr/share/examples/bhyve/vmrun.sh -c 4 -m 1024M -t tap0 -d guest.img guestname</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-linux">24.6.3. 创建一个 Linux® 虚拟机<a class="anchor" href="#virtualization-bhyve-linux"></a></h4>
<div class="paragraph">
<p>为了引导除 FreeBSD 之外的操作系统，必须首先安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/">sysutils/grub2-bhyve</a> 端口。</p>
</div>
<div class="paragraph">
<p>接下来，创建一个文件作为虚拟磁盘用于客户机。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># truncate -s 16G linux.img</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 bhyve 启动虚拟机是一个两步骤的过程。首先必须加载内核，然后才能启动客户机。使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/grub2-bhyve/">sysutils/grub2-bhyve</a> 加载 Linux® 内核。创建一个 <span class="filename">device.map</span> ，供 grub 使用，将虚拟设备映射到主机系统上的文件。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>(hd0) ./linux.img
(cd0) ./somelinux.iso</pre>
</div>
</div>
<div class="paragraph">
<p>使用包： sysutils/grub2-bhyve[] 从 ISO 镜像中加载 Linux® 内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># grub-bhyve -m device.map -r cd0 -M 1024M linuxguest</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将启动 grub 。如果安装 CD 包含一个 <span class="filename">grub.cfg</span> 文件，将显示一个菜单。如果没有，必须手动定位并加载 <code>vmlinuz</code> 和 <code>initrd</code> 文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">grub&gt; </span>ls
<span class="o">(</span>hd0<span class="o">)</span> <span class="o">(</span>cd0<span class="o">)</span> <span class="o">(</span>cd0,msdos1<span class="o">)</span> <span class="o">(</span>host<span class="o">)</span>
<span class="gp">grub&gt; </span>ls <span class="o">(</span>cd0<span class="o">)</span>/isolinux
boot.cat boot.msg grub.conf initrd.img isolinux.bin isolinux.cfg memtest
splash.jpg TRANS.TBL vesamenu.c32 vmlinuz
<span class="gp">grub&gt; </span>linux <span class="o">(</span>cd0<span class="o">)</span>/isolinux/vmlinuz
<span class="gp">grub&gt; </span>initrd <span class="o">(</span>cd0<span class="o">)</span>/isolinux/initrd.img
<span class="gp">grub&gt; </span>boot</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在 Linux® 内核已经加载完毕，可以启动虚拟机了：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    -s 4:0,ahci-cd,./somelinux.iso -l com1,stdio -c 4 -m 1024M linuxguest</code></pre>
</div>
</div>
<div class="paragraph">
<p>系统将启动并启动安装程序。在虚拟机中安装系统后，重新启动虚拟机。这将导致 bhyve 退出。在可以再次启动之前，需要销毁虚拟机的实例。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyvectl --destroy --vm=linuxguest</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在可以直接从虚拟磁盘启动客户机。加载内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># grub-bhyve -m device.map -r hd0,msdos1 -M 1024M linuxguest</span>
<span class="gp">grub&gt; </span>ls
<span class="o">(</span>hd0<span class="o">)</span> <span class="o">(</span>hd0,msdos2<span class="o">)</span> <span class="o">(</span>hd0,msdos1<span class="o">)</span> <span class="o">(</span>cd0<span class="o">)</span> <span class="o">(</span>cd0,msdos1<span class="o">)</span> <span class="o">(</span>host<span class="o">)</span>
<span class="o">(</span>lvm/VolGroup-lv_swap<span class="o">)</span> <span class="o">(</span>lvm/VolGroup-lv_root<span class="o">)</span>
<span class="gp">grub&gt; </span>ls <span class="o">(</span>hd0,msdos1<span class="o">)</span>/
lost+found/ grub/ efi/ System.map-2.6.32-431.el6.x86_64 config-2.6.32-431.el6.x
86_64 symvers-2.6.32-431.el6.x86_64.gz vmlinuz-2.6.32-431.el6.x86_64
initramfs-2.6.32-431.el6.x86_64.img
<span class="gp">grub&gt; </span>linux <span class="o">(</span>hd0,msdos1<span class="o">)</span>/vmlinuz-2.6.32-431.el6.x86_64 <span class="nv">root</span><span class="o">=</span>/dev/mapper/VolGroup-lv_root
<span class="gp">grub&gt; </span>initrd <span class="o">(</span>hd0,msdos1<span class="o">)</span>/initramfs-2.6.32-431.el6.x86_64.img
<span class="gp">grub&gt; </span>boot</code></pre>
</div>
</div>
<div class="paragraph">
<p>启动虚拟机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 \</span>
    -s 3:0,virtio-blk,./linux.img -l com1,stdio -c 4 -m 1024M linuxguest</code></pre>
</div>
</div>
<div class="paragraph">
<p>Linux® 现在将在虚拟机中启动，并最终呈现给您登录提示符。登录并使用虚拟机。完成后，重新启动虚拟机以退出 bhyve 。销毁虚拟机实例：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyvectl --destroy --vm=linuxguest</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-uefi">24.6.4. 使用 UEFI 固件引导 bhyve 虚拟机<a class="anchor" href="#virtualization-bhyve-uefi"></a></h4>
<div class="paragraph">
<p>除了 bhyveload 和 grub-bhyve 之外， bhyve 虚拟机监视器还可以使用 UEFI 用户空间固件引导虚拟机。这个选项可能支持其他加载器不支持的客户操作系统。</p>
</div>
<div class="paragraph">
<p>为了在 bhyve 中使用 UEFI 支持，首先需要获取 UEFI 固件镜像。可以通过安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/">sysutils/bhyve-firmware</a> 端口或包来完成。</p>
</div>
<div class="paragraph">
<p>在固件安装完成后，将标志 <code>-l bootrom ,<em>/path/to/firmware</em></code> 添加到您的 bhyve 命令行中。实际的 bhyve 命令可能如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
-s 2:0,virtio-net,tap1 -s 3:0,virtio-blk,./disk.img <span class="se">\</span>
-s 4:0,ahci-cd,./install.iso -c 4 -m 1024M <span class="se">\</span>
-l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd <span class="se">\</span>
guest</code></pre>
</div>
</div>
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/bhyve-firmware/">sysutils/bhyve-firmware</a> 还包含一个启用了 CSM 的固件，用于以传统 BIOS 模式启动不支持 UEFI 的虚拟机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyve -AHP -s 0:0,hostbridge -s 1:0,lpc \</span>
-s 2:0,virtio-net,tap1 -s 3:0,virtio-blk,./disk.img <span class="se">\</span>
-s 4:0,ahci-cd,./install.iso -c 4 -m 1024M <span class="se">\</span>
-l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI_CSM.fd <span class="se">\</span>
guest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-framebuffer">24.6.5. bhyve 客户机的图形 UEFI 帧缓冲<a class="anchor" href="#virtualization-bhyve-framebuffer"></a></h4>
<div class="paragraph">
<p>UEFI 固件支持对于主要以图形为主的客户操作系统（如 Microsoft Windows® ）特别有用。</p>
</div>
<div class="paragraph">
<p>还可以使用 <code>-s 29 , fbuf , tcp =<em>0.0.0.0:5900</em></code> 标志来启用对 UEFI-GOP 帧缓冲的支持。可以使用 <code>w =<em>800</em></code> 和 <code>h =<em>600</em></code> 来配置帧缓冲的分辨率，并且可以通过添加 <code>wait</code> 来指示 bhyve 在启动客户机之前等待 VNC 连接。帧缓冲可以通过主机或通过 VNC 协议通过网络访问。此外，还可以添加 <code>-s 30 , xhci , tablet</code> 以实现与主机的精确鼠标光标同步。</p>
</div>
<div class="paragraph">
<p>生成的 bhyve 命令将如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyve -AHP -s 0:0,hostbridge -s 31:0,lpc \</span>
-s 2:0,virtio-net,tap1 -s 3:0,virtio-blk,./disk.img <span class="se">\</span>
-s 4:0,ahci-cd,./install.iso -c 4 -m 1024M <span class="se">\</span>
-s 29,fbuf,tcp<span class="o">=</span>0.0.0.0:5900,w<span class="o">=</span>800,h<span class="o">=</span>600,wait <span class="se">\</span>
-s 30,xhci,tablet <span class="se">\</span>
-l bootrom,/usr/local/share/uefi-firmware/BHYVE_UEFI.fd <span class="se">\</span>
guest</code></pre>
</div>
</div>
<div class="paragraph">
<p>注意，在 BIOS 仿真模式下，一旦控制权从固件转移到客户操作系统，帧缓冲将停止接收更新。</p>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-zfs">24.6.6. 使用 ZFS 与 bhyve 虚拟机<a class="anchor" href="#virtualization-bhyve-zfs"></a></h4>
<div class="paragraph">
<p>如果主机上可用 ZFS ，使用 ZFS 卷而不是磁盘映像文件可以为客户机提供显著的性能优势。可以通过以下方式创建 ZFS 卷：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -V16G -o volmode=dev zroot/linuxdisk0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在启动虚拟机时，将 ZFS 卷指定为磁盘驱动器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s3:0,virtio-blk,/dev/zvol/zroot/linuxdisk0 \</span>
    -l com1,stdio -c 4 -m 1024M linuxguest</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-nmdm">24.6.7. 虚拟机控制台<a class="anchor" href="#virtualization-bhyve-nmdm"></a></h4>
<div class="paragraph">
<p>将 bhyve 控制台包装在会话管理工具（如 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/tmux/">sysutils/tmux</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/screen/">sysutils/screen</a> ）中是有优势的，这样可以分离和重新连接到控制台。还可以将 bhyve 的控制台设置为一个空调制解调器设备，可以使用 <code>cu</code> 访问。为此，加载 <span class="filename">nmdm</span> 内核模块，并将 <code>-l com1 , stdio</code> 替换为 <code>-l com1 , /dev/nmdm0A</code> 。 <span class="filename">/dev/nmdm</span> 设备会根据需要自动创建，每个设备都是一对，对应于空调制解调器电缆的两端（ <span class="filename">/dev/nmdm0A</span> 和 <span class="filename">/dev/nmdm0B</span> ）。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=nmdm&amp;sektion=4&amp;format=html">nmdm(4)</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload nmdm</span>
<span class="c"># bhyve -A -H -P -s 0:0,hostbridge -s 1:0,lpc -s 2:0,virtio-net,tap0 -s 3:0,virtio-blk,./linux.img \</span>
    -l com1,/dev/nmdm0A -c 4 -m 1024M linuxguest
<span class="c"># cu -l /dev/nmdm0B</span>
Connected

Ubuntu 13.10 handbook ttyS0

handbook login:</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-managing">24.6.8. 管理虚拟机<a class="anchor" href="#virtualization-bhyve-managing"></a></h4>
<div class="paragraph">
<p>每个虚拟机都在 <code>/dev/vmm</code> 目录下创建了一个设备节点。这样管理员就可以轻松地查看正在运行的虚拟机列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ls -al /dev/vmm</span>
total 1
dr-xr-xr-x   2 root  wheel    512 Mar 17 12:19 ./
dr-xr-xr-x  14 root  wheel    512 Mar 17 06:38 ../
crw-------   1 root  wheel  0x1a2 Mar 17 12:20 guestname
crw-------   1 root  wheel  0x19f Mar 17 12:19 linuxguest
crw-------   1 root  wheel  0x1a1 Mar 17 12:19 otherguest</code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code>bhyvectl</code> 命令销毁指定的虚拟机：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># bhyvectl --destroy --vm=guestname</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-bhyve-onboot">24.6.9. 持久化配置<a class="anchor" href="#virtualization-bhyve-onboot"></a></h4>
<div class="paragraph">
<p>为了在启动时配置系统以启动 bhyve 虚拟机，必须在指定的文件中进行以下配置：</p>
</div>
<div class="olist arabic procedure">
<ol class="arabic">
<li>
<p><span class="filename">/etc/sysctl.conf</span></p>
<div class="literalblock programlisting">
<div class="content">
<pre>net.link.tap.up_on_open=1</pre>
</div>
</div>
</li>
<li>
<p><span class="filename">/etc/rc.conf</span></p>
<div class="literalblock programlisting">
<div class="content">
<pre>cloned_interfaces=&#34;bridge0 tap0&#34;
ifconfig_bridge0=&#34;addm igb0 addm tap0&#34;
kld_list=&#34;nmdm vmm&#34;</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect2">
<h3 id="virtualization-host-xen">24.7. FreeBSD 作为 Xen™ 主机<a class="anchor" href="#virtualization-host-xen"></a></h3>
<div class="paragraph">
<p>Xen 是一种基于 GPLv2 许可的 <a href="https://en.wikipedia.org/wiki/Hypervisor#Classification">1 型虚拟化监控程序</a> ，适用于 Intel® 和 ARM® 架构。 FreeBSD 自 8.0 版本起包含了 i386™ 和 AMD® 64 位 <a href="https://wiki.xenproject.org/wiki/DomU">DomU</a> 以及 <a href="https://en.wikipedia.org/wiki/Amazon_Elastic_Compute_Cloud">Amazon EC2</a> 非特权域（虚拟机）支持，并在 FreeBSD 11.0 中增加了 Dom0 控制域（主机）支持。在 FreeBSD 11 中，对于半虚拟化（ PV ）域的支持已被移除，取而代之的是硬件虚拟化（ HVM ）域，这提供了更好的性能。</p>
</div>
<div class="paragraph">
<p>Xen™ 是一个裸金属虚拟化监控程序，这意味着它是在 BIOS 之后加载的第一个程序。然后启动一个特殊的特权客户机，称为 Domain-0 （简称为 Dom0 ）。 Dom0 利用其特权直接访问底层物理硬件，使其成为高性能解决方案。它能够直接访问磁盘控制器和网络适配器。 Dom0 还使用 Xen™ 管理工具来管理和控制 Xen™ 虚拟化监控程序，创建、列出和销毁虚拟机（ VMs ）。 Dom0 为非特权域（通常称为 DomU ）提供虚拟磁盘和网络。 Xen™ Dom0 可以与其他虚拟化监控程序解决方案的服务控制台进行比较，而 DomU 是运行各个客户机虚拟机的地方。</p>
</div>
<div class="paragraph">
<p>Xen™ 可以在不同的 Xen™ 服务器之间迁移虚拟机。当两个 Xen 主机共享相同的底层存储时，迁移可以在不必先关闭虚拟机的情况下进行。相反，迁移是在 DomU 运行时进行的，无需重新启动或计划停机时间。这在维护场景或升级窗口中非常有用，以确保 DomU 提供的服务仍然可用。 Xen™ 的许多其他功能列在 <a href="https://wiki.xenproject.org/wiki/Category:Overview">Xen Wiki 概述页面</a> 上。请注意，目前并非所有功能都在 FreeBSD 上受支持。</p>
</div>
<div class="sect3">
<h4 id="virtualization-host-xen-requirements">24.7.1. Xen™ Dom0 的硬件要求<a class="anchor" href="#virtualization-host-xen-requirements"></a></h4>
<div class="paragraph">
<p>要在主机上运行 Xen™ 虚拟机监视器，需要一定的硬件功能。硬件虚拟化域需要主机处理器支持扩展页表（ EPT ）和输入 / 输出内存管理单元（ IOMMU ）。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了运行 FreeBSD Xen™ Dom0 ，必须使用传统引导（ BIOS ）启动该设备。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-host-xen-dom0-setup">24.7.2. Xen™ Dom0 控制域设置<a class="anchor" href="#virtualization-host-xen-dom0-setup"></a></h4>
<div class="paragraph">
<p>FreeBSD 11 的用户应安装基于 Xen 4.7 版本的包： emulators/xen-kernel47[] 和包： sysutils/xen-tools47[] 。运行在 FreeBSD-12.0 或更新版本上的系统可以分别使用基于 Xen 4.11 的包： emulators/xen-kernel411[] 和包： sysutils/xen-tools411[] 。</p>
</div>
<div class="paragraph">
<p>在安装 Xen 软件包后，必须编辑配置文件以准备主机进行 Dom0 集成。在 [/etc/sysctl.conf] 中添加条目可以禁用内存页面的限制。否则，具有较高内存需求的 DomU 虚拟机将无法运行。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#39;vm.max_wired=-1&#39; &gt;&gt; /etc/sysctl.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个与内存相关的设置涉及更改 <span class="filename">/etc/login.conf</span> ，将 <code>memorylocked</code> 选项设置为 <code>unlimited</code> 。否则，创建 DomU 域可能会失败，并显示 <code>Cannot allocate memory</code> 错误。在对 <span class="filename">/etc/login.conf</span> 进行更改后，运行 <code>cap_mkdb</code> 以更新能力数据库。有关详细信息，请参阅 <a href="./#security-resourcelimits">资源限制</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sed -i &#39;&#39; -e &#39;s/memorylocked=64K/memorylocked=unlimited/&#39; /etc/login.conf</span>
<span class="c"># cap_mkdb /etc/login.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <span class="filename">/etc/ttys</span> 中添加一个 Xen™ 控制台的条目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#39;xc0     &#34;/usr/libexec/getty Pc&#34;         xterm   onifconsole  secure&#39; &gt;&gt; /etc/ttys</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <span class="filename">/boot/loader.conf</span> 中选择一个 Xen™ 内核会激活 Dom0 。 Xen™ 还需要来自主机机器的 CPU 和内存资源，用于自身和其他 DomU 域。 CPU 和内存的数量取决于个体需求和硬件能力。在这个例子中，为 Dom0 提供了 8 GB 的内存和 4 个虚拟 CPU 。串行控制台也被激活，并定义了日志选项。</p>
</div>
<div class="paragraph">
<p>以下命令用于 Xen 4.7 软件包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#39;hw.pci.mcfg=0&#39; &gt;&gt; /boot/loader.conf</span>
<span class="c"># echo &#39;if_tap_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class="c"># echo &#39;xen_kernel=&#34;/boot/xen&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class="c"># echo &#39;xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0pvh=1 console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于 Xen 版本 4.11 及更高版本，应使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#39;if_tap_load=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class="c"># echo &#39;xen_kernel=&#34;/boot/xen&#34;&#39; &gt;&gt; /boot/loader.conf</span>
<span class="c"># echo &#39;xen_cmdline=&#34;dom0_mem=8192M dom0_max_vcpus=4 dom0=pvh console=com1,vga com1=115200,8n1 guest_loglvl=all loglvl=all&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Xen™ 为 DomU 虚拟机创建的日志文件存储在 [/var/log/xen] 目录中。如果遇到问题，请务必检查该目录的内容。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在系统启动时激活 xencommons 服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc xencommons_enable=yes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些设置足以启动一个启用了 Dom0 的系统。然而，它缺乏用于 DomU 虚拟机的网络功能。为了解决这个问题，需要定义一个桥接接口，使用系统的主要网络接口（主机网络接口名称替换为_em0_），以便 DomU 虚拟机可以连接到网络。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc cloned_interfaces=&#34;bridge0&#34;</span>
<span class="c"># sysrc ifconfig_bridge0=&#34;addm em0 SYNCDHCP&#34;</span>
<span class="c"># sysrc ifconfig_em0=&#34;up&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>重新启动主机以加载 Xen™ 内核并启动 Dom0 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># reboot</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在成功启动 Xen™ 内核并再次登录系统后，使用 Xen™ 管理工具 <code>xl</code> 来显示有关域的信息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class="o">(</span>s<span class="o">)</span>
Domain-0                                     0  8192     4     r-----     962.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出确认了 Dom0 （称为 <code>Domain-0</code> ）的 ID 为 <code>0</code> 并且正在运行。它还具有之前在 <span class="filename">/boot/loader.conf</span> 中定义的内存和虚拟 CPU 。更多信息可以在 <a href="https://www.xenproject.org/help/documentation.html">Xen™ 文档</a> 中找到。现在可以创建 DomU 客户机虚拟机。</p>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-host-xen-domu-setup">24.7.3. Xen™ DomU 客户机虚拟机配置<a class="anchor" href="#virtualization-host-xen-domu-setup"></a></h4>
<div class="paragraph">
<p>非特权域由配置文件和虚拟或物理硬盘组成。 DomU 的虚拟磁盘存储可以是由 <a href="https://man.freebsd.org/cgi/man.cgi?query=truncate&amp;sektion=1&amp;format=html">truncate(1)</a> 创建的文件，也可以是 <a href="./#zfs-zfs-volume ，“创建和销毁卷”"></a> 中描述的 ZFS 卷。 在此示例中，使用了一个 20 GB 的卷。 使用 ZFS 卷、 FreeBSD ISO 映像、 1 GB 的 RAM 和两个虚拟 CPU 创建了一个虚拟机。 ISO 安装文件使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=fetch&amp;sektion=1&amp;format=html">fetch(1)</a> 获取，并保存在名为 <span class="filename">freebsd.iso</span> 的本地文件中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># fetch https://download.freebsd.org/releases/ISO-IMAGES/13.1/FreeBSD-13.1-RELEASE-amd64-bootonly.iso -o freebsd.iso</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>创建了一个名为 <span class="filename">xendisk0</span> 的 20 GB ZFS 卷，用作虚拟机的磁盘空间。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># zfs create -V20G -o volmode=dev zroot/xendisk0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>新的 DomU 客户机虚拟机在一个文件中定义。一些特定的定义，如名称、键盘映射和 VNC 连接详细信息也被定义。以下是一个示例的最小 DomU 配置的 <span class="filename">freebsd.cfg</span> 文件内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat freebsd.cfg</span>
builder <span class="o">=</span> <span class="s2">&#34;hvm&#34;</span> <i class="conum" data-value="1"></i><b>(1)</b>
name <span class="o">=</span> <span class="s2">&#34;freebsd&#34;</span> <i class="conum" data-value="2"></i><b>(2)</b>
memory <span class="o">=</span> 1024 <i class="conum" data-value="3"></i><b>(3)</b>
vcpus <span class="o">=</span> 2 <i class="conum" data-value="4"></i><b>(4)</b>
vif <span class="o">=</span> <span class="o">[</span> <span class="s1">&#39;mac=00:16:3E:74:34:32,bridge=bridge0&#39;</span> <span class="o">]</span> <i class="conum" data-value="5"></i><b>(5)</b>
disk <span class="o">=</span> <span class="o">[</span>
<span class="s1">&#39;/dev/zvol/tank/xendisk0,raw,hda,rw&#39;</span>, <i class="conum" data-value="6"></i><b>(6)</b>
<span class="s1">&#39;/root/freebsd.iso,raw,hdc:cdrom,r&#39;</span> <i class="conum" data-value="7"></i><b>(7)</b>
  <span class="o">]</span>
vnc <span class="o">=</span> 1 <i class="conum" data-value="8"></i><b>(8)</b>
vnclisten <span class="o">=</span> <span class="s2">&#34;0.0.0.0&#34;</span>
serial <span class="o">=</span> <span class="s2">&#34;pty&#34;</span>
usbdevice <span class="o">=</span> <span class="s2">&#34;tablet&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这些行将被更详细地解释：</p>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这定义了要使用的虚拟化类型。 <code>hvm</code> 指的是硬件辅助虚拟化或硬件虚拟机。客户操作系统可以在具有虚拟化扩展的 CPU 上无需修改即可运行，提供与在物理硬件上运行几乎相同的性能。 <code>generic</code> 是默认值，创建一个 PV 域。 &lt;.&gt; 虚拟机的名称，用于区分在同一 Dom0 上运行的其他虚拟机。必填项。 &lt;.&gt; 分配给虚拟机的内存数量，以兆字节为单位。此数量从超级监视程序的总可用内存中减去，而不是从 Dom0 的内存中减去。 &lt;.&gt; 客户虚拟机可用的虚拟 CPU 数量。为了获得最佳性能，请不要创建具有超过主机上物理 CPU 数量的虚拟 CPU 的客户。 &lt;.&gt; 虚拟网络适配器。这是连接到主机网络接口的桥接器。 <code>mac</code> 参数是设置在虚拟网络接口上的 MAC 地址。如果未提供 MAC ，则此参数是可选的， Xen™ 将生成一个随机的 MAC 地址。 &lt;.&gt; 磁盘、文件或 ZFS 磁盘存储的完整路径，用于此虚拟机。选项和多个磁盘定义由逗号分隔。 &lt;.&gt; 定义安装初始操作系统的启动介质。在此示例中，它是之前下载的 ISO 镜像。请参阅 Xen™ 文档以了解其他类型的设备和设置选项。 &lt;.&gt; 控制 VNC 连接到 DomU 的串行控制台的选项。按顺序，它们是：激活 VNC 支持，定义要监听的 IP 地址，串行控制台的设备节点，以及精确定位鼠标和其他输入方法的输入方法。 <code>keymap</code> 定义要使用的键盘映射，默认为 <code>english</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在使用所有必要选项创建文件之后，通过将其作为参数传递给 <code>xl create</code> 来创建 DomU 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># xl create freebsd.cfg</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>每次重新启动 Dom0 时，必须再次将配置文件传递给 <code>xl create</code> 以重新创建 DomU 。默认情况下，在重新启动后只会创建 Dom0 ，而不会创建各个虚拟机。虚拟机可以从它们上次停止的地方继续运行，因为它们将操作系统存储在虚拟磁盘上。虚拟机的配置可以随时间而变化（例如，添加更多内存）。虚拟机的配置文件必须被正确备份并保持可用，以便在需要时重新创建客户虚拟机。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>xl list</code> 的输出确认了 DomU 已经被创建。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># xl list</span>
Name                                        ID   Mem VCPUs      State   Time<span class="o">(</span>s<span class="o">)</span>
Domain-0                                     0  8192     4     r-----  1653.4
freebsd                                      1  1024     1     -b----   663.9</code></pre>
</div>
</div>
<div class="paragraph">
<p>要开始安装基本操作系统，请启动 VNC 客户端，并将其指向主机的主网络地址或在 <span class="filename">freebsd.cfg</span> 文件的 <code>vnclisten</code> 行中定义的 IP 地址。操作系统安装完成后，关闭 DomU 并断开 VNC 查看器的连接。编辑 <span class="filename">freebsd.cfg</span> 文件，删除包含 <code>cdrom</code> 定义的行，或在行的开头插入一个 <code>#</code> 字符进行注释。要加载这个新的配置，需要使用 <code>xl destroy</code> 命令删除旧的 DomU ，参数可以是名称或 ID 。然后，使用修改后的 <strong class="filename">freebsd.cfg</strong> 文件重新创建 DomU 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># xl destroy freebsd</span>
<span class="c"># xl create freebsd.cfg</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后可以使用 VNC 查看器再次访问该机器。这次，它将从已安装操作系统的虚拟磁盘启动，并可用作虚拟机。</p>
</div>
</div>
<div class="sect3">
<h4 id="virtualization-host-xen-troubleshooting">24.7.4. 故障排除<a class="anchor" href="#virtualization-host-xen-troubleshooting"></a></h4>
<div class="paragraph">
<p>本节包含基本信息，以帮助解决在使用 FreeBSD 作为 Xen™ 主机或客户机时遇到的问题。</p>
</div>
<div class="sect4">
<h5 id="virtualization-host-xen-troubleshooting-host">24.7.4.1. 主机启动故障排除<a class="anchor" href="#virtualization-host-xen-troubleshooting-host"></a></h5>
<div class="paragraph">
<p>请注意，以下故障排除提示适用于 Xen™ 4.11 或更新版本。如果您仍在使用 Xen™ 4.7 并且遇到问题，请考虑迁移到更新版本的 Xen™ 。</p>
</div>
<div class="paragraph">
<p>为了解决主机启动问题，您可能需要使用串行电缆或调试 USB 电缆。可以通过向 <span class="filename">loader.conf</span> 中的 <code>xen_cmdline</code> 选项添加选项来获取详细的 Xen™ 引导输出。一些相关的调试选项包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>iommu = debug</code> ：可用于打印有关 IOMMU 的额外诊断信息。</p>
</li>
<li>
<p><code>dom0 = verbose</code> ：可用于打印有关 dom0 构建过程的额外诊断信息。</p>
</li>
<li>
<p><code>sync_console</code> ：用于强制同步控制台输出的标志。在调试过程中非常有用，可以避免由于速率限制而丢失消息。在生产环境中永远不要使用此选项，因为它可能允许恶意虚拟机通过控制台对 Xen™ 进行拒绝服务（ DoS ）攻击。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了识别任何问题， FreeBSD 也应该以详细模式启动。要激活详细启动，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#39;boot_verbose=&#34;YES&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果这些选项都无法解决问题，请将串行引导日志发送至 mailto:freebsd-xen @ FreeBSD.org[freebsd-xen @ FreeBSD.org] 和 mailto:xen-devel @ lists.xenproject.org[xen-devel @ lists.xenproject.org] 以进行进一步分析。</p>
</div>
</div>
<div class="sect4">
<h5 id="virtualization-host-xen-troubleshooting-guest">24.7.4.2. 访客创建故障排除<a class="anchor" href="#virtualization-host-xen-troubleshooting-guest"></a></h5>
<div class="paragraph">
<p>在创建虚拟机时也可能出现问题，下面尝试为那些试图诊断虚拟机创建问题的人提供一些帮助。</p>
</div>
<div class="paragraph">
<p>创建虚拟机失败最常见的原因是 <code>xl</code> 命令输出错误并以非 0 的返回码退出。如果提供的错误信息不足以帮助确定问题，还可以通过多次使用 <code>xl</code> 命令的 <code>v</code> 选项来获取更详细的输出。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># xl -vvv create freebsd.cfg</span>
Parsing config from freebsd.cfg
libxl: debug: libxl_create.c:1693:do_domain_create: Domain 0:ao 0x800d750a0: create: <span class="nv">how</span><span class="o">=</span>0x0 <span class="nv">callback</span><span class="o">=</span>0x0 <span class="nv">poller</span><span class="o">=</span>0x800d6f0f0
libxl: debug: libxl_device.c:397:libxl__device_disk_set_backend: Disk <span class="nv">vdev</span><span class="o">=</span>xvda spec.backend<span class="o">=</span>unknown
libxl: debug: libxl_device.c:432:libxl__device_disk_set_backend: Disk <span class="nv">vdev</span><span class="o">=</span>xvda, using backend phy
libxl: debug: libxl_create.c:1018:initiate_domain_create: Domain 1:running bootloader
libxl: debug: libxl_bootloader.c:328:libxl__bootloader_run: Domain 1:not a PV/PVH domain, skipping bootloader
libxl: debug: libxl_event.c:689:libxl__ev_xswatch_deregister: watch <span class="nv">w</span><span class="o">=</span>0x800d96b98: deregister unregistered
domainbuilder: detail: xc_dom_allocate: <span class="nv">cmdline</span><span class="o">=</span><span class="s2">&#34;&#34;</span>, <span class="nv">features</span><span class="o">=</span><span class="s2">&#34;&#34;</span>
domainbuilder: detail: xc_dom_kernel_file: <span class="nv">filename</span><span class="o">=</span><span class="s2">&#34;/usr/local/lib/xen/boot/hvmloader&#34;</span>
domainbuilder: detail: xc_dom_malloc_filemap    : 326 kB
libxl: debug: libxl_dom.c:988:libxl__load_hvm_firmware_module: Loading BIOS: /usr/local/share/seabios/bios.bin
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果详细输出无法帮助诊断问题，还可以在 <span class="filename">/var/log/xen</span> 中找到 QEMU 和 Xen™ 工具栈的日志。请注意，日志名称后面附加了域的名称，因此如果域的名称为 <code>freebsd</code> ，您应该能找到一个 <span class="filename">/var/log/xen/xl-freebsd.log</span> 和可能还有一个 <span class="filename">/var/log/xen/qemu-dm-freebsd.log</span> 。这两个日志文件都可能包含有用的调试信息。如果以上方法都无法解决问题，请将您面临的问题的描述和尽可能多的信息发送到 mailto:freebsd-xen @ FreeBSD.org[freebsd-xen @ FreeBSD.org] 和 mailto:xen-devel @ lists.xenproject.org[xen-devel @ lists.xenproject.org] 以获取帮助。</p>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="l10n">Chapter 25. 本地化 - i18n/L10n 的使用和设置<a class="anchor" href="#l10n"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="l10n-synopsis">25.1. 简介<a class="anchor" href="#l10n-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 是一个分布式项目，用户和贡献者遍布全球。因此， FreeBSD 支持多种语言的本地化，允许用户以非英语语言查看、输入或处理数据。可以选择大多数主要语言，包括但不限于：中文、德语、日语、韩语、法语、俄语和越南语。</p>
</div>
<div class="paragraph">
<p>国际化一词被缩写为 i18n ，代表着“ internationalization ”中第一个字母和最后一个字母之间的字母数量。 L10n 使用相同的命名方案，但是从“ localization ”中计算。 i18n/L10n 的方法、协议和应用程序允许用户使用他们选择的语言。</p>
</div>
<div class="paragraph">
<p>本章讨论了 FreeBSD 的国际化和本地化功能。阅读本章后，您将了解到：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何构建区域名称。</p>
</li>
<li>
<p>如何为登录 shell 设置区域设置。</p>
</li>
<li>
<p>如何配置控制台以支持非英语语言。</p>
</li>
<li>
<p>如何为不同的语言配置 Xorg 。</p>
</li>
<li>
<p>如何找到符合国际化标准的应用程序。</p>
</li>
<li>
<p>如何找到配置特定语言的更多信息。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解如何交叉引用： ports[ports ，安装额外的第三方应用程序] 。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="using-localization">25.2. 使用本地化<a class="anchor" href="#using-localization"></a></h3>
<div class="paragraph">
<p>本地化设置基于三个组件：语言代码、国家代码和编码。区域设置名称由这些部分构成，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>LanguageCode_CountryCode.Encoding</pre>
</div>
</div>
<div class="paragraph">
<p>_语言代码_和_国家代码_用于确定国家和特定的语言变体。 <a href="#locale-lang-country">常见的语言和国家代码</a> 提供了一些<em>语言代码_国家代码</em>的示例：</p>
</div>
<table id="locale-lang-country" class="tableblock frame-none grid-all stretch">
<caption class="title">表 32. 常见的语言和国家代码</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">语言代码_国家代码</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">en_US</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">英语，美国</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ru_RU</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">俄罗斯，俄罗斯</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">zh_TW</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">繁體中文，台灣</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>可以通过输入以下命令来查看所有可用的区域设置列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>locale -a | more</code></pre>
</div>
</div>
<div class="paragraph">
<p>确定当前的区域设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>locale</code></pre>
</div>
</div>
<div class="paragraph">
<p>特定语言的字符集，如 ISO8859-1 、 ISO8859-15 、 KOI8-R 和 CP437 ，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=multibyte&amp;sektion=3&amp;format=html">multibyte(3)</a> 中有描述。字符集的活动列表可以在 <a href="http://www.iana.org/assignments/character-sets">IANA 注册表</a> 中找到。</p>
</div>
<div class="paragraph">
<p>一些语言，比如中文或日文，不能用 ASCII 字符表示，需要使用宽字符或多字节字符的扩展语言编码。宽字符或多字节编码的例子包括 EUC 和 Big5 。旧的应用程序可能会将这些编码误认为控制字符，而新的应用程序通常能够识别这些字符。根据实现的不同，用户可能需要使用宽字符或多字节字符支持来编译应用程序，或者正确配置它。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>FreeBSD 使用与 Xorg 兼容的区域编码。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本节的其余部分描述了在 FreeBSD 系统上配置区域设置的各种方法。下一节将讨论查找和编译支持国际化（ i18n ）的应用程序的注意事项。</p>
</div>
<div class="sect3">
<h4 id="setting-locale">25.2.1. 设置登录 Shell 的区域设置<a class="anchor" href="#setting-locale"></a></h4>
<div class="paragraph">
<p>区域设置可以在用户的 [.filename]# ~ /.login_conf# 文件中或者用户的 shell 启动文件中进行配置： [.filename]# ~ /.profile# 、 [.filename]# ~ /.bashrc# 或者 [.filename]# ~ /.cshrc# 。</p>
</div>
<div class="paragraph">
<p>应设置两个环境变量：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>LANG</code> ，用于设置区域设置</p>
</li>
<li>
<p><code>MM_CHARSET</code> 是一个设置应用程序使用的 MIME 字符集的变量。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>除了用户的 shell 配置外，这些变量还应该为特定的应用程序配置和 Xorg 配置设置。</p>
</div>
<div class="paragraph">
<p>有两种方法可以进行所需的变量赋值： <a href="#login-class ">登录类 </a> 方法和 <a href="#startup-file ">启动文件 </a> 方法。推荐使用登录类方法，下面的两个部分将演示如何使用这两种方法。</p>
</div>
<div class="sect4">
<h5 id="login-class">25.2.1.1. 登录类方法<a class="anchor" href="#login-class"></a></h5>
<div class="paragraph">
<p>这是推荐的方法，因为它为每个可能的 shell 分配了所需的区域设置和 MIME 字符集的环境变量。这个设置可以由每个用户执行，也可以由超级用户为所有用户配置。</p>
</div>
<div class="paragraph">
<p>这个最简示例在个人用户的主目录的 <span class="filename">.login_conf</span> 文件中设置了两个变量，用于 Latin-1 编码。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>me:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:</pre>
</div>
</div>
<div class="paragraph">
<p>这是一个用户的示例 [.filename]# ~ /.login_conf# ，它设置了使用 BIG-5 编码的繁体中文的变量。由于一些应用程序不正确地遵守中文、日文和韩文的区域变量，因此需要更多的变量。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#Users who do not wish to use monetary units or time formats
#of Taiwan can manually change each variable
me:\
	:lang=zh_TW.Big5:\
	:setenv=LC_ALL=zh_TW.Big5,LC_COLLATE=zh_TW.Big5,LC_CTYPE=zh_TW.Big5,LC_MESSAGES=zh_TW.Big5,LC_MONETARY=zh_TW.Big5,LC_NUMERIC=zh_TW.Big5,LC_TIME=zh_TW.Big5:\
	:charset=big5:\
	:xmodifiers=&#34;@im=gcin&#34;: #Set gcin as the XIM Input Server</pre>
</div>
</div>
<div class="paragraph">
<p>超级用户可以选择配置系统中的所有用户进行本地化。在 /etc/login.conf 文件中，可以使用以下变量来设置区域设置和 MIME 字符集：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>language_name|Account Type Description:\
	:charset=MIME_charset:\
	:lang=locale_name:\
	:tc=default:</pre>
</div>
</div>
<div class="paragraph">
<p>因此，前面的 Latin-1 示例将如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>german|German Users Accounts:\
	:charset=ISO-8859-1:\
	:lang=de_DE.ISO8859-1:\
	:tc=default:</pre>
</div>
</div>
<div class="paragraph">
<p>请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=login.conf&amp;sektion=5&amp;format=html">login.conf(5)</a> 以获取有关这些变量的更多详细信息。请注意，它已经包含了预定义的_russian_类。</p>
</div>
<div class="paragraph">
<p>每当编辑 <span class="filename">/etc/login.conf</span> 文件时，请记得执行以下命令来更新能力数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cap_mkdb /etc/login.conf</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于最终用户来说，需要在他们的 <code>.login_conf</code> 文件上运行 <code>cap_mkdb</code> 命令，以使任何更改生效。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect5">
<h6 id="_更改登录类别的实用工具">25.2.1.1.1. 更改登录类别的实用工具<a class="anchor" href="#_更改登录类别的实用工具"></a></h6>
<div class="paragraph">
<p>除了手动编辑 /etc/login.conf 文件外，还有一些工具可用于设置新创建用户的区域设置。</p>
</div>
<div class="paragraph">
<p>使用 <code>vipw</code> 添加新用户时，需要指定 <em>language</em> 来设置区域设置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>user:password:1111:11:language:0:0:User Name:/home/user:/bin/sh</pre>
</div>
</div>
<div class="paragraph">
<p>当使用 <code>adduser</code> 命令添加新用户时，可以预先配置默认语言适用于所有新用户，或者为单个用户指定语言。</p>
</div>
<div class="paragraph">
<p>如果所有新用户使用相同的语言，请在 <span class="filename">/etc/adduser.conf</span> 中设置 <code>defaultclass =<em>language</em></code> 。</p>
</div>
<div class="paragraph">
<p>要在创建用户时覆盖此设置，请在此提示处输入所需的区域设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Enter login class: default <span class="o">[]</span>:</code></pre>
</div>
</div>
<div class="paragraph">
<p>或者在调用 <code>adduser</code> 时指定要设置的区域设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># adduser -class language</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果使用 <code>pw</code> 来添加新用户，请按照以下方式指定区域设置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw useradd user_name -L language</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要更改现有用户的登录类别，可以使用 <code>chpass</code> 命令。以超级用户身份调用该命令，并将要编辑的用户名作为参数提供。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chpass user_name</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="startup-file">25.2.1.2. Shell 启动文件方法<a class="anchor" href="#startup-file"></a></h5>
<div class="paragraph">
<p>不推荐使用第二种方法，因为每个使用的 shell 都需要手动配置，每个 shell 都有不同的配置文件和语法。例如，要为 <code>sh</code> shell 设置德语语言，可以将以下行添加到 <code>.filename</code> 文件中的 ` ~ /.profile` 中，以仅为该用户设置 shell 。这些行也可以添加到 <code>/etc/profile</code> 或 <code>/usr/share/skel/dot.profile</code> 中，以为所有用户设置该 shell 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>LANG=de_DE.ISO8859-1; export LANG
MM_CHARSET=ISO-8859-1; export MM_CHARSET</pre>
</div>
</div>
<div class="paragraph">
<p>然而，对于 <code>csh</code> shell ，配置文件的名称和使用的语法有所不同。以下是与 [.filename]# ~ /.login# 、 <span class="filename">/etc/csh.login</span> 或 <span class="filename">/usr/share/skel/dot.login</span> 等效的设置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>setenv LANG de_DE.ISO8859-1
setenv MM_CHARSET ISO-8859-1</pre>
</div>
</div>
<div class="paragraph">
<p>为了使事情变得复杂，配置 Xorg 所需的语法也取决于 shell 。第一个示例适用于 <code>sh</code> shell ，第二个示例适用于 <code>csh</code> shell ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>LANG=de_DE.ISO8859-1; export LANG</pre>
</div>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>setenv LANG de_DE.ISO8859-1</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="setting-console">25.2.2. 控制台设置<a class="anchor" href="#setting-console"></a></h4>
<div class="paragraph">
<p>控制台提供了几种本地化字体。要查看可用字体的列表，请键入 <code>ls /usr/share/syscons/fonts</code> 。要配置控制台字体，请在 <code>/etc/rc.conf</code> 中指定字体名称，不包括 <code>.fnt</code> 后缀。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>font8x16=font_name
font8x14=font_name
font8x8=font_name</pre>
</div>
</div>
<div class="paragraph">
<p>可以通过将以下内容添加到 [/etc/rc.conf] 来设置键位映射和屏幕映射：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>scrnmap=screenmap_name
keymap=keymap_name
keychange=&#34;fkey_number sequence&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要查看可用的屏幕映射列表，请键入 <code>ls /usr/share/syscons/scrnmaps</code> 。在指定_screenmap_name_时，请不要包括 <span class="filename">.scm</span> 后缀。通常需要具有相应映射字体的屏幕映射作为解决方案，以便将位 8 扩展到 VGA 适配器的字体字符矩阵的位 9 ，以便在屏幕字体使用位 8 列时将字母移出伪图形区域。</p>
</div>
<div class="paragraph">
<p>要查看可用的键盘映射列表，请输入 <code>ls /usr/share/syscons/keymaps</code> 。在指定 <em>keymap_name</em> 时，不要包括 <span class="filename">.kbd</span> 后缀。要在不重新启动的情况下测试键盘映射，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=kbdmap&amp;sektion=1&amp;format=html">kbdmap(1)</a> 。</p>
</div>
<div class="paragraph">
<p>通常需要使用 <code>keychange</code> 条目来将功能键编程为与所选终端类型匹配，因为功能键序列无法在键映射中定义。</p>
</div>
<div class="paragraph">
<p>接下来，在所有虚拟终端条目的 <span class="filename">/etc/ttys</span> 中设置正确的控制台终端类型。 <a href="#locale-charset">字符集的终端类型定义</a> 总结了可用的终端类型。</p>
</div>
<table id="locale-charset" class="tableblock frame-none grid-all stretch">
<caption class="title">表 33. 字符集的终端类型定义</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">字符集</th>
<th class="tableblock halign-left valign-top">终端类型</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ISO8859-1 or ISO8859-15</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cons25l1</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ISO8859-2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cons25l2</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">ISO8859-7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cons25l7</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KOI8-R</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cons25r</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">KOI8-U</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cons25u</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CP437 (VGA default)</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cons25</code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">US-ASCII</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cons25w</code></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>对于具有宽字符或多字节字符的语言，请从 FreeBSD Ports Collection 中安装适用于该语言的控制台。可用的端口在 <a href="#locale-console">从 Ports Collection 可用的控制台</a> 中进行了总结。安装完成后，请参考端口的 <span class="filename">pkg-message</span> 或 man 页面以获取配置和使用说明。</p>
</div>
<table id="locale-console" class="tableblock frame-none grid-all stretch">
<caption class="title">表 34. 从 Ports Collection 可用的控制台</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">语言</th>
<th class="tableblock halign-left valign-top">端口位置</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">繁体中文（ BIG-5 ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/big5con[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文 / 日文 / 韩文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/cce[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文 / 日文 / 韩文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/zhcon[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/kon2[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：日语 /kon2-14 点 []</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/kon2-16dot[]</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果在 [/etc/rc.conf] 中启用了鼠标，可能需要进行额外的配置。默认情况下， <a href="https://man.freebsd.org/cgi/man.cgi?query=syscons&amp;sektion=4&amp;format=html">syscons(4)</a> 驱动程序的鼠标光标占用字符集中的 <code>0xd0</code>-<code>0xd3</code> 范围。如果语言使用此范围，请通过在 [/etc/rc.conf] 中添加以下行来移动光标的范围：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>mousechar_start=3</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_xorg_设置">25.2.3. Xorg 设置<a class="anchor" href="#_xorg_设置"></a></h4>
<div class="paragraph">
<p><a href="./#x11 ， X Window 系统"></a> 描述了如何安装和配置 Xorg 。在配置 Xorg 进行本地化时，可以从 FreeBSD Ports Collection 中获取额外的字体和输入法。应用程序特定的国际化设置，如字体和菜单，可以在 [.filename]# ~ /.Xresources# 中进行调整，这样用户就可以在图形应用程序菜单中查看他们选择的语言。</p>
</div>
<div class="paragraph">
<p>X 输入法（ XIM ）协议是用于输入非英语字符的 Xorg 标准。 <a href="#locale-xim">可用的输入方法</a> 总结了在 FreeBSD Ports Collection 中可用的输入法应用程序。还有其他 Fcitx 和 Uim 应用程序可用。</p>
</div>
<table id="locale-xim" class="tableblock frame-none grid-all stretch">
<caption class="title">表 35. 可用的输入方法</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">语言</th>
<th class="tableblock halign-left valign-top">输入法</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/gcin[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/ibus-chewing[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/ibus-pinyin[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/oxim[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/scim-fcitx[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/scim-pinyin[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">中文</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： chinese/scim-tables[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/ibus-anthy[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/ibus-mozc[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：日语 /ibus-skk[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/japanese/im-ja/">japanese/im-ja</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/japanese/kinput2/">japanese/kinput2</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-anthy[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-canna[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-honoka[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-honoka-plugin-romkan[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-honoka-plugin-wnn[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-prime[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/japanese/scim-skk/">japanese/scim-skk</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/japanese/scim-tables/">japanese/scim-tables</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-tomoe[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/scim-uim[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/japanese/skkinput/">japanese/skkinput</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/japanese/skkinput3/">japanese/skkinput3</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包： japanese/uim-anthy[]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">韩国人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/korean/ibus-hangul/">korean/ibus-hangul</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">韩国人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/korean/imhangul/">korean/imhangul</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">韩国人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">包：韩国 / 纳比 []</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">韩国人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/korean/scim-hangul/">korean/scim-hangul</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">韩国人</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/korean/scim-tables/">korean/scim-tables</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">越南语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/vietnamese/xvnkb/">vietnamese/xvnkb</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">越南语</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a class="package" href="https://cgit.freebsd.org/ports/tree/vietnamese/x-unikey/">vietnamese/x-unikey</a></p></td>
</tr>
</tbody>
</table>
</div>
</div>
<div class="sect2">
<h3 id="l10n-compiling">25.3. 寻找国际化应用程序<a class="anchor" href="#l10n-compiling"></a></h3>
<div class="paragraph">
<p>国际化（ i18n ）应用程序是使用库中的国际化工具包进行编程的。这些工具包允许开发人员编写一个简单的文件，并将显示的菜单和文本翻译成每种语言。</p>
</div>
<div class="paragraph">
<p>链接： <a href="https://www.FreeBSD.org/ports/">FreeBSD Ports Collection</a> 包含许多应用程序，这些应用程序内置了对多种语言的宽字符或多字节字符的支持。这些应用程序的名称中包含“ i18n ”，以便于识别。然而，它们并不总是支持所需的语言。</p>
</div>
<div class="paragraph">
<p>一些应用程序可以使用特定的字符集进行编译。通常在端口的 Makefile 文件中完成，或者通过传递一个值给 configure 来实现。有关如何确定所需的 configure 值或在构建端口时使用哪些编译选项的更多信息，请参阅相应的 FreeBSD 端口源代码中的 i18n 文档。</p>
</div>
</div>
<div class="sect2">
<h3 id="lang-setup">25.4. 特定语言的区域配置<a class="anchor" href="#lang-setup"></a></h3>
<div class="paragraph">
<p>本节提供了将 FreeBSD 系统本地化为俄语的配置示例。然后，它还提供了一些本地化其他语言的附加资源。</p>
</div>
<div class="sect3">
<h4 id="ru-localize">25.4.1. 俄语（ KOI8-R 编码）<a class="anchor" href="#ru-localize"></a></h4>
<div class="paragraph">
<p>本节展示了将 FreeBSD 系统本地化为俄语所需的具体设置。有关每种类型设置的更详细描述，请参阅 <a href="#using-localization ">使用本地化 </a> 。</p>
</div>
<div class="paragraph">
<p>要为登录 shell 设置此区域设置，请将以下行添加到每个用户的 [.filename]# ~ /.login_conf# 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>me:My Account:\
	:charset=KOI8-R:\
	:lang=ru_RU.KOI8-R:</pre>
</div>
</div>
<div class="paragraph">
<p>要配置控制台，请将以下行添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>keymap=&#34;ru.utf-8&#34;
scrnmap=&#34;utf-82cp866&#34;
font8x16=&#34;cp866b-8x16&#34;
font8x14=&#34;cp866-8x14&#34;
font8x8=&#34;cp866-8x8&#34;
mousechar_start=3</pre>
</div>
</div>
<div class="paragraph">
<p>对于 [/etc/ttys] 中的每个 <code>ttyv</code> 条目，请使用 <code>cons25r</code> 作为终端类型。</p>
</div>
<div class="paragraph">
<p>要配置打印，需要一个特殊的输出过滤器，将 KOI8-R 转换为 CP866 ，因为大多数带有俄语字符的打印机都配备了硬件代码页 CP866 。 FreeBSD 包含了一个默认的过滤器，位于 [/usr/libexec/lpr/ru/koi2alt] 。要使用这个过滤器，将以下条目添加到 [/etc/printcap] 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>lp|Russian local line printer:\
	:sh:of=/usr/libexec/lpr/ru/koi2alt:\
	:lp=/dev/lpt0:sd=/var/spool/output/lpd:lf=/var/log/lpd-errs:</pre>
</div>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=printcap&amp;sektion=5&amp;format=html">printcap(5)</a> 以获取更详细的解释。</p>
</div>
<div class="paragraph">
<p>要在挂载的 MS-DOS® 文件系统中配置对俄语文件名的支持，请在向 [/etc/fstab] 添加条目时包括 <code>-L</code> 和区域设置名称：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/dev/ad0s2      /dos/c  msdos   rw,-Lru_RU.KOI8-R 0 0</pre>
</div>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_msdosfs&amp;sektion=8&amp;format=html">mount_msdosfs(8)</a> 获取更多详细信息。</p>
</div>
<div class="paragraph">
<p>要为 Xorg 配置俄文字体，请安装包： x11-fonts/xorg-fonts-cyrillic[] 。然后，在 <span class="filename">/etc/X11/xorg.conf</span> 中检查 <code>&#34;Files&#34;</code> 部分。以下行必须在任何其他 <code>FontPath</code> 条目之前添加：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>FontPath   &#34;/usr/local/lib/X11/fonts/cyrillic&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在 Ports Collection 中提供了额外的西里尔字体。</p>
</div>
<div class="paragraph">
<p>要激活俄语键盘，请将以下内容添加到 <span class="filename">/etc/xorg.conf</span> 文件的 <code>&#34;Keyboard&#34;</code> 部分：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Option &#34;XkbLayout&#34;   &#34;us,ru&#34;
Option &#34;XkbOptions&#34;  &#34;grp:toggle&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>确保在该文件中将 <code>XkbDisable</code> 注释掉。</p>
</div>
<div class="paragraph">
<p>对于 <code>grp:toggle</code> ，使用 <kbd>右 Alt</kbd> ；对于 <code>grp:ctrl_shift_toggle</code> ，使用 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>Shift</kbd></span> ；对于 <code>grp:caps_toggle</code> ，使用 <kbd>CapsLock</kbd> 。在 LAT 模式下，仍然可以使用旧的 <kbd>CapsLock</kbd> 功能，使用 <span class="keyseq"><kbd>Shift</kbd>+<kbd>CapsLock</kbd></span> 。由于某种未知的原因， <code>grp:caps_toggle</code> 在 Xorg 中无法正常工作。</p>
</div>
<div class="paragraph">
<p>如果键盘上有&#34;Windows®&#34;键，并且一些非字母键映射不正确，请将以下行添加到 <span class="filename">/etc/xorg.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Option &#34;XkbVariant&#34; &#34;,winkeys&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>俄罗斯的 XKB 键盘可能无法与非本地化的应用程序配合使用。最低程度的本地化应用程序应在程序早期调用 `XtSetLanguageProc(NULL , NULL , NULL) ; ` 函数。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>请参考 <a href="http://koi8.pp.ru/xwin.html">http://koi8.pp.ru/xwin.html</a> 获取有关本地化 Xorg 应用程序的更多说明。有关 KOI8-R 编码的更一般信息，请参考 <a href="http://koi8.pp.ru/">http://koi8.pp.ru/</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_其他语言特定资源">25.4.2. 其他语言特定资源<a class="anchor" href="#_其他语言特定资源"></a></h4>
<div class="paragraph">
<p>本节列出了一些配置其他区域设置的附加资源。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">繁體中文（台灣）</dt>
<dd>
<p>FreeBSD-Taiwan 项目在 <a href="http://netlab.cse.yzu.edu.tw/" class="bare">http://netlab.cse.yzu.edu.tw/</a> \~ statue/freebsd/zh-tut/ 上提供了一份关于 FreeBSD 的中文 HOWTO 文档。</p>
</dd>
<dt class="hdlist1">希腊语本地化</dt>
<dd>
<p>有关 FreeBSD 中希腊语支持的完整文章可以在此处找到： <a href="https://www.FreeBSD.org/doc/gr/articles/greek-language-support/" class="bare">https://www.FreeBSD.org/doc/gr/articles/greek-language-support/</a> ，该文章仅以希腊语提供，并作为官方 FreeBSD 希腊文档的一部分。</p>
</dd>
<dt class="hdlist1">日本语和韩国语本地化</dt>
<dd>
<p>对于日语，请参考 <a href="http://www.jp.FreeBSD.org/">http://www.jp.FreeBSD.org/</a> ，对于韩语，请参考 <a href="http://www.kr.FreeBSD.org/">http://www.kr.FreeBSD.org/</a> 。</p>
</dd>
<dt class="hdlist1">非英语的 FreeBSD 文档</dt>
<dd>
<p>一些 FreeBSD 的贡献者已经将 FreeBSD 文档的部分内容翻译成其他语言。这些翻译可以通过 [FreeBSD 网站](<a href="https://www.FreeBSD.org/" class="bare">https://www.FreeBSD.org/</a>) 上的链接或者在 <code>/usr/share/doc</code> 目录中找到。</p>
</dd>
</dl>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="updating-upgrading">Chapter 26. 更新和升级 FreeBSD<a class="anchor" href="#updating-upgrading"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="updating-upgrading-synopsis">26.1. 简介<a class="anchor" href="#updating-upgrading-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 在发布之间处于不断的开发中。有些人喜欢使用官方发布的版本，而其他人则喜欢与最新的开发保持同步。然而，即使是官方发布的版本也经常会更新以修复安全和其他关键问题。无论使用哪个版本， FreeBSD 都提供了所有必要的工具来保持系统更新，并允许在版本之间进行轻松升级。本章介绍如何跟踪开发系统以及保持 FreeBSD 系统最新的基本工具。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何使用 freebsd-update 或 Git 来保持 FreeBSD 系统的最新状态。</p>
</li>
<li>
<p>如何将已安装系统的状态与已知的原始副本进行比较。</p>
</li>
<li>
<p>如何使用 Git 或文档端口来保持已安装文档的最新状态。</p>
</li>
<li>
<p>两个开发分支之间的区别： FreeBSD-STABLE 和 FreeBSD-CURRENT 。</p>
</li>
<li>
<p>如何重建和重新安装整个基础系统。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>正确设置网络连接（参见：高级网络设置）。</p>
</li>
<li>
<p>了解如何安装额外的第三方软件（参考： ports[ports ，安装应用程序：软件包和端口] ）。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在本章中，使用 <code>git</code> 来获取和更新 FreeBSD 源代码。可选地，可以使用 <code><a class="package" href="https://cgit.freebsd.org/ports/tree/devel/git/">devel/git</a></code> 端口或软件包。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="updating-upgrading-freebsdupdate">26.2. FreeBSD 更新<a class="anchor" href="#updating-upgrading-freebsdupdate"></a></h3>
<div class="paragraph">
<p>及时应用安全补丁和升级到操作系统的新版本是系统管理的重要方面。 FreeBSD 包含一个名为 <code>freebsd-update</code> 的实用程序，可用于执行这两个任务。</p>
</div>
<div class="paragraph">
<p>该实用程序支持对 FreeBSD 进行二进制安全性和勘误更新，无需手动编译和安装补丁或新内核。二进制更新适用于安全团队当前支持的所有架构和版本。支持的版本列表及其预计的生命周期日期可在 <a href="https://www.FreeBSD.org/security/" class="bare">https://www.FreeBSD.org/security/</a> 上找到。</p>
</div>
<div class="paragraph">
<p>该实用程序还支持将操作系统升级到次要点版本以及升级到另一个发布分支。在升级到新版本之前，请查看其发布公告，因为其中包含与该版本相关的重要信息。发布公告可从 <a href="https://www.FreeBSD.org/releases/" class="bare">https://www.FreeBSD.org/releases/</a> 获取。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果存在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update&amp;sektion=8&amp;format=html">freebsd-update(8)</a> 功能的 <a href="https://man.freebsd.org/cgi/man.cgi?query=crontab&amp;sektion=5&amp;format=html">crontab(5)</a> ，在升级操作系统之前必须将其禁用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本节描述了 <code>freebsd-update</code> 使用的配置文件，演示了如何应用安全补丁以及如何升级到次要或主要操作系统版本，并讨论了升级操作系统时的一些考虑因素。</p>
</div>
<div class="sect3">
<h4 id="freebsdupdate-config-file">26.2.1. 配置文件<a class="anchor" href="#freebsdupdate-config-file"></a></h4>
<div class="paragraph">
<p><code>freebsd-update</code> 的默认配置文件可以直接使用。一些用户可能希望调整默认配置文件 <code>/etc/freebsd-update.conf</code> ，以便更好地控制该过程。该文件中的注释解释了可用的选项，但以下内容可能需要更多的解释：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Components of the base system which should be kept updated.
Components world kernel</pre>
</div>
</div>
<div class="paragraph">
<p>该参数控制着哪些部分的 FreeBSD 将保持最新。默认情况下，会更新整个基础系统和内核。也可以指定单个组件，例如 <code>src/base</code> 或 <code>src/sys</code> 。然而，最好的选择是将其保持默认状态，因为更改它以包括特定项需要列出每个所需的项。随着时间的推移，这可能会导致源代码和二进制文件不同步，从而产生灾难性后果。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Paths which start with anything matching an entry in an IgnorePaths
# statement will be ignored.
IgnorePaths /boot/kernel/linker.hints</pre>
</div>
</div>
<div class="paragraph">
<p>为了在更新过程中保留指定目录（例如 <span class="filename">/bin</span> 或 <span class="filename">/sbin</span> ）的内容不变，可以将它们的路径添加到此语句中。此选项可用于防止 <code>freebsd-update</code> 覆盖本地修改。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Paths which start with anything matching an entry in an UpdateIfUnmodified
# statement will only be updated if the contents of the file have not been
# modified by the user (unless changes are merged; see below).
UpdateIfUnmodified /etc/ /var/ /root/ /.cshrc /.profile</pre>
</div>
</div>
<div class="paragraph">
<p>此选项仅会更新指定目录中未修改的配置文件。用户所做的任何更改都会阻止这些文件的自动更新。还有另一个选项 <code>KeepModifiedMetadata</code> ，它会指示 <code>freebsd-update</code> 在合并过程中保存更改。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># When upgrading to a new FreeBSD release, files which match MergeChanges
# will have any local changes merged into the version from the new release.
MergeChanges /etc/ /var/named/etc/ /boot/device.hints</pre>
</div>
</div>
<div class="paragraph">
<p><code>freebsd-update</code> 应尝试合并的配置文件目录列表。文件合并过程是一系列类似于 <code>mergemaster</code> 的 <a href="https://man.freebsd.org/cgi/man.cgi?query=diff&amp;sektion=1&amp;format=html">diff(1)</a> 补丁，但选项较少。合并可以被接受、打开编辑器或导致 <code>freebsd-update</code> 中止。如果不确定，备份 <span class="filename">/etc</span> 并接受合并。有关 <code>mergemaster</code> 的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Directory in which to store downloaded updates and temporary
# files used by FreeBSD Update.
# WorkDir /var/db/freebsd-update</pre>
</div>
</div>
<div class="paragraph">
<p>该目录是用于存放所有补丁和临时文件的位置。在用户进行版本升级的情况下，该位置应至少有 1GB 的可用磁盘空间。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># When upgrading between releases, should the list of Components be
# read strictly (StrictComponents yes) or merely as a list of components
# which *might* be installed of which FreeBSD Update should figure out
# which actually are installed and upgrade those (StrictComponents no)?
# StrictComponents no</pre>
</div>
</div>
<div class="paragraph">
<p>当将此选项设置为 <code>yes</code> 时， <code>freebsd-update</code> 将假设 <code>Components</code> 列表是完整的，并且不会尝试在列表之外进行更改。实际上， <code>freebsd-update</code> 将尝试更新属于 <code>Components</code> 列表的每个文件。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=freebsd-update.conf&amp;sektion=5&amp;format=html">freebsd-update.conf(5)</a> 获取更多详细信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="freebsdupdate-security-patches">26.2.2. 应用安全补丁<a class="anchor" href="#freebsdupdate-security-patches"></a></h4>
<div class="paragraph">
<p>应用 FreeBSD 安全补丁的过程已经简化，管理员可以使用 <code>freebsd-update</code> 来保持系统完全更新。有关 FreeBSD 安全公告的更多信息，请参阅 <a href="./#security-advisories">FreeBSD Security Advisories</a> 。</p>
</div>
<div class="paragraph">
<p>可以使用以下命令下载和安装 FreeBSD 安全补丁。第一个命令将确定是否有可用的未解决补丁，并且如果应用了这些补丁，将列出将被修改的文件。第二个命令将应用这些补丁。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update fetch</span>
<span class="c"># freebsd-update install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果更新应用了任何内核补丁，系统将需要重新启动以引导到已打补丁的内核。如果补丁被应用于正在运行的二进制文件，受影响的应用程序应该重新启动，以便使用已打补丁的二进制版本。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通常，用户需要准备好重新启动系统。要知道系统是否需要由于内核更新而重新启动，请执行命令 <code>freebsd-version -k</code> 和 <code>uname -r</code> 。如果输出不同，请重新启动系统。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>系统可以通过将以下条目添加到 [/etc/crontab] 来配置每天自动检查更新：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>@daily                                  root    freebsd-update cron</pre>
</div>
</div>
<div class="paragraph">
<p>如果存在补丁，它们将会自动下载但不会被应用。系统会向 <code>root</code> 用户发送一封电子邮件，以便可以审查这些补丁，并使用 <code>freebsd-update install</code> 命令手动安装它们。</p>
</div>
<div class="paragraph">
<p>如果出现任何问题， <code>freebsd-update</code> 可以使用以下命令回滚最后一组更改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update rollback</span>
Uninstalling updates... <span class="k">done</span>.</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果内核或任何内核模块被修改，系统应该重新启动，并且应该重新启动任何受影响的二进制文件。</p>
</div>
<div class="paragraph">
<p>只有 <span class="filename">GENERIC</span> 内核可以被 <code>freebsd-update</code> 自动更新。如果安装了自定义内核，则需要在 <code>freebsd-update</code> 完成更新后重新构建和安装它。默认的内核名称是 <em>GENERIC</em>。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> 命令来验证其安装情况。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>始终保留一个 <span class="filename">GENERIC</span> 内核的副本在 <span class="filename">/boot/GENERIC</span> 中。这对于诊断各种问题和进行版本升级非常有帮助。请参考 <a href="#freebsd-update-custom-kernel-9x">使用 FreeBSD 9.X 及更高版本的自定义内核</a> 了解如何获取 <span class="filename">GENERIC</span> 内核的副本的说明。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>除非已更改 <span class="filename">/etc/freebsd-update.conf</span> 中的默认配置，否则 <code>freebsd-update</code> 将与其他更新一起安装更新的内核源代码。然后可以按照通常的方式重新构建和重新安装新的自定义内核。</p>
</div>
<div class="paragraph">
<p><code>freebsd-update</code> 分发的更新并不总是涉及内核。如果内核源代码没有被 <code>freebsd-update install</code> 修改过，那么重新构建自定义内核是不必要的。然而， <code>freebsd-update</code> 总是会更新 <code>/usr/src/sys/conf/newvers.sh</code> 文件。通过 <code>uname -r</code> 命令报告的 <code>-p</code> 数字表示的当前补丁级别是从这个文件中获取的。即使没有其他变化，重新构建自定义内核也可以使 <code>uname</code> 准确地报告系统的当前补丁级别。这在维护多个系统时特别有帮助，因为它可以快速评估每个系统中安装的更新。</p>
</div>
</div>
<div class="sect3">
<h4 id="freebsdupdate-upgrade">26.2.3. 执行次要和主要版本升级<a class="anchor" href="#freebsdupdate-upgrade"></a></h4>
<div class="paragraph">
<p>从一个 FreeBSD 的次要版本升级到另一个次要版本被称为“次要版本”升级。一个例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>从 FreeBSD 13.1 升级到 13.2 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>主要版本升级会增加主要版本号。一个例子：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FreeBSD 13.2 升级至 14.0 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>通过为 <code>freebsd-update</code> 提供一个发布版本目标，可以执行两种类型的升级。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在每次新的 <code>RELEASE</code> 之后， FreeBSD 软件包构建服务器在有限的时间内 * 不会 * 使用较新的操作系统版本。这为许多用户提供了连续性，这些用户在发布公告后不会立即升级。例如：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 13.1 版本达到生命周期结束之前，将在运行 13.1 的服务器上构建适用于 13.1 和 13.2 用户的软件包。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p> — 而且，至关重要的是：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 13.1 上构建的内核模块可能 * 不适用于 *13.2 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>因此，无论是小型还是大型操作系统升级，如果您的软件包要求包括任何内核模块：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>* 准备好从源代码构建模块 * 。</p>
</li>
</ul>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果系统正在运行自定义内核，请确保在升级之前在 [/boot/GENERIC] 目录下存在一个 <span class="filename">GENERIC</span> 内核的副本。请参考 <a href="#freebsd-update-custom-kernel-9x">使用 FreeBSD 9.X 及更高版本的自定义内核</a> 以获取 <span class="filename">GENERIC</span> 内核的副本的说明。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在 FreeBSD 13.1 系统上运行以下命令将升级到 FreeBSD 13.2 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update -r 13.2-RELEASE upgrade</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在接收到命令后， <code>freebsd-update</code> 将评估配置文件和当前系统，以尝试收集执行升级所需的信息。屏幕上将显示一个列表，列出已检测到和未检测到的组件。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Looking up update.FreeBSD.org mirrors... 1 mirrors found.
Fetching metadata signature <span class="k">for </span>13.1-RELEASE from update1.FreeBSD.org... <span class="k">done</span>.
Fetching metadata index... <span class="k">done</span>.
Inspecting system... <span class="k">done</span>.

The following components of FreeBSD seem to be installed:
kernel/smp src/base src/bin src/contrib src/crypto src/etc src/games
src/gnu src/include src/krb5 src/lib src/libexec src/release src/rescue
src/sbin src/secure src/share src/sys src/tools src/ubin src/usbin
world/base world/info world/lib32 world/manpages

The following components of FreeBSD <span class="k">do </span>not seem to be installed:
kernel/generic world/catpages world/dict world/doc world/games
world/proflibs

Does this look reasonable <span class="o">(</span>y/n<span class="o">)</span>? y</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这一点上， <code>freebsd-update</code> 将尝试下载升级所需的所有文件。在某些情况下，用户可能会被要求回答关于安装哪些文件或如何继续的问题。</p>
</div>
<div class="paragraph">
<p>当使用自定义内核时，上述步骤将产生类似以下的警告：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">WARNING: This system is running a <span class="s2">&#34;MYKERNEL&#34;</span> kernel, which is not a
kernel configuration distributed as part of FreeBSD 13.1-RELEASE.
This kernel will not be updated: you MUST update the kernel manually
before running <span class="s2">&#34;/usr/sbin/freebsd-update install&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>此警告可以在此时安全地忽略。更新的 <span class="filename">GENERIC</span> 内核将作为升级过程中的中间步骤使用。</p>
</div>
<div class="paragraph">
<p>一旦所有补丁都下载到本地系统后，它们将被应用。这个过程可能需要一些时间，具体取决于机器的速度和工作负载。然后将合并配置文件。合并过程需要一些用户干预，因为可能需要合并文件或者在屏幕上出现编辑器进行手动合并。每次成功合并的结果都会在进程继续时显示给用户。如果合并失败或被忽略，进程将中止。用户可能希望在以后的某个时间备份 [/etc] 目录并手动合并重要文件，例如 master.passwd 或 group 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>系统尚未进行修改，因为所有的修补和合并都在另一个目录中进行。一旦所有的修补程序都成功应用，所有的配置文件都已经合并，并且看起来进程将顺利进行，用户可以使用以下命令将更改提交到磁盘：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update install</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>首先，将对内核和内核模块进行补丁。如果系统正在运行自定义内核，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=nextboot&amp;sektion=8&amp;format=html">nextboot(8)</a> 命令将内核设置为下一次启动时更新的 <span class="filename">/boot/GENERIC</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># nextboot -k GENERIC</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在使用 <span class="filename">GENERIC</span> 内核重新启动之前，请确保它包含了系统正常启动和连接到网络所需的所有驱动程序，如果正在更新的机器是远程访问的。特别是，如果正在运行的自定义内核包含通常由内核模块提供的内置功能，请确保使用 <span class="filename">/boot/loader.conf</span> 工具将这些模块临时加载到 <span class="filename">GENERIC</span> 内核中。建议在升级过程完成之前禁用非必要的服务以及任何磁盘和网络挂载。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>现在应该使用更新的内核重新启动机器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># shutdown -r now</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦系统恢复在线状态，使用以下命令重新启动 <code>freebsd-update</code> 。由于进程的状态已被保存， <code>freebsd-update</code> 将不会从头开始，而是继续进行下一阶段并删除所有旧的共享库和对象文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update install</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>根据库版本号是否有所增加，安装过程可能只有两个阶段，而不是三个阶段。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>升级已完成。如果这是一个主要版本的升级，请按照 <a href="#freebsdupdate-portsrebuild">在主要版本升级后升级软件包</a> 中描述的步骤重新安装所有端口和软件包。</p>
</div>
<div class="sect4">
<h5 id="freebsd-update-custom-kernel-9x">26.2.3.1. 使用 FreeBSD 9.X 及更高版本的自定义内核<a class="anchor" href="#freebsd-update-custom-kernel-9x"></a></h5>
<div class="paragraph">
<p>在使用 <code>freebsd-update</code> 前，请确保 <span class="filename">/boot/GENERIC</span> 目录下存在一个 <span class="filename">GENERIC</span> 内核的副本。如果只构建了一个自定义内核，那么 <span class="filename">/boot/kernel.old</span> 目录下的内核就是 <code>GENERIC</code> 内核。只需将此目录重命名为 <span class="filename">/boot/GENERIC</span> 。</p>
</div>
<div class="paragraph">
<p>如果自定义内核已经构建了多次，或者不知道自定义内核已经构建了多少次，请获取与当前操作系统版本匹配的 <code>GENERIC</code> 内核的副本。如果可以物理访问系统，则可以从安装介质中安装 <code>GENERIC</code> 内核的副本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount /cdrom</span>
<span class="c"># cd /cdrom/usr/freebsd-dist</span>
<span class="c"># tar -C/ -xvf kernel.txz boot/kernel/kernel</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，也可以从源代码重新构建并安装 <code>GENERIC</code> 内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># make kernel __MAKE_CONF=/dev/null SRCCONF=/dev/null</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了使这个内核被 <code>freebsd-update</code> 识别为 <code>GENERIC</code> 内核，必须确保 <span class="filename">GENERIC</span> 配置文件没有被任何方式修改过。同时建议在构建内核时不使用任何其他特殊选项。</p>
</div>
<div class="paragraph">
<p>不需要重新启动到“ GENERIC ”内核，因为“ freebsd-update ”只需要存在“ /boot/GENERIC ”文件。</p>
</div>
</div>
<div class="sect4">
<h5 id="freebsdupdate-portsrebuild">26.2.3.2. 在主要版本升级后升级软件包<a class="anchor" href="#freebsdupdate-portsrebuild"></a></h5>
<div class="paragraph">
<p>通常，在小版本升级后，已安装的应用程序将继续正常工作，没有问题。主要版本使用不同的应用程序二进制接口（ ABI ），这将导致大多数第三方应用程序无法正常工作。在进行主要版本升级后，所有已安装的软件包和端口都需要升级。可以使用 <code>pkg upgrade</code> 命令升级软件包。要升级已安装的端口，请使用类似于 <a class="package" href="https://cgit.freebsd.org/ports/tree/ports-mgmt/portmaster/">ports-mgmt/portmaster</a> 的实用工具。</p>
</div>
<div class="paragraph">
<p>强制升级所有已安装的软件包将使用存储库中的新版本替换软件包，即使版本号没有增加。这是因为在升级 FreeBSD 的主要版本之间时， ABI 版本会发生变化。可以通过执行以下操作来完成强制升级：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg-static upgrade -f</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用以下命令可以重新构建所有已安装的应用程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># portmaster -af</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令将显示每个具有可配置选项的应用程序的配置屏幕，并等待用户与这些屏幕进行交互。为了防止这种行为，并仅使用默认选项，请在上述命令中包含 <code>-G</code> 。</p>
</div>
<div class="paragraph">
<p>一旦软件升级完成，通过最后一次调用 <code>freebsd-update</code> 来完成升级过程，以解决升级过程中的所有问题。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果临时使用了 <span class="filename">GENERIC</span> 内核，现在是构建和安装新的自定义内核的时候了，可以按照 <a href="./#kernelconfig">Configuring the FreeBSD Kernel</a> 中的说明进行操作。</p>
</div>
<div class="paragraph">
<p>将机器重启到新的 FreeBSD 版本。升级过程现在已经完成。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="freebsdupdate-system-comparison">26.2.4. 系统状态比较<a class="anchor" href="#freebsdupdate-system-comparison"></a></h4>
<div class="paragraph">
<p>可以使用 <code>freebsd-update IDS</code> 命令来测试已安装的 FreeBSD 版本与已知的良好副本之间的状态。该命令评估系统实用程序、库和配置文件的当前版本，并可用作内置的入侵检测系统（ IDS ）。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这个命令不能替代真正的入侵检测系统，比如 <a class="package" href="https://cgit.freebsd.org/ports/tree/security/snort/">security/snort</a> 。由于 <code>freebsd-update</code> 将数据存储在磁盘上，篡改的可能性是显而易见的。虽然可以通过使用 <code>kern.securelevel</code> 和在不使用时将 <code>freebsd-update</code> 数据存储在只读文件系统上来减少这种可能性，但更好的解决方案是将系统与安全磁盘（如 DVD 或安全存储的外部 USB 磁盘设备）进行比较。使用内置工具提供 IDS 功能的替代方法在 <a href="./#security-ids">Binary Verification</a> 中有描述。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>开始比较之前，请指定要将结果保存到的输出文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># freebsd-update IDS &gt;&gt; outfile.ids</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>系统将会被检查，并且会将文件的详细列表以及已知发布版本和当前安装版本的 SHA256 哈希值发送到指定的输出文件中。</p>
</div>
<div class="paragraph">
<p>列表中的条目非常长，但输出格式很容易解析。例如，要获取与发布版本不同的所有文件的列表，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat outfile.ids | awk &#39;{ print $1 }&#39; | more</span>
/etc/master.passwd
/etc/motd
/etc/passwd
/etc/pf.conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>由于存在更多的文件，此示例输出已被截断。一些文件具有自然的修改。例如，如果系统中添加了用户， [/etc/passwd] 文件将被修改。内核模块可能会有所不同，因为 <code>freebsd-update</code> 可能已经对它们进行了更新。要排除特定的文件或目录，请将它们添加到 [/etc/freebsd-update.conf] 文件中的 <code>IDSIgnorePaths</code> 选项中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="updating-bootcode">26.3. 更新引导代码<a class="anchor" href="#updating-bootcode"></a></h3>
<div class="paragraph">
<p>以下手册描述了引导代码和引导加载程序的升级过程： <a href="https://man.freebsd.org/cgi/man.cgi?query=gpart&amp;sektion=8&amp;format=html">gpart(8)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=gptboot&amp;sektion=8&amp;format=html">gptboot(8)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=gptzfsboot&amp;sektion=8&amp;format=html">gptzfsboot(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.efi&amp;sektion=8&amp;format=html">loader.efi(8)</a> 。</p>
</div>
</div>
<div class="sect2">
<h3 id="updating-upgrading-documentation">26.4. 更新文档集合<a class="anchor" href="#updating-upgrading-documentation"></a></h3>
<div class="paragraph">
<p>文档是 FreeBSD 操作系统的一个重要组成部分。虽然 FreeBSD 网站上始终提供最新版本的文档（链接： <a href="https://docs.FreeBSD.org">文档门户</a> ），但拥有一个最新的本地副本也是很方便的，包括 FreeBSD 网站、手册、常见问题解答和文章。</p>
</div>
<div class="paragraph">
<p>本节介绍如何使用源代码或 FreeBSD Ports Collection 来保持本地的 FreeBSD 文档最新。</p>
</div>
<div class="paragraph">
<p>有关编辑和提交文档更正的信息，请参阅《 FreeBSD 文档项目新贡献者入门指南》（ <a href="{fdp-primer}">FreeBSD 文档项目新贡献者入门指南</a> ）。</p>
</div>
<div class="sect3">
<h4 id="updating-installed-documentation">26.4.1. 从源代码更新文档<a class="anchor" href="#updating-installed-documentation"></a></h4>
<div class="paragraph">
<p>从源代码重新构建 FreeBSD 文档需要一系列工具，这些工具不是 FreeBSD 基本系统的一部分。可以按照 FreeBSD 文档项目入门指南中的 <a href="{fdp-primer}">这些步骤， overview-quick-start</a> 来安装所需的工具。</p>
</div>
<div class="paragraph">
<p>安装完成后，使用 <code>git</code> 获取文档源代码的干净副本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git clone https://git.FreeBSD.org/doc.git /usr/doc</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下载文档源文件可能需要一些时间。请让它运行直到完成。</p>
</div>
<div class="paragraph">
<p>未来可以通过运行以下命令获取文档源的更新：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git pull</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦文档源的最新快照被获取到 [/usr/doc] 目录下，所有准备工作就完成了，可以更新已安装的文档。</p>
</div>
<div class="paragraph">
<p>可以通过输入以下命令来执行完整更新：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/doc</span>
<span class="c"># make</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="current-stable">26.5. 跟踪开发分支<a class="anchor" href="#current-stable"></a></h3>
<div class="paragraph">
<p>FreeBSD 有两个开发分支： FreeBSD-CURRENT 和 FreeBSD-STABLE 。</p>
</div>
<div class="paragraph">
<p>本节提供了每个分支及其预期受众的解释，以及如何使系统与每个相应分支保持最新的说明。</p>
</div>
<div class="sect3">
<h4 id="current">26.5.1. 使用 FreeBSD-CURRENT<a class="anchor" href="#current"></a></h4>
<div class="paragraph">
<p>FreeBSD-CURRENT 是 FreeBSD 开发的“最前沿”，使用 FreeBSD-CURRENT 的用户需要具备较高的技术能力。希望跟踪开发分支但技术水平较低的用户应该选择跟踪 FreeBSD-STABLE 。</p>
</div>
<div class="paragraph">
<p>FreeBSD-CURRENT 是 FreeBSD 的最新源代码，包括正在进行中的工作、实验性的更改以及可能存在于下一个官方发布版本中的过渡机制。虽然许多 FreeBSD 开发人员每天编译 FreeBSD-CURRENT 源代码，但在某些短暂的时间内，源代码可能无法构建。这些问题会尽快解决，但是 FreeBSD-CURRENT 是否带来灾难或新功能可能取决于源代码同步的时间。</p>
</div>
<div class="paragraph">
<p>FreeBSD-CURRENT 提供给三个主要的利益群体使用：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>活跃在 FreeBSD 社区中，正在积极参与源代码树某个部分工作的成员。</p>
</li>
<li>
<p>FreeBSD 社区的活跃测试人员。他们愿意花时间解决问题，就 FreeBSD 的变化和整体方向提出主题建议，并提交补丁。</p>
</li>
<li>
<p>希望密切关注事物、使用当前源代码进行参考，或偶尔发表评论或贡献代码的用户。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>FreeBSD-CURRENT 不应被视为在下一次发布之前获取新功能的快速途径，因为预发布功能尚未经过完全测试，很可能包含错误。它也不是获取错误修复的快速方式，因为每个提交都有可能引入新的错误而不是修复现有的错误。 FreeBSD-CURRENT 在任何情况下都不是“官方支持”的。</p>
</div>
<div class="paragraph">
<p>要追踪 FreeBSD-CURRENT ：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>加入 {freebsd-current} 和 {dev-commits-src-main} 邮件列表。这是非常重要的，可以看到人们对系统当前状态的评论，并接收有关 FreeBSD-CURRENT 当前状态的重要公告。</p>
<div class="paragraph">
<p>{dev-commits-src-main} 列表记录每次更改的提交日志条目，以及可能的副作用的相关信息。</p>
</div>
<div class="paragraph">
<p>要加入这些邮件列表，请转到 {mailing-lists} ，点击要订阅的列表，并按照说明进行操作。为了跟踪整个源代码树的变化，而不仅仅是 FreeBSD-CURRENT 的变化，请订阅 {dev-commits-src-all} 。</p>
</div>
</li>
<li>
<p>与 FreeBSD-CURRENT 源代码同步。通常情况下，使用 <code>git</code> 从 FreeBSD Git 存储库的 <code>main</code> 分支检出 -CURRENT 代码（有关详细信息，请参阅 <a href="./#git ，“使用 Git ”"></a> ）。</p>
</li>
<li>
<p>由于存储库的大小，一些用户选择只同步他们感兴趣的或者他们正在贡献补丁的源代码部分。然而，计划从源代码编译操作系统的用户必须下载整个 FreeBSD-CURRENT ，而不仅仅是选择的部分。</p>
<div class="paragraph">
<p>在编译 FreeBSD-CURRENT 之前，请仔细阅读 [/usr/src/Makefile] 文件，并按照 [makeworld] 中的说明进行操作。阅读 {freebsd-current} 和 [/usr/src/UPDATING] 文件以了解其他引导程序的更新情况，有时在进行下一个版本发布的过程中可能需要这些更新。</p>
</div>
</li>
<li>
<p>积极参与！鼓励 FreeBSD-CURRENT 用户提交他们对增强功能或修复错误的建议。附带代码的建议将会受到欢迎。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="stable">26.5.2. 使用 FreeBSD-STABLE<a class="anchor" href="#stable"></a></h4>
<div class="paragraph">
<p>FreeBSD-STABLE 是用于制作主要发布版本的开发分支。更改以较慢的速度进入此分支，并且通常假定它们首先在 FreeBSD-CURRENT 中进行了测试。这仍然是一个开发分支，并且在任何给定时间， FreeBSD-STABLE 的源代码可能适用或不适用于一般使用。它只是另一个工程开发轨道，而不是面向最终用户的资源。没有资源进行测试的用户应该运行最新版本的 FreeBSD 。</p>
</div>
<div class="paragraph">
<p>对于那些对追踪或参与 FreeBSD 开发过程感兴趣的人，尤其是与下一个 FreeBSD 版本相关的人，应该考虑关注 FreeBSD-STABLE 。</p>
</div>
<div class="paragraph">
<p>尽管 FreeBSD-STABLE 分支应该始终能够编译和运行，但无法保证这一点。由于运行 FreeBSD-STABLE 的人比运行 FreeBSD-CURRENT 的人更多，因此不可避免地会在 FreeBSD-STABLE 中发现一些在 FreeBSD-CURRENT 中不明显的错误和边界情况。因此，不应盲目跟踪 FreeBSD-STABLE 。特别重要的是，在没有在开发或测试环境中彻底测试代码的情况下，不要将任何生产服务器更新到 FreeBSD-STABLE 。</p>
</div>
<div class="paragraph">
<p>跟踪 FreeBSD-STABLE 的方法：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>加入 {freebsd-stable} 以便及时了解在 FreeBSD-STABLE 中可能出现的构建依赖项或其他需要特别关注的问题。开发人员还会在这个邮件列表中发布公告，当他们考虑一些有争议的修复或更新时，给用户一个机会回应，如果他们有任何关于拟议变更的问题需要提出。</p>
<div class="paragraph">
<p>加入与正在跟踪的分支相关的 git 列表。例如，跟踪 13-STABLE 分支的用户应该加入 {dev-commits-src-branches} 。该列表记录每个更改的提交日志条目，以及可能的副作用的任何相关信息。</p>
</div>
<div class="paragraph">
<p>要加入这些列表，请转到 {mailing-lists} ，点击要订阅的列表，并按照说明进行操作。为了跟踪整个源代码树的变化，请订阅 {dev-commits-src-all} 。</p>
</div>
</li>
<li>
<p>要安装一个新的 FreeBSD-STABLE 系统，请从 <a href="./#FreeBSD 镜像站点"></a> 安装最新的 FreeBSD-STABLE 版本，或者使用从 FreeBSD-STABLE 构建的每月快照。有关快照的更多信息，请参考 <a href="https://www.FreeBSD.org/snapshots/">www.freebsd.org/snapshots</a> 。</p>
<div class="paragraph">
<p>要编译或升级现有的 FreeBSD 系统到 FreeBSD-STABLE ，使用 <code>git</code> 来检出所需分支的源代码。分支名称，例如 <code>stable/13</code> ，在 <a href="https://www.FreeBSD.org/releng/">www.freebsd.org/releng</a> 上列出。</p>
</div>
</li>
<li>
<p>在编译或升级到 FreeBSD-STABLE 之前，请仔细阅读 [/usr/src/Makefile] 并按照 <a href="#makeworld">从源代码更新 FreeBSD</a> 中的说明进行操作。阅读 {freebsd-stable} 和 [/usr/src/UPDATING] 以了解其他引导程序的最新信息，有时在进行下一个版本发布的过程中可能需要这些信息。</p>
</li>
</ol>
</div>
</div>
<div class="sect3">
<h4 id="translate-n-number">26.5.3. N 号码<a class="anchor" href="#translate-n-number"></a></h4>
<div class="paragraph">
<p>在追踪错误时，了解使用哪些版本的源代码创建了出现问题的系统非常重要。 FreeBSD 在内核中提供了编译的版本信息。 <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> 可以检索到这些信息，例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>uname -v
FreeBSD 14.0-CURRENT <span class="c">#112 main-n247514-031260d64c18: Tue Jun 22 20:43:19 MDT 2021     fred@machine:/usr/home/fred/obj/usr/home/fred/git/head/amd64.amd64/sys/FRED</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后一个字段提供了有关内核名称、构建内核的人以及编译位置的信息。观察第四个字段，它由几个部分组成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">main-n247514-031260d64c18

main		<i class="conum" data-value="1"></i><b>(1)</b>
n247514		<i class="conum" data-value="2"></i><b>(2)</b>
031260d64c18	<i class="conum" data-value="3"></i><b>(3)</b>
		<i class="conum" data-value="4"></i><b>(4)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Git 分支名称。注意：仅对项目发布的分支（ <code>main</code> ， <code>stable/XX</code> 和 <code>releng/XX</code> ）进行 n- 数字的比较才有效。本地分支的 n- 数字将与其父分支的提交重叠。 &lt;.&gt; n- 数字是从包含在该行中的 Git 哈希开始的 Git 存储库的提交线性计数。 &lt;.&gt; 检出树的 Git 哈希 &lt;.&gt; 当内核在具有未提交更改的树中构建时，有时会出现后缀 <code>-dirty</code> 。在此示例中，它不存在，因为 FRED 内核是从原始的检出构建的。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><code>git rev-list</code> 命令用于查找与 Git 哈希对应的 n-number 。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>git rev-list --first-parent --count 031260d64c18 <i class="conum" data-value="1"></i><b>(1)</b>
247514 <i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>要翻译的 git 哈希（上面示例中的哈希被重用） &lt;.&gt; N 号码。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通常这个数字并不是非常重要。然而，当提交了错误修复时，这个数字可以快速确定修复是否存在于当前运行的系统中。开发人员通常会引用提交的哈希值（或提供具有该哈希值的 URL ），而不是 n 号，因为哈希值是一个易于识别的变更标识符，而 n 号则不是。安全公告和勘误通知也会注明一个 n 号，可以直接与您的系统进行比较。当您需要使用浅层 Git 克隆时，您无法可靠地比较 n 号，因为 <code>git rev-list</code> 命令会计算仓库中的所有修订版本，而浅层克隆会省略一些修订版本。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="makeworld">26.6. 从源代码更新 FreeBSD<a class="anchor" href="#makeworld"></a></h3>
<div class="paragraph">
<p>通过从源代码编译来更新 FreeBSD 相比二进制更新有几个优点。可以使用选项构建代码以充分利用特定的硬件。可以使用非默认设置构建基本系统的部分，或者在不需要或不希望的地方完全省略它们。与仅安装二进制更新相比，构建过程更新系统需要更长时间，但允许完全定制以生成定制版本的 FreeBSD 。</p>
</div>
<div class="sect3">
<h4 id="updating-src-quick-start">26.6.1. 快速入门<a class="anchor" href="#updating-src-quick-start"></a></h4>
<div class="paragraph">
<p>这是一个快速参考，用于通过从源代码构建来更新 FreeBSD 的典型步骤。后面的章节将更详细地描述这个过程。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当从 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 切换到 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 时，第一次运行可能会错误地合并更改，从而生成虚假的冲突。为了防止这种情况发生，在更新源代码和构建新的系统之前，请执行以下步骤：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># etcupdate extract </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="c"># etcupdate diff </span><i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引导数据库的股票 <span class="filename">/etc</span> 文件；有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在引导完成后检查差异。修剪不再需要的本地更改，以减少将来更新中冲突的可能性。</td>
</tr>
</tbody></table>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="ulist">
<ul>
<li>
<p>更新和构建</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git pull /usr/src  </span><i class="conum" data-value="1"></i><b>(1)</b>
check /usr/src/UPDATING  <i class="conum" data-value="2"></i><b>(2)</b>
<span class="c"># cd /usr/src          </span><i class="conum" data-value="3"></i><b>(3)</b>
<span class="c"># make -j4 buildworld  </span><i class="conum" data-value="4"></i><b>(4)</b>
<span class="c"># make -j4 kernel      </span><i class="conum" data-value="5"></i><b>(5)</b>
<span class="c"># shutdown -r now      </span><i class="conum" data-value="6"></i><b>(6)</b>
<span class="c"># etcupdate -p         </span><i class="conum" data-value="7"></i><b>(7)</b>
<span class="c"># cd /usr/src          </span><i class="conum" data-value="8"></i><b>(8)</b>
<span class="c"># make installworld    </span><i class="conum" data-value="9"></i><b>(9)</b>
<span class="c"># etcupdate -B         </span><i class="conum" data-value="10"></i><b>(10)</b>
<span class="c"># shutdown -r now      </span><i class="conum" data-value="11"></i><b>(11)</b></code></pre>
</div>
</div>
</li>
</ul>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>获取最新版本的源代码。有关获取和更新源代码的更多信息，请参阅 <a href="#updating-src-obtaining-src">更新源代码</a> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在从源代码构建之前或之后，请检查 <span class="filename">/usr/src/UPDATING</span> 是否有任何需要手动执行的步骤。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>进入源代码目录。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>编译整个世界，除了内核之外的一切。</p>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>编译并安装内核。这相当于执行 <code>make buildkernel installkernel</code> 命令。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>重新启动系统以加载新内核。</td>
</tr>
<tr>
<td><i class="conum" data-value="3"></i><b>3</b></td>
<td>在安装世界之前，需要更新和合并位于 <span class="filename">/etc/</span> 的配置文件。</td>
</tr>
<tr>
<td><i class="conum" data-value="4"></i><b>4</b></td>
<td>进入源代码目录。</td>
</tr>
<tr>
<td><i class="conum" data-value="5"></i><b>5</b></td>
<td>安装世界。</td>
</tr>
<tr>
<td><i class="conum" data-value="6"></i><b>6</b></td>
<td>更新并合并 <span class="filename">/etc/</span> 中的配置文件。</td>
</tr>
<tr>
<td><i class="conum" data-value="7"></i><b>7</b></td>
<td>重新启动系统以使用新构建的世界和内核。</td>
</tr>
</tbody></table>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updating-src-preparing">26.6.2. 准备进行源代码更新<a class="anchor" href="#updating-src-preparing"></a></h4>
<div class="paragraph">
<p>阅读 [/usr/src/UPDATING] 文件。该文件描述了在更新之前或之后必须执行的任何手动步骤。</p>
</div>
</div>
<div class="sect3">
<h4 id="updating-src-obtaining-src">26.6.3. 更新源代码<a class="anchor" href="#updating-src-obtaining-src"></a></h4>
<div class="paragraph">
<p>FreeBSD 源代码位于 [/usr/src/] 目录下。更新源代码的首选方法是通过 Git 版本控制系统。请确认源代码已经处于版本控制下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># git remote --v</span>
origin  https://git.freebsd.org/src.git <span class="o">(</span>fetch<span class="o">)</span>
origin  https://git.freebsd.org/src.git <span class="o">(</span>push<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这表示 <span class="filename">/usr/src/</span> 已经受到版本控制，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=git&amp;sektion=1&amp;format=html">git(1)</a> 进行更新。</p>
</div>
<div id="synching" class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git pull /usr/src</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果目录最近没有更新，更新过程可能需要一些时间。完成后，源代码将是最新的，可以开始下一节中描述的构建过程。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>获取源代码：</p>
</div>
<div class="paragraph">
<p>如果输出显示“ fatal: not a git repository ”，则表示文件丢失或使用了不同的安装方法。需要重新检出源代码。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<table id="updating-src-obtaining-src-repopath" class="tableblock frame-all grid-all stretch">
<caption class="title">表 36. FreeBSD 版本和存储库分支</caption>
<colgroup>
<col style="width: 10%;"/>
<col style="width: 10%;"/>
<col style="width: 80%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">uname -r 的输出结果</th>
<th class="tableblock halign-left valign-top">仓库路径</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>X.Y</em>-RELEASE</code> 表示一个版本号，其中 <code>X</code> 和 <code>Y</code> 是数字，表示主版本号和次版本号。 <code>RELEASE</code> 表示这是一个正式发布的版本。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>releng/<em>X.Y</em></code> 是一个文件或目录的路径，其中 <code>X.Y</code> 是一个占位符，表示一个特定的版本号。在计算机领域中， <code>releng</code> 通常是指与软件发布和工程相关的任务和流程。这个路径可能用于存储与特定版本相关的发布工程文件或目录。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发布版本加上仅包含关键安全和错误修复补丁。这个分支推荐给大多数用户使用。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>X.Y</em>-STABLE</code> 表示一个稳定版本，其中 <code>X.Y</code> 是具体的版本号。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>stable/<em>X</em></code> 的中文翻译是 ` 稳定版 /<em>X</em>` 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">稳定版本加上该分支上的所有额外开发。<em>STABLE</em> 指的是应用程序二进制接口（ ABI ）不会改变，因此为早期版本编译的软件仍然可以运行。例如，为了在 FreeBSD 10.1 上运行而编译的软件仍然可以在稍后编译的 FreeBSD 10-STABLE 上运行。</p>
<p class="tableblock">稳定分支偶尔会有错误或不兼容性，可能会影响用户，尽管这些问题通常会很快修复。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><em>X</em>-CURRENT</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>main</code> 是一个在计算机编程中常见的术语，表示程序的入口点或主函数。在许多编程语言中，程序的执行通常从 <code>main</code> 函数开始。 <code>main</code> 函数包含了程序的主要逻辑和执行流程。当程序运行时，操作系统会首先调用 <code>main</code> 函数，并从这里开始执行程序的代码。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">最新的未发布开发版本的 FreeBSD 。 CURRENT 分支可能存在重大错误或不兼容性问题，仅推荐给高级用户使用。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=uname&amp;sektion=1&amp;format=html">uname(1)</a> 命令确定正在使用的 FreeBSD 版本。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># uname -r</span>
13.2-RELEASE</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据 &lt;&lt; 更新源码 - 获取源码存储路径 &gt;&gt; ，用于更新 <code>13.2-RELEASE</code> 的源码具有存储路径 <code>releng/13.2</code> 。在检出源码时使用该路径：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mv /usr/src /usr/src.bak </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="c"># git clone --branch releng/13.2 https://git.FreeBSD.org/src.git /usr/src </span><i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>将旧目录移开。如果该目录没有本地修改，可以删除。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>将从 <a href="#updating-src-obtaining-src-repopath">FreeBSD 版本和存储库分支</a> 的路径添加到存储库 URL 中。第三个参数是本地系统上源代码的目标目录。</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="updating-src-building">26.6.4. 从源代码构建<a class="anchor" href="#updating-src-building"></a></h4>
<div class="paragraph">
<p>整个操作系统除了内核之外的部分被编译。首先这样做是为了提供最新的工具来构建内核。然后构建内核本身：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># make buildworld</span>
<span class="c"># make buildkernel</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>编译后的代码被写入到 <span class="filename">/usr/obj</span> 。</p>
</div>
<div class="paragraph">
<p>这些是基本步骤。下面描述了用于控制构建的其他选项。</p>
</div>
<div class="sect4">
<h5 id="updating-src-building-clean-build">26.6.4.1. 执行清理构建<a class="anchor" href="#updating-src-building-clean-build"></a></h5>
<div class="paragraph">
<p>一些 FreeBSD 构建系统的版本会在临时对象目录 [/usr/obj] 中保留先前编译的代码。这可以通过避免重新编译未更改的代码来加快后续的构建过程。要强制进行全面的清理重建，请在开始构建之前使用 <code>cleanworld</code> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make cleanworld</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="updating-src-building-jobs">26.6.4.2. 设置作业数量<a class="anchor" href="#updating-src-building-jobs"></a></h5>
<div class="paragraph">
<p>增加多核处理器上的构建作业数量可以提高构建速度。使用 <code>sysctl hw.ncpu</code> 确定核心数。处理器和不同版本的 FreeBSD 使用的构建系统各不相同，因此测试是唯一确定不同作业数量如何影响构建速度的可靠方法。作为起点，考虑在核心数的一半和两倍之间选择值。作业数量使用 <code>-j</code> 参数指定。</p>
</div>
<div id="updating-src-building-jobs-example" class="exampleblock">
<div class="title">例 33. 增加构建作业的数量</div>
<div class="content">
<div class="paragraph">
<p>使用四个作业构建世界和内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make -j4 buildworld buildkernel</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect4">
<h5 id="updating-src-building-only-kernel">26.6.4.3. 仅构建内核<a class="anchor" href="#updating-src-building-only-kernel"></a></h5>
<div class="paragraph">
<p>如果源代码发生了变化，必须完成 <code>buildworld</code> 。之后，可以随时运行 <code>buildkernel</code> 来构建内核。要仅构建内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># make buildkernel</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="updating-src-building-custom-kernel">26.6.4.4. 构建自定义内核<a class="anchor" href="#updating-src-building-custom-kernel"></a></h5>
<div class="paragraph">
<p>标准的 FreeBSD 内核基于一个名为 <span class="filename">GENERIC</span> 的_内核配置文件_。 <span class="filename">GENERIC</span> 内核包含了最常用的设备驱动程序和选项。有时候，构建一个自定义内核是有用或必要的，可以添加或删除设备驱动程序或选项以满足特定需求。</p>
</div>
<div class="paragraph">
<p>例如，某人正在开发一台内存严重有限的小型嵌入式计算机，可以删除不需要的设备驱动程序或选项，以使内核稍微变小。</p>
</div>
<div class="paragraph">
<p>内核配置文件位于 <span class="filename">/usr/src/sys/arch/conf/</span> ，其中 <em>arch</em> 是从 <code>uname -m</code> 命令的输出中获取的。在大多数计算机上，这个值是 <code>amd64</code> ，因此配置文件目录为 <span class="filename">/usr/src/sys/amd64/conf/</span> 。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><span class="filename">/usr/src</span> 可以被删除或重新创建，因此最好将自定义内核配置文件保存在一个单独的目录中，比如 <span class="filename">/root</span> 。将内核配置文件链接到 <span class="filename">conf</span> 目录中。如果该目录被删除或覆盖，可以将内核配置重新链接到新的目录中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以通过复制 <span class="filename">GENERIC</span> 配置文件来创建自定义配置文件。在这个例子中，新的自定义内核是用于存储服务器的，所以被命名为 <span class="filename">STORAGESERVER</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /usr/src/sys/amd64/conf/GENERIC /root/STORAGESERVER</span>
<span class="c"># cd /usr/src/sys/amd64/conf</span>
<span class="c"># ln -s /root/STORAGESERVER .</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后编辑 <span class="filename">/root/STORAGESERVER</span> ，根据 <a href="https://man.freebsd.org/cgi/man.cgi?query=config&amp;sektion=5&amp;format=html">config(5)</a> 中所示的方式添加或删除设备或选项。</p>
</div>
<div class="paragraph">
<p>通过在命令行中设置 <code>KERNCONF</code> 为内核配置文件来构建自定义内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make buildkernel KERNCONF=STORAGESERVER</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updating-src-installing">26.6.5. 安装编译后的代码<a class="anchor" href="#updating-src-installing"></a></h4>
<div class="paragraph">
<p>在完成 <code>buildworld</code> 和 <code>buildkernel</code> 步骤后，新的内核和系统已被安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># make installkernel</span>
<span class="c"># shutdown -r now</span>
<span class="c"># cd /usr/src</span>
<span class="c"># make installworld</span>
<span class="c"># shutdown -r now</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果构建了自定义内核，则还必须设置 <code>KERNCONF</code> 以使用新的自定义内核：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># make installkernel KERNCONF=STORAGESERVER</span>
<span class="c"># shutdown -r now</span>
<span class="c"># cd /usr/src</span>
<span class="c"># make installworld</span>
<span class="c"># shutdown -r now</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="updating-src-completing">26.6.6. 完成更新<a class="anchor" href="#updating-src-completing"></a></h4>
<div class="paragraph">
<p>完成更新还需要进行一些最后的任务。任何已修改的配置文件都将与新版本合并，过时的库将被定位并删除，然后系统将重新启动。</p>
</div>
<div class="sect4">
<h5 id="updating-src-completing-merge-etcupdate">26.6.6.1. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 合并配置文件<a class="anchor" href="#updating-src-completing-merge-etcupdate"></a></h5>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 是一个用于管理不作为 installworld 的一部分而更新的文件的工具，例如位于 <span class="filename">/etc/</span> 中的文件。它通过对这些文件所做的更改与本地版本进行三方合并来管理更新。与 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 的交互提示相比，它还旨在最小化用户干预的程度。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通常情况下， <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 在执行任务时不需要任何特定的参数。然而，第一次使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 时，有一个方便的中间命令用于检查将要执行的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># etcupdate diff</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该命令允许用户审计配置更改。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 无法自动合并文件，则可以通过手动交互来解决合并冲突，方法是执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># etcupdate resolve</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当从 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 切换到 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 时，第一次运行可能会错误地合并更改，从而生成虚假的冲突。为了防止这种情况发生，在更新源代码和构建新的系统之前，请执行以下步骤：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># etcupdate extract </span><i class="conum" data-value="1"></i><b>(1)</b>
<span class="c"># etcupdate diff </span><i class="conum" data-value="2"></i><b>(2)</b></code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>引导数据库的股票 <span class="filename">/etc</span> 文件；有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 。</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>在引导完成后检查差异。修剪不再需要的本地更改，以减少将来更新中冲突的可能性。</td>
</tr>
</tbody></table>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="updating-src-completing-merge-mergemaster">26.6.6.2. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 合并配置文件<a class="anchor" href="#updating-src-completing-merge-mergemaster"></a></h5>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 提供了一种将对系统配置文件所做的更改与这些文件的新版本合并的方法。 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 是 <a href="https://man.freebsd.org/cgi/man.cgi?query=etcupdate&amp;sektion=8&amp;format=html">etcupdate(8)</a> 的替代方法。使用 <code>-Ui</code> 选项， <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 会自动更新未被用户修改的文件，并安装尚未存在的新文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mergemaster -Ui</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果一个文件需要手动合并，交互式显示将允许用户选择保留文件的哪些部分。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 。</p>
</div>
<div class="paragraph">
<p>如果没有使用标准的 <code>/usr/src</code> 路径，必须向 <a href="https://man.freebsd.org/cgi/man.cgi?query=mergemaster&amp;sektion=8&amp;format=html">mergemaster(8)</a> 传递另一个参数：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mergemaster -Ui PATH_TO_SRC</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="updating-src-completing-check-old">26.6.6.3. 检查过时的文件和库<a class="anchor" href="#updating-src-completing-check-old"></a></h5>
<div class="paragraph">
<p>更新后可能会保留一些过时的文件或目录。这些文件可以位于以下位置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make check-old</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>已删除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make delete-old</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>还可能存在一些过时的库。可以使用以下方法检测到这些库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make check-old-libs</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>并且被删除了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make delete-old-libs</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当删除了这些旧库后，仍在使用这些旧库的程序将停止工作。这些程序必须在删除旧库后重新构建或替换。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当所有旧文件或目录都被确认为安全可删除时，可以通过在命令中设置 <code>BATCH_DELETE_OLD_FILES</code> 来避免按下 <kbd>y</kbd> 和 <kbd>Enter</kbd> 来删除每个文件。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># make BATCH_DELETE_OLD_FILES=yes delete-old-libs</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect4">
<h5 id="updating-src-completing-restart">26.6.6.4. 更新后重新启动<a class="anchor" href="#updating-src-completing-restart"></a></h5>
<div class="paragraph">
<p>更新完成后的最后一步是重新启动计算机，以使所有更改生效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># shutdown -r now</span></code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="small-lan">26.7. 多台机器的追踪<a class="anchor" href="#small-lan"></a></h3>
<div class="paragraph">
<p>当多台机器需要跟踪同一个源代码树时，让每台系统都下载源代码并重新构建会浪费磁盘空间、网络带宽和 CPU 周期。解决方案是让一台机器完成大部分工作，而其他机器通过 NFS 挂载这个工作。本节介绍了一种实现方法。有关使用 NFS 的更多信息，请参考 <a href="./#network-nfs">网络文件系统（ NFS ）</a> 。</p>
</div>
<div class="paragraph">
<p>首先，确定一组将运行相同二进制文件的机器，称为“构建集”。每台机器可以有自定义的内核，但将运行相同的用户空间二进制文件。从该集合中选择一台机器作为“构建机器”，用于构建世界和内核。理想情况下，这是一台速度快且具有足够空闲 CPU 来运行 <code>make buildworld</code> 和 <code>make buildkernel</code> 的机器。</p>
</div>
<div class="paragraph">
<p>选择一台机器作为“测试机器”，在将软件更新投入生产之前对其进行测试。这台机器必须能够承受较长时间的停机。它可以是构建机器，但不一定是。</p>
</div>
<div class="paragraph">
<p>此构建集中的所有机器都需要通过 NFS 从构建机器挂载 <span class="filename">/usr/obj</span> 和 <span class="filename">/usr/src</span> 。对于多个构建集， <span class="filename">/usr/src</span> 应该在一个构建机器上，并在其他机器上通过 NFS 挂载。</p>
</div>
<div class="paragraph">
<p>确保构建集中所有机器上的 <code>/etc/make.conf</code> 和 <code>/etc/src.conf</code> 与构建机器保持一致。这意味着构建机器必须构建基本系统的所有部分，以便构建集中的任何机器都可以安装。此外，每个构建机器应该使用 <code>/etc/make.conf</code> 中的 <code>KERNCONF</code> 设置其内核名称，并且构建机器应该在其 <code>KERNCONF</code> 中列出所有这些内核，将自己的内核列在第一位。构建机器必须在 <code>/usr/src/sys/arch/conf</code> 中拥有每个机器的内核配置文件。</p>
</div>
<div class="paragraph">
<p>在构建机上，按照 <a href="#makeworld">从源代码更新 FreeBSD</a> 中描述的方式构建内核和世界，但不要在构建机上安装任何东西。相反，将构建好的内核安装在测试机上。在测试机上，通过 NFS 挂载 <span class="filename">/usr/src</span> 和 <span class="filename">/usr/obj</span> 。然后，运行 <code>shutdown now</code> 进入单用户模式，以便安装新的内核和世界，并像往常一样运行 <code>mergemaster</code> 。完成后，重新启动以返回到正常的多用户操作。</p>
</div>
<div class="paragraph">
<p>在验证测试机上的一切正常工作后，使用相同的步骤在构建集中的每台其他机器上安装新软件。</p>
</div>
<div class="paragraph">
<p>相同的方法可以用于端口树。第一步是通过 NFS 将 <code>/usr/ports</code> 共享给构建集中的所有机器。要配置 <code>/etc/make.conf</code> 以共享 distfiles ，将 <code>DISTDIR</code> 设置为一个由 NFS 挂载映射到 <code>root</code> 用户的可写共享目录。如果要在本地构建端口，则每台机器应将 <code>WRKDIRPREFIX</code> 设置为本地构建目录。或者，如果构建系统要构建并分发软件包给构建集中的机器，则在构建系统上将 <code>PACKAGES</code> 设置为类似于 <code>DISTDIR</code> 的目录。</p>
</div>
</div>
<div class="sect2">
<h3 id="building-on-non-freebsd-hosts">26.8. 在非 FreeBSD 主机上构建<a class="anchor" href="#building-on-non-freebsd-hosts"></a></h3>
<div class="paragraph">
<p>从历史上看，构建 FreeBSD 需要一个 FreeBSD 主机。如今， FreeBSD 可以在 Linux 发行版和 macOS 上构建。</p>
</div>
<div class="paragraph">
<p>在非 FreeBSD 主机上构建 FreeBSD 的推荐方法是使用 <code>tools/build/make.py</code> 脚本。该脚本作为 <code>bmake</code> 的包装器， <code>bmake</code> 是 FreeBSD 使用的 make 实现。它确保了必要的工具，包括实际的 FreeBSD 的 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a></code> ，被引导并且构建环境被正确配置。特别是，它设置了外部工具链变量，如 <code>XCC</code> 、 <code>XLD</code> 等。此外，该脚本可以将任何额外的命令参数，如 <code>-j 4</code> 用于并行构建或特定的 make 目标，传递给 <code>bmake</code> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>最近版本的 <code>bmake</code> 也可以替代 <code>tools/build/make.py</code> 脚本。但在这种情况下，需要手动设置所需的环境变量（最简单的方法是运行 <code>tools/build/make.py --debug</code> 来获取它们的列表）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>否则，构建 FreeBSD 所需的先决条件列表相当简短。实际上，它只需要安装几个依赖项。</p>
</div>
<div class="paragraph">
<p>在 macOS 上，唯一的依赖是 LLVM 。必要的依赖项可以通过包管理器（例如， <a href="https://brew.sh/">Homebrew</a> ）进行安装。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">brew install llvm</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 Linux 发行版上，安装 Clang 10.0 或更新版本，以及 libarchive 和 libbz2 的头文件（通常打包为 libarchive-dev 和 libbz2-dev ）。</p>
</div>
<div class="paragraph">
<p>一旦安装了依赖项，主机就应该能够构建 FreeBSD 。</p>
</div>
<div class="paragraph">
<p>例如，下面的 <code>tools/build/make.py</code> 命令构建整个项目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="nv">MAKEOBJDIRPREFIX</span><span class="o">=</span>/tmp/obj tools/build/make.py -j 8 <span class="nv">TARGET</span><span class="o">=</span>arm64 <span class="nv">TARGET_ARCH</span><span class="o">=</span>aarch64 buildworld</code></pre>
</div>
</div>
<div class="paragraph">
<p>它在 8 个 CPU 上为目标 <code>aarch64:arm64</code> 构建世界，并使用 <code>/tmp/obj</code> 作为对象文件。请注意，在非 FreeBSD 主机上构建时，变量 <code>MAKEOBJDIRPREFIX</code> 、 <code>TARGET</code> 和 <code>TARGET_ARCH</code> 是必需的。此外，请确保创建由 <code>MAKEOBJDIRPREFIX</code> 环境变量指向的对象目录。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=arch&amp;sektion=7&amp;format=html">arch(7)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=build&amp;sektion=7&amp;format=html">build(7)</a> 以获取更多详细信息。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="dtrace">Chapter 27. DTrace 是一种动态跟踪工具，用于在操作系统和应用程序中收集和分析性能数据。它最初是由 Sun Microsystems 开发的，现在已经成为许多操作系统的标准特性，包括 Solaris 、 FreeBSD 和 Mac OS X 。 DTrace 可以帮助开发人员和系统管理员识别和解决性能问题，优化代码和系统配置，并提供深入的可视化和分析功能。它使用一种称为 D 语言的特殊语法来编写跟踪脚本，并提供了丰富的系统调用和内核事件的跟踪功能。 DTrace 是一个强大而灵活的工具，被广泛用于调试和优化各种类型的软件和系统。<a class="anchor" href="#dtrace"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="dtrace-synopsis">27.1. 简介<a class="anchor" href="#dtrace-synopsis"></a></h3>
<div class="paragraph">
<p>DTrace ，也被称为动态跟踪，是由 Sun™ 开发的一种工具，用于定位生产和预生产系统中的性能瓶颈。除了诊断性能问题外， DTrace 还可以用于帮助调查和调试 FreeBSD 内核和用户程序中的意外行为。</p>
</div>
<div class="paragraph">
<p>DTrace 是一个出色的性能分析工具，具有令人印象深刻的一系列功能，用于诊断系统问题。它还可以用于运行预先编写的脚本，以利用其功能。用户可以使用 DTrace D 语言编写自己的实用工具，根据特定需求自定义性能分析。</p>
</div>
<div class="paragraph">
<p>FreeBSD 实现提供了对内核 DTrace 的完全支持，并对用户空间 DTrace 提供了实验性支持。用户空间 DTrace 允许用户使用 <code>pid</code> 提供程序对用户空间程序进行函数边界跟踪，并在用户空间程序中插入静态探针以供后续跟踪。一些端口，如 <a class="package" href="https://cgit.freebsd.org/ports/tree/databases/postgresql12-server/">databases/postgresql12-server</a> 和 <a class="package" href="https://cgit.freebsd.org/ports/tree/lang/php74/">lang/php74</a> ，具有启用静态探针的 DTrace 选项。</p>
</div>
<div class="paragraph">
<p>DTrace 的官方指南由 Illumos 项目维护，网址为 <a href="http://dtrace.org/guide">DTrace 指南</a> 。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>DTrace 是一种强大的动态跟踪工具，用于在操作系统和应用程序中收集和分析数据。它提供了许多功能，包括实时监测、故障排除、性能分析和系统优化等。 DTrace 可以帮助开发人员和系统管理员深入了解系统的运行情况，识别性能瓶颈和问题，并提供详细的数据和统计信息以支持决策和优化。它还具有灵活的脚本语言和丰富的工具集，使用户能够自定义和扩展跟踪功能，以满足各种需求。总之， DTrace 是一个强大而全面的工具，可以提供深入的系统级分析和调试能力。</p>
</li>
<li>
<p>Solaris™ DTrace 实现与 FreeBSD 提供的实现之间的区别。</p>
</li>
<li>
<p>如何在 FreeBSD 上启用和使用 DTrace 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 UNIX® 和 FreeBSD 基础知识（参见 :basics[basics , FreeBSD Basics] ）。</p>
</li>
<li>
<p>对 FreeBSD 的安全性有一定的了解（参考： security[security , Security] ）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="dtrace-implementation">27.2. 实现差异<a class="anchor" href="#dtrace-implementation"></a></h3>
<div class="paragraph">
<p>尽管 FreeBSD 中的 DTrace 与 Solaris™ 中的 DTrace 相似，但仍存在一些差异。主要的差异在于，在 FreeBSD 中， DTrace 是作为一组内核模块实现的，只有在加载这些模块之后才能使用 DTrace 。要加载所有必要的模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload dtraceall</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从 FreeBSD 10.0-RELEASE 开始，当运行 <code>dtrace</code> 时，模块会自动加载。</p>
</div>
<div class="paragraph">
<p>FreeBSD 使用 <code>DDB_CTF</code> 内核选项来启用对从内核模块和内核本身加载 <code>CTF</code> 数据的支持。 <code>CTF</code> 是 Solaris™ Compact C Type Format ，它封装了一种类似于 <code>DWARF</code> 和古老的 stabs 的调试信息的简化形式。 <code>CTF</code> 数据是由 <code>ctfconvert</code> 和 <code>ctfmerge</code> 构建工具添加到二进制文件中的。 <code>ctfconvert</code> 实用程序解析由编译器创建的 <code>DWARF<code>ELF</code> 调试部分，而 <code>ctfmerge</code> 将对象中的 <code>CTF</code>ELF</code> 部分合并到可执行文件或共享库中。</p>
</div>
<div class="paragraph">
<p>FreeBSD 和 Solaris™ 存在一些不同的提供商。其中最显著的是 <code>dtmalloc</code> 提供商，它允许在 FreeBSD 内核中按类型跟踪 <code>malloc()</code> 。 Solaris™ 中的一些提供商，如 <code>cpc</code> 和 <code>mib</code> ，在 FreeBSD 中不存在。这些可能会出现在未来的 FreeBSD 版本中。此外，两个操作系统中都可用的一些提供商不兼容，因为它们的探测器具有不同的参数类型。因此，在 Solaris™ 上编写的 <code>D</code> 脚本可能无法在 FreeBSD 上不经修改地工作，反之亦然。</p>
</div>
<div class="paragraph">
<p>由于安全差异，只有 <code>root</code> 用户可以在 FreeBSD 上使用 DTrace 。 Solaris™ 在安全方面有一些低级别的安全检查，在 FreeBSD 中尚不存在。因此， <code>.filename</code><mark>/dev/dtrace/dtrace</mark> 严格限制为 <code>root</code> 用户。</p>
</div>
<div class="paragraph">
<p>DTrace 属于 Common Development and Distribution License （ CDDL ）许可证。要在 FreeBSD 上查看此许可证，请参阅 /usr/src/cddl/contrib/opensolaris/OPENSOLARIS.LICENSE 文件，或在线查看 <a href="http://opensource.org/licenses/CDDL-1.0">http://opensource.org/licenses/CDDL-1.0</a> 。虽然支持 DTrace 的 FreeBSD 内核是 BSD 许可证，但在以二进制形式分发模块或加载二进制文件时，使用 CDDL 许可证。</p>
</div>
</div>
<div class="sect2">
<h3 id="dtrace-enable">27.3. 启用 DTrace 支持<a class="anchor" href="#dtrace-enable"></a></h3>
<div class="paragraph">
<p>在 FreeBSD 9.2 和 10.0 中， DTrace 支持已经内置在 <span class="filename">GENERIC</span> 内核中。使用早期版本的 FreeBSD 或者更喜欢静态编译 DTrace 支持的用户应该在自定义内核配置文件中添加以下行，并按照 <a href="./#kernelconfig">Configuring the FreeBSD Kernel</a> 中的说明重新编译内核。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options         KDTRACE_HOOKS
options         DDB_CTF
makeoptions	DEBUG=-g
makeoptions	WITH_CTF=1</pre>
</div>
</div>
<div class="paragraph">
<p>使用 AMD64 架构的用户还应添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options         KDTRACE_FRAME</pre>
</div>
</div>
<div class="paragraph">
<p>此选项提供对 <code>FBT</code> 的支持。虽然在没有此选项的情况下 DTrace 也可以工作，但对于函数边界跟踪的支持将受到限制。</p>
</div>
<div class="paragraph">
<p>一旦 FreeBSD 系统重启到新内核，或者使用 <code>kldload dtraceall</code> 加载了 DTrace 内核模块，系统将需要支持 Korn shell ，因为 DTrace Toolkit 中有几个工具是用 <code>ksh</code> 编写的。确保安装了 <a class="package" href="https://cgit.freebsd.org/ports/tree/shells/ksh93/">shells/ksh93</a> 软件包或端口。也可以在 <a class="package" href="https://cgit.freebsd.org/ports/tree/shells/pdksh/">shells/pdksh</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/shells/mksh/">shells/mksh</a> 下运行这些工具。</p>
</div>
<div class="paragraph">
<p>最后，安装当前的 DTrace Toolkit ，这是一个收集系统信息的现成脚本集合。其中包括检查打开文件、内存、 <code>CPU</code> 使用情况等脚本。 FreeBSD 10 会将其中一些脚本安装在 <span class="filename">/usr/share/dtrace</span> 目录下。对于其他版本的 FreeBSD ，或者要安装完整的 DTrace Toolkit ，可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/dtrace-toolkit/">sysutils/dtrace-toolkit</a> 包或端口进行安装。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <span class="filename">/usr/share/dtrace</span> 中找到的脚本已经专门移植到了 FreeBSD 。并非所有在 DTrace Toolkit 中找到的脚本都可以直接在 FreeBSD 上运行，有些脚本可能需要一些努力才能在 FreeBSD 上运行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>DTrace 工具包中包含了许多使用 DTrace 特殊语言编写的脚本。这种语言被称为 D 语言，它与 C ++非常相似。本文档不会深入讨论该语言的细节，但在 <a href="http://www.dtrace.org/guide">Illumos 动态跟踪指南</a> 中有详细介绍。</p>
</div>
</div>
<div class="sect2">
<h3 id="dtrace-using">27.4. 使用 DTrace<a class="anchor" href="#dtrace-using"></a></h3>
<div class="paragraph">
<p>DTrace 脚本由一个或多个探针（或称为仪器点）的列表组成，每个探针都与一个动作相关联。当探针的条件满足时，执行相应的动作。例如，当文件被打开、进程被启动或者代码行被执行时，可能会触发一个动作。动作可以是记录一些信息或修改上下文变量。读取和写入上下文变量允许探针共享信息并协同分析不同事件之间的关联性。</p>
</div>
<div class="paragraph">
<p>要查看所有探针，管理员可以执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dtrace -l | more</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>每个探针都有一个 <code>ID</code> ，一个 <code>PROVIDER</code> （ dtrace 或 fbt ），一个 <code>MODULE</code> 和一个 <code>FUNCTION NAME</code> 。有关此命令的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=dtrace&amp;sektion=1&amp;format=html">dtrace(1)</a> 。</p>
</div>
<div class="paragraph">
<p>本节中的示例提供了如何使用 DTrace Toolkit 中两个完全支持的脚本的概述： <span class="filename">hotkernel</span> 和 <span class="filename">procsystime</span> 脚本。</p>
</div>
<div class="paragraph">
<p><span class="filename">hotkernel</span> 脚本旨在识别哪个函数使用了最多的内核时间。它将产生类似以下的输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/local/share/dtrace-toolkit</span>
<span class="c"># ./hotkernel</span>
Sampling... Hit Ctrl-C to end.</code></pre>
</div>
</div>
<div class="paragraph">
<p>按照指示，使用 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>C</kbd></span> 键组合来停止进程。在终止后，脚本将显示一个内核函数列表和时间信息，按时间递增的顺序排序输出：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">kernel<span class="sb">`</span>_thread_lock_flags                                   2   0.0%
0xc1097063                                                  2   0.0%
kernel<span class="sb">`</span>sched_userret                                        2   0.0%
kernel<span class="sb">`</span>kern_select                                          2   0.0%
kernel<span class="sb">`</span>generic_copyin                                       3   0.0%
kernel<span class="sb">`</span>_mtx_assert                                          3   0.0%
kernel<span class="sb">`</span>vm_fault                                             3   0.0%
kernel<span class="sb">`</span>sopoll_generic                                       3   0.0%
kernel<span class="sb">`</span>fixup_filename                                       4   0.0%
kernel<span class="sb">`</span>_isitmyx                                             4   0.0%
kernel<span class="sb">`</span>find_instance                                        4   0.0%
kernel<span class="sb">`</span>_mtx_unlock_flags                                    5   0.0%
kernel<span class="sb">`</span>syscall                                              5   0.0%
kernel<span class="sb">`</span>DELAY                                                5   0.0%
0xc108a253                                                  6   0.0%
kernel<span class="sb">`</span>witness_lock                                         7   0.0%
kernel<span class="sb">`</span>read_aux_data_no_wait                                7   0.0%
kernel<span class="sb">`</span>Xint0x80_syscall                                     7   0.0%
kernel<span class="sb">`</span>witness_checkorder                                   7   0.0%
kernel<span class="sb">`</span>sse2_pagezero                                        8   0.0%
kernel<span class="sb">`</span>strncmp                                              9   0.0%
kernel<span class="sb">`</span>spinlock_exit                                       10   0.0%
kernel<span class="sb">`</span>_mtx_lock_flags                                     11   0.0%
kernel<span class="sb">`</span>witness_unlock                                      15   0.0%
kernel<span class="sb">`</span>sched_idletd                                       137   0.3%
0xc10981a5                                              42139  99.3%</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个脚本也可以用于内核模块。要使用这个功能，请使用 <code>-m</code> 选项运行脚本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ./hotkernel -m</span>
Sampling... Hit Ctrl-C to end.
^C
MODULE                                                  COUNT   PCNT
0xc107882e                                                  1   0.0%
0xc10e6aa4                                                  1   0.0%
0xc1076983                                                  1   0.0%
0xc109708a                                                  1   0.0%
0xc1075a5d                                                  1   0.0%
0xc1077325                                                  1   0.0%
0xc108a245                                                  1   0.0%
0xc107730d                                                  1   0.0%
0xc1097063                                                  2   0.0%
0xc108a253                                                 73   0.0%
kernel                                                    874   0.4%
0xc10981a5                                             213781  99.6%</code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">procsystime</span> 脚本用于捕获并打印给定进程 <code>ID</code> (<code>PID</code>) 或进程名称的系统调用时间使用情况。在下面的示例中，一个新的 <span class="filename">/bin/csh</span> 实例被创建。然后，执行了 <span class="filename">procsystime</span> 并保持等待状态，同时在另一个 <code>csh</code> 实例中输入了一些命令。这是这个测试的结果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ./procsystime -n csh</span>
Tracing... Hit Ctrl-C to end...
^C

Elapsed Times <span class="k">for </span>processes csh,

         SYSCALL          TIME <span class="o">(</span>ns<span class="o">)</span>
          getpid               6131
       sigreturn               8121
           close              19127
           fcntl              19959
             dup              26955
         setpgid              28070
            stat              31899
       setitimer              40938
           wait4              62717
       sigaction              67372
     sigprocmask             119091
    gettimeofday             183710
           write             263242
          execve             492547
           ioctl             770073
           vfork            3258923
      sigsuspend            6985124
            <span class="nb">read         </span>3988049784</code></pre>
</div>
</div>
<div class="paragraph">
<p>如图所示， <code>read()</code> 系统调用使用的时间最长，以纳秒为单位，而 <code>getpid()</code> 系统调用使用的时间最短。</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="usb-device-mode">Chapter 28. USB 设备模式 /USB OTG<a class="anchor" href="#usb-device-mode"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="usb-device-mode-synopsis">28.1. 简介<a class="anchor" href="#usb-device-mode-synopsis"></a></h3>
<div class="paragraph">
<p>本章介绍了在 FreeBSD 中使用 USB 设备模式和 USB On The Go （ USB OTG ）。这包括虚拟串行控制台、虚拟网络接口和虚拟 USB 驱动器的使用。</p>
</div>
<div class="paragraph">
<p>当在支持 USB 设备模式或 USB OTG 的硬件上运行时，例如许多嵌入式板上内置的硬件， FreeBSD USB 堆栈可以运行在“设备模式”下。设备模式使得计算机能够以不同种类的 USB 设备类别呈现自身，包括串口、网络适配器、大容量存储设备，或者它们的组合。像笔记本电脑或台式电脑这样的 USB 主机可以像访问物理 USB 设备一样访问它们。设备模式有时也被称为“ USB 小工具模式”。</p>
</div>
<div class="paragraph">
<p>硬件可以通过两种基本方式提供设备模式功能：一种是使用单独的“客户端端口”，该端口仅支持设备模式；另一种是使用 USB OTG （ On-The-Go ）端口，该端口可以同时提供设备模式和主机模式。对于 USB OTG 端口， USB 堆栈会根据连接到端口的设备自动切换主机端和设备端。将 USB 设备（如存储设备）连接到端口会导致 FreeBSD 切换到主机模式。将 USB 主机（如计算机）连接到端口会导致 FreeBSD 切换到设备模式。而单用途的“客户端端口”始终以设备模式工作。</p>
</div>
<div class="paragraph">
<p>FreeBSD 向 USB 主机呈现的内容取决于 <code>hw.usb.template</code> sysctl 。一些模板提供单个设备，例如串行终端；其他模板提供多个设备，可以同时使用。一个例子是模板 10 ，它提供了一个大容量存储设备、一个串行控制台和一个网络接口。请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> 以获取可用值的列表。</p>
</div>
<div class="paragraph">
<p>请注意，在某些情况下，根据硬件和主机操作系统的不同，为了使主机注意到配置更改，必须要么物理断开并重新连接，要么以特定于系统的方式强制重新扫描 USB 总线。当主机上运行 FreeBSD 时，可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=usbconfig&amp;sektion=8&amp;format=html">usbconfig(8)</a> <code>reset</code> 命令。如果 USB 主机已经连接到 USBOTG 插座，则还必须在加载 <span class="filename">usb_template.ko</span> 之后执行此操作。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 FreeBSD 上如何设置 USB 设备模式功能。</p>
</li>
<li>
<p>如何在 FreeBSD 上配置虚拟串口。</p>
</li>
<li>
<p>如何从不同的操作系统连接到虚拟串口。</p>
</li>
<li>
<p>如何配置 FreeBSD 以提供虚拟 USB 网络接口。</p>
</li>
<li>
<p>如何配置 FreeBSD 以提供虚拟 USB 存储设备。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="usb-device-mode-terminals">28.2. USB 虚拟串口<a class="anchor" href="#usb-device-mode-terminals"></a></h3>
<div class="sect3">
<h4 id="_配置_usb_设备模式串口">28.2.1. 配置 USB 设备模式串口<a class="anchor" href="#_配置_usb_设备模式串口"></a></h4>
<div class="paragraph">
<p>虚拟串口支持由模板 3 、 8 和 10 提供。请注意，模板 3 可以在 Microsoft Windows 10 上使用，无需特殊驱动程序和 INF 文件。其他主机操作系统可以与这三个模板一起使用。必须加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=umodem&amp;sektion=4&amp;format=html">umodem(4)</a> 内核模块。</p>
</div>
<div class="paragraph">
<p>要启用 USB 设备模式的串口，请将以下行添加到 [/etc/ttys] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ttyU0	&#34;/usr/libexec/getty 3wire&#34;	vt100	onifconsole secure
ttyU1	&#34;/usr/libexec/getty 3wire&#34;	vt100	onifconsole secure</pre>
</div>
</div>
<div class="paragraph">
<p>然后将以下行添加到 [/etc/devd.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>notify 100 {
	match &#34;system&#34;		&#34;DEVFS&#34;;
	match &#34;subsystem&#34;	&#34;CDEV&#34;;
	match &#34;type&#34;		&#34;CREATE&#34;;
	match &#34;cdev&#34;		&#34;ttyU[0-9]+&#34;;
	action &#34;/sbin/init q&#34;;
};</pre>
</div>
</div>
<div class="paragraph">
<p>如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 已经在运行，请重新加载配置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service devd restart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>确保所需的模块已加载并在启动时设置正确的模板，通过将这些行添加到 [/boot/loader.conf]# 文件中，如果该文件不存在，则创建它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="nv">umodem_load</span><span class="o">=</span><span class="s2">&#34;YES&#34;</span>
hw.usb.template<span class="o">=</span>3</code></pre>
</div>
</div>
<div class="paragraph">
<p>要在不重新启动的情况下加载模块并设置模板，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload umodem</span>
<span class="c"># sysctl hw.usb.template=3</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_从_freebsd_连接到_usb_设备模式串口">28.2.2. 从 FreeBSD 连接到 USB 设备模式串口<a class="anchor" href="#_从_freebsd_连接到_usb_设备模式串口"></a></h4>
<div class="paragraph">
<p>要连接到配置为提供 USB 设备模式串行端口的板子，将 USB 主机（例如笔记本电脑）连接到板子的 USB OTG 或 USB 客户端端口。在主机上使用 <code>pstat -t</code> 命令列出终端线路。在列表的末尾附近，您应该会看到一个 USB 串行端口，例如&#34;ttyU0&#34;。要打开连接，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cu -l /dev/ttyU0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>按下 <kbd>Enter</kbd> 键几次后，您将看到一个登录提示符。</p>
</div>
</div>
<div class="sect3">
<h4 id="_在_macos_上连接_usb_设备模式串口">28.2.3. 在 macOS 上连接 USB 设备模式串口<a class="anchor" href="#_在_macos_上连接_usb_设备模式串口"></a></h4>
<div class="paragraph">
<p>要连接到配置为提供 USB 设备模式串行端口的板子，将 USB 主机（例如笔记本电脑）连接到板子的 USB OTG 或 USB 客户端端口。要打开连接，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cu -l /dev/cu.usbmodemFreeBSD1</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_在_linux_上连接_usb_设备模式串口">28.2.4. 在 Linux 上连接 USB 设备模式串口<a class="anchor" href="#_在_linux_上连接_usb_设备模式串口"></a></h4>
<div class="paragraph">
<p>要连接到配置为提供 USB 设备模式串行端口的板子，将 USB 主机（例如笔记本电脑）连接到板子的 USB OTG 或 USB 客户端端口。要打开连接，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># minicom -D /dev/ttyACM0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_在_microsoft_windows_10_上连接_usb_设备模式串口">28.2.5. 在 Microsoft Windows 10 上连接 USB 设备模式串口<a class="anchor" href="#_在_microsoft_windows_10_上连接_usb_设备模式串口"></a></h4>
<div class="paragraph">
<p>要连接到配置为提供 USB 设备模式串口的板子，需要将 USB 主机（例如笔记本电脑）连接到板子的 USB OTG 或 USB 客户端端口。要打开连接，您需要一个串口终端程序，例如 PuTTY 。要检查 Windows 使用的 COM 端口名称，请运行设备管理器，展开“端口（ COM 和 LPT ）”。您将看到一个类似于“ USB 串行设备（ COM4 ）”的名称。运行您选择的串口终端程序，例如 PuTTY 。在 PuTTY 对话框中将“连接类型”设置为“串行”，在“串行线路”对话框中输入从设备管理器获取的 COMx ，并点击打开。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="usb-device-mode-network">28.3. USB 设备模式网络接口<a class="anchor" href="#usb-device-mode-network"></a></h3>
<div class="paragraph">
<p>虚拟网络接口的支持由模板 1 、 8 和 10 提供。请注意，它们都不适用于 Microsoft Windows 。其他主机操作系统都适用于这三个模板。必须加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=if_cdce&amp;sektion=4&amp;format=html">if_cdce(4)</a> 内核模块。</p>
</div>
<div class="paragraph">
<p>确保所需的模块已加载并在启动时设置正确的模板，通过将这些行添加到 [/boot/loader.conf]# 文件中，如果该文件不存在，则创建它：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>if_cdce_load=&#34;YES&#34;
hw.usb.template=1</pre>
</div>
</div>
<div class="paragraph">
<p>要在不重新启动的情况下加载模块并设置模板，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload if_cdce</span>
<span class="c"># sysctl hw.usb.template=1</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="usb-device-mode-storage">28.4. USB 虚拟存储设备<a class="anchor" href="#usb-device-mode-storage"></a></h3>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> 驱动程序是一个 USB 设备模式驱动程序，首次在 FreeBSD 12.0 中可用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>模板 0 和 10 提供了大容量存储目标。必须加载 <a href="https://man.freebsd.org/cgi/man.cgi?query=usb_template&amp;sektion=4&amp;format=html">usb_template(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> 内核模块。 <a href="https://man.freebsd.org/cgi/man.cgi?query=cfumass&amp;sektion=4&amp;format=html">cfumass(4)</a> 与 CTL 子系统进行接口交互，该子系统也用于 iSCSI 或光纤通道目标。在主机端， USB 大容量存储发起器只能访问一个逻辑单元（ LUN ），即 LUN 0 。</p>
</div>
<div class="sect3">
<h4 id="_使用_cfumass_启动脚本配置_usb_大容量存储目标">28.4.1. 使用 cfumass 启动脚本配置 USB 大容量存储目标<a class="anchor" href="#_使用_cfumass_启动脚本配置_usb_大容量存储目标"></a></h4>
<div class="paragraph">
<p>设置只读 USB 存储目标的最简单方法是使用 <span class="filename">cfumass</span> rc 脚本。要以这种方式配置它，将要呈现给 USB 主机机器的文件复制到 <code>/var/cfumass</code> 目录，并将以下行添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cfumass_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要在不重新启动的情况下配置目标，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service cfumass start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与串行和网络功能不同，模板不应在 <span class="filename">/boot/loader.conf</span> 中设置为 0 或 10 。这是因为在设置模板之前必须设置 LUN 。当启动时， cfumass 启动脚本会自动设置正确的模板编号。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用其他方法配置_usb_大容量存储设备">28.4.2. 使用其他方法配置 USB 大容量存储设备<a class="anchor" href="#_使用其他方法配置_usb_大容量存储设备"></a></h4>
<div class="paragraph">
<p>本章的其余部分提供了在不使用 cfumass rc 文件的情况下设置目标的详细描述。如果想要提供可写的逻辑单元（ LUN ），这是必要的。</p>
</div>
<div class="paragraph">
<p>USB Mass Storage 不需要运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 守护进程，尽管如果需要可以使用它。这与 iSCSI 不同。因此，有两种配置目标的方式： <a href="https://man.freebsd.org/cgi/man.cgi?query=ctladm&amp;sektion=8&amp;format=html">ctladm(8)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 。两者都需要加载 <span class="filename">cfumass.ko</span> 内核模块。可以手动加载该模块：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload cfumass</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <span class="filename">cfumass.ko</span> 没有被编译进内核中，可以在 <span class="filename">/boot/loader.conf</span> 中设置在启动时加载该模块：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cfumass_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>可以在没有 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 守护进程的情况下创建一个 LUN 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ctladm create -b block -o file=/data/target0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将把图像文件 <span class="filename">/data/target0</span> 的内容作为 LUN 提供给 USB 主机。在执行命令之前，文件必须存在。要在系统启动时配置 LUN ，请将该命令添加到 <span class="filename">/etc/rc.local</span> 中。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 也可以用来管理逻辑单元（ LUNs ）。创建 <span class="filename">/etc/ctl.conf</span> 文件，添加一行到 <span class="filename">/etc/rc.conf</span> 文件中，以确保在启动时自动启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> ，然后启动守护进程。</p>
</div>
<div class="paragraph">
<p>这是一个简单的 <span class="filename">/etc/ctl.conf</span> 配置文件的示例。有关选项的更完整描述，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>target naa.50015178f369f092 {
	lun 0 {
		path /data/target0
		size 4G
	}
}</pre>
</div>
</div>
<div class="paragraph">
<p>该示例创建了一个具有单个 LUN 的单个目标。 <code>naa.50015178f369f092</code> 是由 32 个随机十六进制数字组成的设备标识符。 <code>path</code> 行定义了指向支持 LUN 的文件或 zvol 的完整路径。在启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 之前，该文件必须存在。第二行是可选的，用于指定 LUN 的大小。</p>
</div>
<div class="paragraph">
<p>为了确保 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 守护进程在启动时自动启动，请将以下行添加到 .filename#/etc/rc.conf#:</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ctld_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> ，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ctld start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 守护进程时，它会读取 .filename#/etc/ctl.conf# 文件。如果在守护进程启动后编辑了此文件，则重新加载更改以立即生效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ctld reload</span></code></pre>
</div>
</div>
</div>
</div>
</div>
</div>
<h1 id="network-communication" class="sect0">Part IV: 网络通信<a class="anchor" href="#network-communication"></a></h1>
<div class="openblock partintro">
<div class="content">
<div class="paragraph">
<p>FreeBSD 是最广泛部署的高性能网络服务器操作系统之一。本部分的章节内容包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>串行通信</p>
</li>
<li>
<p>PPP 和以太网上的 PPP</p>
</li>
<li>
<p>电子邮件</p>
</li>
<li>
<p>运行网络服务器</p>
</li>
<li>
<p>防火墙</p>
</li>
<li>
<p>其他高级网络主题</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些章节的设计是在需要信息时阅读。它们不需要按照特定的顺序阅读，也不需要在使用 FreeBSD 在网络环境中之前阅读所有章节。</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="serialcomms">Chapter 29. 串行通信<a class="anchor" href="#serialcomms"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="serial-synopsis">29.1. 简介<a class="anchor" href="#serial-synopsis"></a></h3>
<div class="paragraph">
<p>UNIX® 一直以来都支持串行通信，因为最早的 UNIX® 机器依赖串行线路进行用户输入和输出。从平均终端只包含一个每秒 10 个字符的串行打印机和一个键盘的时代以来，情况发生了很大变化。本章介绍了在 FreeBSD 上使用串行通信的一些方法。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何将终端连接到 FreeBSD 系统。</p>
</li>
<li>
<p>如何使用调制解调器拨打远程主机。</p>
</li>
<li>
<p>如何允许远程用户通过调制解调器登录到 FreeBSD 系统。</p>
</li>
<li>
<p>如何从串行控制台启动 FreeBSD 系统。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，你应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解如何交叉引用： kernelconfig[kernelconfig ，配置和安装自定义内核] 。</p>
</li>
<li>
<p>了解 <a href="./#基础知识， FreeBSD 的权限和进程"></a> 。</p>
</li>
<li>
<p>可以访问与 FreeBSD 一起使用的串行硬件的技术手册。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="serial">29.2. 串行术语和硬件<a class="anchor" href="#serial"></a></h3>
<div class="paragraph">
<p>以下术语常用于串行通信：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">bps 是&#34;每秒位数&#34;的缩写，是衡量数据传输速度的单位。它表示每秒传输的位数或比特数。</dt>
<dd>
<p>每秒比特数（ bps ）是数据传输的速率。</p>
</dd>
<dt class="hdlist1">DTE 是数据终端设备（ Data Terminal Equipment ）的缩写，指的是计算机系统中与用户进行交互的设备，如计算机终端、打印机、键盘等。</dt>
<dd>
<p>数据终端设备（ DTE ）是串行通信中的两个端点之一。一个例子就是计算机。</p>
</dd>
<dt class="hdlist1">DCE 是分布式计算环境（ Distributed Computing Environment ）的缩写，它是一种用于构建分布式计算系统的软件架构。 DCE 提供了一组标准的接口和协议，使得不同的计算机和操作系统能够互相通信和协同工作。 DCE 可以实现分布式计算资源的共享和管理，提高计算效率和可靠性。 DCE 还提供了安全认证和访问控制机制，保护分布式系统的安全性和隐私。 DCE 广泛应用于企业级计算环境中，例如大型网络和云计算平台。</dt>
<dd>
<p>数据通信设备（ DCE ）是串行通信中的另一端点。通常情况下，它是一个调制解调器或串行终端。</p>
</dd>
<dt class="hdlist1">RS-232 是一种常见的串行通信接口标准，用于在计算机和外部设备之间传输数据。它定义了数据传输的电气特性、信号线的功能和连接方式。 RS-232 接口通常用于连接调制解调器、打印机、串行鼠标和其他外部设备。它是一种简单而可靠的通信方式，但由于其传输速率较低和信号距离限制，现在已经被更先进的接口标准所取代。</dt>
<dd>
<p>最初定义硬件串行通信的标准。后来更名为 TIA-232 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在涉及通信数据速率时，本节不使用术语“波特（ baud ）”。波特是指在一段时间内进行的电气状态转换的数量，而 bps 是正确的术语。</p>
</div>
<div class="paragraph">
<p>要将串行终端连接到 FreeBSD 系统，需要计算机上的串行端口和连接到串行设备的适当电缆。已经熟悉串行硬件和电缆的用户可以安全地跳过本节。</p>
</div>
<div class="sect3">
<h4 id="term-cables-null">29.2.1. 串行电缆和端口<a class="anchor" href="#term-cables-null"></a></h4>
<div class="paragraph">
<p>有几种不同类型的串行电缆。其中最常见的两种类型是空模拟电缆和标准 RS-232 电缆。硬件的文档应该描述所需的电缆类型。</p>
</div>
<div class="paragraph">
<p>这两种类型的电缆在连接线缆到连接器的方式上有所不同。每根线代表一个信号，定义的信号总结在 <a href="#serialcomms-signal-names">RS-232C 信号名称</a> 中。标准的串行电缆直接传递所有的 RS-232C 信号。例如，电缆一端的“传输数据”引脚连接到另一端的“传输数据”引脚。这种类型的电缆用于将调制解调器连接到 FreeBSD 系统，并且也适用于某些终端。</p>
</div>
<div class="paragraph">
<p>空模拟电缆将一个端口上的“传输数据”引脚与另一个端口上的“接收数据”引脚进行切换。连接器可以是 DB-25 或 DB-9 。</p>
</div>
<div class="paragraph">
<p>可以使用在 <a href="#nullmodem-db25">DB-25 到 DB-25 空调制模电缆</a> 、 <a href="#nullmodem-db9">DB-9 到 DB-9 的空模线缆</a> 和 <a href="#nullmodem-db9-25">DB-9 到 DB-25 空模拟电缆</a> 中总结的引脚连接来构建一个空调制电缆。虽然标准要求使用直通的引脚 1 到引脚 1 的“保护地”线，但通常会省略。一些终端只使用引脚 2 、 3 和 7 ，而其他终端则需要不同的配置。如果有疑问，请参考硬件的文档。</p>
</div>
<table id="serialcomms-signal-names" class="tableblock frame-none grid-all stretch">
<caption class="title">表 37. RS-232C 信号名称</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">首字母缩略词</th>
<th class="tableblock halign-left valign-top">名称</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">研发部门</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">接收到的数据</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">传输的数据</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据终端就绪</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。它是一种无线通信技术，通过动态地分配可用的频谱资源，以提高频谱利用效率和网络性能。 DSR 可以根据实时需求和环境条件，自动调整频谱资源的分配，以满足不同用户和应用的需求。这种技术在无线通信领域具有重要的应用价值，可以有效地解决频谱资源稀缺和频谱管理的问题。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据集准备完毕</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCD 是指设计类图（ Design Class Diagram ），它是一种用于描述软件系统中类和类之间关系的图形表示方法。在软件设计过程中， DCD 被广泛应用于分析和设计阶段，用于展示系统的结构和组成部分之间的关系。通过 DCD ，开发人员可以更好地理解系统的架构和设计，并在开发过程中进行有效的沟通和协作。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">数据载波检测</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新加坡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">信号地线</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">实时战略游戏（ RTS ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">请求发送</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于 Android 操作系统的一种测试工具，用于验证设备是否符合 Android 兼容性标准。 CTS 包含一系列的测试用例，用于检测设备的功能和性能是否符合 Android 的要求。通过运行 CTS ，开发者可以确保他们的应用程序在不同的 Android 设备上能够正常运行。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">发送准备</p></td>
</tr>
</tbody>
</table>
<table id="nullmodem-db25" class="tableblock frame-none grid-all stretch">
<caption class="title">表 38. DB-25 到 DB-25 空调制模电缆</caption>
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">信号</th>
<th class="tableblock halign-left valign-top">引脚号码</th>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">引脚号码</th>
<th class="tableblock halign-left valign-top">信号</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新加坡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">新加坡</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">研发部门</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">研发部门</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">实时战略游戏（ RTS ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于 Android 操作系统的一种测试工具，用于验证设备是否符合 Android 兼容性标准。 CTS 包含一系列的测试用例，用于检测设备的功能和性能是否符合 Android 的要求。通过运行 CTS ，开发者可以确保他们的应用程序在不同的 Android 设备上能够正常运行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于 Android 操作系统的一种测试工具，用于验证设备是否符合 Android 兼容性标准。 CTS 包含一系列的测试用例，用于检测设备的功能和性能是否符合 Android 的要求。通过运行 CTS ，开发者可以确保他们的应用程序在不同的 Android 设备上能够正常运行。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实时战略游戏（ RTS ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。它是一种无线通信技术，通过动态地分配可用的频谱资源，以提高频谱利用效率和网络性能。 DSR 可以根据实时需求和环境条件，自动调整频谱资源的分配，以满足不同用户和应用的需求。这种技术在无线通信领域具有重要的应用价值，可以有效地解决频谱资源稀缺和频谱管理的问题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCD 是指设计类图（ Design Class Diagram ），它是一种用于描述软件系统中类和类之间关系的图形表示方法。在软件设计过程中， DCD 被广泛应用于分析和设计阶段，用于展示系统的结构和组成部分之间的关系。通过 DCD ，开发人员可以更好地理解系统的架构和设计，并在开发过程中进行有效的沟通和协作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。它是一种无线通信技术，通过动态地分配可用的频谱资源，以提高频谱利用效率和网络性能。 DSR 可以根据实时需求和环境条件，自动调整频谱资源的分配，以满足不同用户和应用的需求。这种技术在无线通信领域具有重要的应用价值，可以有效地解决频谱资源稀缺和频谱管理的问题。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCD 是指设计类图（ Design Class Diagram ），它是一种用于描述软件系统中类和类之间关系的图形表示方法。在软件设计过程中， DCD 被广泛应用于分析和设计阶段，用于展示系统的结构和组成部分之间的关系。通过 DCD ，开发人员可以更好地理解系统的架构和设计，并在开发过程中进行有效的沟通和协作。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
</tr>
</tbody>
</table>
<table id="nullmodem-db9" class="tableblock frame-none grid-all stretch">
<caption class="title">表 39. DB-9 到 DB-9 的空模线缆</caption>
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">信号</th>
<th class="tableblock halign-left valign-top">引脚号码</th>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">引脚号码</th>
<th class="tableblock halign-left valign-top">信号</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">研发部门</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">研发部门</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。它是一种无线通信技术，通过动态地分配可用的频谱资源，以提高频谱利用效率和网络性能。 DSR 可以根据实时需求和环境条件，自动调整频谱资源的分配，以满足不同用户和应用的需求。这种技术在无线通信领域具有重要的应用价值，可以有效地解决频谱资源稀缺和频谱管理的问题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCD 是指设计类图（ Design Class Diagram ），它是一种用于描述软件系统中类和类之间关系的图形表示方法。在软件设计过程中， DCD 被广泛应用于分析和设计阶段，用于展示系统的结构和组成部分之间的关系。通过 DCD ，开发人员可以更好地理解系统的架构和设计，并在开发过程中进行有效的沟通和协作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新加坡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">新加坡</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。它是一种无线通信技术，通过动态地分配可用的频谱资源，以提高频谱利用效率和网络性能。 DSR 可以根据实时需求和环境条件，自动调整频谱资源的分配，以满足不同用户和应用的需求。这种技术在无线通信领域具有重要的应用价值，可以有效地解决频谱资源稀缺和频谱管理的问题。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCD 是指设计类图（ Design Class Diagram ），它是一种用于描述软件系统中类和类之间关系的图形表示方法。在软件设计过程中， DCD 被广泛应用于分析和设计阶段，用于展示系统的结构和组成部分之间的关系。通过 DCD ，开发人员可以更好地理解系统的架构和设计，并在开发过程中进行有效的沟通和协作。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">实时战略游戏（ RTS ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于 Android 操作系统的一种测试工具，用于验证设备是否符合 Android 兼容性标准。 CTS 包含一系列的测试用例，用于检测设备的功能和性能是否符合 Android 的要求。通过运行 CTS ，开发者可以确保他们的应用程序在不同的 Android 设备上能够正常运行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于 Android 操作系统的一种测试工具，用于验证设备是否符合 Android 兼容性标准。 CTS 包含一系列的测试用例，用于检测设备的功能和性能是否符合 Android 的要求。通过运行 CTS ，开发者可以确保他们的应用程序在不同的 Android 设备上能够正常运行。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实时战略游戏（ RTS ）</p></td>
</tr>
</tbody>
</table>
<table id="nullmodem-db9-25" class="tableblock frame-none grid-all stretch">
<caption class="title">表 40. DB-9 到 DB-25 空模拟电缆</caption>
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">信号</th>
<th class="tableblock halign-left valign-top">引脚号码</th>
<th class="tableblock halign-left valign-top"></th>
<th class="tableblock halign-left valign-top">引脚号码</th>
<th class="tableblock halign-left valign-top">信号</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">研发部门</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">2</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TD</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TD</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">3</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">研发部门</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。它是一种无线通信技术，通过动态地分配可用的频谱资源，以提高频谱利用效率和网络性能。 DSR 可以根据实时需求和环境条件，自动调整频谱资源的分配，以满足不同用户和应用的需求。这种技术在无线通信领域具有重要的应用价值，可以有效地解决频谱资源稀缺和频谱管理的问题。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCD 是指设计类图（ Design Class Diagram ），它是一种用于描述软件系统中类和类之间关系的图形表示方法。在软件设计过程中， DCD 被广泛应用于分析和设计阶段，用于展示系统的结构和组成部分之间的关系。通过 DCD ，开发人员可以更好地理解系统的架构和设计，并在开发过程中进行有效的沟通和协作。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新加坡</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">新加坡</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。它是一种无线通信技术，通过动态地分配可用的频谱资源，以提高频谱利用效率和网络性能。 DSR 可以根据实时需求和环境条件，自动调整频谱资源的分配，以满足不同用户和应用的需求。这种技术在无线通信领域具有重要的应用价值，可以有效地解决频谱资源稀缺和频谱管理的问题。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">6</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">DCD 是指设计类图（ Design Class Diagram ），它是一种用于描述软件系统中类和类之间关系的图形表示方法。在软件设计过程中， DCD 被广泛应用于分析和设计阶段，用于展示系统的结构和组成部分之间的关系。通过 DCD ，开发人员可以更好地理解系统的架构和设计，并在开发过程中进行有效的沟通和协作。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">1</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">二十</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">DTR 的全称是“定义测试关系（ Defect Tracking and Reporting ）”，它是一种用于跟踪和报告软件缺陷的方法。 DTR 通常由一个工具或系统来支持，它可以帮助开发团队记录和管理发现的缺陷，并跟踪它们的解决进度。通过使用 DTR ，团队可以更好地组织和协调缺陷修复工作，提高软件质量和开发效率。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">实时战略游戏（ RTS ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">7</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">5</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于 Android 操作系统的一种测试工具，用于验证设备是否符合 Android 兼容性标准。 CTS 包含一系列的测试用例，用于检测设备的功能和性能是否符合 Android 的要求。通过运行 CTS ，开发者可以确保他们的应用程序在不同的 Android 设备上能够正常运行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于 Android 操作系统的一种测试工具，用于验证设备是否符合 Android 兼容性标准。 CTS 包含一系列的测试用例，用于检测设备的功能和性能是否符合 Android 的要求。通过运行 CTS ，开发者可以确保他们的应用程序在不同的 Android 设备上能够正常运行。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">8</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">连接到</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实时战略游戏（ RTS ）</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当一个端口的一根引脚连接到另一个端口的一对引脚时，通常会使用一根短线连接这对引脚的连接器，以及一根长线连接到另一个单独的引脚。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>串口是在 FreeBSD 主机和终端之间传输数据的设备。存在几种类型的串口。在购买或制作电缆之前，请确保它适配终端和 FreeBSD 系统上的串口。</p>
</div>
<div class="paragraph">
<p>大多数终端设备都有 DB-25 端口。个人电脑可能有 DB-25 或 DB-9 端口。多端口串行卡可能有 RJ-12 或 RJ-45 端口。请查看随附硬件的文档，以了解端口类型的规格，或者通过目视确认端口类型。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，每个串口通过 [/dev] 中的一个条目进行访问。有两种不同类型的条目：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>呼叫端口的命名方式为 <span class="filename">/dev/ttyuN</span> ，其中_N_为端口号，从零开始计数。如果终端连接到第一个串口（ <span class="filename">COM1</span> ），则使用 <span class="filename">/dev/ttyu0</span> 来引用该终端。如果终端连接到第二个串口（ <span class="filename">COM2</span> ），则使用 <span class="filename">/dev/ttyu1</span> ，依此类推。通常，呼叫端口用于终端。呼叫端口要求串行线路正确工作时要断言“数据载波检测”信号。</p>
</li>
<li>
<p>在 FreeBSD 8.X 及更高版本上，呼叫输出端口被命名为 <code>/dev/cuauN</code> ，而在 FreeBSD 7.X 及更低版本上被命名为 <code>/dev/cuadN</code> 。呼叫输出端口通常不用于终端，而是用于调制解调器。如果串行电缆或终端不支持“数据载波检测”信号，可以使用呼叫输出端口。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FreeBSD 还提供了初始化设备（ <span class="filename">/dev/ttyuN.init</span> 和 <span class="filename">/dev/cuauN.init</span> 或 <span class="filename">/dev/cuadN.init</span> ）和锁定设备（ <span class="filename">/dev/ttyuN.lock</span> 和 <span class="filename">/dev/cuauN.lock</span> 或 <span class="filename">/dev/cuadN.lock</span> ）。初始化设备用于在每次打开端口时初始化通信端口参数，例如对于使用 <code>RTS/CTS</code> 信号进行流量控制的调制解调器，可以使用 <code>crtscts</code> 。锁定设备用于锁定端口上的标志，以防止用户或程序更改某些参数。有关终端设置、锁定和初始化设备以及设置终端选项的信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=termios&amp;sektion=4&amp;format=html">termios(4)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=uart&amp;sektion=4&amp;format=html">uart(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=stty&amp;sektion=1&amp;format=html">stty(1)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="serial-hw-config">29.2.2. 串口配置<a class="anchor" href="#serial-hw-config"></a></h4>
<div class="paragraph">
<p>默认情况下， FreeBSD 支持四个串口，通常被称为 COM1 、 COM2 、 COM3 和 COM4 。 FreeBSD 还支持一些简单的多串口接口卡，如 BocaBoard 1008 和 2016 ，以及一些更智能的多串口卡，如 Digiboard 制造的卡。然而，默认内核只会寻找标准的 COM 端口。</p>
</div>
<div class="paragraph">
<p>要查看系统是否识别串口，请查找以 <code>uart</code> 开头的系统引导消息。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># grep uart /var/run/dmesg.boot</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果系统无法识别所有所需的串口，可以将其他条目添加到 <code>/boot/device.hints</code> 文件中。该文件已经包含了针对 COM1 的 <code>hint.uart.0.<strong></strong></code><strong> 条目和针对 COM2 的 <code>hint.uart.1.</code></strong> 条目。当为 COM3 添加串口条目时，请使用 <code>0x3E8</code> ，而对于 COM4 ，请使用 <code>0x2E8</code> 。常见的 IRQ 地址是 COM3 的 <code>5</code> 和 COM4 的 <code>9</code> 。</p>
</div>
<div class="paragraph">
<p>要确定端口使用的默认终端 I/O 设置集，请指定其设备名称。此示例确定了 <span class="filename">COM2</span> 上呼入端口的设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># stty -a -f /dev/ttyu1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>系统范围内的串行设备初始化由 <span class="filename">/etc/rc.d/serial</span> 控制。该文件影响串行设备的默认设置。要更改设备的设置，请使用 <code>stty</code> 命令。默认情况下，更改的设置在设备关闭之前有效，当设备重新打开时，它会恢复到默认设置。要永久更改默认设置，请打开并调整初始化设备的设置。例如，要为 <span class="filename">ttyu5</span> 打开 <code>CLOCAL</code> 模式、 8 位通信和 <code>XON/XOFF</code> 流控制，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># stty -f /dev/ttyu5.init clocal cs8 ixon ixoff</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了防止应用程序更改某些设置，请对锁定设备进行调整。例如，要将 <span class="filename">ttyu5</span> 的速度锁定为 57600 bps ，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># stty -f /dev/ttyu5.lock 57600</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，任何打开 <span class="filename">ttyu5</span> 并尝试更改端口速度的应用程序都将被困在 57600 bps 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="term">29.3. 终端<a class="anchor" href="#term"></a></h3>
<div class="paragraph">
<p>终端提供了一种方便且低成本的方式，用于在未连接到计算机控制台或网络的情况下访问 FreeBSD 系统。本节介绍了如何在 FreeBSD 中使用终端。</p>
</div>
<div class="paragraph">
<p>最初的 UNIX® 系统没有控制台。相反，用户通过连接到计算机的串口登录并运行程序。</p>
</div>
<div class="paragraph">
<p>在几乎所有类 UNIX® 操作系统中，包括 FreeBSD ，仍然存在在串行端口上建立登录会话的能力。通过使用连接到未使用的串行端口的终端，用户可以登录并运行任何通常可以在控制台或 <code>xterm</code> 窗口中运行的文本程序。</p>
</div>
<div class="paragraph">
<p>FreeBSD 系统可以连接多个终端。可以使用一台旧的备用计算机作为终端，通过有线连接到运行 FreeBSD 的更强大的计算机上。这可以将原本可能是单用户计算机转变为功能强大的多用户系统。</p>
</div>
<div class="paragraph">
<p>FreeBSD 支持三种类型的终端：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">哑终端</dt>
<dd>
<p>哑终端是一种专门通过串行线连接到计算机的硬件。它们被称为“哑终端”，是因为它们只有足够的计算能力来显示、发送和接收文本。这些设备上无法运行任何程序。相反，哑终端连接到运行所需程序的计算机上。</p>
<div class="paragraph">
<p>有许多制造商生产的数百种愚蠢终端，几乎任何一种终端都可以与 FreeBSD 配合使用。一些高端终端甚至可以显示图形，但只有特定的软件包才能利用这些高级功能。</p>
</div>
<div class="paragraph">
<p>在工作环境中，工人不需要访问图形应用程序时，哑终端非常受欢迎。</p>
</div>
</dd>
<dt class="hdlist1">计算机作为终端的角色</dt>
<dd>
<p>由于哑终端只具备足够的能力来显示、发送和接收文本，任何多余的计算机都可以成为哑终端。所需的只是正确的电缆和一些在计算机上运行的“终端仿真”软件。</p>
<div class="paragraph">
<p>这个配置非常有用。例如，如果一个用户正在忙于在 FreeBSD 系统的控制台上工作，另一个用户可以同时使用一台性能较弱的个人电脑作为终端连接到 FreeBSD 系统上进行纯文本工作。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 的基本系统中，至少有两个工具可以通过串行连接进行使用： <a href="https://man.freebsd.org/cgi/man.cgi?query=cu&amp;sektion=1&amp;format=html">cu(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=tip&amp;sektion=1&amp;format=html">tip(1)</a> 。</p>
</div>
<div class="paragraph">
<p>例如，要从运行 FreeBSD 的客户端系统连接到另一个系统的串行连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cu -l /dev/cuauN</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>端口从零开始编号。这意味着 <span class="filename">COM1</span> 对应的是 <span class="filename">/dev/cuau0</span> 。</p>
</div>
<div class="paragraph">
<p>通过 Ports Collection 可以获得其他的程序，例如 <a class="package" href="https://cgit.freebsd.org/ports/tree/comms/minicom/">comms/minicom</a> 。</p>
</div>
</dd>
<dt class="hdlist1">X 终端</dt>
<dd>
<p>X 终端是最复杂的终端类型。它们通常不连接串行端口，而是连接到像以太网这样的网络。它们不仅仅局限于纯文本应用程序，还可以显示任何 Xorg 应用程序。</p>
<div class="paragraph">
<p>本章不涵盖 X 终端的设置、配置或使用。</p>
</div>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="term-config">29.3.1. 终端配置<a class="anchor" href="#term-config"></a></h4>
<div class="paragraph">
<p>本节介绍了如何配置 FreeBSD 系统以在串行终端上启用登录会话。它假设系统能够识别终端所连接的串行端口，并且终端使用了正确的连接线缆。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中， <code>init</code> 读取 [/etc/ttys] 文件并在可用的终端上启动一个 <code>getty</code> 进程。 <code>getty</code> 进程负责读取登录名并启动 <code>login</code> 程序。允许登录的 FreeBSD 系统上的端口在 [/etc/ttys] 文件中列出。例如，第一个虚拟控制台 [ttyv0] 在该文件中有一个条目，允许在控制台上登录。该文件还包含其他虚拟控制台、串口和伪终端的条目。对于硬连线终端，串口的 [/dev] 条目被列为不带 <code>/dev</code> 部分的形式。例如， [/dev/ttyv0] 被列为 <code>ttyv0</code> 。</p>
</div>
<div class="paragraph">
<p>默认的 <span class="filename">/etc/ttys</span> 配置支持前四个串口，即 <span class="filename">ttyu0</span> 到 <span class="filename">ttyu3</span> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ttyu0   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu1   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu2   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure
ttyu3   &#34;/usr/libexec/getty std.9600&#34;   dialup  off secure</pre>
</div>
</div>
<div class="paragraph">
<p>当连接终端到其中一个端口时，修改默认条目以设置所需的速度和终端类型，打开设备，并且如果需要，更改端口的安全设置。如果终端连接到另一个端口，添加一个端口的条目。</p>
</div>
<div class="paragraph">
<p><a href="#ex-etc-ttys">配置终端条目</a> 配置了两个终端在 [/etc/ttys] 中。第一个条目配置了一个连接到 [COM2] 的 Wyse-50 终端。第二个条目配置了一台运行 Procomm 终端软件模拟 VT-100 终端的旧计算机。该计算机连接到多端口串行卡的第六个串行端口。</p>
</div>
<div id="ex-etc-ttys" class="exampleblock">
<div class="title">例 34. 配置终端条目</div>
<div class="content">
<div class="literalblock programlisting">
<div class="content">
<pre>ttyu1  &#34;/usr/libexec/getty std.38400&#34;  wy50   on insecure
ttyu5   &#34;/usr/libexec/getty std.19200&#34;  vt100  on insecure</pre>
</div>
</div>
<div class="paragraph">
<p>第一个字段指定了串行终端的设备名称。</p>
</div>
<div class="paragraph">
<p>第二个字段告诉 <code>getty</code> 初始化并打开线路，设置线路速度，提示用户输入用户名，然后执行 <code>login</code> 程序。可选的_getty 类型_配置终端线路的特性，如 bps 速率和奇偶校验。可用的 getty 类型在 [/etc/gettytab](/etc/gettytab) 中列出。在几乎所有情况下，以 <code>std</code> 开头的 getty 类型适用于硬连线终端，因为这些条目忽略奇偶校验。每个 bps 速率从 110 到 115200 都有一个 <code>std</code> 条目。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=gettytab&amp;sektion=5&amp;format=html">gettytab(5)</a> 。在设置 getty 类型时，请确保与终端使用的通信设置匹配。对于此示例， Wyse-50 不使用奇偶校验，并以 38400 bps 连接。计算机不使用奇偶校验，并以 19200 bps 连接。</p>
</div>
<div class="paragraph">
<p>第三个字段是终端的类型。对于拨号端口，通常使用 <code>unknown</code> 或 <code>dialup</code> ，因为用户可以使用几乎任何类型的终端或软件进行拨号。由于有线终端的终端类型不会改变，可以指定来自 <span class="filename">/etc/termcap</span> 的真实终端类型。在这个例子中， Wyse-50 使用真实的终端类型，而运行 Procomm 的计算机设置为模拟 VT-100 。</p>
</div>
<div class="paragraph">
<p>第四个字段指定端口是否应该被启用。要在该端口上启用登录，此字段必须设置为 <code>on</code> 。</p>
</div>
<div class="paragraph">
<p>最后一个字段用于指定端口是否安全。将端口标记为“ secure ”表示该端口足够可信，允许“ root ”从该端口登录。不安全的端口不允许“ root ”登录。在不安全的端口上，用户必须从非特权帐户登录，然后使用“ su ”或类似的机制获取超级用户权限，如 <a href="./#users-superuser ，“超级用户帐户”"></a> 中所述。出于安全原因，建议将此设置更改为“ insecure ”。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>在对 [/etc/ttys] 文件进行任何更改后，向 <code>init</code> 进程发送 SIGHUP （挂断）信号，强制其重新读取配置文件。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kill -HUP 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <code>init</code> 始终是系统上运行的第一个进程，因此它的进程 ID 始终为 <code>1</code> 。</p>
</div>
<div class="paragraph">
<p>如果一切设置正确，所有电缆都已连接好，终端已经启动，那么每个终端现在应该运行着一个 <code>getty</code> 进程，并且每个终端上都应该有登录提示符可用。</p>
</div>
</div>
<div class="sect3">
<h4 id="term-debug">29.3.2. 连接故障排除<a class="anchor" href="#term-debug"></a></h4>
<div class="paragraph">
<p>即使在对细节极为细致入微的情况下，设置终端时仍然可能出现问题。以下是一些常见症状和一些建议的解决方法。</p>
</div>
<div class="paragraph">
<p>如果没有出现登录提示，请确保终端已插好并已开机。如果终端是个人电脑充当的，确保它在正确的串口上运行终端仿真软件。</p>
</div>
<div class="paragraph">
<p>确保电缆牢固地连接到终端和 FreeBSD 计算机上。确保它是正确类型的电缆。</p>
</div>
<div class="paragraph">
<p>确保终端和 FreeBSD 在波特率和奇偶校验设置上达成一致。对于视频显示终端，请确保对比度和亮度控制已调高。如果是打印终端，请确保纸张和墨水充足。</p>
</div>
<div class="paragraph">
<p>使用 <code>ps</code> 命令确保 <code>getty</code> 进程正在运行并为终端提供服务。例如，以下列表显示 <code>getty</code> 正在第二个串口（ .filename]<mark>ttyu1</mark> ）上运行，并且正在使用 <span class="filename">/etc/gettytab</span> 中的 <code>std.38400</code> 条目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ps -axww|grep ttyu</span>
22189  d1  Is+    0:00.03 /usr/libexec/getty std.38400 ttyu1</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有运行 <code>getty</code> 进程，请确保端口在 [/etc/ttys](/etc/ttys) 中已启用。在修改 [/etc/ttys](/etc/ttys) 后记得运行 <code>kill -HUP 1</code> 命令。</p>
</div>
<div class="paragraph">
<p>如果 <code>getty</code> 进程正在运行，但终端仍然没有显示登录提示符，或者显示了提示符但无法接受键入的输入，那么终端或电缆可能不支持硬件握手。尝试将 <span class="filename">/etc/ttys</span> 中的条目从 <code>std.38400</code> 更改为 <code>3wire.38400</code> ，然后在修改 <span class="filename">/etc/ttys</span> 后运行 <code>kill -HUP 1</code> 命令。 <code>3wire</code> 条目类似于 <code>std</code> ，但忽略了硬件握手。当使用 <code>3wire</code> 时，可能还需要降低波特率或启用软件流控制以防止缓冲区溢出。</p>
</div>
<div class="paragraph">
<p>如果登录提示符显示垃圾字符，请确保终端和 FreeBSD 在波特率和奇偶校验设置上达成一致。检查 <code>getty</code> 进程，确保使用了正确的_getty_类型。如果没有，请编辑 <span class="filename">/etc/ttys</span> 并运行 <code>kill -HUP 1</code> 。</p>
</div>
<div class="paragraph">
<p>如果字符出现重复，并且在键入时密码出现，请将终端或终端仿真软件从“半双工”或“本地回显”切换到“全双工”。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dialup">29.4. 拨入服务<a class="anchor" href="#dialup"></a></h3>
<div class="paragraph">
<p>为了配置一个用于拨入服务的 FreeBSD 系统，与配置终端类似，只是使用调制解调器而不是终端设备。 FreeBSD 支持外部和内部调制解调器。</p>
</div>
<div class="paragraph">
<p>外部调制解调器更方便，因为它们通常可以通过存储在非易失性 RAM 中的参数进行配置，并且它们通常提供带有指示灯的指示器，显示重要的 RS-232 信号的状态，以指示调制解调器是否正常运行。</p>
</div>
<div class="paragraph">
<p>内置调制解调器通常缺乏非易失性 RAM ，因此它们的配置可能仅限于设置 DIP 开关。如果内置调制解调器有任何信号指示灯，当系统的盖子放在位时很难查看。</p>
</div>
<div class="paragraph">
<p>使用外部调制解调器时，需要使用适当的电缆。标准的 RS-232C 串行电缆应该足够。</p>
</div>
<div class="paragraph">
<p>FreeBSD 在超过 2400 bps 的速度下需要 RTS 和 CTS 信号进行流控制，需要 CD 信号来检测呼叫是否已接听或线路是否已挂断，并且需要 DTR 信号在会话结束后重置调制解调器。有些电缆没有连接所有必需的信号，所以如果登录会话在线路挂断后仍然存在，可能是电缆存在问题。有关这些信号的更多信息，请参考 <a href="#term-cables-null">串行电缆和端口</a> 。</p>
</div>
<div class="paragraph">
<p>与其他类 UNIX® 操作系统一样， FreeBSD 使用硬件信号来判断呼叫是否已接听或线路是否已挂断，并在呼叫结束后挂断和重置调制解调器。 FreeBSD 避免向调制解调器发送命令或监视调制解调器的状态报告。</p>
</div>
<div class="paragraph">
<p>FreeBSD 支持 NS8250 、 NS16450 、 NS16550 和 NS16550A 基于 RS-232C （ CCITT V.24 ）通信接口。 8250 和 16450 设备具有单字符缓冲区。 16550 设备提供了一个 16 字符缓冲区，可以提高系统性能。普通的 16550 设备存在缺陷，无法使用 16 字符缓冲区，因此如果可能的话，请使用 16550A 设备。由于单字符缓冲区设备需要操作系统进行更多的工作，所以更倾向于使用基于 16550A 的串行接口卡。如果系统有许多活动的串行端口或将承受重负载，基于 16550A 的卡对于低误码率通信更好。</p>
</div>
<div class="paragraph">
<p>本节的其余部分演示了如何配置调制解调器以接收传入连接，如何与调制解调器通信，并提供一些故障排除技巧。</p>
</div>
<div class="sect3">
<h4 id="dialup-ttys">29.4.1. 调制解调器配置<a class="anchor" href="#dialup-ttys"></a></h4>
<div class="paragraph">
<p>与终端一样， <code>init</code> 为每个配置的串口生成一个 <code>getty</code> 进程，用于拨入连接。当用户拨号并且调制解调器连接成功时，调制解调器会报告“载波检测”信号。内核注意到已检测到载波，并指示 <code>getty</code> 打开端口并在指定的初始线速度下显示一个 <code>login:</code> 提示符。在典型的配置中，如果接收到垃圾字符，通常是由于调制解调器的连接速度与配置的速度不同， <code>getty</code> 会尝试调整线速度，直到接收到合理的字符为止。用户输入登录名后， <code>getty</code> 执行 <code>login</code> ，通过询问用户的密码，然后启动用户的 shell 来完成登录过程。</p>
</div>
<div class="paragraph">
<p>关于拨号调制解调器有两种观点。一种配置方法是设置调制解调器和系统，以便无论远程用户以何种速度拨入，拨入的 RS-232 接口都以固定速度运行。这种配置的好处是远程用户总是能立即看到系统登录提示。缺点是系统不知道用户的真实数据速率，因此像 Emacs 这样的全屏程序不会调整其屏幕绘制方法，以使其在较慢的连接下响应更好。</p>
</div>
<div class="paragraph">
<p>第二种方法是配置 RS-232 接口，根据远程用户的连接速度来变化速度。由于 <code>getty</code> 不了解任何特定调制解调器的连接速度报告，它会以初始速度发送 <code>login:</code> 消息，并监视响应中返回的字符。如果用户看到乱码，他们应该按下 <kbd>Enter</kbd> 直到看到一个可识别的提示符。如果数据速率不匹配， <code>getty</code> 会将用户输入的任何内容视为乱码，尝试下一个速度，并再次给出 <code>login:</code> 提示符。在用户看到一个良好的提示符之前，这个过程通常只需要按下一个或两个按键。这个登录序列看起来不像锁定速度的方法那样干净，但是低速连接的用户应该能够从全屏程序中获得更好的交互响应。</p>
</div>
<div class="paragraph">
<p>在锁定调制解调器的数据通信速率时，不需要对 [/etc/gettytab] 进行任何更改。然而，对于匹配速度的配置，可能需要添加额外的条目来定义调制解调器使用的速率。此示例配置了一个速率为 14.4 Kbps 的调制解调器，顶部接口速率为 19.2 Kbps ，使用 8 位，无奇偶校验连接。它配置 <code>getty</code> 以 19.2 Kbps 启动 V.32bis 连接的通信速率，然后循环使用 9600 bps 、 2400 bps 、 1200 bps 、 300 bps ，最后回到 19.2 Kbps 。通信速率循环是通过 `nx = ` （下一个表）功能实现的。每行使用 `tc = ` （表继续）条目来获取特定数据速率的其余设置。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#
# Additions for a V.32bis Modem
#
um|V300|High Speed Modem at 300,8-bit:\
        :nx=V19200:tc=std.300:
un|V1200|High Speed Modem at 1200,8-bit:\
        :nx=V300:tc=std.1200:
uo|V2400|High Speed Modem at 2400,8-bit:\
        :nx=V1200:tc=std.2400:
up|V9600|High Speed Modem at 9600,8-bit:\
        :nx=V2400:tc=std.9600:
uq|V19200|High Speed Modem at 19200,8-bit:\
        :nx=V9600:tc=std.19200:</pre>
</div>
</div>
<div class="paragraph">
<p>对于一个 28.8 Kbps 的调制解调器，或者为了利用 14.4 Kbps 调制解调器上的压缩功能，可以使用更高的通信速率，如下面的示例所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#
# Additions for a V.32bis or V.34 Modem
# Starting at 57.6 Kbps
#
vm|VH300|Very High Speed Modem at 300,8-bit:\
        :nx=VH57600:tc=std.300:
vn|VH1200|Very High Speed Modem at 1200,8-bit:\
        :nx=VH300:tc=std.1200:
vo|VH2400|Very High Speed Modem at 2400,8-bit:\
        :nx=VH1200:tc=std.2400:
vp|VH9600|Very High Speed Modem at 9600,8-bit:\
        :nx=VH2400:tc=std.9600:
vq|VH57600|Very High Speed Modem at 57600,8-bit:\
        :nx=VH9600:tc=std.57600:</pre>
</div>
</div>
<div class="paragraph">
<p>对于 CPU 速度较慢或负载较重的系统，如果没有基于 16550A 的串口，这种配置可能会在 57.6 Kbps 时产生“ uart ”“ silo ”错误。</p>
</div>
<div class="paragraph">
<p><span class="filename">/etc/ttys</span> 的配置与 <a href="#ex-etc-ttys">配置终端条目</a> 类似，但是传递给 <code>getty</code> 的参数不同，并且使用 <code>dialup</code> 作为终端类型。将 <em>xxx</em> 替换为 <code>init</code> 将在设备上运行的进程。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ttyu0   &#34;/usr/libexec/getty xxx&#34;   dialup on</pre>
</div>
</div>
<div class="paragraph">
<p><code>dialup</code> 终端类型可以进行更改。例如，将 <code>vt102</code> 设置为默认终端类型，允许用户在远程系统上使用 VT102 仿真。</p>
</div>
<div class="paragraph">
<p>对于锁定速度的配置，请使用 <span class="filename">/etc/gettytab</span> 中列出的有效类型指定速度。以下示例是针对一个端口速度锁定在 19.2 Kbps 的调制解调器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ttyu0   &#34;/usr/libexec/getty std.19200&#34;   dialup on</pre>
</div>
</div>
<div class="paragraph">
<p>在匹配速度配置中，该条目需要引用 <span class="filename">/etc/gettytab</span> 中适当的起始 &#34;auto-baud&#34; 条目。继续以一个以 19.2 Kbps 启动的匹配速度调制解调器为例，使用以下条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ttyu0   &#34;/usr/libexec/getty V19200&#34;   dialup on</pre>
</div>
</div>
<div class="paragraph">
<p>在编辑 [/etc/ttys] 文件后，在向 <code>init</code> 发送信号之前，请等待调制解调器正确配置并连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kill -HUP 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>高速调制解调器，如 V.32 、 V.32bis 和 V.34 调制解调器，使用硬件（ <code>RTS/CTS</code> ）流控制。使用 <code>stty</code> 命令为调制解调器端口设置硬件流控制标志。以下示例在 <span class="filename">COM2</span> 的拨入和拨出初始化设备上设置了 <code>crtscts</code> 标志：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># stty -f /dev/ttyu1.init crtscts</span>
<span class="c"># stty -f /dev/cuau1.init crtscts</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_故障排除_2">29.4.2. 故障排除<a class="anchor" href="#_故障排除_2"></a></h4>
<div class="paragraph">
<p>本节提供了一些解决无法连接到 FreeBSD 系统的拨号调制解调器的技巧。</p>
</div>
<div class="paragraph">
<p>将调制解调器连接到 FreeBSD 系统并启动系统。如果调制解调器具有状态指示灯，请观察当系统控制台上出现“ login: ”提示时，调制解调器的 DTR 指示灯是否亮起。如果它亮起，那应该意味着 FreeBSD 已经在适当的通信端口上启动了一个“ getty ”进程，并且正在等待调制解调器接受呼叫。</p>
</div>
<div class="paragraph">
<p>如果 DTR 指示灯没有亮起，请通过控制台登录 FreeBSD 系统，并输入 <code>ps ax</code> 命令查看 FreeBSD 是否在正确的端口上运行了 <code>getty</code> 进程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">  114 ??  I      0:00.10 /usr/libexec/getty V19200 ttyu0</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果第二列包含的是 <code>d0</code> 而不是 ` ?? ` ，并且调制解调器尚未接受呼叫，这意味着 <code>getty</code> 已经完成了对通信端口的打开。这可能表明存在电缆问题或调制解调器配置错误，因为在调制解调器断开检测信号被断言之前， <code>getty</code> 不应该能够打开通信端口。</p>
</div>
<div class="paragraph">
<p>如果没有 <code>getty</code> 进程等待打开端口，请再次检查在 <span class="filename">/etc/ttys</span> 中端口的条目是否正确。此外，请检查 <span class="filename">/var/log/messages</span> 以查看是否有来自 <code>init</code> 或 <code>getty</code> 的日志消息。</p>
</div>
<div class="paragraph">
<p>接下来，请尝试拨入系统。确保在远程系统上使用 8 位、无奇偶校验和 1 个停止位。如果没有立即出现提示符，或者提示符显示乱码，请尝试每秒按下 <kbd>Enter</kbd> 键一次。如果仍然没有出现 <code>login:</code> 提示符，请尝试发送 <code>BREAK</code> 信号。当使用高速调制解调器时，在锁定拨号调制解调器的接口速度后再次拨号。</p>
</div>
<div class="paragraph">
<p>如果仍然没有出现 <code>login:</code> 提示符，请再次检查 <span class="filename">/etc/gettytab</span> ，并仔细确认以下内容：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在 [/etc/ttys] 文件中指定的初始能力名称与 [/etc/gettytab] 文件中的能力名称匹配。</p>
</li>
<li>
<p>每个 `nx = ` 条目都与 <span class="filename">gettytab</span> 的能力名称相匹配。</p>
</li>
<li>
<p>每个 `tc = ` 条目都与另一个 <span class="filename">gettytab</span> 能力名称匹配。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果 FreeBSD 系统上的调制解调器不会应答，请确保调制解调器配置为在 DTR 被断开时接听电话。如果调制解调器似乎已正确配置，请通过检查调制解调器的指示灯来验证 DTR 线是否被断开。</p>
</div>
<div class="paragraph">
<p>如果仍然无法解决问题，请尝试发送电子邮件到 {freebsd-questions} ，描述调制解调器和问题。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="dialout">29.5. 拨出服务<a class="anchor" href="#dialout"></a></h3>
<div class="paragraph">
<p>以下是通过调制解调器将主机连接到另一台计算机的提示。这适用于与远程主机建立终端会话。</p>
</div>
<div class="paragraph">
<p>如果使用 PPP 存在问题，这种连接方式可以帮助获取互联网上的文件。如果 PPP 无法正常工作，可以使用终端会话来通过 FTP 获取所需文件。然后使用 zmodem 将其传输到计算机上。</p>
</div>
<div class="sect3">
<h4 id="hayes-unsupported">29.5.1. 使用一台斯托克海斯调制解调器<a class="anchor" href="#hayes-unsupported"></a></h4>
<div class="paragraph">
<p><code>tip</code> 内置了一个通用的 Hayes 拨号器。在 <code>/etc/remote</code> 文件中使用 <code>at = hayes</code> 。</p>
</div>
<div class="paragraph">
<p>Hayes 驱动程序不够智能，无法识别一些较新调制解调器消息的高级功能，例如“ BUSY ”、“ NO DIALTONE ”或“ CONNECT 115200 ”。在使用“ tip ”和“ ATX0 &amp; W ”时，请关闭这些消息。</p>
</div>
<div class="paragraph">
<p><code>tip</code> 的拨号超时时间为 60 秒。调制解调器应该使用更短的时间，否则 <code>tip</code> 会认为存在通信问题。尝试使用 <code>ATS7 = 45 &amp; W</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="direct-at">29.5.2. 使用 <code>AT</code> 命令<a class="anchor" href="#direct-at"></a></h4>
<div class="paragraph">
<p>在 <span class="filename">/etc/remote</span> 中创建一个&#34;direct&#34;条目。例如，如果调制解调器连接到第一个串口， <span class="filename">/dev/cuau0</span> ，请使用以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cuau0:dv=/dev/cuau0:br#19200:pa=none</pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>br</code> 功能中使用调制解调器支持的最高 bps 速率。然后，键入 <code>tip cuau0</code> 以连接到调制解调器。</p>
</div>
<div class="paragraph">
<p>或者，使用以下命令将 <code>cu</code> 作为 <code>root</code> 使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cu -lline -sspeed</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><em>line</em> 是串口，例如 <span class="filename">/dev/cuau0</span> ，而 <em>speed</em> 是速度，例如 <code>57600</code> 。输入完 AT 命令后，输入 ` ~ .` 退出。</p>
</div>
</div>
<div class="sect3">
<h4 id="gt-failure">29.5.3. ` @ ` 符号不起作用<a class="anchor" href="#gt-failure"></a></h4>
<div class="paragraph">
<p>电话号码能力中的 ` @ ` 符号告诉 <code>tip</code> 在 <code>/etc/phones</code> 文件中查找电话号码。但是，在像 <code>/etc/remote</code> 这样的能力文件中， ` @ ` 符号也是一个特殊字符，因此需要用反斜杠进行转义：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pn=\@</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="dial-command-line">29.5.4. 从命令行拨号<a class="anchor" href="#dial-command-line"></a></h4>
<div class="paragraph">
<p>在 <span class="filename">/etc/remote</span> 中添加一个“通用”条目。例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>tip115200|Dial any phone number at 115200 bps:\
        :dv=/dev/cuau0:br#115200:at=hayes:pa=none:du:
tip57600|Dial any phone number at 57600 bps:\
        :dv=/dev/cuau0:br#57600:at=hayes:pa=none:du:</pre>
</div>
</div>
<div class="paragraph">
<p>现在应该可以工作了。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tip -115200 5551234</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>喜欢使用 <code>cu</code> 而不是 <code>tip</code> 的用户可以使用通用的 <code>cu</code> 条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cu115200|Use cu to dial any number at 115200bps:\
        :dv=/dev/cuau1:br#57600:at=hayes:pa=none:du:</pre>
</div>
</div>
<div class="paragraph">
<p>并且类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cu 5551234 -s 115200</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="set-bps">29.5.5. 设置波特率<a class="anchor" href="#set-bps"></a></h4>
<div class="paragraph">
<p>为 <code>tip1200</code> 或 <code>cu1200</code> 添加一个条目，但请根据 <code>br</code> 功能使用适当的 bps 速率。 <code>tip</code> 认为默认的速率是 1200 bps ，这就是为什么它会寻找 <code>tip1200</code> 条目的原因。然而，并不一定非要使用 1200 bps 。</p>
</div>
</div>
<div class="sect3">
<h4 id="terminal-server">29.5.6. 通过终端服务器访问多台主机<a class="anchor" href="#terminal-server"></a></h4>
<div class="paragraph">
<p>不必每次等待连接并输入 <code>CONNECT <em>host</em></code> ，可以使用 <code>tip</code> 的 <code>cm</code> 功能。例如，在 <span class="filename">/etc/remote</span> 中添加以下条目，可以通过输入 <code>tip pain</code> 或 <code>tip muffin</code> 连接到主机 <code>pain</code> 或 <code>muffin</code> ，以及通过输入 <code>tip deep13</code> 连接到终端服务器。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pain|pain.deep13.com|Forrester&#39;s machine:\
        :cm=CONNECT pain\n:tc=deep13:
muffin|muffin.deep13.com|Frank&#39;s machine:\
        :cm=CONNECT muffin\n:tc=deep13:
deep13:Gizmonics Institute terminal server:\
        :dv=/dev/cuau2:br#38400:at=hayes:du:pa=none:pn=5551234:</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="tip-multiline">29.5.7. 使用多行显示 <code>tip</code> 提示信息<a class="anchor" href="#tip-multiline"></a></h4>
<div class="paragraph">
<p>这通常是一个问题，当一所大学拥有多条调制解调器线路，并有几千名学生试图使用它们时。</p>
</div>
<div class="paragraph">
<p>在 <span class="filename">/etc/remote</span> 中添加一条条目，并使用 ` @ ` 作为 <code>pn</code> 功能的标识符：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>big-university:\
        :pn=\@:tc=dialout
dialout:\
        :dv=/dev/cuau3:br#9600:at=courier:du:pa=none:</pre>
</div>
</div>
<div class="paragraph">
<p>然后，在 <span class="filename">/etc/phones</span> 中列出电话号码：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>big-university 5551111
big-university 5551112
big-university 5551113
big-university 5551114</pre>
</div>
</div>
<div class="paragraph">
<p><code>tip</code> 会按照列表中的顺序尝试每个数字，然后放弃。要保持重试，可以在一个 <code>while</code> 循环中运行 <code>tip</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="multi-controlp">29.5.8. 使用 Force 字符<a class="anchor" href="#multi-controlp"></a></h4>
<div class="paragraph">
<p><span class="keyseq"><kbd>Ctrl</kbd>+<kbd>P</kbd></span> 是默认的“强制”字符，用于告诉 <code>tip</code> 下一个字符是字面数据。可以使用 ` ~ s` 转义将强制字符设置为任何其他字符，该转义意味着“设置变量”。</p>
</div>
<div class="paragraph">
<p>在新行后面输入 ` ~ sforce =<em>single-char</em>` 。<em>single-char_是任意一个字符。如果省略_single-char</em>，则强制字符为空字符，可以通过键入 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>2</kbd></span> 或 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>Space</kbd></span> 来访问。一个很好的_single-char_值是 <span class="keyseq"><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span> ，这只在某些终端服务器上使用。</p>
</div>
<div class="paragraph">
<p>要更改力字符，请在 [.filename]# ~ /.tiprc# 中指定以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>force=single-char</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="uppercase">29.5.9. 大写字母<a class="anchor" href="#uppercase"></a></h4>
<div class="paragraph">
<p>当按下 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>A</kbd></span> 时，会发生这种情况，这是 <code>tip</code> 的“提升字符”，专为那些键盘上的大写锁定键损坏的人设计的。使用 ` ~ s` 来设置 <code>raisechar</code> 为合理的值。如果两个特性都没有使用，它可以被设置为与强制字符相同。</p>
</div>
<div class="paragraph">
<p>这是一个给需要在 Emacs 中输入 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>2</kbd></span> 和 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>A</kbd></span> 的用户的示例 [.filename]# ~ /.tiprc# 文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>force=^^
raisechar=^^</pre>
</div>
</div>
<div class="paragraph">
<p>` ^^ ` 是 <span class="keyseq"><kbd>Shift</kbd>+<kbd>Ctrl</kbd>+<kbd>6</kbd></span> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="tip-filetransfer">29.5.10. 使用 <code>tip</code> 进行文件传输<a class="anchor" href="#tip-filetransfer"></a></h4>
<div class="paragraph">
<p>当与另一个类 UNIX® 操作系统进行通信时，可以使用 ` ~ p` （ put ）和 ` ~ t` （ take ）命令发送和接收文件。这些命令在远程系统上运行 <code>cat</code> 和 <code>echo</code> 命令来接受和发送文件。语法如下： ` ~ p` 本地文件 [ 远程文件 ] ` ~ t` 远程文件 [ 本地文件 ] 。</p>
</div>
<div class="paragraph">
<p>没有错误检查，所以可能应该使用另一种协议，比如 zmodem 。</p>
</div>
</div>
<div class="sect3">
<h4 id="zmodem-tip">29.5.11. 使用 <code>tip</code> 与 zmodem 一起使用？<a class="anchor" href="#zmodem-tip"></a></h4>
<div class="paragraph">
<p>要接收文件，请在远程端启动发送程序。然后，输入 ` ~ C rz` 以开始在本地接收文件。</p>
</div>
<div class="paragraph">
<p>要发送文件，请在远程端启动接收程序。然后，输入 ` ~ C sz <em>files</em>` 将文件发送到远程系统。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="serialconsole-setup">29.6. 设置串行控制台<a class="anchor" href="#serialconsole-setup"></a></h3>
<div class="paragraph">
<p>FreeBSD 具有通过串口作为控制台来启动系统的能力。这种配置对于希望在没有键盘或显示器连接的机器上安装 FreeBSD 的系统管理员以及希望调试内核或设备驱动程序的开发人员非常有用。</p>
</div>
<div class="paragraph">
<p>如 <a href="./#boot">FreeBSD 引导过程</a> 中所描述的， FreeBSD 采用了三阶段的引导过程。前两个阶段是存储在引导磁盘上 FreeBSD 分区的开头的引导块代码。然后，引导块加载并运行引导加载程序作为第三阶段的代码。</p>
</div>
<div class="paragraph">
<p>为了设置从串行控制台启动，需要配置引导块代码、引导加载程序代码和内核。</p>
</div>
<div class="sect3">
<h4 id="serialconsole-howto-fast">29.6.1. 快速串行控制台配置<a class="anchor" href="#serialconsole-howto-fast"></a></h4>
<div class="paragraph">
<p>本节提供了设置串行控制台的快速概述。当哑终端连接到 COM1 时，可以使用此过程。</p>
</div>
<div class="olist arabic procedure">
<div class="title">过程：在 <span class="filename">COM1</span> 上配置串行控制台</div>
<ol class="arabic">
<li>
<p>将串行电缆连接到 <span class="filename">COM1</span> 和控制终端。</p>
</li>
<li>
<p>要配置启动消息在串行控制台上显示，以超级用户身份执行以下命令：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#39;console=&#34;comconsole&#34;&#39; &gt;&gt; /boot/loader.conf</span></code></pre>
</div>
</div>
</li>
<li>
<p>编辑 <span class="filename">/etc/ttys</span> 文件，将 <code>off</code> 改为 <code>on</code> ，将 <code>dialup</code> 改为 <code>vt100</code> ，针对 <span class="filename">ttyu0</span> 条目。否则，通过串行控制台连接时将不需要密码，可能导致安全漏洞。</p>
</li>
<li>
<p>重新启动系统以查看更改是否生效。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果需要不同的配置，请参阅下一节以获取更详细的配置说明。</p>
</div>
</div>
<div class="sect3">
<h4 id="serialconsole-howto">29.6.2. 深入的串行控制台配置<a class="anchor" href="#serialconsole-howto"></a></h4>
<div class="paragraph">
<p>本节提供了在 FreeBSD 中设置串行控制台所需步骤的更详细解释。</p>
</div>
<div class="olist arabic procedure">
<div class="title">过程：配置串行控制台</div>
<ol class="arabic">
<li>
<p>Connect a serial cable from your computer to the serial console port on the device.</p>
</li>
<li>
<p>Open a terminal emulator program on your computer.</p>
</li>
<li>
<p>Configure the terminal emulator program to use the appropriate serial port settings (baud rate , data bits , parity , stop bits).</p>
</li>
<li>
<p>Power on the device.</p>
</li>
<li>
<p>In the terminal emulator program , press Enter to display the device’s login prompt.</p>
</li>
<li>
<p>Enter the login credentials for the device.</p>
</li>
<li>
<p>Once logged in , you can access the device’s command-line interface (CLI) through the terminal emulator program.</p>
</li>
<li>
<p>To exit the CLI , type &#34;exit&#34; or use the appropriate command.</p>
</li>
<li>
<p>To disconnect the serial console , power off the device and remove the serial cable from the computer and the device.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>过程：配置串行控制台</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>将一根串行电缆从计算机连接到设备上的串行控制台端口。</p>
</li>
<li>
<p>在计算机上打开一个终端仿真程序。</p>
</li>
<li>
<p>配置终端仿真程序以使用适当的串行端口设置（波特率、数据位、奇偶校验、停止位）。</p>
</li>
<li>
<p>打开设备的电源。</p>
</li>
<li>
<p>在终端仿真程序中，按 Enter 键显示设备的登录提示符。</p>
</li>
<li>
<p>输入设备的登录凭据。</p>
</li>
<li>
<p>登录后，您可以通过终端仿真程序访问设备的命令行界面（ CLI ）。</p>
</li>
<li>
<p>要退出 CLI ，请键入&#34;exit&#34;或使用适当的命令。</p>
</li>
<li>
<p>要断开串行控制台，请关闭设备的电源，并将串行电缆从计算机和设备上拔出。</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>准备一根串行电缆。</p>
<div class="paragraph">
<p>使用空模拟电缆或标准串行电缆和空模拟适配器。有关串行电缆的讨论，请参见 <a href="#term-cables-null">串行电缆和端口</a> 。</p>
</div>
</li>
<li>
<p>拔下键盘。</p>
<div class="paragraph">
<p>许多系统在开机自检（ POST ）期间会检测键盘，并且如果未检测到键盘，将生成错误。一些机器在键盘未连接时将拒绝启动。</p>
</div>
<div class="paragraph">
<p>如果计算机在出现错误时抱怨，但仍能正常启动，那么无需进行进一步配置。</p>
</div>
<div class="paragraph">
<p>如果计算机在没有连接键盘的情况下拒绝启动，请配置 BIOS 以忽略此错误。请参考主板的手册以获取详细信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>尝试在 BIOS 中将键盘设置为“未安装”。该设置告诉 BIOS 在开机时不要探测键盘，因此如果键盘不存在，它就不会发出警告。如果 BIOS 中没有这个选项，请寻找一个名为“错误停止”（ Halt on Error ）的选项。将其设置为“除键盘外的所有错误”或“无错误”将产生相同的效果。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果系统上有 PS/2® 鼠标，请将其拔出。 PS/2® 鼠标与键盘共享一些硬件，如果鼠标仍然插着，可能会让键盘探测程序误以为键盘仍然存在。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然大多数系统可以在没有键盘的情况下启动，但有些系统在没有图形适配器的情况下无法启动。一些系统可以通过在 BIOS 配置中将“图形适配器”设置为“未安装”来配置为无图形适配器启动。其他系统不支持此选项，如果系统中没有显示硬件，将拒绝启动。对于这些机器，即使只是一个糟糕的单色板，也要插入某种图形卡。不需要连接显示器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>将一个哑终端、一个带有调制解调器程序的旧计算机，或者另一台 UNIX® 系统的串行端口插入串行端口。</p>
</li>
<li>
<p>在串口上，向 <span class="filename">/boot/device.hints</span> 添加适当的 <code>hint.uart.*</code> 条目。一些多串口卡还需要内核配置选项。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=uart&amp;sektion=4&amp;format=html">uart(4)</a> 获取所需的选项和每个支持的串口的设备提示。</p>
</li>
<li>
<p>在引导驱动器的 <code>a</code> 分区的根目录中创建名为 <code>boot.config</code> 的文件。</p>
<div class="paragraph">
<p>这个文件指示引导块代码如何引导系统。为了激活串行控制台，需要一个或多个以下选项。当使用多个选项时，请将它们都包含在同一行中：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>-h</code> 是一个常见的命令行选项，用于显示帮助信息。</dt>
<dd>
<p>在内部和串行控制台之间切换。使用此选项来切换控制台设备。例如，要从内部（视频）控制台启动，请使用 <code>-h</code> 将引导加载程序和内核指定使用串行端口作为控制台设备。或者，要从串行端口启动，请使用 <code>-h</code> 告诉引导加载程序和内核使用视频显示作为控制台。</p>
</dd>
<dt class="hdlist1"><code>-D</code> 是一个命令行选项，用于指定程序运行时的系统属性。</dt>
<dd>
<p>在单一和双重控制台配置之间切换。在单一配置中，控制台将根据 <code>-h</code> 的状态，选择内部控制台（视频显示）或串口。在双重控制台配置中，无论 <code>-h</code> 的状态如何，视频显示和串口将同时成为控制台。然而，双重控制台配置仅在引导块运行时生效。一旦引导加载程序获得控制权，由 <code>-h</code> 指定的控制台将成为唯一的控制台。</p>
</dd>
<dt class="hdlist1"><code>-P</code> 是一个命令行选项，用于指定要传递给程序的参数。</dt>
<dd>
<p>使引导块探测键盘。如果未找到键盘，则自动设置 <code>-D</code> 和 <code>-h</code> 选项。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于当前版本的引导块空间限制， <code>-P</code> 只能检测到扩展键盘。少于 101 个键且没有 F11 和 F12 键的键盘可能无法被检测到。由于这个限制，某些笔记本电脑上的键盘可能无法正确识别。如果是这种情况，请不要使用 <code>-P</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>使用 <code>-P</code> 来自动选择控制台，或者使用 <code>-h</code> 来激活串行控制台。更多详细信息请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot&amp;sektion=8&amp;format=html">boot(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=boot.config&amp;sektion=5&amp;format=html">boot.config(5)</a> 。</p>
</div>
<div class="paragraph">
<p>除了 <code>-P</code> 之外的选项都会传递给引导加载程序。引导加载程序将通过检查 <code>-h</code> 的状态来确定内部视频还是串口应该成为控制台。这意味着如果在 <code>/boot.config</code> 中指定了 <code>-D</code> 但未指定 <code>-h</code> ，则串口只能在引导块期间用作控制台，因为引导加载程序将使用内部视频显示作为控制台。</p>
</div>
</dd>
</dl>
</div>
</li>
<li>
<p>启动机器。</p>
<div class="paragraph">
<p>当 FreeBSD 启动时，引导块会将 <span class="filename">/boot.config</span> 的内容回显到控制台。例如：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">/boot.config: -P
Keyboard: no</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在 <span class="filename">/boot.config</span> 中存在 <code>-P</code> ，则第二行才会出现，并指示键盘的存在或不存在。这些消息会发送到串行或内部控制台，或者两者都会发送，具体取决于 <span class="filename">/boot.config</span> 中的选项。</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">选项</th>
<th class="tableblock halign-left valign-top">消息发送至</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">none</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">内部控制台</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-h</code> 是一个常见的命令行选项，用于显示帮助信息。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串行控制台</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-D</code> 是一个命令行选项，用于指定程序运行时的系统属性。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串行和内部控制台</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-Dh</code> 是一个命令行选项，用于在运行程序时设置 Java 虚拟机的堆大小。在 Java 中，堆是用于存储对象实例的内存区域。通过使用 <code>-Dh</code> 选项，可以指定堆的最大大小。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串行和内部控制台</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-P</code> ，键盘存在</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">内部控制台</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>-P</code> ，键盘缺失</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">串行控制台</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在消息之后，启动块将会有一个小的暂停，然后继续加载引导加载程序，并在打印任何进一步的消息到控制台之前。在正常情况下，没有必要中断启动块，但可以这样做以确保设置正确。</p>
</div>
<div class="paragraph">
<p>在控制台上按下除 <kbd>Enter</kbd> 键以外的任意键，以中断引导过程。然后引导块将提示进一步的操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">&gt;&gt; </span>FreeBSD/i386 BOOT
Default: 0:ad<span class="o">(</span>0,a<span class="o">)</span>/boot/loader
boot:</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据 <span class="filename">/boot.config</span> 中的选项，验证上述消息是否出现在串行或内部控制台上，或者两者都有。如果消息出现在正确的控制台上，请按下 <kbd>Enter</kbd> 键继续引导过程。</p>
</div>
<div class="paragraph">
<p>如果串行终端上没有提示符，说明设置有问题。输入 <code>-h</code> 然后按下键盘上的 <kbd>Enter</kbd> 或 <kbd>Return</kbd> 键，告诉引导块（然后是引导加载程序和内核）选择串行端口作为控制台。系统启动后，返回并检查出了什么问题。</p>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>在引导过程的第三阶段，可以通过在引导加载程序中设置适当的环境变量来在内部控制台和串行控制台之间切换。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader&amp;sektion=8&amp;format=html">loader(8)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>无论 <span class="filename">/boot.config</span> 中的选项如何，此行在 <span class="filename">/boot/loader.conf</span> 或 <span class="filename">/boot/loader.conf.local</span> 中配置引导加载程序和内核将其引导消息发送到串行控制台。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>console=&#34;comconsole&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>这行应该是 <span class="filename">/boot/loader.conf</span> 的第一行，以便尽早在串行控制台上显示引导消息。</p>
</div>
<div class="paragraph">
<p>如果该行不存在，或者设置为 <code>console =&#34;vidconsole&#34;</code> ，引导加载程序和内核将使用引导块中通过 <code>-h</code> 指定的控制台。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=loader.conf&amp;sektion=5&amp;format=html">loader.conf(5)</a> 。</p>
</div>
<div class="paragraph">
<p>目前，引导加载程序没有与引导块中的 <code>-P</code> 选项相当的选项，并且没有根据键盘的存在自动选择内部控制台和串行控制台的功能。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>虽然不是必需的，但可以通过串行线提供“登录”提示。要配置此功能，请按照 <a href="#term-config">终端配置</a> 中的说明编辑 <span class="filename">/etc/ttys</span> 中串行端口的条目。如果串行端口的速度已更改，请将 <code>std.9600</code> 更改为与新设置匹配的值。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_设置更快的串口速度">29.6.3. 设置更快的串口速度<a class="anchor" href="#_设置更快的串口速度"></a></h4>
<div class="paragraph">
<p>默认情况下，串口设置为 9600 波特率， 8 位数据位，无奇偶校验， 1 个停止位。要更改默认控制台速度，请使用以下选项之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>编辑 <span class="filename">/etc/make.conf</span> 文件，并将 <code>BOOT_COMCONSOLE_SPEED</code> 设置为新的控制台速度。然后，重新编译并安装引导块和引导加载程序：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /sys/boot</span>
<span class="c"># make clean</span>
<span class="c"># make</span>
<span class="c"># make install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果串行控制台的配置方式与使用 <code>-h</code> 引导不同，或者内核使用的串行控制台与引导块使用的不同，可以将以下选项添加到自定义内核配置文件中，并编译一个新的内核，以设置所需的速度：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options CONSPEED=19200</pre>
</div>
</div>
</li>
<li>
<p>将 <code>-S<em>19200</em></code> 引导选项添加到 <span class="filename">/boot.config</span> 文件中，将 <code><em>19200</em></code> 替换为要使用的速度。</p>
</li>
<li>
<p>将以下选项添加到 <code>/boot/loader.conf</code> 文件中。将 <code><em>115200</em></code> 替换为要使用的速度。</p>
<div class="literalblock programlisting">
<div class="content">
<pre>boot_multicons=&#34;YES&#34;
boot_serial=&#34;YES&#34;
comconsole_speed=&#34;115200&#34;
console=&#34;comconsole,vidconsole&#34;</pre>
</div>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="serialconsole-ddb">29.6.4. 通过串行线进入 DDB 调试器<a class="anchor" href="#serialconsole-ddb"></a></h4>
<div class="paragraph">
<p>要配置从串行控制台进入内核调试器的能力，请将以下选项添加到自定义内核配置文件中，并按照 <a href="./#kernelconfig">Configuring the FreeBSD Kernel</a> 中的说明编译内核。请注意，虽然这对于远程诊断很有用，但如果串口上生成了一个虚假的 BREAK 信号，也是很危险的。有关内核调试器的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=4&amp;format=html">ddb(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=ddb&amp;sektion=8&amp;format=html">ddb(8)</a> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options BREAK_TO_DEBUGGER
options DDB</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="ppp-and-slip">Chapter 30. PPP<a class="anchor" href="#ppp-and-slip"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="ppp-and-slip-synopsis">30.1. 简介<a class="anchor" href="#ppp-and-slip-synopsis"></a></h3>
<div class="paragraph">
<p>FreeBSD 支持点对点（ PPP ）协议，可以使用拨号调制解调器建立网络或互联网连接。本章介绍了如何在 FreeBSD 中配置基于调制解调器的通信服务。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何配置、使用和排除故障 PPP 连接。</p>
</li>
<li>
<p>如何设置以太网上的 PPP （ PPPoE ）。</p>
</li>
<li>
<p>如何设置 PPP over ATM （ PPPoA ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，您应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>熟悉基本的网络术语。</p>
</li>
<li>
<p>了解拨号连接和 PPP 的基本原理和目的。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="userppp">30.2. 配置 PPP<a class="anchor" href="#userppp"></a></h3>
<div class="paragraph">
<p>FreeBSD 提供了内置的支持，用于使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 管理拨号 PPP 连接。默认的 FreeBSD 内核提供了对 .tun 文件的支持，该文件用于与调制解调器硬件进行交互。配置是通过编辑至少一个配置文件来完成的，并且提供了包含示例的配置文件。最后，使用 <code>ppp</code> 来启动和管理连接。</p>
</div>
<div class="paragraph">
<p>为了使用 PPP 连接，需要以下物品：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个拨号上网账户，由互联网服务提供商（ ISP ）提供。</p>
</li>
<li>
<p>一个拨号调制解调器。</p>
</li>
<li>
<p>ISP 的拨号号码。</p>
</li>
<li>
<p>由 ISP 分配的登录名和密码。</p>
</li>
<li>
<p>一个或多个 DNS 服务器的 IP 地址。通常，这些地址由 ISP 提供。如果没有提供， FreeBSD 可以配置为使用 DNS 协商。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果缺少任何必要的信息，请联系互联网服务提供商。</p>
</div>
<div class="paragraph">
<p>以下信息可能由 ISP 提供，但并非必需：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>默认网关的 IP 地址。如果这个信息未知， ISP 将在连接设置过程中自动提供正确的值。在 FreeBSD 上配置 PPP 时，这个地址被称为 <code>HISADDR</code> 。</p>
</li>
<li>
<p>子网掩码。如果 ISP 没有提供子网掩码，则在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 配置文件中将使用 <code>255.255.255.255</code> 。</p>
<div class="paragraph">
<p>如果 ISP 分配了静态 IP 地址和主机名，则应将其输入到配置文件中。否则，在连接设置期间，此信息将自动提供。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>本节的其余部分演示了如何配置 FreeBSD 以适应常见的 PPP 连接场景。所需的配置文件是 [/etc/ppp/ppp.conf] ，其他文件和示例可在 [/usr/share/examples/ppp/] 中找到。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在本节中，许多文件示例都显示了行号。这些行号是为了更容易跟踪讨论而添加的，并不是要放在实际文件中。</p>
</div>
<div class="paragraph">
<p>在编辑配置文件时，正确的缩进非常重要。以 <code>:</code> 结尾的行应该从第一列（行的开头）开始，而其他所有行都应该按照所示使用空格或制表符进行缩进。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="userppp-staticIP">30.2.1. 基本配置<a class="anchor" href="#userppp-staticIP"></a></h4>
<div class="paragraph">
<p>为了配置 PPP 连接，首先使用 ISP 的拨入信息编辑 [/etc/ppp/ppp.conf] 文件。该文件的描述如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>1     default:
2       set log Phase Chat LCP IPCP CCP tun command
3       ident user-ppp VERSION
4       set device /dev/cuau0
5       set speed 115200
6       set dial &#34;ABORT BUSY ABORT NO\\sCARRIER TIMEOUT 5 \
7                 \&#34;\&#34; AT OK-AT-OK ATE1Q0 OK \\dATDT\\T TIMEOUT 40 CONNECT&#34;
8       set timeout 180
9       enable dns
10
11    provider:
12      set phone &#34;(123) 456 7890&#34;
13      set authname foo
14      set authkey bar
15      set timeout 300
16      set ifaddr x.x.x.x/0 y.y.y.y/0 255.255.255.255 0.0.0.0
17      add default HISADDR</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">第一行</dt>
<dd>
<p>识别 <code>default</code> 条目。当运行 <code>ppp</code> 时，该条目中的命令（第 2 到 9 行）会自动执行。</p>
</dd>
<dt class="hdlist1">第 2 行</dt>
<dd>
<p>启用详细日志记录参数以测试连接。一旦配置正常工作，此行应缩减为：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>set log phase tun</pre>
</div>
</div>
</dd>
<dt class="hdlist1">第三行</dt>
<dd>
<p>显示与连接另一端运行的 PPP 软件的 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 版本。</p>
</dd>
<dt class="hdlist1">第 4 行</dt>
<dd>
<p>标识了调制解调器连接的设备，其中 <span class="filename">COM1</span> 是 <span class="filename">/dev/cuau0</span> ，而 <span class="filename">COM2</span> 是 <span class="filename">/dev/cuau1</span> 。</p>
</dd>
<dt class="hdlist1">第 5 行</dt>
<dd>
<p>设置连接速度。如果在旧调制解调器上 <code>115200</code> 不起作用，请尝试使用 <code>38400</code> 。</p>
</dd>
<dt class="hdlist1">第 6 行和第 7 行</dt>
<dd>
<p>将拨号字符串写成期望 - 发送语法。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=chat&amp;sektion=8&amp;format=html">chat(8)</a> 。</p>
<div class="paragraph">
<p>请注意，为了提高可读性，该命令会继续到下一行。如果行的最后一个字符是 ` \ ` ，则 <span class="filename">ppp.conf</span> 中的任何命令都可以这样做。</p>
</div>
</dd>
<dt class="hdlist1">第 8 行</dt>
<dd>
<p>设置链接的空闲超时时间，单位为秒。</p>
</dd>
<dt class="hdlist1">第 9 行</dt>
<dd>
<p>指示对等方确认 DNS 设置。如果本地网络正在运行自己的 DNS 服务器，则应该将此行注释掉，方法是在行首添加“ # +”，或者将其删除。</p>
</dd>
<dt class="hdlist1">第 10 行</dt>
<dd>
<p>为了提高可读性而留下的空行。空行在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 中会被忽略。</p>
</dd>
<dt class="hdlist1">第 11 行</dt>
<dd>
<p>标识一个名为 <code>provider</code> 的条目。可以将其更改为 ISP 的名称，以便可以使用 <code>load <em>ISP</em></code> 来启动连接。</p>
</dd>
<dt class="hdlist1">第 12 行</dt>
<dd>
<p>使用 ISP 的电话号码。可以使用冒号（ <code>:</code> ）或竖线字符（ ` | ` ）作为分隔符来指定多个电话号码。要循环使用这些号码，请使用冒号。要始终首先尝试拨打第一个号码，并且只有在第一个号码失败时才使用其他号码，请使用竖线字符。始终使用引号（ <code>&#34;</code> ）将整组电话号码括起来，以防止拨号失败。</p>
</dd>
<dt class="hdlist1">第 13 行和第 14 行</dt>
<dd>
<p>使用 ISP 的用户名和密码。</p>
</dd>
<dt class="hdlist1">第 15 行</dt>
<dd>
<p>设置连接的默认空闲超时时间（以秒为单位）。在此示例中，连接在 300 秒的不活动后将自动关闭。要防止超时，将此值设置为零。</p>
</dd>
<dt class="hdlist1">第 16 行</dt>
<dd>
<p>设置接口地址。使用的值取决于是否从 ISP 获取了静态 IP 地址，还是在连接过程中协商动态 IP 地址。</p>
<div class="paragraph">
<p>如果 ISP 分配了静态 IP 地址和默认网关，请将_x.x.x.x_替换为静态 IP 地址，并将_y.y.y.y_替换为默认网关的 IP 地址。如果 ISP 只提供了静态 IP 地址而没有网关地址，请将_y.y.y.y_替换为 <code>10.0.0.2/0</code> 。</p>
</div>
<div class="paragraph">
<p>如果每次建立连接时 IP 地址都会更改，请将此行更改为以下值。这告诉 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 使用 IP 配置协议（ IPCP ）来协商动态 IP 地址：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>set ifaddr 10.0.0.1/0 10.0.0.2/0 255.255.255.255 0.0.0.0</pre>
</div>
</div>
</dd>
<dt class="hdlist1">第 17 行</dt>
<dd>
<p>保持这行不变，因为它会向网关添加一个默认路由。 <code>HISADDR</code> 将自动替换为第 16 行指定的网关地址。重要的是，这行出现在第 16 行之后。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>根据 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 是手动启动还是自动启动，可能还需要创建一个 .filename#/etc/ppp/ppp.linkup# 文件，其中包含以下内容。在以 -auto 模式运行 ppp 时，需要此文件。此文件在连接建立后使用。此时， IP 地址已被分配，现在可以添加路由表条目。创建此文件时，请确保_provider_与 .filename#ppp.conf# 的第 11 行中演示的值匹配。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>provider:
      add default HISADDR</pre>
</div>
</div>
<div class="paragraph">
<p>当在静态 IP 地址配置中“猜测”默认网关地址时，也需要此文件。在这种情况下，从 <span class="filename">ppp.conf</span> 中删除第 17 行，并创建包含上述两行的 <span class="filename">/etc/ppp/ppp.linkup</span> 文件。有关此文件的更多示例可以在 <span class="filename">/usr/share/examples/ppp/</span> 中找到。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>ppp</code> 必须以 <code>root</code> 用户身份运行。要更改此默认设置，请将应该运行 <code>ppp</code> 的用户的帐户添加到 <code>/etc/group</code> 文件中的 <code>network</code> 组中。</p>
</div>
<div class="paragraph">
<p>然后，使用 <code>allow</code> 命令给用户访问 <span class="filename">/etc/ppp/ppp.conf</span> 中的一个或多个条目的权限。例如，要给 <code>fred</code> 和 <code>mary</code> 只能访问 <code>provider:</code> 条目的权限，在 <code>provider:</code> 部分添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>allow users fred mary</pre>
</div>
</div>
<div class="paragraph">
<p>将指定用户授予对所有条目的访问权限，请将该行放在 <code>default</code> 部分中。</p>
</div>
</div>
<div class="sect3">
<h4 id="_高级配置">30.2.2. 高级配置<a class="anchor" href="#_高级配置"></a></h4>
<div class="paragraph">
<p>可以配置 PPP 在需要时提供 DNS 和 NetBIOS 名称服务器地址。</p>
</div>
<div class="paragraph">
<p>要在 PPP 版本 1.x 中启用这些扩展功能，可以将以下行添加到 <span class="filename">/etc/ppp/ppp.conf</span> 的相关部分。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>enable msext
set ns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre>
</div>
</div>
<div class="paragraph">
<p>对于 PPP 版本 2 及以上：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>accept dns
set dns 203.14.100.1 203.14.100.2
set nbns 203.14.100.5</pre>
</div>
</div>
<div class="paragraph">
<p>这将向客户端提供主要和次要的名称服务器地址，以及一个 NetBIOS 名称服务器主机。</p>
</div>
<div class="paragraph">
<p>在 2 版本及以上，如果省略了 <code>set dns</code> 行， PPP 将使用在 <span class="filename">/etc/resolv.conf</span> 中找到的值。</p>
</div>
<div class="sect4">
<h5 id="userppp-PAPnCHAP">30.2.2.1. PAP 和 CHAP 身份验证<a class="anchor" href="#userppp-PAPnCHAP"></a></h5>
<div class="paragraph">
<p>一些互联网服务提供商（ ISP ）设置他们的系统，使连接的身份验证部分使用 PAP 或 CHAP 身份验证机制之一完成。如果是这种情况， ISP 在连接时不会提供“ login: ”提示，而是立即开始使用 PPP 进行通信。</p>
</div>
<div class="paragraph">
<p>PAP 比 CHAP 安全性较低，但通常情况下安全性并不是一个问题，因为密码虽然以明文形式通过 PAP 发送，但只是通过串行线传输。破解者很难进行“窃听”。</p>
</div>
<div class="paragraph">
<p>必须进行以下修改：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>13      set authname MyUserName
14      set authkey MyPassword
15      set login</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">第 13 行</dt>
<dd>
<p>这行指定了 PAP/CHAP 用户名。请插入正确的值作为_MyUserName_。</p>
</dd>
<dt class="hdlist1">第 14 行</dt>
<dd>
<p>这行指定了 PAP/CHAP 密码。请插入正确的值作为_MyPassword_。您可能还想添加一行额外的内容，例如：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>16      accept PAP</pre>
</div>
</div>
<div class="paragraph">
<p>或者</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>16      accept CHAP</pre>
</div>
</div>
<div class="paragraph">
<p>为了明确这是意图，但是默认情况下， PAP 和 CHAP 都被接受。</p>
</div>
</dd>
<dt class="hdlist1">第 15 行</dt>
<dd>
<p>当使用 PAP 或 CHAP 时， ISP 通常不需要登录到服务器。因此，请禁用“ set login ”字符串。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="userppp-nat">30.2.2.2. 使用 PPP 网络地址转换功能<a class="anchor" href="#userppp-nat"></a></h5>
<div class="paragraph">
<p>PPP 具有使用内部 NAT 而无需内核转发功能的能力。可以通过在 /etc/ppp/ppp.conf 文件中添加以下行来启用此功能：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nat enable yes</pre>
</div>
</div>
<div class="paragraph">
<p>另外，也可以通过命令行选项 <code>-nat</code> 来启用 NAT 。此外，还有一个名为 <code>ppp_nat</code> 的 <span class="filename">/etc/rc.conf</span> 开关，默认情况下是启用的。</p>
</div>
<div class="paragraph">
<p>在使用此功能时，可以考虑包含以下选项 <span class="filename">/etc/ppp/ppp.conf</span> ，以启用传入连接转发：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nat port tcp 10.0.0.2:ftp ftp
nat port tcp 10.0.0.2:http http</pre>
</div>
</div>
<div class="paragraph">
<p>或者完全不信任外界</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nat deny_incoming yes</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="userppp-final">30.2.3. 最终系统配置<a class="anchor" href="#userppp-final"></a></h4>
<div class="paragraph">
<p>虽然 <code>ppp</code> 已经配置好了，但是还需要对 <span class="filename">/etc/rc.conf</span> 进行一些编辑。</p>
</div>
<div class="paragraph">
<p>从上到下逐步操作这个文件，在 `hostname = ` 行上确保已设置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;foo.example.com&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果 ISP 提供了静态 IP 地址和名称，请将此名称用作主机名。</p>
</div>
<div class="paragraph">
<p>查找 <code>network_interfaces</code> 变量。要配置系统按需拨号 ISP ，请确保将 <span class="filename">tun0</span> 设备添加到列表中，否则将其删除。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network_interfaces=&#34;lo0 tun0&#34;
ifconfig_tun0=</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><code>ifconfig_tun0</code> 变量应该为空，并且应该创建一个名为 <code>/etc/start_if.tun0</code> 的文件。该文件应包含以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ppp -auto mysystem</pre>
</div>
</div>
<div class="paragraph">
<p>此脚本在网络配置时执行，以自动模式启动 ppp 守护进程。如果此机器充当网关，请考虑包含 <code>-alias</code> 选项。有关详细信息，请参阅手册页。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>确保在 <span class="filename">/etc/rc.conf</span> 文件中，将路由器程序设置为 <code>NO</code> ，使用以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>router_enable=&#34;NO&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>重要的是不要启动 <code>routed</code> 守护进程，因为 <code>routed</code> 倾向于删除 <code>ppp</code> 创建的默认路由表条目。</p>
</div>
<div class="paragraph">
<p>确保 <code>sendmail_flags</code> 行不包含 <code>-q</code> 选项可能是一个好主意，否则 <code>sendmail</code> 会不时尝试进行网络查找，可能导致您的机器拨号。您可以尝试：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>sendmail_flags=&#34;-bd&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>缺点是每当 ppp 链接时， <code>sendmail</code> 被迫重新检查邮件队列。为了自动化这个过程，在 <span class="filename">ppp.linkup</span> 中包含 ` ! bg` 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>1     provider:
2       delete ALL
3       add 0 0 HISADDR
4       !bg sendmail -bd -q30m</pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是设置一个“ dfilter ”来阻止 SMTP 流量。有关详细信息，请参考示例文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_ppp">30.2.4. 使用 <code>ppp</code><a class="anchor" href="#_使用_ppp"></a></h4>
<div class="paragraph">
<p>只剩下重新启动机器了。重新启动后，要么输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ppp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后执行 <code>dial provider</code> 命令来启动 PPP 会话，或者，要配置 <code>ppp</code> 在有出站流量且 <span class="filename">start_if.tun0</span> 不存在时自动建立会话，请输入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ppp -auto provider</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>ppp</code> 程序在后台运行时，可以通过适当设置诊断端口来进行通信。要实现这一点，请将以下行添加到配置中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>set server /var/run/ppp-tun%d DiagnosticPassword 0177</pre>
</div>
</div>
<div class="paragraph">
<p>这将告诉 PPP 监听指定的 UNIX® 域套接字，在允许访问之前要求客户端提供指定的密码。名称中的 <code>%d</code> 将被替换为正在使用的 <span class="filename">tun</span> 设备号。</p>
</div>
<div class="paragraph">
<p>一旦建立了一个套接字，可以在希望操作正在运行的程序的脚本中使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pppctl&amp;sektion=8&amp;format=html">pppctl(8)</a> 程序。</p>
</div>
</div>
<div class="sect3">
<h4 id="userppp-mgetty">30.2.5. 配置拨入服务<a class="anchor" href="#userppp-mgetty"></a></h4>
<div class="paragraph">
<p><a href="./#dialup">“拨入服务”</a> 提供了使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=getty&amp;sektion=8&amp;format=html">getty(8)</a> 启用拨入服务的详细说明。</p>
</div>
<div class="paragraph">
<p><code>getty</code> 的替代方案是 <code>comms/mgetty + sendfax</code> （端口），这是 <code>getty</code> 的智能版本，专为拨号线路而设计。</p>
</div>
<div class="paragraph">
<p>使用 <code>mgetty</code> 的优点是它能够主动与调制解调器进行通信，这意味着如果在 <code>/etc/ttys</code> 中关闭了端口，调制解调器将不会接听电话。</p>
</div>
<div class="paragraph">
<p><code>mgetty</code> 的后续版本（从 0.99beta 开始）还支持自动检测 PPP 流，允许客户端无需脚本即可访问服务器。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="http://mgetty.greenie.net/doc/mgetty_toc.html">http://mgetty.greenie.net/doc/mgetty_toc.html</a> 获取有关 <code>mgetty</code> 的更多信息。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>comms/mgetty + sendfax</code> 包的端口带有启用的 <code>AUTO_PPP</code> 选项，允许 <code>mgetty</code> 检测 PPP 连接的 LCP 阶段并自动生成 ppp shell 。然而，由于默认的登录 / 密码序列不会发生，因此需要使用 PAP 或 CHAP 对用户进行身份验证。</p>
</div>
<div class="paragraph">
<p>本节假设用户已经成功编译并安装了 comms/mgetty + sendfax[] 软件包。</p>
</div>
<div class="paragraph">
<p>确保 <span class="filename">/usr/local/etc/mgetty + sendfax/login.config</span> 包含以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/AutoPPP/ -     - /etc/ppp/ppp-pap-dialup</pre>
</div>
</div>
<div class="paragraph">
<p>这将告诉 <code>mgetty</code> 在检测到 PPP 连接时运行 <span class="filename">ppp-pap-dialup</span> 。</p>
</div>
<div class="paragraph">
<p>创建一个名为 [/etc/ppp/ppp-pap-dialup] 的可执行文件，其中包含以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
exec /usr/sbin/ppp -direct pap$IDENT</pre>
</div>
</div>
<div class="paragraph">
<p>对于在 [/etc/ttys] 中启用的每个拨号线路，创建一个相应的条目在 [/etc/ppp/ppp.conf] 中。这将与我们上面创建的定义和谐共存。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pap:
  enable pap
  set ifaddr 203.14.100.1 203.14.100.20-203.14.100.40
  enable proxy</pre>
</div>
</div>
<div class="paragraph">
<p>使用这种方法登录的每个用户都需要在 <span class="filename">/etc/ppp/ppp.secret</span> 中拥有用户名 / 密码，或者可以选择在 <span class="filename">/etc/passwd</span> 中添加以下选项以通过 PAP 验证用户。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>enable passwdauth</pre>
</div>
</div>
<div class="paragraph">
<p>要为一些用户分配静态 IP 地址，请将该数字作为第三个参数指定在 [/etc/ppp/ppp.secret] 中。有关示例，请参见 [/usr/share/examples/ppp/ppp.secret.sample] 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="ppp-troubleshoot">30.3. PPP 连接故障排除<a class="anchor" href="#ppp-troubleshoot"></a></h3>
<div class="paragraph">
<p>本节涵盖了在使用调制解调器连接时可能出现的一些问题。一些 ISP 会显示 <code>ssword</code> 提示，而其他人则显示 <code>password</code> 。如果 <code>ppp</code> 脚本没有相应地编写，登录尝试将失败。调试 <code>ppp</code> 连接的最常见方法是按照本节所述手动连接。</p>
</div>
<div class="sect3">
<h4 id="_检查设备节点">30.3.1. 检查设备节点<a class="anchor" href="#_检查设备节点"></a></h4>
<div class="paragraph">
<p>在使用自定义内核时，请确保在内核配置文件中包含以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device   uart</pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">uart</span> 设备已经包含在 <code>GENERIC</code> 内核中，因此在这种情况下不需要额外的步骤。只需使用以下命令检查 <code>dmesg</code> 输出中的调制解调器设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dmesg | grep uart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该显示有关 <span class="filename">uart</span> 设备的一些相关输出。这些是我们需要的 COM 端口。如果调制解调器表现得像一个标准串口，它应该会列在 <span class="filename">uart1</span> 或者 <span class="filename">COM2</span> 上。如果是这样的话，不需要重新编译内核。当进行匹配时，如果调制解调器在 <span class="filename">uart1</span> 上，调制解调器设备将会是 <span class="filename">/dev/cuau1</span> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_手动连接">30.3.2. 手动连接<a class="anchor" href="#_手动连接"></a></h4>
<div class="paragraph">
<p>通过手动控制 <code>ppp</code> 连接到互联网是快速、简单且调试连接或获取有关 ISP 处理 <code>ppp</code> 客户端连接的信息的好方法。让我们从命令行开始 PPP 。请注意，在我们的所有示例中，我们将使用_example_作为运行 PPP 的机器的主机名。要启动 <code>ppp</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ppp</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ppp ON example&gt; <span class="nb">set </span>device /dev/cuau1</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个第二个命令将调制解调器设备设置为 <span class="filename">cuau1</span> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ppp ON example&gt; <span class="nb">set </span>speed 115200</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将连接速度设置为 115 , 200 kbps 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ppp ON example&gt; <span class="nb">enable </span>dns</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将告诉 <code>ppp</code> 配置解析器并将 nameserver 行添加到 <span class="filename">/etc/resolv.conf</span> 中。如果 <code>ppp</code> 无法确定主机名，可以稍后手动设置。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ppp ON example&gt; term</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将切换到“终端”模式，以手动控制调制解调器。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>deflink: Entering terminal mode on /dev/cuau1
type &#39;~h&#39; for help</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">at
OK
atdt123456789</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>at</code> 命令初始化调制解调器，然后使用 <code>atdt</code> 命令和 ISP 的号码开始拨号过程。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">CONNECT</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果我们遇到与硬件无关的连接问题，这里是我们尝试解决问题的地方。确认连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ISP Login:myusername</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个提示符下，返回由 ISP 提供的用户名的提示符。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ISP Pass:mypassword</code></pre>
</div>
</div>
<div class="paragraph">
<p>在提示符下，请回复由 ISP 提供的密码。就像登录 FreeBSD 一样，密码不会显示出来。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Shell or PPP:ppp</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据互联网服务提供商的不同，可能不会出现此提示。如果出现了，它会询问是否使用提供商的 shell 或启动 <code>ppp</code> 。在这个例子中，选择了 <code>ppp</code> 以建立互联网连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Ppp ON example&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，在这个例子中，第一个 <code>p</code> 已经被大写了。这表明我们已经成功连接到了互联网服务提供商。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Ppp ON example&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经成功通过我们的 ISP 进行了身份验证，并正在等待分配的 IP 地址。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">PPP ON example&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>我们已经就一个 IP 地址达成协议，并成功完成了连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">PPP ON example&gt;add default HISADDR</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这里，我们添加了默认路由，我们需要在与外部世界通信之前这样做，因为目前唯一建立的连接是与对等方的连接。如果由于现有路由而失败，请在 <code>add</code> 前面加上感叹号 ` ! ` 。或者，在进行实际连接之前设置这个选项，它将相应地协商一个新的路由。</p>
</div>
<div class="paragraph">
<p>如果一切顺利，我们现在应该已经建立了与互联网的活动连接，可以使用 <span class="keyseq"><kbd>CTRL</kbd>+<kbd>z</kbd></span> 将其置于后台。如果 <code>PPP</code> 返回到 <code>ppp</code> ，则表示连接已丢失。这是很重要的信息，因为它显示了连接状态。大写的 P 表示与互联网服务提供商的连接，小写的 p 表示连接已丢失。</p>
</div>
</div>
<div class="sect3">
<h4 id="_调试">30.3.3. 调试<a class="anchor" href="#_调试"></a></h4>
<div class="paragraph">
<p>如果无法建立连接，请使用 <code>set ctsrts off</code> 关闭硬件流控制 CTS/RTS 。这主要发生在连接到一些支持 PPP 的终端服务器时，当 PPP 尝试向通信链路写入数据时， PPP 会挂起并等待一个可能永远不会到来的 CTS 信号。使用此选项时，请包括 <code>set accmap</code> ，因为可能需要打败依赖于从端到端传递某些字符的硬件，大部分时间是 XON/XOFF 。有关此选项及其使用方法的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 。</p>
</div>
<div class="paragraph">
<p>一个较旧的调制解调器可能需要设置奇偶校验为“偶校验”。默认情况下，奇偶校验被设置为无校验，但在较旧的调制解调器上，当流量大增时，会用于错误检查。</p>
</div>
<div class="paragraph">
<p>PPP 可能无法返回到命令模式，这通常是一种协商错误，即 ISP 正在等待协商开始。此时，使用 ` ~ p` 将强制 PPP 开始发送配置信息。</p>
</div>
<div class="paragraph">
<p>如果登录提示从未出现，则很可能需要进行 PAP 或 CHAP 身份验证。要使用 PAP 或 CHAP ，在进入终端模式之前，请将以下选项添加到 PPP 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ppp ON example&gt; <span class="nb">set </span>authname myusername</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <em>myusername</em> 替换为由 ISP 分配的用户名。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ppp ON example&gt; <span class="nb">set </span>authkey mypassword</code></pre>
</div>
</div>
<div class="paragraph">
<p>将 <em>mypassword</em> 替换为由 ISP 分配的密码。</p>
</div>
<div class="paragraph">
<p>如果建立了连接，但似乎找不到任何域名，请尝试使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 命令 ping 一个 IP 地址。如果出现 100% 的数据包丢失，很可能是没有设置默认路由。请再次检查在连接期间是否设置了 <code>add default HISADDR</code> 。如果可以连接到远程 IP 地址，可能是因为没有将解析器地址添加到 [/etc/resolv.conf] 文件中。该文件应该如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>domain example.com
nameserver x.x.x.x
nameserver y.y.y.y</pre>
</div>
</div>
<div class="paragraph">
<p>_x.x.x.x_和_y.y.y.y_应该替换为 ISP 的 DNS 服务器的 IP 地址。</p>
</div>
<div class="paragraph">
<p>要配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> 以提供 PPP 连接的日志记录，请确保以下行存在于 <span class="filename">/etc/syslog.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>!ppp
*.*     /var/log/ppp.log</pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pppoe">30.4. 使用以太网上的点对点协议（ PPP over Ethernet ， PPPoE ）<a class="anchor" href="#pppoe"></a></h3>
<div class="paragraph">
<p>本节介绍了如何设置以太网上的 PPP （ PPPoE ）。</p>
</div>
<div class="paragraph">
<p>这是一个工作的 <span class="filename">ppp.conf</span> 的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>default:
  set log Phase tun command # you can add more detailed logging if you wish
  set ifaddr 10.0.0.1/0 10.0.0.2/0

name_of_service_provider:
  set device PPPoE:xl1 # replace xl1 with your Ethernet device
  set authname YOURLOGINNAME
  set authkey YOURPASSWORD
  set dial
  set login
  add default HISADDR</pre>
</div>
</div>
<div class="paragraph">
<p>以 <code>root</code> 身份运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ppp -ddial name_of_service_provider</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将以下内容添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ppp_enable=&#34;YES&#34;
ppp_mode=&#34;ddial&#34;
ppp_nat=&#34;YES&#34;	# if you want to enable nat for your local network, otherwise NO
ppp_profile=&#34;name_of_service_provider&#34;</pre>
</div>
</div>
<div class="sect3">
<h4 id="_使用_pppoe_服务标签">30.4.1. 使用 PPPoE 服务标签<a class="anchor" href="#_使用_pppoe_服务标签"></a></h4>
<div class="paragraph">
<p>有时候需要使用服务标签来建立连接。服务标签用于区分连接到给定网络的不同 PPPoE 服务器。</p>
</div>
<div class="paragraph">
<p>任何必需的服务标签信息应该在 ISP 提供的文档中。</p>
</div>
<div class="paragraph">
<p>作为最后的办法，可以尝试安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/rr-pppoe/">net/rr-pppoe</a> 包或端口。但请记住，这可能会取消您的调制解调器的编程并使其变得无用，所以在执行之前请三思。只需安装随调制解调器一起提供的程序。然后，从程序中访问 <b class="menuref">System</b> 菜单。配置文件的名称应该在那里列出。通常是_ISP_。</p>
</div>
<div class="paragraph">
<p>配置文件中的配置项 <code>set device</code> 中，配置文件名（服务标签）将作为 PPPoE 配置项的提供者部分。详细信息请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 。配置项应该如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>set device PPPoE:xl1:ISP</pre>
</div>
</div>
<div class="paragraph">
<p>不要忘记将_xl1_更改为适合以太网卡的正确设备。</p>
</div>
<div class="paragraph">
<p>不要忘记将_ISP_更改为配置文件。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参阅 Renaud Waldura 的 [使用 FreeBSD 在 DSL 上获得更便宜的宽带] （ <a href="http://renaud.waldura.com/doc/freebsd/pppoe/" class="bare">http://renaud.waldura.com/doc/freebsd/pppoe/</a> ）。</p>
</div>
</div>
<div class="sect3">
<h4 id="ppp-3com">30.4.2. 使用 3Com® HomeConnect™ ADSL Modem Dual Link 的 PPPoE<a class="anchor" href="#ppp-3com"></a></h4>
<div class="paragraph">
<p>该调制解调器不遵循在 <a href="http://www.faqs.org/rfcs/rfc2516.html">RFC 2516</a> 中定义的 PPPoE 规范。</p>
</div>
<div class="paragraph">
<p>为了使 FreeBSD 能够与该设备通信，必须设置一个 sysctl 。可以通过更新 /etc/sysctl.conf 文件，在启动时自动完成此操作。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>net.graph.nonstandard_pppoe=1</pre>
</div>
</div>
<div class="paragraph">
<p>或者可以立即使用命令完成：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl net.graph.nonstandard_pppoe=1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>很遗憾，由于这是一个系统级的设置，无法同时与普通的 PPPoE 客户端或服务器以及 3Com® HomeConnect™ ADSL 调制解调器进行通信。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="pppoa">30.5. 使用 ATM 上的 PPP （ PPPoA ）<a class="anchor" href="#pppoa"></a></h3>
<div class="paragraph">
<p>以下是如何设置 PPP over ATM （ PPPoA ）的说明。 PPPoA 是欧洲 DSL 提供商中的一种流行选择。</p>
</div>
<div class="sect3">
<h4 id="_使用_mpd">30.5.1. 使用 mpd<a class="anchor" href="#_使用_mpd"></a></h4>
<div class="paragraph">
<p>mpd 应用程序可以用于连接各种服务，特别是 PPTP 服务。可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/mpd5/">net/mpd5</a> 包或端口进行安装。许多 ADSL 调制解调器要求在调制解调器和计算机之间创建一个 PPTP 隧道。</p>
</div>
<div class="paragraph">
<p>安装完成后，配置 mpd 以适应提供商的设置。端口会提供一组示例配置文件，这些文件在 [/usr/local/etc/mpd/] 目录下有详细的文档。有一份完整的 mpd 配置指南以 HTML 格式提供，位于 [/usr/ports/shared/doc/mpd/] 目录下。以下是连接到 ADSL 服务的 mpd 示例配置。配置分为两个文件，首先是 mpd.conf 文件：</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这个例子 <span class="filename">mpd.conf</span> 只适用于 mpd 4.x 版本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>default:
    load adsl

adsl:
    new -i ng0 adsl adsl
    set bundle authname username <i class="conum" data-value="1"></i><b>(1)</b>
    set bundle password password <i class="conum" data-value="2"></i><b>(2)</b>
    set bundle disable multilink

    set link no pap acfcomp protocomp
    set link disable chap
    set link accept chap
    set link keep-alive 30 10

    set ipcp no vjcomp
    set ipcp ranges 0.0.0.0/0 0.0.0.0/0

    set iface route default
    set iface disable on-demand
    set iface enable proxy-arp
    set iface idle 0

    open</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用于与您的 ISP 进行身份验证的用户名。 &lt;.&gt; 用于与您的 ISP 进行身份验证的密码。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>关于要建立的链接或链接的信息可以在 <span class="filename">mpd.links</span> 中找到。下面是一个与上面示例相配套的 <span class="filename">mpd.links</span> 示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>adsl:
    set link type pptp
    set pptp mode active
    set pptp enable originate outcall
    set pptp self 10.0.0.1 <i class="conum" data-value="1"></i><b>(1)</b>
    set pptp peer 10.0.0.138 <i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>运行 mpd 的 FreeBSD 计算机的 IP 地址。 &lt;.&gt; ADSL 调制解调器的 IP 地址。 Alcatel SpeedTouch™ Home 的默认 IP 地址是 <code>10.0.0.138</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以通过以下命令作为“ root ”用户轻松初始化连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mpd -b adsl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>查看连接的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ifconfig ng0
ng0: <span class="nv">flags</span><span class="o">=</span>88d1&lt;UP,POINTOPOINT,RUNNING,NOARP,SIMPLEX,MULTICAST&gt; mtu 1500
     inet 216.136.204.117 --&gt; 204.152.186.171 netmask 0xffffffff</code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 mpd 是在 FreeBSD 上连接 ADSL 服务的推荐方法。</p>
</div>
</div>
<div class="sect3">
<h4 id="_使用_pptpclient">30.5.2. 使用 pptpclient<a class="anchor" href="#_使用_pptpclient"></a></h4>
<div class="paragraph">
<p>还可以使用 FreeBSD 来连接其他 PPPoA 服务，使用的软件包是： net/pptpclient[] 。</p>
</div>
<div class="paragraph">
<p>要使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/pptpclient/">net/pptpclient</a> 连接到 DSL 服务，请安装端口或包，然后编辑 <span class="filename">/etc/ppp/ppp.conf</span> 。下面是一个示例的 <span class="filename">ppp.conf</span> 部分。有关 <span class="filename">ppp.conf</span> 选项的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>adsl:
 set log phase chat lcp ipcp ccp tun command
 set timeout 0
 enable dns
 set authname username <i class="conum" data-value="1"></i><b>(1)</b>
 set authkey password <i class="conum" data-value="2"></i><b>(2)</b>
 set ifaddr 0 0
 add default HISADDR</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>DSL 供应商的用户名。 &lt;.&gt; 您账户的密码。</td>
</tr>
</tbody></table>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于账户密码以明文形式添加到 <span class="filename">ppp.conf</span> 文件中，请确保没有人可以读取此文件的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chown root:wheel /etc/ppp/ppp.conf</span>
<span class="c"># chmod 600 /etc/ppp/ppp.conf</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这将打开一个用于 DSL 路由器的 PPP 会话的隧道。以太网 DSL 调制解调器有一个预配置的 LAN IP 地址用于连接。在 Alcatel SpeedTouch™ Home 的情况下，该地址是 <code>10.0.0.138</code> 。路由器的文档应该列出设备使用的地址。要打开隧道并启动 PPP 会话：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pptp address adsl</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果在这个命令的末尾添加一个和号（&#34;&amp;&#34;）， pptp 将返回提示符。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>将创建一个名为 <span class="filename">tun</span> 的虚拟隧道设备，用于 pptp 和 ppp 进程之间的交互。一旦提示返回，或者 pptp 进程确认连接后，检查隧道：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ifconfig tun0
tun0: <span class="nv">flags</span><span class="o">=</span>8051&lt;UP,POINTOPOINT,RUNNING,MULTICAST&gt; mtu 1500
        inet 216.136.204.21 --&gt; 204.152.186.171 netmask 0xffffff00
	Opened by PID 918</code></pre>
</div>
</div>
<div class="paragraph">
<p>如果连接失败，请检查路由器的配置，通常可以使用 Web 浏览器访问。此外，检查 <code>pptp</code> 的输出和日志文件 <span class="filename">/var/log/ppp.log</span> ，以获取线索。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="mail">Chapter 31. 电子邮件<a class="anchor" href="#mail"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="mail-synopsis">31.1. 简介<a class="anchor" href="#mail-synopsis"></a></h3>
<div class="paragraph">
<p>“电子邮件”，更为人所知的是 email ，是当今最广泛使用的通信形式之一。本章介绍了在 FreeBSD 上运行邮件服务器的基本概念，以及使用 FreeBSD 发送和接收电子邮件的简介。如需更全面的内容，请参考 <a href="./#bibliography">Bibliography</a> 中列出的书籍。</p>
</div>
<div class="paragraph">
<p>本章内容包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>发送和接收电子邮件涉及哪些软件组件？</p>
</li>
<li>
<p>如何配置 DragonFly Mail Agent 。</p>
</li>
<li>
<p>在 FreeBSD 中，基本的 Sendmail 配置文件位于哪里？</p>
</li>
<li>
<p>远程邮箱和本地邮箱的区别。</p>
</li>
<li>
<p>如何安装和配置替代的邮件传输代理（ Mail Transfer Agent ），以替换 DragonFly Mail Agent 或 Sendmail 。</p>
</li>
<li>
<p>如何解决常见的邮件服务器问题。</p>
</li>
<li>
<p>如何配置 Sendmail 仅发送邮件。</p>
</li>
<li>
<p>如何在 Sendmail 中配置 SMTP 身份验证以增加安全性。</p>
</li>
<li>
<p>如何安装和使用邮件用户代理（ Mail User Agent ），例如 mutt ，来发送和接收电子邮件。</p>
</li>
<li>
<p>如何从远程的 POP 或 IMAP 服务器下载邮件。</p>
</li>
<li>
<p>如何自动应用过滤器和规则到收件箱中的电子邮件。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="mail-using">31.2. 邮件组件<a class="anchor" href="#mail-using"></a></h3>
<div class="paragraph">
<p>电子邮件交换涉及五个主要部分：邮件用户代理（ MUA ），邮件传输代理（ MTA ），邮件主机，远程或本地邮箱以及 DNS 。本节概述了这些组件。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">邮件用户代理（ MUA ）</dt>
<dd>
<p>邮件用户代理（ MUA ）是一种用于撰写、发送和接收电子邮件的应用程序。这个应用程序可以是一个命令行程序，比如内置的 <code>mail</code> 实用程序，也可以是来自 Ports Collection 的第三方应用程序，比如 alpine 、 elm 或 mutt 。 Ports Collection 中还提供了许多图形化程序，包括 Claws Mail 、 Evolution 和 Thunderbird 。一些组织提供了一个可以通过 Web 浏览器访问的 Web 邮件程序。关于在 FreeBSD 上安装和使用 MUA 的更多信息可以在 <a href="#mail-agents">邮件用户代理</a> 中找到。</p>
</dd>
<dt class="hdlist1">邮件传输代理（ MTA ）</dt>
<dd>
<p>邮件传输代理（ MTA ）负责接收传入邮件和投递传出邮件。从 FreeBSD 14.0 版本开始，默认的 MTA 是 DragonFly Mail Agent （ <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> ）；在早期版本中，默认的 MTA 是 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 。其他 MTA ，包括 Exim 、 Postfix 和 qmail ，可以安装来替换默认的 MTA 。</p>
</dd>
<dt class="hdlist1">邮件主机和邮箱</dt>
<dd>
<p>邮件主机是负责为主机或网络传递和接收邮件的服务器。邮件主机收集发送到该域的所有邮件，并根据配置将其存储在默认的 <code>mbox</code> 或备选的 Maildir 格式中。一旦邮件被存储，可以使用 MUA 在本地阅读，也可以使用 POP 或 IMAP 等协议进行远程访问和收取。如果邮件在本地阅读，则不需要安装 POP 或 IMAP 服务器。</p>
</dd>
<dt class="hdlist1">域名系统（ DNS ）</dt>
<dd>
<p>域名系统（ DNS ）及其守护进程 <a href="https://man.freebsd.org/cgi/man.cgi?query=named&amp;sektion=8&amp;format=html">named(8)</a> 在邮件传递中起着重要作用。为了将邮件从一个站点传递到另一个站点，邮件传输代理（ MTA ）将在 DNS 中查找远程站点，以确定哪个主机将接收目标站点的邮件。当邮件从远程主机发送到 MTA 时，也会发生这个过程。</p>
</dd>
</dl>
</div>
</div>
<div class="sect2">
<h3 id="dragonFly-mail-agent">31.3. DragonFly Mail Agent （ DMA ）<a class="anchor" href="#dragonFly-mail-agent"></a></h3>
<div class="paragraph">
<p>DragonFly Mail Agent (DMA) 是 FreeBSD 14.0 版本开始的默认邮件传输代理（ MTA ）。 <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 是一个小型的邮件传输代理，专为家庭和办公室使用而设计。它接收来自本地安装的邮件用户代理（ MUA ）的邮件，并将邮件传递到本地或远程目的地。远程传递包括多个功能，如 TLS/SSL 支持和 SMTP 身份验证。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 并不是用来替代真正的、大型的邮件传输代理（ MTA ）如 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=postfix&amp;sektion=1&amp;format=html">postfix(1)</a> 的。因此， <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 不会监听端口 25 来接收传入连接。</p>
</div>
<div class="sect3">
<h4 id="configuring-dragonfly-mail-agent">31.3.1. 配置 DragonFly Mail Agent (DMA)<a class="anchor" href="#configuring-dragonfly-mail-agent"></a></h4>
<div class="paragraph">
<p>DMA 带有一个默认配置，适用于许多部署。自定义设置在 [/etc/dma/dma.conf] 中定义， SMTP 身份验证在 [/etc/dma/auth.conf] 中配置。</p>
</div>
<div class="sect4">
<h5 id="configuring-gmail-dma">31.3.1.1. 使用 DMA 通过 Gmail 路由发送邮件（ STARTTLS:SMTP 示例）<a class="anchor" href="#configuring-gmail-dma"></a></h5>
<div class="paragraph">
<p>这个示例 <span class="filename">/etc/dma/dma.conf</span> 可以用来通过 Google 的 SMTP 服务器发送邮件。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>SMARTHOST smtp.gmail.com
PORT 587
AUTHPATH /etc/dma/auth.conf
SECURETRANSFER
STARTTLS
MASQUERADE username@gmail.com</pre>
</div>
</div>
<div class="paragraph">
<p>在 [/etc/dma/auth.conf] 文件中，可以通过一行代码设置身份验证。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>username@gmail.com|smtp.gmail.com:password</pre>
</div>
</div>
<div class="paragraph">
<p>执行以下命令来测试配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo </span>this is a <span class="nb">test</span> | mail -v -s testing-email username@gmail.com</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="configuring-fastmail-dma">31.3.1.2. 使用 DMA 将出站邮件通过 Fastmail 路由（ SSL/TLS 示例）<a class="anchor" href="#configuring-fastmail-dma"></a></h5>
<div class="paragraph">
<p>这个示例 <span class="filename">/etc/dma/dma.conf</span> 可以用来通过 Fastmail 的 SMTP 服务器发送邮件。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>SMARTHOST smtp.fastmail.com
PORT 465
AUTHPATH /etc/dma/auth.conf
SECURETRANSFER
MAILNAME example.server.com</pre>
</div>
</div>
<div class="paragraph">
<p>在 [/etc/dma/auth.conf] 文件中，可以通过一行代码设置身份验证。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>username@fastmail.com|smtp.fastmail.com:password</pre>
</div>
</div>
<div class="paragraph">
<p>执行以下命令来测试配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo </span>this is a <span class="nb">test</span> | mail -v -s testing-email username@fastmail.com</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="configuring-custom-dma">31.3.1.3. 使用 DMA 将出站邮件路由到自定义邮件主机<a class="anchor" href="#configuring-custom-dma"></a></h5>
<div class="paragraph">
<p>这个示例 <span class="filename">/etc/dma/dma.conf</span> 可以用来使用自定义邮件主机发送邮件。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>SMARTHOST mail.example.org
PORT 587
AUTHPATH /etc/dma/auth.conf
SECURETRANSFER
STARTTLS</pre>
</div>
</div>
<div class="paragraph">
<p>在 [/etc/dma/auth.conf] 文件中，可以通过一行代码设置身份验证。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>username@example.org|mail.example.org:password</pre>
</div>
</div>
<div class="paragraph">
<p>执行以下命令来测试配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span><span class="nb">echo </span>this is a <span class="nb">test</span> | mail -v -s testing-email username@example.org</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="sendmail">31.4. Sendmail 是一种用于电子邮件传输的开源软件。它是一种邮件传输代理（ MTA ），用于将电子邮件从发送者的计算机发送到接收者的计算机。 Sendmail 具有广泛的功能和灵活性，可以在各种操作系统上运行，并且被广泛用于互联网上的电子邮件传输。它支持多种邮件协议和格式，并提供了丰富的配置选项，使用户能够根据自己的需求进行定制。 Sendmail 是互联网上最早的邮件传输代理之一，至今仍然被广泛使用。<a class="anchor" href="#sendmail"></a></h3>
<div class="paragraph">
<p>Sendmail 是一个古老而多功能的邮件传输代理（ MTA ），在 UNIX 和类 UNIX 系统中有着悠久的历史。它曾是 FreeBSD 基本系统的一部分，直到 FreeBSD 13 版本，提供强大的电子邮件传输功能、广泛的自定义选项以及对复杂路由和过滤的支持。</p>
</div>
<div class="sect3">
<h4 id="configuring-sendmail">31.4.1. 配置文件<a class="anchor" href="#configuring-sendmail"></a></h4>
<div class="paragraph">
<p>Sendmail 的配置文件位于 [/etc/mail/] 目录中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><span class="filename">/etc/mail/access</span></dt>
<dd>
<p>此访问数据库文件定义了哪些主机或 IP 地址可以访问本地邮件服务器以及他们的访问权限。以“ OK ”列出的主机是允许向本主机发送邮件的，默认选项是只要邮件的最终目的地是本地机器即可。以“ REJECT ”列出的主机将被拒绝所有邮件连接。以“ RELAY ”列出的主机可以使用此邮件服务器发送任何目的地的邮件。以“ ERROR ”列出的主机将返回带有指定邮件错误的邮件。如果将主机列为“ SKIP ”， Sendmail 将中止对此条目的当前搜索，而不接受或拒绝邮件。以“ QUARANTINE ”列出的主机的消息将被保留，并将收到指定的文本作为保留原因。</p>
<div class="paragraph">
<p>在 FreeBSD 的示例配置文件 <span class="filename">/etc/mail/access.sample</span> 中可以找到使用这些选项的 IPv4 和 IPv6 地址的示例。</p>
</div>
<div class="paragraph">
<p>要配置访问数据库，请使用示例中显示的格式在 [/etc/mail/access] 文件中进行条目输入，但不要在条目前面加上注释符号（ <code>#</code> ）。为每个需要配置访问权限的主机或网络创建一个条目。与表格左侧匹配的邮件发送者将受到表格右侧操作的影响。</p>
</div>
<div class="paragraph">
<p>每当此文件更新时，更新其数据库并重新启动 Sendmail ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># makemap hash /etc/mail/access &lt; /etc/mail/access</span>
<span class="c"># service sendmail restart</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><span class="filename">/etc/mail/aliases</span></dt>
<dd>
<p>这个数据库文件包含了一个虚拟邮箱列表，这些邮箱可以扩展到用户、文件、程序或其他别名。以下是一些条目，用于说明文件格式：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>root: localuser
ftp-bugs: joe,eric,paul
bit.bucket:  /dev/null
procmail: &#34;|/usr/local/bin/procmail&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>冒号左侧的邮箱名称会被扩展为右侧的目标邮箱。第一个条目将 <code>root</code> 邮箱扩展为 <code>localuser</code> 邮箱，然后在 <code>.filename</code><mark>/etc/mail/aliases</mark> 数据库中查找。如果找不到匹配项，则将消息发送到 <code>localuser</code> 。第二个条目显示了一个邮件列表。邮件发送到 <code>ftp-bugs</code> 会被扩展为三个本地邮箱 <code>joe</code> 、 <code>eric</code> 和 <code>paul</code> 。远程邮箱可以指定为_user @ example.com_。第三个条目展示了如何将邮件写入文件，本例中为 <code>.filename</code><mark>/dev/null</mark> 。最后一个条目演示了如何通过 UNIX® 管道将邮件发送到一个程序，即 <code>.filename</code><mark>/usr/local/bin/procmail</mark> 。有关此文件格式的更多信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=aliases&amp;sektion=5&amp;format=html">aliases(5)</a> 。</p>
</div>
<div class="paragraph">
<p>每当此文件更新时，运行 <code>newaliases</code> 命令以更新和初始化别名数据库。</p>
</div>
</dd>
<dt class="hdlist1"><span class="filename">/etc/mail/sendmail.cf</span></dt>
<dd>
<p>这是 Sendmail 的主配置文件。它控制 Sendmail 的整体行为，包括从重写电子邮件地址到向远程邮件服务器打印拒绝消息的一切。因此，这个配置文件非常复杂。幸运的是，对于标准邮件服务器来说，这个文件很少需要更改。</p>
<div class="paragraph">
<p>主 Sendmail 配置文件可以使用定义 Sendmail 功能和行为的 m4 宏来构建。有关详细信息，请参阅 <code>/usr/src/contrib/sendmail/cf/README</code> 文件。</p>
</div>
<div class="paragraph">
<p>每当对该文件进行更改时，需要重新启动 Sendmail 才能使更改生效。</p>
</div>
</dd>
<dt class="hdlist1"><span class="filename">/etc/mail/virtusertable</span></dt>
<dd>
<p>这个数据库文件将虚拟域和用户的邮件地址映射到真实的邮箱。这些邮箱可以是本地的、远程的、在 [/etc/mail/aliases](/etc/mail/aliases) 中定义的别名，或者是文件。这样可以在一台机器上托管多个虚拟域。</p>
<div class="paragraph">
<p>FreeBSD 在 [/etc/mail/virtusertable.sample] 提供了一个示例配置文件，以进一步展示其格式。以下示例演示了如何使用该格式创建自定义条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>root@example.com                root
postmaster@example.com          postmaster@noc.example.net
@example.com                    joe</pre>
</div>
</div>
<div class="paragraph">
<p>此文件按照第一匹配的顺序进行处理。当电子邮件地址与左侧的地址匹配时，它将映射到右侧列出的本地邮箱。在此示例中，第一条目的格式将特定的电子邮件地址映射到本地邮箱，而第二条目的格式将特定的电子邮件地址映射到远程邮箱。最后，任何未与前面的条目匹配的来自 <code>example.com</code> 的电子邮件地址将匹配最后一个映射，并发送到本地邮箱 <code>joe</code> 。创建自定义条目时，请使用此格式并将其添加到 <span class="filename">/etc/mail/virtusertable</span> 。每当编辑此文件时，请更新其数据库并重新启动 Sendmail ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># makemap hash /etc/mail/virtusertable &lt; /etc/mail/virtusertable</span>
<span class="c"># service sendmail restart</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1"><span class="filename">/etc/mail/relay-domains</span></dt>
<dd>
<p>在默认的 FreeBSD 安装中， Sendmail 被配置为只能从运行它的主机发送邮件。例如，如果有一个 POP 服务器可用，用户可以从远程位置检查邮件，但他们将无法从外部位置发送出站邮件。通常，在尝试发送邮件后的几分钟内，将会收到来自 <code>MAILER-DAEMON</code> 的邮件，并附带有 <code>5.7 Relaying Denied</code> 的消息。</p>
<div class="paragraph">
<p>最直接的解决方案是将 ISP 的 FQDN 添加到 [/etc/mail/relay-domains] 文件中。如果需要多个地址，请每行添加一个地址：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>your.isp.example.com
other.isp.example.net
users-isp.example.org
www.example.org</pre>
</div>
</div>
<div class="paragraph">
<p>在创建或编辑此文件后，使用 <code>service sendmail restart</code> 重新启动 Sendmail 。</p>
</div>
<div class="paragraph">
<p>现在，只要在此列表中的任何主机通过系统发送邮件，并且用户在系统上有一个账户，邮件将会成功发送。这使得用户可以远程从系统发送邮件，而不会使系统暴露于来自互联网的垃圾邮件中继。</p>
</div>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mail-changingmta">31.5. 更改邮件传输代理<a class="anchor" href="#mail-changingmta"></a></h3>
<div class="paragraph">
<p>从 FreeBSD 14.0 版本开始，默认的 MTA 是 <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> ，而在 14.0 之前，默认的 MTA 是 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 。然而，系统管理员可以更改系统的 MTA 。在 FreeBSD Ports Collection 的 <code>mail</code> 类别中提供了多种可选的 MTA 。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果默认的出站邮件服务被禁用，重要的是要用替代的邮件传递系统来替代它。否则，像 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 这样的系统功能将无法通过电子邮件传递其结果。系统的许多部分都期望有一个可用的邮件传输代理（ MTA ）。如果应用程序在禁用后继续使用默认的二进制文件尝试发送电子邮件，邮件可能会进入非活动队列并永远无法传递。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="replace-sendmail-dma">31.5.1. 替换 Sendmail 与其他 MTA<a class="anchor" href="#replace-sendmail-dma"></a></h4>
<div class="paragraph">
<p>为了完全禁用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> ，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc sendmail_enable=&#34;NO&#34;</span>
<span class="c"># sysrc sendmail_submit_enable=&#34;NO&#34;</span>
<span class="c"># sysrc sendmail_outbound_enable=&#34;NO&#34;</span>
<span class="c"># sysrc sendmail_msp_queue_enable=&#34;NO&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要仅禁用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 的传入邮件服务，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc sendmail_enable=&#34;NO&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后停止 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service sendmail onestop</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于 <a href="https://man.freebsd.org/cgi/man.cgi?query=sendmail&amp;sektion=8&amp;format=html">sendmail(8)</a> 非常普遍，一些软件假设它已经安装和配置好，因此需要进行一些额外的配置。请检查 .filename#/etc/periodic.conf# 文件，并确保这些值设置为 <code>NO</code> 。如果该文件不存在，请创建并添加以下条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>daily_clean_hoststat_enable=&#34;NO&#34;
daily_status_mail_rejects_enable=&#34;NO&#34;
daily_status_include_submit_mailq=&#34;NO&#34;
daily_submit_queuerun=&#34;NO&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是安装另一个 MTA ，本示例将使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 。如上所述， <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 是 FreeBSD 14.0 版本开始的默认 MTA 。因此，如果您使用的是旧版本，则只需要从 ports 安装它。</p>
</div>
<div class="paragraph">
<p>要安装它，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install dma</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>按照 &lt;&lt; 配置 Dragonfly 邮件代理 &gt;&gt; 中所示进行配置。</p>
</div>
<div class="paragraph">
<p>然后将文件 <span class="filename">/etc/mail/mailer.conf</span> 中的所有条目更改为 <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># $FreeBSD$
#
# Execute the &#34;real&#34; sendmail program, named /usr/libexec/sendmail/sendmail
#
# If dma(8) is installed, an example mailer.conf that uses dma(8) instead can
# be found in /usr/share/examples/dma
#
sendmail        /usr/local/libexec/dma
mailq           /usr/local/libexec/dma
newaliases      /usr/local/libexec/dma</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当使用基本系统中包含的 <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 版本时，路径将更改为 [/usr/libexec/dma]#.</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>为了确保在启动或关机之前将队列中的所有内容刷新，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc dma_flushq_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦所有配置完成，建议重新启动系统。重新启动可以确保系统正确配置，以便在启动时自动启动新的 MTA 。</p>
</div>
</div>
<div class="sect3">
<h4 id="replace-dma">31.5.2. 用其他邮件传输代理（ MTA ）替换 DragonFly Mail Agent （ DMA ）<a class="anchor" href="#replace-dma"></a></h4>
<div class="paragraph">
<p>如上所述，从 FreeBSD 14.0 版本开始，默认的 MTA 是 DMA 。在这个例子中，将使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/postfix/">mail/postfix</a> 作为替代的 MTA 。</p>
</div>
<div class="paragraph">
<p>在安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/postfix/">mail/postfix</a> 之前，需要进行一些额外的配置。检查 <span class="filename">/etc/periodic.conf</span> 并确保这些值设置为 <code>NO</code> 。如果该文件不存在，请创建它并添加以下条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>daily_clean_hoststat_enable=&#34;NO&#34;
daily_status_mail_rejects_enable=&#34;NO&#34;
daily_status_include_submit_mailq=&#34;NO&#34;
daily_submit_queuerun=&#34;NO&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后安装包： mail/postfix[] ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install postfix</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在系统启动时启动 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/postfix/">mail/postfix</a> ，执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc postfix_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在安装应用程序后阅读安装消息是一个好的做法。它提供了有关设置等方面的有用信息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果在 <code>/usr/local/etc/mail/mailer.conf</code> 中 * 尚未 * 激活后缀，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">mv /usr/local/etc/mail/mailer.conf /usr/local/etc/mail/mailer.conf.old
install -d /usr/local/etc/mail
install -m 0644 /usr/local/share/postfix/mailer.conf.postfix /usr/local/etc/mail/mailer.conf</code></pre>
</div>
</div>
<div class="paragraph">
<p>在使用 SASL 时，请确保 postfix 有权限读取 sasldb 文件。可以通过将 postfix 添加到 mail 组，并将 /usr/local/etc/sasldb* 文件设置为 mail 组可读（这应该是新安装的默认设置）来实现这一点。</p>
</div>
<div class="paragraph">
<p>一旦所有配置完成，建议重新启动系统。重新启动可以确保系统正确配置，以便在启动时自动启动新的 MTA 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mail-agents">31.6. 邮件用户代理<a class="anchor" href="#mail-agents"></a></h3>
<div class="paragraph">
<p>MUA 是一种用于发送和接收电子邮件的应用程序。随着电子邮件的“演变”和变得越来越复杂， MUA 变得越来越强大，为用户提供了更多的功能和灵活性。 FreeBSD Ports Collection 的“ mail ”类别中包含了许多 MUA 。这些包括图形化的电子邮件客户端，如 Evolution 或 Balsa ，以及基于控制台的客户端，如 mutt 或 alpine 。</p>
</div>
<div class="sect3">
<h4 id="mail-command">31.6.1. 邮件<a class="anchor" href="#mail-command"></a></h4>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 是默认安装在 FreeBSD 上的 MUA （邮件用户代理）。它是一个基于控制台的 MUA ，提供发送和接收基于文本的电子邮件所需的基本功能。它提供有限的附件支持，并且只能访问本地邮箱。</p>
</div>
<div class="paragraph">
<p>虽然 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 本身不支持与 POP 或 IMAP 服务器的交互，但可以使用诸如 fetchmail 或 getmail 之类的应用程序将这些邮箱下载到本地的 <code>mbox</code> 中。</p>
</div>
<div class="paragraph">
<p>为了发送和接收电子邮件，请运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mail</code></pre>
</div>
</div>
<div class="paragraph">
<p>用户的邮箱内容位于 <span class="filename">/var/mail</span> 中，会被 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 自动读取。如果邮箱为空，该工具将退出并显示一条消息表示未找到邮件。如果存在邮件，应用程序界面将启动，并显示一份消息列表。</p>
</div>
<div class="paragraph">
<p>消息会自动编号，如下面的示例所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Mail version 8.1 6/6/93.  Type ? for help.
&#34;/var/mail/username&#34;: 3 messages 3 new
&gt;N  1 root@localhost        Mon Mar  8 14:05  14/510   &#34;test&#34;
 N  2 root@localhost        Mon Mar  8 14:05  14/509   &#34;user account&#34;
 N  3 root@localhost        Mon Mar  8 14:05  14/509   &#34;sample&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>现在可以通过键入 <kbd>t</kbd> 后跟消息编号来阅读消息。</p>
</div>
<div class="paragraph">
<p>这个例子读取第一封电子邮件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&amp; t 1
Message 1:
From root@localhost  Mon Mar  8 14:05:52 2004
X-Original-To: username@localhost
Delivered-To: username@localhost
To: username@localhost
Subject: test
Date: Mon,  8 Mar 2004 14:05:52 +0200 (SAST)
From: root@localhost (Charlie Root)

This is a test message, please reply if you receive it.</pre>
</div>
</div>
<div class="paragraph">
<p>如本示例所示，消息将显示完整的标题。</p>
</div>
<div class="paragraph">
<p>要再次显示消息列表，请按下 <kbd>h</kbd> 。</p>
</div>
<div class="paragraph">
<p>如果需要回复邮件，请按下 <kbd>R</kbd> 或 <kbd>r</kbd> 键。 <kbd>R</kbd> 命令指示 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 仅回复邮件的发送者，而 <kbd>r</kbd> 命令则回复给所有其他收件人。这些命令可以在回复的邮件编号后面添加。在输入回复内容后，邮件的结尾应该用单独一行的 <kbd>.</kbd> 标记。</p>
</div>
<div class="paragraph">
<p>下面是一个示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&amp; R 1
To: root@localhost
Subject: Re: test

Thank you, I did get your email.
.
EOT</pre>
</div>
</div>
<div class="paragraph">
<p>要发送一封新邮件，按下 <kbd>m</kbd> 键，然后输入收件人的电子邮件地址。可以通过使用 <kbd>,</kbd> 分隔符来指定多个收件人。然后可以输入邮件的主题，然后是邮件内容。邮件的结束应该在单独的一行上放置一个单独的 <kbd>.</kbd> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&amp; mail root@localhost
Subject: I mastered mail

Now I can send and receive email using mail ... :)
.
EOT</pre>
</div>
</div>
<div class="paragraph">
<p>在使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 时，按下 <kbd>?</kbd> 以随时显示帮助。有关如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 的更多帮助，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 并不是为了处理附件而设计的，因此在处理附件方面表现不佳。较新的邮件用户代理（ MUAs ）以更智能的方式处理附件。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="mutt-command">31.6.2. Mutt 是一个基于文本的电子邮件客户端，它在 Unix-like 操作系统上运行。它具有高度可定制性和灵活性，可以通过配置文件进行个性化设置。 Mutt 支持多种邮件协议，包括 POP3 、 IMAP 和 SMTP ，并且可以与其他工具集成，如 GnuPG 和 Muttprint 。它被广泛用于命令行环境下的电子邮件管理。<a class="anchor" href="#mutt-command"></a></h4>
<div class="paragraph">
<p>Mutt 是一个功能强大的邮件用户代理程序，具有许多功能，包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>线程消息的能力。</p>
</li>
<li>
<p>PGP 支持对电子邮件进行数字签名和加密。</p>
</li>
<li>
<p>MIME 支持。</p>
</li>
<li>
<p>Maildir 支持。</p>
</li>
<li>
<p>高度可定制。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请参考链接： [<a href="http://www.mutt.org" class="bare">http://www.mutt.org</a>](<a href="http://www.mutt.org" class="bare">http://www.mutt.org</a>) 获取有关 Mutt 的更多信息。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>值得一提的是一个名为 NeoMutt 的 Mutt 分支，它带来了额外的功能。请访问链接了解更多信息： [NeoMutt 网站](<a href="https://neomutt.org/about.html" class="bare">https://neomutt.org/about.html</a>) 。如果选择 NeoMutt ，请将以下命令示例中的 <code>mutt</code> 替换为 <code>neomutt</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Mutt 可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/mutt/">mail/mutt</a> 端口进行安装。安装完成后，可以通过以下命令启动 Mutt ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>mutt</code></pre>
</div>
</div>
<div class="paragraph">
<p>Mutt 将自动读取并显示用户邮箱的内容，路径为 <code>/var/mail</code> 。如果没有找到邮件， Mutt 将等待用户的命令。下面的示例显示了 Mutt 显示消息列表的情况：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/mutt1.png" alt="Mutt 邮件客户端显示消息列表"/>
</div>
</div>
<div class="paragraph">
<p>要阅读一封电子邮件，使用光标键选择它，然后按下 <kbd>Enter</kbd> 。下面是 Mutt 显示电子邮件的示例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/mutt2.png" alt="Mutt 邮件客户端显示一封电子邮件"/>
</div>
</div>
<div class="paragraph">
<p>与 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 类似， Mutt 可以用于仅回复邮件的发件人，也可以回复给所有收件人。要仅回复给邮件的发件人，按下键盘上的 [r] 键。要向原始发件人和所有收件人发送群组回复，按下键盘上的 [g] 键。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>默认情况下， Mutt 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> 编辑器来创建和回复电子邮件。每个用户可以通过在其主目录中创建或编辑 .filename#.muttrc# 文件并设置 <code>editor</code> 变量，或者设置 <code>EDITOR</code> 环境变量来自定义此设置。有关配置 Mutt 的更多信息，请参阅 <a href="http://www.mutt.org/">http://www.mutt.org/</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>按下 <kbd>m</kbd> 键来撰写一封新的邮件。在输入有效的主题后， Mutt 将启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> 以便编写邮件内容。完成邮件内容后，保存并退出 <code>vi</code> 。 Mutt 将恢复，并显示待发送邮件的摘要屏幕。要发送邮件，请按下 <kbd>y</kbd> 键。下面是摘要屏幕的示例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/mutt3.png" alt="Mutt 邮件客户端显示摘要屏幕"/>
</div>
</div>
<div class="paragraph">
<p>Mutt 包含丰富的帮助信息，可以通过在大多数菜单中按下 <kbd>?</kbd> 来访问。在适当的情况下，顶部行还显示键盘快捷键。</p>
</div>
</div>
<div class="sect3">
<h4 id="alpine-command">31.6.3. 阿尔卑斯<a class="anchor" href="#alpine-command"></a></h4>
<div class="paragraph">
<p>Alpine 面向初学者用户，同时也包含一些高级功能。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在过去， Alpine 曾发现过几个远程漏洞，允许远程攻击者通过发送特制的电子邮件，在本地系统上以用户身份执行任意代码。虽然已经修复了已知的问题，但 Alpine 的代码编写方式存在安全隐患， FreeBSD 安全官员认为可能还存在其他未被发现的漏洞。用户在安装 Alpine 时需自行承担风险。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/alpine/">mail/alpine</a> 端口安装当前版本的 alpine 。安装完成后，可以通过以下命令启动 alpine ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>alpine</code></pre>
</div>
</div>
<div class="paragraph">
<p>当 alpine 第一次运行时，它会显示一个问候页面，其中包含简要介绍，以及 alpine 开发团队的请求，要求发送一封匿名电子邮件，以便他们判断有多少用户在使用他们的客户端。要发送这封匿名邮件，请按下 <kbd>Enter</kbd> 。或者，按下 <kbd>E</kbd> 退出问候页面，而不发送匿名邮件。下面是问候页面的示例：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/pine1.png" alt="Alpine 邮件客户端显示问候页面。"/>
</div>
</div>
<div class="paragraph">
<p>然后显示主菜单，可以使用光标键进行导航。该主菜单提供了快捷方式，用于撰写新邮件、浏览邮件目录和管理通讯录条目。在主菜单下方，显示了与当前任务相关的执行特定功能的键盘快捷键。</p>
</div>
<div class="paragraph">
<p>alpine 打开的默认目录是 <span class="filename">inbox</span> 。要查看消息索引，请按下 <kbd>I</kbd> ，或选择下面显示的 <span class="guimenuitem">MESSAGE INDEX</span> 选项。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/pine2.png" alt="Alpine 邮件客户端显示默认目录。"/>
</div>
</div>
<div class="paragraph">
<p>消息索引显示当前目录中的消息，并可以使用光标键进行导航。按下 <kbd>Enter</kbd> 可以阅读突出显示的消息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/pine3.png" alt="Alpine 邮件客户端显示消息索引"/>
</div>
</div>
<div class="paragraph">
<p>在下面的截图中， alpine 显示了一个示例消息。屏幕底部显示了上下文键盘快捷键。一个快捷键的示例是 <kbd>r</kbd> ，它告诉 MUA 回复当前显示的消息。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/pine4.png" alt="阿尔派恩邮件客户端显示一封电子邮件。"/>
</div>
</div>
<div class="paragraph">
<p>在 alpine 中回复电子邮件是使用 pico 编辑器完成的， pico 编辑器是 alpine 的默认安装选项。 pico 编辑器使得浏览邮件变得容易，并且对于新手用户来说比 <a href="https://man.freebsd.org/cgi/man.cgi?query=vi&amp;sektion=1&amp;format=html">vi(1)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 更容易使用。完成回复后，按下 <span class="keyseq"><kbd>Ctrl</kbd>+<kbd>X</kbd></span> 即可发送邮件。在发送邮件之前， alpine 会要求确认。</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/mail/pine5.png" alt="阿尔派恩邮件客户端显示消息撰写窗口"/>
</div>
</div>
<div class="paragraph">
<p>可以使用主菜单中的 <span class="guimenuitem">SETUP</span> 选项来自定义 Alpine 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mail-advanced">31.7. 高级主题<a class="anchor" href="#mail-advanced"></a></h3>
<div class="paragraph">
<p>本节涵盖了更复杂的主题，如邮件配置和为整个域名设置邮件。</p>
</div>
<div class="sect3">
<h4 id="mail-config">31.7.1. 基本配置<a class="anchor" href="#mail-config"></a></h4>
<div class="paragraph">
<p>只要配置了 <span class="filename">/etc/resolv.conf</span> 或者网络可以访问到配置的 DNS 服务器，就可以直接向外部主机发送电子邮件。要将电子邮件传递到 FreeBSD 主机上的 MTA ，请执行以下操作之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>为该域名运行一个 DNS 服务器。</p>
</li>
<li>
<p>将邮件直接发送到机器的 FQDN 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>为了直接将邮件投递到主机，它必须拥有一个永久的静态 IP 地址，而不是动态 IP 地址。如果系统位于防火墙后面，必须配置防火墙以允许 SMTP 流量。要在主机上直接接收邮件，必须配置以下两种方式之一：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保 DNS 中最低编号的 MX 记录指向主机的静态 IP 地址。</p>
</li>
<li>
<p>确保 DNS 中没有主机的 MX 记录。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>以上两种方法都可以直接将邮件发送到主机。</p>
</div>
<div class="paragraph">
<p>试试这个：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hostname</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>example.FreeBSD.org</pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># host example.FreeBSD.org</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>example.FreeBSD.org has address 204.216.27.XX</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，直接发送到 mailto:yourlogin @ example.FreeBSD.org[yourlogin @ example.FreeBSD.org] 的邮件应该可以正常工作，前提是在 <code>example.FreeBSD.org</code> 上运行了一个功能齐全的 MTA 。请注意， <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 不会在端口 25 上监听传入连接，因此在这种情况下不能使用它。</p>
</div>
<div class="paragraph">
<p>对于这个例子：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># host example.FreeBSD.org</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>example.FreeBSD.org has address 204.216.27.XX
example.FreeBSD.org mail is handled (pri=10) by nevdull.FreeBSD.org</pre>
</div>
</div>
<div class="paragraph">
<p>所有发送到 <code>example.FreeBSD.org</code> 的邮件将会被收集在 <code>nevdull</code> 上，使用相同的用户名，而不是直接发送到您的主机。</p>
</div>
<div class="paragraph">
<p>上述信息由 DNS 服务器处理。携带邮件路由信息的 DNS 记录是邮件交换器记录（ MX 记录）。如果不存在 MX 记录，则邮件将通过其 IP 地址直接传递给主机。</p>
</div>
<div class="paragraph">
<p><code>freefall.FreeBSD.org</code> 的 MX 记录曾经是这样的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>freefall		MX	30	mail.crl.net
freefall		MX	40	agora.rdrop.com
freefall		MX	10	freefall.FreeBSD.org
freefall		MX	20	who.cdrom.com</pre>
</div>
</div>
<div class="paragraph">
<p><code>freefall</code> 有许多 MX 记录。最低的 MX 号码对应的主机直接接收邮件，如果可用的话。如果由于某种原因无法访问该主机，下一个较低编号的主机将暂时接收邮件，并在较低编号的主机可用时将其传递。</p>
</div>
<div class="paragraph">
<p>备用 MX 站点应该有独立的互联网连接，以便发挥最大的作用。您的互联网服务提供商可以提供这项服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="mail-domain">31.7.2. 域名的邮件<a class="anchor" href="#mail-domain"></a></h4>
<div class="paragraph">
<p>在为网络配置邮件传输代理（ MTA ）时，任何发送到其域中的主机的邮件都应该被重定向到 MTA ，以便用户可以在主邮件服务器上接收到他们的邮件。</p>
</div>
<div class="paragraph">
<p>为了使生活更加方便，在 MTA 和带有 MUA 的系统上应该存在相同的用户名的用户账户。使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=adduser&amp;sektion=8&amp;format=html">adduser(8)</a> 命令来创建用户账户。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除了将本地用户添加到主机上之外，还有一种称为虚拟用户的替代方法。像 Cyrus 和 Dovecot 这样的程序可以集成到 MTA 中，用于处理用户、邮件存储，并通过 POP3 和 IMAP 提供访问。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>MTA 必须成为网络上每个工作站的指定邮件交换器。这是通过 DNS 配置中的 MX 记录来完成的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>example.FreeBSD.org	A	204.216.27.XX		; Workstation
			MX	10 nevdull.FreeBSD.org	; Mailhost</pre>
</div>
</div>
<div class="paragraph">
<p>无论 A 记录指向何处，这将把工作站的邮件重定向到 MTA 。邮件将发送到 MX 主机。</p>
</div>
<div class="paragraph">
<p>这必须在 DNS 服务器上进行配置。如果网络没有运行自己的 DNS 服务器，请与 ISP 或 DNS 提供商联系。</p>
</div>
<div class="paragraph">
<p>以下是虚拟邮件托管的示例。</p>
</div>
<div class="paragraph">
<p>考虑一个域名为 <code>customer1.org</code> 的客户，所有发送给 <code>customer1.org</code> 的邮件都应该发送到 <code>mail.myhost.com</code> 。</p>
</div>
<div class="paragraph">
<p>DNS 条目应该如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>customer1.org		MX	10	mail.myhost.com</pre>
</div>
</div>
<div class="paragraph">
<p>为了仅处理 <code>customer1.org</code> 域名的电子邮件，不需要为其创建 <code>A</code> 记录。然而，如果没有为 <code>customer1.org</code> 创建 <code>A</code> 记录，则无法使用 <code>ping</code> 命令对其进行测试。</p>
</div>
<div class="paragraph">
<p>告诉 MTA 应该接受哪些域名和 / 或主机名的邮件。对于 Sendmail ，以下任一方式都可以使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在使用 <code>FEATURE(use_cw_file)</code> 时，将主机添加到 <span class="filename">/etc/mail/local-host-names</span> 中。</p>
</li>
<li>
<p>在 <span class="filename">/etc/sendmail.cf</span> 文件中添加一行 <code>Cwyour.host.com</code> 。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="outgoing-only">31.7.3. 设置仅发送的配置<a class="anchor" href="#outgoing-only"></a></h4>
<div class="paragraph">
<p>有许多情况下，人们可能只想通过中继发送邮件。一些例子包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>计算机是一台台式机，需要使用诸如 <a href="https://man.freebsd.org/cgi/man.cgi?query=mail&amp;sektion=1&amp;format=html">mail(1)</a> 这样的程序，使用 ISP 的邮件中继。</p>
</li>
<li>
<p>计算机是一个服务器，不处理本地邮件，但需要将所有邮件传递给中继进行处理。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>虽然任何邮件传输代理（ MTA ）都能够满足这个特定需求，但是仅仅为了处理邮件转发而正确配置一个功能齐全的 MTA 可能会很困难。像 Sendmail 和 Postfix 这样的程序对于这种用途来说过于复杂。</p>
</div>
<div class="paragraph">
<p>此外，一个典型的互联网接入服务协议可能禁止用户运行“邮件服务器”。</p>
</div>
<div class="paragraph">
<p>满足这些需求的最简单方法是使用包含在 <a href="#configuring-dragonfly-mail-agent ，基本系统 ">[configuring-dragonfly-mail-agent ，基本系统 ]</a> 中的 <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> MTA 。对于版本低于 13.2 的系统，需要从 ports 进行安装。</p>
</div>
<div class="paragraph">
<p>除了 <a href="https://man.freebsd.org/cgi/man.cgi?query=dma&amp;sektion=8&amp;format=html">dma(8)</a> 之外，还可以使用第三方软件来实现相同的功能，比如 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/ssmtp/">mail/ssmtp</a> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/mail/ssmtp</span>
<span class="c"># make install replace clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>安装完成后，可以使用 <span class="filename">/usr/local/etc/ssmtp/ssmtp.conf</span> 配置 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/ssmtp/">mail/ssmtp</a> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>root=yourrealemail@example.com
mailhub=mail.example.com
rewriteDomain=example.com
hostname=_HOSTNAME_</pre>
</div>
</div>
<div class="paragraph">
<p>使用真实的电子邮件地址替换 <code>root</code> 。在 <code>mail.example.com</code> 的位置输入 ISP 的出站邮件中继。一些 ISP 称其为“出站邮件服务器”或“ SMTP 服务器”。</p>
</div>
<div class="paragraph">
<p>请确保禁用 Sendmail ，包括出站邮件服务。有关详细信息，请参阅 <a href="#mail-disable-sendmail">[mail-disable-sendmail]</a> 。</p>
</div>
<div class="paragraph">
<p>包： mail/ssmtp[] 还有其他可用的选项。有关更多信息，请参阅 <span class="filename">/usr/local/etc/ssmtp</span> 中的示例或 ssmtp 的手册页。</p>
</div>
<div class="paragraph">
<p>以这种方式设置 ssmtp 允许计算机上需要发送邮件的任何软件正常运行，同时不违反 ISP 的使用政策，也不允许计算机被劫持用于发送垃圾邮件。</p>
</div>
</div>
<div class="sect3">
<h4 id="SMTP-Auth">31.7.4. Sendmail 中的 SMTP 身份验证<a class="anchor" href="#SMTP-Auth"></a></h4>
<div class="paragraph">
<p>在 MTA 上配置 SMTP 身份验证提供了许多好处。 SMTP 身份验证为 Sendmail 增加了一层安全性，并为切换主机的移动用户提供了在不需要每次重新配置邮件客户端设置的情况下使用相同 MTA 的能力。</p>
</div>
<div class="paragraph">
<p>从 Ports Collection 安装包： security/cyrus-sasl2[] 。该端口支持许多编译时选项。对于在此示例中演示的 SMTP 身份验证方法，请确保 <code>LOGIN</code> 未禁用。</p>
</div>
<div class="paragraph">
<p>安装完包 :security/cyrus-sasl2[] 后，编辑 <span class="filename">/usr/local/lib/sasl2/Sendmail.conf</span> ，如果该文件不存在则创建，并添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pwcheck_method: saslauthd</pre>
</div>
</div>
<div class="paragraph">
<p>接下来，安装包： security/cyrus-sasl2-saslauthd[] ，并执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc saslauthd_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>最后，启动 saslauthd 守护进程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service saslauthd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该守护进程用作 Sendmail 的代理，用于对 FreeBSD <a href="https://man.freebsd.org/cgi/man.cgi?query=passwd&amp;sektion=5&amp;format=html">passwd(5)</a> 数据库进行身份验证。这样可以避免为每个需要使用 SMTP 身份验证的用户创建新的用户名和密码，并保持登录和邮件密码相同。</p>
</div>
<div class="paragraph">
<p>接下来，编辑 [/etc/make.conf] 文件，并添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>SENDMAIL_CFLAGS=-I/usr/local/include/sasl -DSASL
SENDMAIL_LDADD=/usr/local/lib/libsasl2.so</pre>
</div>
</div>
<div class="paragraph">
<p>这些行为 Sendmail 提供了在编译时链接到 <a class="package" href="https://cgit.freebsd.org/ports/tree/cyrus-sasl2/">cyrus-sasl2</a> 的正确配置选项。在重新编译 Sendmail 之前，请确保已安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/cyrus-sasl2/">cyrus-sasl2</a> 。</p>
</div>
<div class="paragraph">
<p>通过执行以下命令重新编译 Sendmail ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src/lib/libsmutil</span>
<span class="c"># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class="c"># cd /usr/src/lib/libsm</span>
<span class="c"># make cleandir &amp;&amp; make obj &amp;&amp; make</span>
<span class="c"># cd /usr/src/usr.sbin/sendmail</span>
<span class="c"># make cleandir &amp;&amp; make obj &amp;&amp; make &amp;&amp; make install</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <span class="filename">/usr/src</span> 没有发生大量更改，并且所需的共享库可用，那么这个编译过程不应该出现任何问题。</p>
</div>
<div class="paragraph">
<p>在重新编译和安装 Sendmail 之后，编辑 [/etc/mail/freebsd.mc] 或本地 [.mc] 文件。许多管理员选择使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=hostname&amp;sektion=1&amp;format=html">hostname(1)</a> 的输出作为 [.mc] 文件的名称，以确保唯一性。</p>
</div>
<div class="paragraph">
<p>添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dnl set SASL options
TRUST_AUTH_MECH(`GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl
define(`confAUTH_MECHANISMS&#39;, `GSSAPI DIGEST-MD5 CRAM-MD5 LOGIN&#39;)dnl</pre>
</div>
</div>
<div class="paragraph">
<p>这些选项配置了 Sendmail 用于对用户进行身份验证的不同方法。如果要使用除 pwcheck 之外的方法，请参考 Sendmail 文档。</p>
</div>
<div class="paragraph">
<p>最后，在 [/etc/mail] 目录下运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=make&amp;sektion=1&amp;format=html">make(1)</a> 。这将运行新的 .mc 文件并创建一个名为 freebsd.cf 或者与本地 .mc 文件相同的名称的 .cf 文件。</p>
</div>
<div class="paragraph">
<p>然后，运行 <code>make install restart</code> 命令，它将会把文件复制到 <span class="filename">sendmail.cf</span> ，并且正确地重新启动 Sendmail 。</p>
</div>
<div class="paragraph">
<p>有关此过程的更多信息，请参考 [/etc/mail/Makefile](/etc/mail/Makefile) 。</p>
</div>
<div class="paragraph">
<p>要测试配置，请使用 MUA 发送一封测试邮件。如需进一步调查，请将 Sendmail 的 <code>LogLevel</code> 设置为 <code>13</code> ，并观察 <code>/var/log/maillog</code> 中是否有任何错误。</p>
</div>
<div class="paragraph">
<p>有关更多信息，请参考 <a href="http://www.sendmail.org/" class="bare">http://www.sendmail.org/</a> ~ ca/email/auth.html[SMTP 认证] 。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="network-servers">Chapter 32. 网络服务器<a class="anchor" href="#network-servers"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="network-servers-synopsis">32.1. 简介<a class="anchor" href="#network-servers-synopsis"></a></h3>
<div class="paragraph">
<p>本章介绍了 UNIX® 系统上一些常用的网络服务。这包括安装、配置、测试和维护许多不同类型的网络服务。本章中还包含了示例配置文件，供参考使用。</p>
</div>
<div class="paragraph">
<p>到本章结束时，读者将会了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何管理 inetd 守护进程。</p>
</li>
<li>
<p>如何设置网络文件系统（ NFS ）。</p>
</li>
<li>
<p>如何设置网络信息服务器（ NIS ）以实现用户账户的集中和共享。</p>
</li>
<li>
<p>如何将 FreeBSD 设置为 LDAP 服务器或客户端</p>
</li>
<li>
<p>如何使用 DHCP 设置自动网络设置。</p>
</li>
<li>
<p>如何设置域名服务器（ DNS ）。</p>
</li>
<li>
<p>如何设置 Apache HTTP 服务器。</p>
</li>
<li>
<p>如何设置一个文件传输协议（ FTP ）服务器。</p>
</li>
<li>
<p>如何使用 Samba 为 Windows® 客户端设置文件和打印服务器。</p>
</li>
<li>
<p>如何使用网络时间协议（ NTP ）同步时间和日期，并设置时间服务器。</p>
</li>
<li>
<p>如何设置 iSCSI 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>本章假设读者具备以下基本知识：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="filename">/etc/rc</span> 脚本。</p>
</li>
<li>
<p>网络术语。</p>
</li>
<li>
<p>安装额外的第三方软件（参考： ports[ports ，安装应用程序：软件包和端口] ）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="network-inetd">32.2. inetd 超级服务器<a class="anchor" href="#network-inetd"></a></h3>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 守护进程有时被称为超级服务器，因为它管理许多服务的连接。不需要启动多个应用程序，只需启动 inetd 服务即可。当 inetd 接收到由其管理的服务的连接时，它确定连接所需的程序，为该程序生成一个进程，并为该程序分配一个套接字。与在独立模式下单独运行每个守护进程相比，使用 inetd 来处理不常用的服务可以减少系统负载。</p>
</div>
<div class="paragraph">
<p>inetd 主要用于生成其他守护进程，但也会处理一些内部的简单协议，例如 chargen 、 auth 、 time 、 echo 、 discard 和 daytime 。</p>
</div>
<div class="paragraph">
<p>本节介绍了配置 inetd 的基础知识。</p>
</div>
<div class="sect3">
<h4 id="network-inetd-conf">32.2.1. 配置文件<a class="anchor" href="#network-inetd-conf"></a></h4>
<div class="paragraph">
<p>配置 inetd 是通过编辑 /etc/inetd.conf 文件来完成的。该配置文件的每一行表示一个可以由 inetd 启动的应用程序。默认情况下，每一行都以注释（ # + # ）开头，表示 inetd 不监听任何应用程序。要配置 inetd 监听应用程序的连接，请删除该应用程序行开头的 # + # 。</p>
</div>
<div class="paragraph">
<p>在保存您的编辑后，通过编辑 [/etc/rc.conf] 配置 inetd 在系统启动时启动：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>inetd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要立即启动 inetd ，以便它监听您配置的服务，请键入：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service inetd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦 inetd 启动，每当对 /etc/inetd.conf 文件进行修改时，需要通知它。</p>
</div>
<div id="network-inetd-reread" class="exampleblock">
<div class="title">例 35. 重新加载 inetd 配置文件</div>
<div class="content">
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service inetd reload</span></code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>通常情况下，应用程序的默认条目无需编辑，只需删除 <code>#</code> 即可。在某些情况下，可能需要编辑默认条目。</p>
</div>
<div class="paragraph">
<p>作为一个例子，这是 IPv4 上 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> 的默认条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ftp     stream  tcp     nowait  root    /usr/libexec/ftpd       ftpd -l</pre>
</div>
</div>
<div class="paragraph">
<p>一个条目中的七列如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>service-name
socket-type
protocol
{wait|nowait}[/max-child[/max-connections-per-ip-per-minute[/max-child-per-ip]]]
user[:group][/login-class]
server-program
server-program-arguments</pre>
</div>
</div>
<div class="paragraph">
<p>在哪里：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">服务名称</dt>
<dd>
<p>要启动的守护进程的服务名称。它必须对应于 <span class="filename">/etc/services</span> 中列出的服务。这决定了 inetd 监听哪个端口以接收该服务的传入连接。当使用自定义服务时，必须首先将其添加到 <span class="filename">/etc/services</span> 中。</p>
</dd>
<dt class="hdlist1">套接字类型</dt>
<dd>
<p>可以使用 <code>stream</code> 、 <code>dgram</code> 、 <code>raw</code> 或 <code>seqpacket</code> 。对于 TCP 连接，请使用 <code>stream</code> ，对于 UDP 服务，请使用 <code>dgram</code> 。</p>
</dd>
<dt class="hdlist1">协议</dt>
<dd>
<p>使用以下协议名称之一：</p>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">协议名称</th>
<th class="tableblock halign-left valign-top">解释</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">tcp 或 tcp4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP （传输控制协议）是一种用于在计算机网络中传输数据的协议。它提供了可靠的、面向连接的通信，确保数据的可靠性和顺序性。 IPv4 （互联网协议版本 4 ）是一种用于在互联网上进行数据传输的协议。它定义了互联网上的设备如何寻址和路由数据包。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP 或 UDP4</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP 是用户数据报协议（ User Datagram Protocol ）的缩写，它是一种在计算机网络中常用的传输协议。 UDP 提供了一种无连接、不可靠的数据传输方式，适用于对数据传输延迟要求较低的应用场景。</p>
<p class="tableblock"> IPv4 是互联网协议第四版（ Internet Protocol version 4 ）的缩写，它是目前广泛使用的互联网协议之一。 IPv4 使用 32 位地址来标识网络上的设备，它定义了数据在网络中的传输方式和路由规则。</p>
<p class="tableblock">在计算机网络中， UDP 和 IPv4 通常一起使用， UDP 负责提供数据传输的功能，而 IPv4 负责定义数据在网络中的传输路径。这种组合常用于实时音视频传输、网络游戏等应用中。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP6 是指 IPv6 上的 TCP 协议。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP IPv6 是一种基于 IPv6 协议的传输控制协议。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP6 是 IPv6 上的用户数据报协议。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP 是一种传输层协议，用于在计算机网络中传输数据。 IPv6 是 Internet 协议的第六个版本，用于在互联网上唯一标识和定位设备。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP46 是一种网络传输协议，它是 TCP/IP 协议族中的一部分。它是 IPv6 （ Internet Protocol version 6 ）的一种扩展，用于在 IPv6 网络中进行可靠的数据传输。 TCP46 提供了面向连接的、可靠的、有序的数据传输服务，以及流量控制和拥塞控制机制，确保数据的可靠性和稳定性。与 IPv4 相比， TCP46 支持更大的地址空间和更高的安全性，是未来互联网发展的重要组成部分。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">TCP IPv4 和 IPv6 都是网络协议。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP46 是一种基于 IPv6 的用户数据报协议。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">UDP IPv4 和 IPv6 都支持。</p></td>
</tr>
</tbody>
</table>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在这个字段中，必须指定 <code>wait</code> 或 <code>nowait</code> 。 <code>max-child</code> 、 <code>max-connections-per-ip-per-minute</code> 和 <code>max-child-per-ip</code> 是可选的。</p>
</div>
<div class="paragraph">
<p>+
<code>wait | nowait</code> 表示服务是否能够处理自己的套接字。 <code>dgram</code> 套接字类型必须使用 <code>wait</code> ，而通常是多线程的 <code>stream</code> 守护进程应该使用 <code>nowait</code> 。 <code>wait</code> 通常将多个套接字交给单个守护进程处理，而 <code>nowait</code> 则为每个新套接字生成一个子守护进程。</p>
</div>
<div class="paragraph">
<p>+
<code>max-child</code> 参数设置了 inetd 可以生成的子守护进程的最大数量。例如，要限制守护进程的实例数为十个，可以在 <code>nowait</code> 后面加上 <code>/10</code> 。指定 <code>/0</code> 允许无限数量的子进程。</p>
</div>
<div class="paragraph">
<p>+
<code>max-connections-per-ip-per-minute</code> 限制每个特定 IP 地址每分钟的连接数。一旦达到限制，该 IP 地址的进一步连接将被丢弃，直到分钟结束。例如，值为 <code>/10</code> 将限制每个特定 IP 地址每分钟的连接尝试次数为十次。 <code>max-child-per-ip</code> 限制在任何单个 IP 地址上代表启动的子进程数量。这些选项可以限制过度的资源消耗，并帮助防止拒绝服务攻击。</p>
</div>
<div class="paragraph">
<p>+
在 <a href="https://man.freebsd.org/cgi/man.cgi?query=fingerd&amp;sektion=8&amp;format=html">fingerd(8)</a> 的默认设置中可以看到一个示例：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>finger stream  tcp     nowait/3/10 nobody /usr/libexec/fingerd fingerd -k -s</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">用户</dt>
<dd>
<p>守护进程将以哪个用户名运行。守护进程通常以 <code>root</code> 、 <code>daemon</code> 或 <code>nobody</code> 运行。</p>
</dd>
<dt class="hdlist1">服务器程序</dt>
<dd>
<p>守护进程的完整路径。如果守护进程是由 inetd 内部提供的服务，请使用 <code>internal</code> 。</p>
</dd>
<dt class="hdlist1">服务器程序参数</dt>
<dd>
<p>用于指定在调用守护程序时要传递的任何命令参数。如果守护程序是内部服务，请使用 <code>internal</code> 。</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="network-inetd-cmdline">32.2.2. 命令行选项<a class="anchor" href="#network-inetd-cmdline"></a></h4>
<div class="paragraph">
<p>像大多数服务器守护程序一样， inetd 有一些选项可以用来修改其行为。默认情况下， inetd 使用 <code>-wW -C 60</code> 启动。这些选项启用了所有服务的 TCP 包装器，包括内部服务，并防止任何 IP 地址在一分钟内请求超过 60 次的服务。</p>
</div>
<div class="paragraph">
<p>要更改传递给 inetd 的默认选项，请在 <code>/etc/rc.conf</code> 中添加一个 <code>inetd_flags</code> 条目。如果 inetd 已经在运行，请使用 <code>service inetd restart</code> 重新启动它。</p>
</div>
<div class="paragraph">
<p>可用的速率限制选项有：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">-c 最大值</dt>
<dd>
<p>指定每个服务的默认最大并发调用数，其中默认值为无限制。可以通过在 <code>/etc/inetd.conf</code> 中使用 <code>max-child</code> 来对每个服务进行单独设置。</p>
</dd>
<dt class="hdlist1">-C 速率</dt>
<dd>
<p>指定单个 IP 地址每分钟可以调用服务的默认最大次数。可以通过在 <code>/etc/inetd.conf</code> 中使用 <code>max-connections-per-ip-per-minute</code> 来覆盖每个服务的基础上。</p>
</dd>
<dt class="hdlist1">-R rate</dt>
<dd>
<p>指定一个服务在一分钟内可以被调用的最大次数，其中默认值为 <code>256</code> 。设置为 <code>0</code> 表示允许无限次调用。</p>
</dd>
<dt class="hdlist1">-s maximum 的中文翻译是“ -s 最大值”。</dt>
<dd>
<p>指定单个 IP 地址在任何一次中可以调用服务的最大次数，其中默认值为无限。可以通过在 <code>/etc/inetd.conf</code> 中使用 <code>max-child-per-ip</code> 来覆盖每个服务的基础设置。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>还有其他选项可用。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> 获取完整的选项列表。</p>
</div>
</div>
<div class="sect3">
<h4 id="network-inetd-security">32.2.3. 安全考虑<a class="anchor" href="#network-inetd-security"></a></h4>
<div class="paragraph">
<p>许多可以由 inetd 管理的守护进程并不注重安全性。一些守护进程，比如 fingerd ，可能提供对攻击者有用的信息。只启用所需的服务，并监控系统是否存在过多的连接尝试。可以使用 <code>max-connections-per-ip-per-minute</code> 、 <code>max-child</code> 和 <code>max-child-per-ip</code> 来限制此类攻击。</p>
</div>
<div class="paragraph">
<p>默认情况下， TCP 包装器是启用的。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=hosts_access&amp;sektion=5&amp;format=html">hosts_access(5)</a> 了解如何在各种 inetd 调用的守护进程上设置 TCP 限制的更多信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-nfs">32.3. 网络文件系统（ NFS ）<a class="anchor" href="#network-nfs"></a></h3>
<div class="paragraph">
<p>FreeBSD 支持网络文件系统（ NFS ），它允许服务器通过网络与客户端共享目录和文件。使用 NFS ，用户和程序可以像访问本地存储的文件一样访问远程系统上的文件。</p>
</div>
<div class="paragraph">
<p>NFS 有许多实际用途。其中一些常见的用途包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>在网络上，原本需要在每个客户端上重复的数据可以保存在一个单一的位置，并且可以被网络上的客户端访问。</p>
</li>
<li>
<p>多个客户端可能需要访问 <span class="filename">/usr/ports/distfiles</span> 目录。共享该目录可以快速访问源文件，而无需将它们下载到每个客户端。</p>
</li>
<li>
<p>在大型网络中，通常更方便地配置一个中央 NFS 服务器，用于存储所有用户的主目录。用户可以在网络中的任何客户端登录，并访问他们的主目录。</p>
</li>
<li>
<p>NFS 导出的管理变得更加简化。例如，只需要在一个文件系统中设置安全性或备份策略。</p>
</li>
<li>
<p>可移动媒体存储设备可以被网络上的其他机器使用。这减少了网络中设备的数量，并提供了一个集中管理安全性的位置。从集中安装媒体上安装软件到多台机器上通常更加方便。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>NFS 由一个服务器和一个或多个客户端组成。客户端远程访问存储在服务器机器上的数据。为了使其正常运行，需要配置和运行一些进程。</p>
</div>
<div class="paragraph">
<p>这些守护进程必须在服务器上运行：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">守护进程</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">nfsd 是 Network File System （网络文件系统）的守护进程。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NFS 守护进程负责为 NFS 客户端提供服务。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">mountd 是一个在 Unix 和类 Unix 系统上运行的守护进程，它负责处理文件系统的挂载和卸载操作。它接收来自客户端的挂载请求，并将其转发给相应的文件系统。 mountd 还负责维护挂载表，记录当前已挂载的文件系统信息。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NFS 挂载守护进程负责处理从 nfsd 接收到的请求。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">rpcbind 是一个用于绑定远程过程调用（ RPC ）服务的工具。它允许客户端程序通过网络连接到服务器上的 RPC 服务，并调用远程过程。 rpcbind 在服务器上监听指定的端口，以便客户端可以找到并连接到 RPC 服务。它还负责将 RPC 程序的端口号映射到相应的 RPC 程序版本。 rpcbind 在计算机网络中起到了重要的作用，使得不同计算机之间可以进行远程过程调用。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该守护进程允许 NFS 客户端发现 NFS 服务器正在使用的端口。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在客户端上运行 nfsiod[8] 可以提高性能，但不是必需的。</p>
</div>
<div class="sect3">
<h4 id="network-configuring-nfs">32.3.1. 配置服务器<a class="anchor" href="#network-configuring-nfs"></a></h4>
<div class="paragraph">
<p>NFS 服务器将共享的文件系统在 [/etc/exports] 文件中指定。该文件中的每一行都指定了要导出的文件系统，客户端对该文件系统的访问权限以及任何访问选项。在向该文件添加条目时，每个导出的文件系统、其属性和允许的主机必须出现在同一行上。如果条目中没有列出客户端，则任何网络上的客户端都可以挂载该文件系统。</p>
</div>
<div class="paragraph">
<p>以下是示例的 <span class="filename">/etc/exports</span> 条目，演示了如何导出文件系统。这些示例可以根据读者网络上的文件系统和客户端名称进行修改。在此文件中可以使用许多选项，但这里只提到了一些。有关所有选项的完整列表，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=exports&amp;sektion=5&amp;format=html">exports(5)</a> 。</p>
</div>
<div class="paragraph">
<p>这个示例展示了如何将 <span class="filename">/cdrom</span> 导出到名为 <em>alpha</em>、<em>bravo</em> 和 <em>charlie</em> 的三台主机：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/cdrom -ro alpha bravo charlie</pre>
</div>
</div>
<div class="paragraph">
<p><code>-ro</code> 标志使文件系统变为只读，防止客户端对导出的文件系统进行任何更改。此示例假设主机名要么在 DNS 中，要么在 <code>/etc/hosts</code> 文件中。如果网络没有 DNS 服务器，请参考 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=hosts&amp;sektion=5&amp;format=html">hosts(5)</a></code> 。</p>
</div>
<div class="paragraph">
<p>下面的示例通过 IP 地址将 <code>/home</code> 导出给三个客户端。这对于没有 DNS 或 <code>/etc/hosts</code> 条目的网络非常有用。 <code>-alldirs</code> 标志允许子目录作为挂载点。换句话说，它不会自动挂载子目录，但会允许客户端根据需要挂载所需的目录。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/usr/home  -alldirs  10.0.0.2 10.0.0.3 10.0.0.4</pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例将 <span class="filename">/a</span> 导出，以便来自不同域的两个客户端可以访问该文件系统。 <code>-maproot = root</code> 允许远程系统上的 <code>root</code> 用户以 <code>root</code> 身份在导出的文件系统上写入数据。如果未指定 <code>-maproot = root</code> ，客户端的 <code>root</code> 用户将被映射到服务器的 <code>nobody</code> 账户，并受到为 <code>nobody</code> 定义的访问限制的约束。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/a  -maproot=root  host.example.com box.example.org</pre>
</div>
</div>
<div class="paragraph">
<p>每个文件系统只能指定一个客户端。例如，如果 <span class="filename">/usr</span> 是一个单独的文件系统，那么这些条目将是无效的，因为两个条目都指定了相同的主机：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Invalid when /usr is one file system
/usr/src   client
/usr/ports client</pre>
</div>
</div>
<div class="paragraph">
<p>在这种情况下，正确的格式是使用一个条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/usr/src /usr/ports  client</pre>
</div>
</div>
<div class="paragraph">
<p>下面是一个有效的导出列表示例，其中 <span class="filename">/usr</span> 和 <span class="filename">/exports</span> 是本地文件系统：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Export src and ports to client01 and client02, but only
# client01 has root privileges on it
/usr/src /usr/ports -maproot=root    client01
/usr/src /usr/ports               client02
# The client machines have root and can mount anywhere
# on /exports. Anyone in the world can mount /exports/obj read-only
/exports -alldirs -maproot=root      client01 client02
/exports/obj -ro</pre>
</div>
</div>
<div class="paragraph">
<p>要在启动时启用 NFS 服务器所需的进程，请将以下选项添加到 /etc/rc.conf 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rpcbind_enable=&#34;YES&#34;
nfs_server_enable=&#34;YES&#34;
mountd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>现在可以通过运行以下命令来启动服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service nfsd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>每当 NFS 服务器启动时， mountd 也会自动启动。然而， mountd 只在启动时读取 /etc/exports 文件。为了使后续对 /etc/exports 文件的编辑立即生效，强制 mountd 重新读取它：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service mountd reload</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=nfsv4&amp;sektion=4&amp;format=html">nfsv4(4)</a> 了解 NFS 版本 4 的设置描述。</p>
</div>
</div>
<div class="sect3">
<h4 id="_配置客户端">32.3.2. 配置客户端<a class="anchor" href="#_配置客户端"></a></h4>
<div class="paragraph">
<p>要启用 NFS 客户端，请在每个客户端的 /etc/rc.conf 文件中设置此选项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nfs_client_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后，在每个 NFS 客户端上运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service nfsclient start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>客户端现在已经拥有了挂载远程文件系统所需的一切。在这些示例中，服务器的名称是 <code>server</code> ，客户端的名称是 <code>client</code> 。要将 <code>server</code> 上的 <span class="filename">/home</span> 挂载到 <code>client</code> 上的 <span class="filename">/mnt</span> 挂载点，可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount server:/home /mnt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在，位于 [/home] 目录中的文件和目录将在 <code>client</code> 上的 [/mnt] 目录中可用。</p>
</div>
<div class="paragraph">
<p>要在每次客户端启动时挂载远程文件系统，请将其添加到 [/etc/fstab] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>server:/home	/mnt	nfs	rw	0	0</pre>
</div>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=fstab&amp;sektion=5&amp;format=html">fstab(5)</a> ，了解所有可用选项的描述。</p>
</div>
</div>
<div class="sect3">
<h4 id="_锁定">32.3.3. 锁定<a class="anchor" href="#_锁定"></a></h4>
<div class="paragraph">
<p>某些应用程序需要文件锁定才能正常运行。要启用锁定，请在客户端和服务器上执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc rpc_lockd_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后启动服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service lockd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果服务器上不需要锁定，可以在运行 mount 时包含 <code>-L</code> 来配置 NFS 客户端进行本地锁定。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mount_nfs&amp;sektion=8&amp;format=html">mount_nfs(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="network-autofs">32.3.4. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 自动挂载<a class="anchor" href="#network-autofs"></a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 自动挂载功能从 FreeBSD 10.1-RELEASE 开始得到支持。要在旧版本的 FreeBSD 中使用自动挂载功能，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> 。本章仅描述 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 自动挂载器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 设施是几个组件的通用名称，这些组件一起允许在访问文件系统中的文件或目录时自动挂载远程和本地文件系统。它由内核组件 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 和几个用户空间应用程序 <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a> 组成。它作为先前的 FreeBSD 版本中 <a href="https://man.freebsd.org/cgi/man.cgi?query=amd&amp;sektion=8&amp;format=html">amd(8)</a> 的替代品。 amd 仍然提供向后兼容性，因为两者使用不同的映射格式； autofs 使用的映射格式与其他 SVR4 自动挂载程序（如 Solaris 、 MacOS X 和 Linux 中的自动挂载程序）相同。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 虚拟文件系统由 <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a> 在指定的挂载点上挂载，通常在启动过程中调用。</p>
</div>
<div class="paragraph">
<p>每当一个进程尝试访问 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 挂载点中的文件时，内核将通知 <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> 守护进程并暂停触发进程。 <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> 守护进程将通过查找正确的映射并根据其挂载文件系统来处理内核请求，然后向内核发出释放被阻塞进程的信号。 <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a> 守护进程会在一段时间后自动卸载自动挂载的文件系统，除非它们仍在使用中。</p>
</div>
<div class="paragraph">
<p>主要的 autofs 配置文件是 <code>/etc/auto_master</code> 。它将各个映射分配给顶级挂载点。有关 <code>auto_master</code> 和映射语法的解释，请参考 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a></code> 。</p>
</div>
<div class="paragraph">
<p>在 <span class="filename">/net</span> 上挂载了一个特殊的自动挂载映射。当在该目录中访问文件时， <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 会查找相应的远程挂载并自动挂载它。例如，尝试访问 <span class="filename">/net/foobar/usr</span> 中的文件会告诉 <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> 从主机 <code>foobar</code> 挂载 <span class="filename">/usr</span> 导出。</p>
</div>
<div class="exampleblock">
<div class="title">例 36. 使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 挂载一个导出目录</div>
<div class="content">
<div class="paragraph">
<p>在这个例子中， <code>showmount -e</code> 显示了可以从 NFS 服务器 <code>foobar</code> 挂载的导出文件系统。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>showmount -e foobar
Exports list on foobar:
/usr                               10.10.10.0
/a                                 10.10.10.0
<span class="gp">% </span><span class="nb">cd</span> /net/foobar/usr</code></pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p><code>showmount</code> 命令的输出显示 [/usr] 目录被导出。当切换到 [/host/foobar/usr] 目录时， <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> 会拦截请求并尝试解析主机名 <code>foobar</code> 。如果成功， <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> 会自动挂载源导出。</p>
</div>
<div class="paragraph">
<p>要在启动时启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> ，请将以下行添加到 <span class="filename">/etc/rc.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>autofs_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后可以通过运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 来启动 autofs[5] 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service automount start</span>
<span class="c"># service automountd start</span>
<span class="c"># service autounmountd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=autofs&amp;sektion=5&amp;format=html">autofs(5)</a> 映射格式与其他操作系统相同。来自其他来源的关于该格式的信息可能会很有用，比如 <a href="http://web.archive.org/web/20160813071113/http://images.apple.com/business/docs/Autofs.pdf">Mac OS X 文档</a> 。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=automount&amp;sektion=8&amp;format=html">automount(8)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=automountd&amp;sektion=8&amp;format=html">automountd(8)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=autounmountd&amp;sektion=8&amp;format=html">autounmountd(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=auto_master&amp;sektion=5&amp;format=html">auto_master(5)</a> 手册页面获取更多信息。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-nis">32.4. 网络信息系统（ NIS ）<a class="anchor" href="#network-nis"></a></h3>
<div class="paragraph">
<p>网络信息系统（ NIS ）旨在集中管理类 UNIX® 系统，如 Solaris™ 、 HP-UX 、 AIX® 、 Linux 、 NetBSD 、 OpenBSD 和 FreeBSD 。 NIS 最初被称为 Yellow Pages ，但由于商标问题而更改了名称。这就是为什么 NIS 命令以 <code>yp</code> 开头的原因。</p>
</div>
<div class="paragraph">
<p>NIS 是一种基于远程过程调用（ RPC ）的客户端 / 服务器系统，允许 NIS 域内的一组机器共享一组公共的配置文件。这使得系统管理员可以仅使用最少的配置数据设置 NIS 客户端系统，并且可以从单一位置添加、删除或修改配置数据。</p>
</div>
<div class="paragraph">
<p>FreeBSD 使用 NIS 协议的第 2 版本。</p>
</div>
<div class="sect3">
<h4 id="_nis_术语和流程">32.4.1. NIS 术语和流程<a class="anchor" href="#_nis_术语和流程"></a></h4>
<div class="paragraph">
<p>表 28.1 总结了 NIS 使用的术语和重要过程。</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 41. NIS 术语</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">术语</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIS 域名</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIS 服务器和客户端共享一个 NIS 域名。通常，这个域名与 DNS 无关。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">手册： rpcbind[8]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此服务启用了 RPC ，并且必须在运行 NIS 服务器或充当 NIS 客户端时才能运行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该服务将 NIS 客户端绑定到其 NIS 服务器。它将获取 NIS 域名并使用 RPC 连接到服务器。它是 NIS 环境中客户端 / 服务器通信的核心。如果客户端机器上没有运行此服务，将无法访问 NIS 服务器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这是 NIS 服务器的流程。如果该服务停止运行，服务器将无法响应 NIS 请求，因此希望有一个从服务器接管。一些非 FreeBSD 客户端可能不会尝试使用从服务器重新连接，这些客户端可能需要重新启动 ypbind 进程。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a> 是一个手册页，它提供了有关 rpc.yppasswdd 命令的详细信息。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">这个进程只在 NIS 主服务器上运行。这个守护进程允许 NIS 客户端更改他们的 NIS 密码。如果这个守护进程没有运行，用户将不得不登录到 NIS 主服务器并在那里更改他们的密码。</p></td>
</tr>
</tbody>
</table>
</div>
<div class="sect3">
<h4 id="_机器类型">32.4.2. 机器类型<a class="anchor" href="#_机器类型"></a></h4>
<div class="paragraph">
<p>在 NIS 环境中有三种类型的主机：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>NIS 主服务器</p>
<div class="paragraph">
<p>该服务器充当主机配置信息的中央存储库，并维护所有 NIS 客户端使用的文件的权威副本。 NIS 客户端使用的 <span class="filename">passwd</span> 、 <span class="filename">group</span> 和其他各种文件存储在主服务器上。虽然一个机器可以成为多个 NIS 域的 NIS 主服务器，但本章不涵盖这种类型的配置，因为它假设一个相对规模较小的 NIS 环境。</p>
</div>
</li>
<li>
<p>NIS 从服务器</p>
<div class="paragraph">
<p>NIS 从服务器维护 NIS 主服务器数据文件的副本，以提供冗余。从服务器还有助于平衡主服务器的负载，因为 NIS 客户端总是连接到首先响应的 NIS 服务器。</p>
</div>
</li>
<li>
<p>NIS 客户端</p>
<div class="paragraph">
<p>NIS 客户端在登录时对 NIS 服务器进行身份验证。</p>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>许多文件的信息可以通过 NIS 共享。 <span class="filename">master.passwd</span> 、 <span class="filename">group</span> 和 <span class="filename">hosts</span> 文件通常通过 NIS 共享。每当客户端上的进程需要通常在这些文件中找到的信息时，它会向绑定的 NIS 服务器发出查询。</p>
</div>
</div>
<div class="sect3">
<h4 id="_规划考虑因素">32.4.3. 规划考虑因素<a class="anchor" href="#_规划考虑因素"></a></h4>
<div class="paragraph">
<p>本节描述了一个示例的 NIS 环境，该环境由 15 台 FreeBSD 机器组成，没有集中的管理点。每台机器都有自己的 /etc/passwd 和 /etc/master.passwd 文件。这些文件只能通过手动干预来保持同步。目前，当在实验室中添加用户时，这个过程必须在所有 15 台机器上重复执行。</p>
</div>
<div class="paragraph">
<p>实验室的配置如下：</p>
</div>
<table class="tableblock frame-none grid-all stretch informaltable">
<colgroup>
<col style="width: 33.3333%;"/>
<col style="width: 33.3333%;"/>
<col style="width: 33.3334%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">机器名称</th>
<th class="tableblock halign-left valign-top">IP 地址</th>
<th class="tableblock halign-left valign-top">机器角色</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ellington</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10.0.0.2</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIS 主服务器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>coltrane</code> 是一个英文单词，没有明确的中文翻译。它可能是一个人名、地名或者其他专有名词。如果有上下文提供更多信息，我可以帮助提供更准确的翻译。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10.0.0.3</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">NIS 从服务器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>basie</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10.0.0.4</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">教职员工工作站</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>bird</code> 是英文中的一个词，意思是鸟。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10.0.0.5</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">客户端机器</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>cli[1-11]</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>10.0.0.[6-17]</code> 表示一个 IP 地址范围，从 <code>10.0.0.6</code> 到 <code>10.0.0.17</code> 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">其他客户机</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>如果这是第一次开发 NIS 方案，应该提前进行彻底的规划。无论网络规模如何，规划过程中需要做出几个决策。</p>
</div>
<div class="sect4">
<h5 id="_选择一个_nis_域名">32.4.3.1. 选择一个 NIS 域名<a class="anchor" href="#_选择一个_nis_域名"></a></h5>
<div class="paragraph">
<p>当客户端广播其信息请求时，它会包含其所属的 NIS 域的名称。这就是在一个网络上多个服务器如何知道哪个服务器应该回答哪个请求的方式。将 NIS 域名视为一组主机的名称。</p>
</div>
<div class="paragraph">
<p>一些组织选择使用其互联网域名作为 NIS 域名。这并不推荐，因为在调试网络问题时可能会引起混淆。 NIS 域名应在网络中是唯一的，并且如果能描述它所代表的机器组，那将会很有帮助。例如， Acme 公司的艺术部门可能在&#34;acme-art&#34;的 NIS 域中。本示例将使用域名 <code>test-domain</code> 。</p>
</div>
<div class="paragraph">
<p>然而，一些非 FreeBSD 操作系统要求 NIS 域名与互联网域名相同。如果网络中的一个或多个机器有此限制，则必须使用互联网域名作为 NIS 域名。</p>
</div>
</div>
<div class="sect4">
<h5 id="_物理服务器要求">32.4.3.2. 物理服务器要求<a class="anchor" href="#_物理服务器要求"></a></h5>
<div class="paragraph">
<p>选择用作 NIS 服务器的机器时，有几个要注意的事项。由于 NIS 客户端依赖于服务器的可用性，因此选择一台不经常重新启动的机器。 NIS 服务器最好是一台独立的机器，其唯一目的就是作为 NIS 服务器。如果网络使用率不高，可以将 NIS 服务器放在运行其他服务的机器上。然而，如果 NIS 服务器不可用，将会对所有 NIS 客户端产生不利影响。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置_nis_主服务器">32.4.4. 配置 NIS 主服务器<a class="anchor" href="#_配置_nis_主服务器"></a></h4>
<div class="paragraph">
<p>所有 NIS 文件的规范副本存储在主服务器上。用于存储信息的数据库称为 NIS 映射。在 FreeBSD 中，这些映射存储在 <span class="filename">/var/yp/[domainname]</span> 中，其中 <span class="filename">[domainname]</span> 是 NIS 域的名称。由于支持多个域，因此可能会有多个目录，每个域一个目录。每个域都有自己独立的映射集。</p>
</div>
<div class="paragraph">
<p>NIS 主服务器和从服务器通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> 处理所有 NIS 请求。该守护进程负责接收来自 NIS 客户端的传入请求，将请求的域和映射名称转换为相应数据库文件的路径，并将数据库中的数据传输回客户端。</p>
</div>
<div class="paragraph">
<p>根据环境需求，设置主 NIS 服务器可以相对简单。由于 FreeBSD 提供了内置的 NIS 支持，只需要通过将以下行添加到 [/etc/rc.conf] 来启用 NIS ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nisdomainname=&#34;test-domain&#34;	<i class="conum" data-value="1"></i><b>(1)</b>
nis_server_enable=&#34;YES&#34;		<i class="conum" data-value="2"></i><b>(2)</b>
nis_yppasswdd_enable=&#34;YES&#34;	<i class="conum" data-value="3"></i><b>(3)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这行代码将 NIS 域名设置为 <code>test-domain</code> 。 &lt;.&gt; 这将在系统启动时自动启动 NIS 服务器进程。 &lt;.&gt; 这将启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rpc.yppasswdd&amp;sektion=8&amp;format=html">rpc.yppasswdd(8)</a> 守护进程，以便用户可以从客户端机器上更改他们的 NIS 密码。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在一个多服务器域中，需要注意服务器机器也是 NIS 客户端的情况。通常最好强制服务器绑定到自己，而不是允许它们广播绑定请求并可能相互绑定。如果一个服务器崩溃，其他服务器依赖于它，可能会出现奇怪的故障模式。最终，所有客户端都会超时并尝试绑定到其他服务器，但涉及的延迟可能相当大，并且故障模式仍然存在，因为服务器可能会再次相互绑定。</p>
</div>
<div class="paragraph">
<p>一个既是服务器又是客户端的服务器可以通过在 [/etc/rc.conf] 中添加以下额外的行来强制绑定到特定的服务器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nis_client_enable=&#34;YES&#34;				<i class="conum" data-value="1"></i><b>(1)</b>
nis_client_flags=&#34;-S test-domain,server&#34;	<i class="conum" data-value="2"></i><b>(2)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这样可以运行客户端的内容。 &lt;.&gt; 这行代码将 NIS 域名设置为 <code>test-domain</code> 并绑定到自身。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>保存编辑后，输入 <code>/etc/netstart</code> 来重新启动网络并应用在 <code>/etc/rc.conf</code> 中定义的值。在初始化 NIS 映射之前，启动 <code>ypserv[8]</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ypserv start</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_初始化_nis_映射">32.4.4.1. 初始化 NIS 映射<a class="anchor" href="#_初始化_nis_映射"></a></h5>
<div class="paragraph">
<p>NIS 映射是从 NIS 主服务器上的配置文件 [/etc] 生成的，只有一个例外： [/etc/master.passwd] 。这是为了防止密码传播到 NIS 域中的所有服务器。因此，在初始化 NIS 映射之前，请配置主密码文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cp /etc/master.passwd /var/yp/master.passwd</span>
<span class="c"># cd /var/yp</span>
<span class="c"># vi master.passwd</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>建议删除所有系统账户的条目，以及不需要传播到 NIS 客户端的任何用户账户，例如 <code>root</code> 和其他管理账户。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>通过将 <span class="filename">/var/yp/master.passwd</span> 的权限设置为 <code>600</code> ，确保它既不可由组读取，也不可由其他用户读取。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>完成此任务后，初始化 NIS 映射。 FreeBSD 包含 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypinit&amp;sektion=8&amp;format=html">ypinit(8)</a> 脚本来完成此操作。在为主服务器生成映射时，包括 <code>-m</code> 选项并指定 NIS 域名：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">ellington# </span>ypinit -m <span class="nb">test</span>-domain
Server Type: MASTER Domain: <span class="nb">test</span>-domain
Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.
Do you want this procedure to quit on non-fatal errors? <span class="o">[</span>y/n: n] n
Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
At this point, we have to construct a list of this domains YP servers.
rod.darktech.org is already known as master server.
Please <span class="k">continue </span>to add any slave servers, one per line. When you are
<span class="k">done </span>with the list, <span class="nb">type </span>a &lt;control D&gt;.
master server   :  ellington
next host to add:  coltrane
next host to add:  ^D
The current list of NIS servers looks like this:
ellington
coltrane
Is this correct?  <span class="o">[</span>y/n: y] y

<span class="o">[</span>..output from map generation..]

NIS Map update completed.
ellington has been setup as an YP master server without any errors.</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将从 <span class="filename">/var/yp/Makefile.dist</span> 创建 <span class="filename">/var/yp/Makefile</span> 。默认情况下，此文件假设环境中只有一个 NIS 服务器和仅有 FreeBSD 客户端。由于 <code>test-domain</code> 有一个从服务器，因此请编辑 <span class="filename">/var/yp/Makefile</span> 中的此行，使其以注释 (<code>#</code>) 开头：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>NOPUSH = &#34;True&#34;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_添加新用户">32.4.4.2. 添加新用户<a class="anchor" href="#_添加新用户"></a></h5>
<div class="paragraph">
<p>每次创建新用户时，都必须将用户帐户添加到主 NIS 服务器并重建 NIS 映射。在此之前，新用户将无法登录除 NIS 主服务器之外的任何地方。例如，要将新用户 <code>jsmith</code> 添加到 <code>test-domain</code> 域中，请在主服务器上运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pw useradd jsmith</span>
<span class="c"># cd /var/yp</span>
<span class="c"># make test-domain</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>用户也可以使用 <code>adduser jsmith</code> 而不是 <code>pw useradd smith</code> 来添加。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_设置一个_nis_从服务器">32.4.5. 设置一个 NIS 从服务器<a class="anchor" href="#_设置一个_nis_从服务器"></a></h4>
<div class="paragraph">
<p>要设置一个 NIS 从服务器，登录到从服务器并像主服务器一样编辑 [/etc/rc.conf] 。不要生成任何 NIS 映射，因为这些映射已经存在于主服务器上。在从服务器上运行 <code>ypinit</code> 时，使用 <code>-s</code> （代表从服务器）而不是 <code>-m</code> （代表主服务器）。此选项除了域名外，还需要提供 NIS 主服务器的名称，如下例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">coltrane# </span>ypinit -s ellington <span class="nb">test</span>-domain

Server Type: SLAVE Domain: <span class="nb">test</span>-domain Master: ellington

Creating an YP server will require that you answer a few questions.
Questions will all be asked at the beginning of the procedure.

Do you want this procedure to quit on non-fatal errors? <span class="o">[</span>y/n: n]  n

Ok, please remember to go back and redo manually whatever fails.
If not, something might not work.
There will be no further questions. The remainder of the procedure
should take a few minutes, to copy the databases from ellington.
Transferring netgroup...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byuser...
ypxfr: Exiting: Map successfully transferred
Transferring netgroup.byhost...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byuid...
ypxfr: Exiting: Map successfully transferred
Transferring passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring group.bygid...
ypxfr: Exiting: Map successfully transferred
Transferring group.byname...
ypxfr: Exiting: Map successfully transferred
Transferring services.byname...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring rpc.byname...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.byname...
ypxfr: Exiting: Map successfully transferred
Transferring master.passwd.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byname...
ypxfr: Exiting: Map successfully transferred
Transferring networks.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring netid.byname...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byaddr...
ypxfr: Exiting: Map successfully transferred
Transferring protocols.bynumber...
ypxfr: Exiting: Map successfully transferred
Transferring ypservers...
ypxfr: Exiting: Map successfully transferred
Transferring hosts.byname...
ypxfr: Exiting: Map successfully transferred

coltrane has been setup as an YP slave server without any errors.
Remember to update map ypservers on ellington.</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将在从服务器上生成一个名为 [/var/yp/test-domain] 的目录，其中包含 NIS 主服务器映射的副本。在每个从服务器上添加这些 [/etc/crontab] 条目将强制从服务器将其映射与主服务器上的映射同步：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>20      *       *       *       *       root   /usr/libexec/ypxfr passwd.byname
21      *       *       *       *       root   /usr/libexec/ypxfr passwd.byuid</pre>
</div>
</div>
<div class="paragraph">
<p>这些条目不是强制性的，因为主服务器会自动尝试将任何地图更改推送到从服务器。然而，由于客户端可能依赖从服务器提供正确的密码信息，建议强制频繁更新密码映射。这在繁忙的网络上尤为重要，因为地图更新可能并不总是完成。</p>
</div>
<div class="paragraph">
<p>要完成配置，请在从服务器上运行 <code>/etc/netstart</code> 以启动 NIS 服务。</p>
</div>
</div>
<div class="sect3">
<h4 id="_设置_nis_客户端">32.4.6. 设置 NIS 客户端<a class="anchor" href="#_设置_nis_客户端"></a></h4>
<div class="paragraph">
<p>一个 NIS 客户端使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> 绑定到一个 NIS 服务器。这个守护进程在本地网络上广播 RPC 请求。这些请求指定了客户端上配置的域名。如果同一域中的一个 NIS 服务器接收到其中一个广播，它将回应 ypbind ，并记录服务器的地址。如果有多个可用的服务器，客户端将使用第一个回应的服务器的地址，并将所有的 NIS 请求定向到该服务器。客户端会定期自动 ping 服务器，以确保它仍然可用。如果在合理的时间内未收到回复， ypbind 将标记该域为未绑定，并重新开始广播，希望找到另一个服务器。</p>
</div>
<div class="paragraph">
<p>要将 FreeBSD 机器配置为 NIS 客户端：</p>
</div>
<div class="exampleblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>编辑 <span class="filename">/etc/rc.conf</span> 文件，并按照以下顺序添加以下行，以设置 NIS 域名并在网络启动时启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypbind&amp;sektion=8&amp;format=html">ypbind(8)</a> ：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>nisdomainname=&#34;test-domain&#34;
nis_client_enable=&#34;YES&#34;</pre>
</div>
</div>
</li>
<li>
<p>要从 NIS 服务器导入所有可能的密码条目，请使用 <code>vipw</code> 命令从 <span class="filename">/etc/master.passwd</span> 中删除除一个之外的所有用户账户。在删除账户时，请记住至少应保留一个本地账户，并且该账户应该是 <code>wheel</code> 组的成员。如果 NIS 出现问题，可以使用该本地账户远程登录，成为超级用户并修复问题。在保存编辑之前，请在文件末尾添加以下行：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>+:::::::::</pre>
</div>
</div>
<div class="paragraph">
<p>这行配置将使客户端为 NIS 服务器密码映射中具有有效帐户的任何人在客户端上提供一个帐户。有许多方法可以通过修改这行来配置 NIS 客户端。其中一种方法在 <a href="#network-netgroups">使用 Netgroups</a> 中有描述。如需更详细的阅读，请参考 O’Reilly Media 出版的《 Managing NFS and NIS 》一书。</p>
</div>
</li>
<li>
<p>要从 NIS 服务器导入所有可能的组条目，请将以下行添加到 [/etc/group] 文件中：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>+:*::</pre>
</div>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>要立即启动 NIS 客户端，请以超级用户身份执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /etc/netstart</span>
<span class="c"># service ypbind start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>完成这些步骤后，在客户端上运行 <code>ypcat passwd</code> 应该显示服务器的 <span class="filename">passwd</span> 映射。</p>
</div>
</div>
<div class="sect3">
<h4 id="_nis_安全">32.4.7. NIS 安全<a class="anchor" href="#_nis_安全"></a></h4>
<div class="paragraph">
<p>由于 RPC 是基于广播的服务，因此在同一域中运行 ypbind 的任何系统都可以检索 NIS 映射的内容。为了防止未经授权的事务， <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> 支持一个名为&#34;securenets&#34;的功能，可以用来限制对给定一组主机的访问。默认情况下，此信息存储在 <span class="filename">/var/yp/securenets</span> 中，除非 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> 使用 <code>-p</code> 和替代路径启动。该文件包含由空格分隔的网络规范和网络掩码组成的条目。以 ` &#34;#&#34; ` 开头的行被视为注释。一个示例的 <span class="filename">securenets</span> 可能如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># allow connections from local host -- mandatory
127.0.0.1     255.255.255.255
# allow connections from any host
# on the 192.168.128.0 network
192.168.128.0 255.255.255.0
# allow connections from any host
# between 10.0.0.0 to 10.0.15.255
# this includes the machines in the testlab
10.0.0.0      255.255.240.0</pre>
</div>
</div>
<div class="paragraph">
<p>如果 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypserv&amp;sektion=8&amp;format=html">ypserv(8)</a> 接收到与这些规则匹配的地址的请求，它将正常处理该请求。如果地址未能匹配规则，请求将被忽略，并记录一条警告信息。如果 <span class="filename">securenets</span> 不存在， <code>ypserv</code> 将允许来自任何主机的连接。</p>
</div>
<div class="paragraph">
<p><a href="./#tcpwrappers">TCP Wrapper</a> 是一种替代的访问控制机制，用于提供对 .securenets# 的访问控制。虽然这两种访问控制机制都增加了一定的安全性，但它们都容易受到&#34;IP 欺骗&#34;攻击的影响。所有与 NIS 相关的流量都应该在防火墙上被阻止。</p>
</div>
<div class="paragraph">
<p>使用 <span class="filename">securenets</span> 的服务器可能无法为使用过时的 TCP/IP 实现的合法 NIS 客户端提供服务。其中一些实现在进行广播时将所有主机位设置为零，或者在计算广播地址时未观察子网掩码。虽然可以通过更改客户端配置来解决其中一些问题，但其他问题可能会迫使退役这些客户端系统或放弃 <span class="filename">securenets</span> 。</p>
</div>
<div class="paragraph">
<p>使用 TCP Wrapper 会增加 NIS 服务器的延迟。额外的延迟可能足够长，以至于在繁忙的网络中，特别是在速度较慢的 NIS 服务器上，会导致客户端程序超时。如果一个或多个客户端受到延迟的影响，将这些客户端转换为 NIS 从服务器，并强制它们绑定到自己。</p>
</div>
<div class="sect4">
<h5 id="_除了某些用户">32.4.7.1. 除了某些用户<a class="anchor" href="#_除了某些用户"></a></h5>
<div class="paragraph">
<p>在这个例子中， <code>basie</code> 系统是 NIS 域中的一个教职工工作站。主 NIS 服务器上的 <span class="filename">passwd</span> 映射包含了教职工和学生的账户。本节演示了如何允许教职工登录这个系统，同时拒绝学生登录。</p>
</div>
<div class="paragraph">
<p>为了防止指定的用户登录系统，即使他们在 NIS 数据库中存在，使用 <code>vipw</code> 在客户端的 <span class="filename">/etc/master.passwd</span> 末尾添加 <code>-<em>username</em></code> ，其中 <code><em>username</em></code> 是要禁止登录的用户的用户名，并且正确的冒号数量。被阻止用户的行必须在允许 NIS 用户的 ` + ` 行之前。在这个例子中， <code>bill</code> 被禁止登录到 <code>basie</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">basie# </span>cat /etc/master.passwd
root:[password]:0:0::0:0:The super-user:/root:/bin/csh
toor:[password]:0:0::0:0:The other super-user:/root:/bin/sh
daemon:<span class="k">*</span>:1:1::0:0:Owner of many system processes:/root:/usr/sbin/nologin
operator:<span class="k">*</span>:2:5::0:0:System &amp;:/:/usr/sbin/nologin
bin:<span class="k">*</span>:3:7::0:0:Binaries Commands and Source,,,:/:/usr/sbin/nologin
tty:<span class="k">*</span>:4:65533::0:0:Tty Sandbox:/:/usr/sbin/nologin
kmem:<span class="k">*</span>:5:65533::0:0:KMem Sandbox:/:/usr/sbin/nologin
games:<span class="k">*</span>:7:13::0:0:Games pseudo-user:/usr/games:/usr/sbin/nologin
news:<span class="k">*</span>:8:8::0:0:News Subsystem:/:/usr/sbin/nologin
man:<span class="k">*</span>:9:9::0:0:Mister Man Pages:/usr/share/man:/usr/sbin/nologin
<span class="nb">bind</span>:<span class="k">*</span>:53:53::0:0:Bind Sandbox:/:/usr/sbin/nologin
uucp:<span class="k">*</span>:66:66::0:0:UUCP pseudo-user:/var/spool/uucppublic:/usr/libexec/uucp/uucico
xten:<span class="k">*</span>:67:67::0:0:X-10 daemon:/usr/local/xten:/usr/sbin/nologin
pop:<span class="k">*</span>:68:6::0:0:Post Office Owner:/nonexistent:/usr/sbin/nologin
nobody:<span class="k">*</span>:65534:65534::0:0:Unprivileged user:/nonexistent:/usr/sbin/nologin
-bill:::::::::
+:::::::::

basie#</code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="network-netgroups">32.4.8. 使用 Netgroups<a class="anchor" href="#network-netgroups"></a></h4>
<div class="literalblock">
<div class="content">
<pre>Netgroups 是一种在计算机网络中组织和管理用户、主机和域的方法。它允许管理员将一组相关的用户、主机或域定义为一个组，并为该组分配特定的权限和访问控制规则。</pre>
</div>
</div>
<div class="literalblock">
<div class="content">
<pre>Netgroups 可以用于各种用途，例如控制访问权限、配置网络服务和管理用户组。它们可以在操作系统级别或应用程序级别使用。</pre>
</div>
</div>
<div class="paragraph">
<p>要使用 Netgroups ，首先需要在网络中的每个主机上配置 Netgroup 数据库。这可以通过编辑 <code>/etc/netgroup</code> 文件来完成。在该文件中，可以定义 Netgroups 及其成员。每个 Netgroup 由一个名称和一个成员列表组成。</p>
</div>
<div class="paragraph">
<p>一旦 Netgroup 数据库配置完成，就可以在系统中使用 Netgroups 了。可以通过在配置文件中引用 Netgroup 名称来控制访问权限，或者在命令行中使用 Netgroup 名称来限制特定操作的范围。</p>
</div>
<div class="paragraph">
<p>总的来说， Netgroups 是一种强大的工具，可以帮助管理员更好地组织和管理网络中的用户、主机和域。它提供了一种灵活的方式来控制访问权限，并简化了配置和管理过程。</p>
</div>
<div class="paragraph">
<p>在较大的网络上，禁止特定用户登录到个别系统变得不可扩展，并且很快失去了 NIS 的主要优势：_集中化_管理。</p>
</div>
<div class="paragraph">
<p>Netgroups 是为处理具有数百个用户和机器的大型复杂网络而开发的。它们的使用类似于 UNIX® 组，主要区别在于缺乏数字 ID ，并且可以通过包含用户账户和其他 netgroups 来定义 netgroup 。</p>
</div>
<div class="paragraph">
<p>为了扩展本章中使用的示例， NIS 域将被扩展以添加表 28.2 和 28.3 中显示的用户和系统。</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 42. 附加用户</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">用户名（们）</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>alpha</code> , <code>beta</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IT 部门员工</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>charlie</code> , <code>delta</code></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IT 部门学徒</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>echo</code> , <code>foxtrott</code> , <code>golf</code> , …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">员工</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>able</code> , <code>baker</code> , …​ 可以翻译为中文为 <code>able</code> , <code>baker</code> , …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">实习生</p></td>
</tr>
</tbody>
</table>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 43. 其他系统</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">机器名称（们）</th>
<th class="tableblock halign-left valign-top">描述</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">战争，死亡，饥荒，污染</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">只有 IT 员工才能登录这些服务器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">` 骄傲 ` , ` 贪婪 ` , ` 嫉妒 ` , ` 愤怒 ` , ` 欲望 ` , ` 懒惰 `</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IT 部门的所有成员都被允许登录这些服务器。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">` 一 ` ， ` 二 ` ， ` 三 ` ， ` 四 ` ， …​</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">员工使用的普通工作站。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>trashcan</code> 的中文翻译是 ` 垃圾桶 ` 。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">一台非常老旧的机器，没有任何关键数据。甚至实习生都可以使用这个系统。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在使用 netgroups 配置这种情况时，每个用户都被分配到一个或多个 netgroups ，并且登录权限会对 netgroup 的所有成员进行允许或禁止。当添加一个新的机器时，必须为所有 netgroups 定义登录限制。当添加一个新用户时，必须将该账户添加到一个或多个 netgroups 中。如果 NIS 设置得当，只需要修改一个中央配置文件就可以授予或拒绝对机器的访问权限。</p>
</div>
<div class="paragraph">
<p>第一步是初始化 NIS 的 <code>netgroup</code> 映射。在 FreeBSD 中，默认情况下不会创建此映射。在 NIS 主服务器上，使用编辑器创建一个名为 <code>/var/yp/netgroup</code> 的映射。</p>
</div>
<div class="paragraph">
<p>这个例子创建了四个网络组，分别代表 IT 员工、 IT 学徒、员工和实习生：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>IT_EMP  (,alpha,test-domain)    (,beta,test-domain)
IT_APP  (,charlie,test-domain)  (,delta,test-domain)
USERS   (,echo,test-domain)     (,foxtrott,test-domain) \
        (,golf,test-domain)
INTERNS (,able,test-domain)     (,baker,test-domain)</pre>
</div>
</div>
<div class="paragraph">
<p>每个条目配置一个 netgroup 。条目中的第一列是 netgroup 的名称。每对括号表示一个或多个用户的组或另一个 netgroup 的名称。在指定用户时，每个组内的三个逗号分隔字段表示：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>表示用户有效的其他字段所在的主机名。如果未指定主机名，则条目在所有主机上有效。</p>
</li>
<li>
<p>属于此网络组的帐户的名称。</p>
</li>
<li>
<p>帐户的 NIS 域。可以将帐户从其他 NIS 域导入到网络组中。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果一个组包含多个用户，请使用空格分隔每个用户。此外，每个字段可以包含通配符。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=netgroup&amp;sektion=5&amp;format=html">netgroup(5)</a> 。</p>
</div>
<div class="paragraph">
<p>不应使用超过 8 个字符的 Netgroup 名称。这些名称区分大小写，使用大写字母作为 Netgroup 名称是区分用户、机器和 Netgroup 名称的简单方法。</p>
</div>
<div class="paragraph">
<p>一些非 FreeBSD 的 NIS 客户端无法处理包含超过 15 个条目的 netgroup 。可以通过创建多个包含 15 个或更少用户的子 netgroup 以及一个由子 netgroup 组成的真正的 netgroup 来绕过此限制，如下面的示例所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>BIGGRP1  (,joe1,domain)  (,joe2,domain)  (,joe3,domain) [...]
BIGGRP2  (,joe16,domain)  (,joe17,domain) [...]
BIGGRP3  (,joe31,domain)  (,joe32,domain)
BIGGROUP  BIGGRP1 BIGGRP2 BIGGRP3</pre>
</div>
</div>
<div class="paragraph">
<p>如果单个网络组中存在超过 225 个（ 15 乘以 15 ）用户，请重复此过程。</p>
</div>
<div class="paragraph">
<p>要激活和分发新的 NIS 映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">ellington# </span><span class="nb">cd</span> /var/yp
<span class="gp">ellington# </span>make</code></pre>
</div>
</div>
<div class="paragraph">
<p>这将生成三个 NIS 映射文件 <span class="filename">netgroup</span> 、 <span class="filename">netgroup.byhost</span> 和 <span class="filename">netgroup.byuser</span> 。使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ypcat&amp;sektion=1&amp;format=html">ypcat(1)</a> 的映射键选项来检查新的 NIS 映射文件是否可用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">ellington% </span>ypcat -k netgroup
<span class="gp">ellington% </span>ypcat -k netgroup.byhost
<span class="gp">ellington% </span>ypcat -k netgroup.byuser</code></pre>
</div>
</div>
<div class="paragraph">
<p>第一个命令的输出应该类似于 <span class="filename">/var/yp/netgroup</span> 文件的内容。只有在创建了特定主机的 netgroup 时，第二个命令才会产生输出。第三个命令用于获取用户的 netgroup 列表。</p>
</div>
<div class="paragraph">
<p>要配置客户端，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> 来指定 netgroup 的名称。例如，在名为“ war ”的服务器上，替换这一行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>+:::::::::</pre>
</div>
</div>
<div class="paragraph">
<p>with</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>+@IT_EMP:::::::::</pre>
</div>
</div>
<div class="paragraph">
<p>这指定只有在 netgroup <code>IT_EMP</code> 中定义的用户将被导入到此系统的密码数据库中，并且只有这些用户被允许登录到此系统。</p>
</div>
<div class="paragraph">
<p>此配置也适用于 shell 的 ` ~ ` 函数和所有在用户名称和数字用户 ID 之间转换的例程。换句话说， <code>cd ~<em>user</em></code> 将无法工作， <code>ls -l</code> 将显示数字 ID 而不是用户名， <code>find . -user joe -print</code> 将以 <code>No such user</code> 的消息失败。要解决此问题，导入所有用户条目时不允许它们登录到服务器。可以通过添加额外的一行来实现这一点：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>+:::::::::/usr/sbin/nologin</pre>
</div>
</div>
<div class="paragraph">
<p>这行配置将客户端配置为导入所有条目，但将这些条目中的 shell 替换为 <span class="filename">/usr/sbin/nologin</span> 。</p>
</div>
<div class="paragraph">
<p>请确保在 ` +@ IT_EMP:::::::::` 之后放置额外的空行。否则，从 NIS 导入的所有用户帐户将将 <span class="filename">/usr/sbin/nologin</span> 作为其登录 shell ，而没有人将能够登录到系统。</p>
</div>
<div class="paragraph">
<p>要配置较不重要的服务器，请将服务器上的旧 ` + :::::::::` 替换为以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>+@IT_EMP:::::::::
+@IT_APP:::::::::
+:::::::::/usr/sbin/nologin</pre>
</div>
</div>
<div class="paragraph">
<p>工作站的相应行为：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>+@IT_EMP:::::::::
+@USERS:::::::::
+:::::::::/usr/sbin/nologin</pre>
</div>
</div>
<div class="paragraph">
<p>NIS 支持从其他 netgroups 创建 netgroups ，这在用户访问策略发生变化时非常有用。一个可能的情况是创建基于角色的 netgroups 。例如，可以创建一个名为 <code>BIGSRV</code> 的 netgroup 来定义重要服务器的登录限制，另一个名为 <code>SMALLSRV</code> 的 netgroup 用于不太重要的服务器，以及一个名为 <code>USERBOX</code> 的 netgroup 用于工作站。每个 netgroup 都包含被允许登录到这些机器上的 netgroups 。 NIS`netgroup` 映射的新条目如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP  ITINTERN
USERBOX   IT_EMP  ITINTERN USERS</pre>
</div>
</div>
<div class="paragraph">
<p>当能够定义具有相同限制的机器组时，这种定义登录限制的方法运作得相当不错。不幸的是，这只是个例而不是规则。大多数情况下，需要能够按照每台机器的基础定义登录限制。</p>
</div>
<div class="paragraph">
<p>机器特定的网络组定义是处理策略变更的另一种可能性。在这种情况下，每个系统的 /etc/master.passwd 文件包含两行以&#34;+&#34;开头的内容。第一行添加了一个允许登录到该机器的帐户的网络组，第二行添加了所有其他帐户，并将其 shell 设置为 /usr/sbin/nologin 。建议使用主机名的大写版本作为网络组的名称：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>+@BOXNAME:::::::::
+:::::::::/usr/sbin/nologin</pre>
</div>
</div>
<div class="paragraph">
<p>一旦在所有机器上完成了这个任务，就不再需要再次修改本地版本的 <code>/etc/master.passwd</code> 文件了。所有后续的更改都可以通过修改 NIS 映射来处理。以下是一个可能的 <code>netgroup</code> 映射的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Define groups of users first
IT_EMP    (,alpha,test-domain)    (,beta,test-domain)
IT_APP    (,charlie,test-domain)  (,delta,test-domain)
DEPT1     (,echo,test-domain)     (,foxtrott,test-domain)
DEPT2     (,golf,test-domain)     (,hotel,test-domain)
DEPT3     (,india,test-domain)    (,juliet,test-domain)
ITINTERN  (,kilo,test-domain)     (,lima,test-domain)
D_INTERNS (,able,test-domain)     (,baker,test-domain)
#
# Now, define some groups based on roles
USERS     DEPT1   DEPT2     DEPT3
BIGSRV    IT_EMP  IT_APP
SMALLSRV  IT_EMP  IT_APP    ITINTERN
USERBOX   IT_EMP  ITINTERN  USERS
#
# And a groups for a special tasks
# Allow echo and golf to access our anti-virus-machine
SECURITY  IT_EMP  (,echo,test-domain)  (,golf,test-domain)
#
# machine-based netgroups
# Our main servers
WAR       BIGSRV
FAMINE    BIGSRV
# User india needs access to this server
POLLUTION  BIGSRV  (,india,test-domain)
#
# This one is really important and needs more access restrictions
DEATH     IT_EMP
#
# The anti-virus-machine mentioned above
ONE       SECURITY
#
# Restrict a machine to a single user
TWO       (,hotel,test-domain)
# [...more groups to follow]</pre>
</div>
</div>
<div class="paragraph">
<p>并不总是建议使用基于机器的网络组。当部署几十个或几百个系统时，可以使用基于角色的网络组代替基于机器的网络组，以保持 NIS 映射的大小在合理范围内。</p>
</div>
</div>
<div class="sect3">
<h4 id="_密码格式">32.4.9. 密码格式<a class="anchor" href="#_密码格式"></a></h4>
<div class="paragraph">
<p>密码是用于验证用户身份和保护个人信息的重要工具。为了确保密码的安全性，常见的密码格式包括以下几种：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>长度要求：密码必须具有一定的长度要求，通常要求在 8 到 16 个字符之间。</p>
</li>
<li>
<p>复杂性要求：密码必须包含不同类型的字符，如大写字母、小写字母、数字和特殊字符。</p>
</li>
<li>
<p>避免常见密码：密码不能使用常见的密码，如&#34;password&#34;或&#34;123456&#34;等。</p>
</li>
<li>
<p>定期更换密码：为了增加密码的安全性，建议定期更换密码，通常是每 3 个月或 6 个月更换一次。</p>
</li>
<li>
<p>多因素认证：除了密码，还可以使用其他因素进行认证，如指纹识别、面部识别或短信验证码等。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>请注意，选择一个强密码并遵循密码格式要求是保护个人信息安全的重要步骤。</p>
</div>
<div class="paragraph">
<p>NIS 要求 NIS 域内的所有主机使用相同的密码加密格式。如果用户在 NIS 客户端上认证时遇到问题，可能是由于密码格式不同。在异构网络中，该格式必须由所有操作系统支持，其中 DES 是最低公共标准。</p>
</div>
<div class="paragraph">
<p>要检查服务器或客户端使用的格式，请查看 <span class="filename">/etc/login.conf</span> 文件的这个部分：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>default:\
	:passwd_format=des:\
	:copyright=/etc/COPYRIGHT:\
	[Further entries elided]</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，系统使用 DES 格式进行密码哈希。其他可能的值包括 <code>blf</code> 表示 Blowfish ， <code>md5</code> 表示 MD5 ， <code>sha256</code> 和 <code>sha512</code> 分别表示 SHA-256 和 SHA-512 。要获取更多信息和系统上可用选项的最新列表，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=crypt&amp;sektion=3&amp;format=html">crypt(3)</a> 手册页。</p>
</div>
<div class="paragraph">
<p>如果需要编辑主机上的格式以匹配在 NIS 域中使用的格式，则在保存更改后必须重新构建登录能力数据库。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cap_mkdb /etc/login.conf</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在登录能力数据库重建之后，只有当每个用户在更改密码之后，现有用户账户的密码格式才会更新。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-ldap">32.5. 轻量级目录访问协议（ LDAP ）<a class="anchor" href="#network-ldap"></a></h3>
<div class="paragraph">
<p>轻量级目录访问协议（ LDAP ）是一种应用层协议，用于访问、修改和认证使用分布式目录信息服务的对象。可以将其视为存储多个层次结构、同质信息的电话簿或记录簿。它在 Active Directory 和 OpenLDAP 网络中使用，并允许用户使用单个帐户访问多个层次的内部信息。例如，电子邮件认证、获取员工联系信息和内部网站认证可能都会使用 LDAP 服务器记录库中的单个用户帐户。</p>
</div>
<div class="paragraph">
<p>本节提供了在 FreeBSD 系统上配置 LDAP 服务器的快速入门指南。它假设管理员已经有了一个设计计划，其中包括要存储的信息类型，该信息将用于什么目的，哪些用户应该访问该信息，以及如何保护该信息免受未经授权的访问。</p>
</div>
<div class="sect3">
<h4 id="_ldap_术语和结构">32.5.1. LDAP 术语和结构<a class="anchor" href="#_ldap_术语和结构"></a></h4>
<div class="paragraph">
<p>在开始配置之前，需要了解 LDAP 使用的几个术语。所有目录条目由一组“属性”组成。每个属性集都包含一个称为“ Distinguished Name ”（ DN ）的唯一标识符，通常由其他属性（如常见的或“ Relative Distinguished Name ”（ RDN ））构建而成。类似于目录具有绝对路径和相对路径，可以将 DN 视为绝对路径，将 RDN 视为相对路径。</p>
</div>
<div class="paragraph">
<p>一个示例 LDAP 条目如下所示。此示例搜索指定用户帐户（ <code>uid</code> ）、组织单位（ <code>ou</code> ）和组织（ <code>o</code> ）的条目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ldapsearch -xb <span class="s2">&#34;uid=trhodes,ou=users,o=example.com&#34;</span>
<span class="c"># extended LDIF</span>
<span class="c">#</span>
<span class="c"># LDAPv3</span>
<span class="c"># base &lt;uid=trhodes,ou=users,o=example.com&gt; with scope subtree</span>
<span class="c"># filter: (objectclass=*)</span>
<span class="c"># requesting: ALL</span>
<span class="c">#</span>

<span class="c"># trhodes, users, example.com</span>
dn: <span class="nv">uid</span><span class="o">=</span>trhodes,ou<span class="o">=</span>users,o<span class="o">=</span>example.com
mail: trhodes@example.com
cn: Tom Rhodes
uid: trhodes
telephoneNumber: <span class="o">(</span>123<span class="o">)</span> 456-7890

<span class="c"># search result</span>
search: 2
result: 0 Success

<span class="c"># numResponses: 2</span>
<span class="c"># numEntries: 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个示例条目显示了 <code>dn</code> 、 <code>mail</code> 、 <code>cn</code> 、 <code>uid</code> 和 <code>telephoneNumber</code> 属性的值。 <code>cn</code> 属性是 RDN 。</p>
</div>
<div class="paragraph">
<p>有关 LDAP 及其术语的更多信息，请访问 <a href="http://www.openldap.org/doc/admin24/intro.html">http://www.openldap.org/doc/admin24/intro.html</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="ldap-config">32.5.2. 配置 LDAP 服务器<a class="anchor" href="#ldap-config"></a></h4>
<div class="paragraph">
<p>FreeBSD 没有提供内置的 LDAP 服务器。开始配置过程，需要安装 <code>net/openldap-server</code> 包或者使用端口进行安装。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install openldap-server</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <a href="{linux-users}#software">package</a> 中启用了一组大量的默认选项。通过运行 <code>pkg info openldap-server</code> 来查看它们。如果它们不足够（例如需要 SQL 支持），请考虑使用适当的 <a href="./#ports-using">framework</a> 重新编译该端口。</p>
</div>
<div class="paragraph">
<p>安装过程会创建目录 <span class="filename">/var/db/openldap-data</span> 来存储数据。必须创建用于存储证书的目录：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /usr/local/etc/openldap/private</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下一步是配置证书颁发机构。以下命令必须从 <span class="filename">/usr/local/etc/openldap/private</span> 目录下执行。这很重要，因为文件权限需要限制，并且用户不应该访问这些文件。有关证书及其参数的更详细信息，请参阅 <a href="./#openssl">OpenSSL</a> 。要创建证书颁发机构，请使用以下命令并按照提示进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl req -days 365 -nodes -new -x509 -keyout ca.key -out ../ca.crt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>提示的条目可以是通用的，除了“ Common Name ”（公共名称）之外。这个条目必须与系统主机名不同。如果这将是一个自签名证书，请在主机名前加上“ CA ”表示证书颁发机构。</p>
</div>
<div class="paragraph">
<p>下一步是创建证书签名请求和私钥。输入以下命令并按照提示进行操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl req -days 365 -nodes -new -keyout server.key -out server.csr</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在证书生成过程中，请确保正确设置“通用名称”属性。证书签名请求必须由证书颁发机构签名，才能用作有效证书。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl x509 -req -days 365 -in server.csr -out ../server.crt -CA ../ca.crt -CAkey ca.key -CAcreateserial</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>证书生成过程的最后一步是生成和签署客户端证书：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl req -days 365 -nodes -new -keyout client.key -out client.csr</span>
<span class="c"># openssl x509 -req -days 3650 -in client.csr -out ../client.crt -CA ../ca.crt -CAkey ca.key</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在提示时，请记得使用相同的“ Common Name ”属性。完成后，请确保通过前面的命令生成了总共八（ 8 ）个新文件。</p>
</div>
<div class="paragraph">
<p>运行 OpenLDAP 服务器的守护进程是 <span class="filename">slapd</span> 。它的配置是通过 <span class="filename">slapd.ldif</span> 文件进行的：旧的 <span class="filename">slapd.conf</span> 已被 OpenLDAP 弃用。</p>
</div>
<div class="paragraph">
<p>[配置示例] 可以在 <span class="filename">slapd.ldif</span> 中找到，并且还可以在 <span class="filename">/usr/local/etc/openldap/slapd.ldif.sample</span> 中找到。选项在 slapd-config(5) 中有文档记录。 <span class="filename">slapd.ldif</span> 的每个部分，就像所有其他 LDAP 属性集一样，都通过 DN 唯一标识。请确保在 <code>dn:</code> 语句和所需部分的末尾之间没有空行。在下面的示例中，将使用 TLS 来实现安全通道。第一部分表示全局配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#
# See slapd-config(5) for details on configuration options.
# This file should NOT be world readable.
#
dn: cn=config
objectClass: olcGlobal
cn: config
#
#
# Define global ACLs to disable default read access.
#
olcArgsFile: /var/run/openldap/slapd.args
olcPidFile: /var/run/openldap/slapd.pid
olcTLSCertificateFile: /usr/local/etc/openldap/server.crt
olcTLSCertificateKeyFile: /usr/local/etc/openldap/private/server.key
olcTLSCACertificateFile: /usr/local/etc/openldap/ca.crt
#olcTLSCipherSuite: HIGH
olcTLSProtocolMin: 3.1
olcTLSVerifyClient: never</pre>
</div>
</div>
<div class="paragraph">
<p>在这里必须指定证书颁发机构、服务器证书和服务器私钥文件。建议让客户端选择安全密码并省略选项 <code>olcTLSCipherSuite</code> （与除 <span class="filename">openssl</span> 之外的 TLS 客户端不兼容）。选项 <code>olcTLSProtocolMin</code> 允许服务器要求最低安全级别：建议使用。虽然服务器必须进行验证，但客户端不需要： <code>olcTLSVerifyClient: never</code> 。</p>
</div>
<div class="paragraph">
<p>第二部分是关于后端模块的，可以按照以下方式进行配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#
# Load dynamic backend modules:
#
dn: cn=module,cn=config
objectClass: olcModuleList
cn: module
olcModulepath:	/usr/local/libexec/openldap
olcModuleload:	back_mdb.la
#olcModuleload:	back_bdb.la
#olcModuleload:	back_hdb.la
#olcModuleload:	back_ldap.la
#olcModuleload:	back_passwd.la
#olcModuleload:	back_shell.la</pre>
</div>
</div>
<div class="paragraph">
<p>第三部分专门用于加载数据库所需的 <code>ldif</code> 模式：它们是必不可少的。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dn: cn=schema,cn=config
objectClass: olcSchemaConfig
cn: schema

include: file:///usr/local/etc/openldap/schema/core.ldif
include: file:///usr/local/etc/openldap/schema/cosine.ldif
include: file:///usr/local/etc/openldap/schema/inetorgperson.ldif
include: file:///usr/local/etc/openldap/schema/nis.ldif</pre>
</div>
</div>
<div class="paragraph">
<p>接下来是前端配置部分：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Frontend settings
#
dn: olcDatabase={-1}frontend,cn=config
objectClass: olcDatabaseConfig
objectClass: olcFrontendConfig
olcDatabase: {-1}frontend
olcAccess: to * by * read
#
# Sample global access control policy:
#	Root DSE: allow anyone to read it
#	Subschema (sub)entry DSE: allow anyone to read it
#	Other DSEs:
#		Allow self write access
#		Allow authenticated users read access
#		Allow anonymous users to authenticate
#
#olcAccess: to dn.base=&#34;&#34; by * read
#olcAccess: to dn.base=&#34;cn=Subschema&#34; by * read
#olcAccess: to *
#	by self write
#	by users read
#	by anonymous auth
#
# if no access controls are present, the default policy
# allows anyone and everyone to read anything but restricts
# updates to rootdn.  (e.g., &#34;access to * by * read&#34;)
#
# rootdn can always read and write EVERYTHING!
#
olcPasswordHash: {SSHA}
# {SSHA} is already the default for olcPasswordHash</pre>
</div>
</div>
<div class="paragraph">
<p>另一个部分专门介绍了“配置后端”，这是以全局超级用户的身份访问 OpenLDAP 服务器配置的唯一方式。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dn: olcDatabase={0}config,cn=config
objectClass: olcDatabaseConfig
olcDatabase: {0}config
olcAccess: to * by * none
olcRootPW: {SSHA}iae+lrQZILpiUdf16Z9KmDmSwT77Dj4U</pre>
</div>
</div>
<div class="paragraph">
<p>默认管理员用户名是 <code>cn = config</code> 。在 shell 中输入 <span class="filename">slappasswd</span> ，选择一个密码并使用其哈希值填写到 <code>olcRootPW</code> 中。如果在导入 <span class="filename">slapd.ldif</span> 之前没有指定此选项，将来将无法修改 <em>全局配置</em> 部分。</p>
</div>
<div class="paragraph">
<p>最后一节是关于数据库后端的内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#######################################################################
# LMDB database definitions
#######################################################################
#
dn: olcDatabase=mdb,cn=config
objectClass: olcDatabaseConfig
objectClass: olcMdbConfig
olcDatabase: mdb
olcDbMaxSize: 1073741824
olcSuffix: dc=domain,dc=example
olcRootDN: cn=mdbadmin,dc=domain,dc=example
# Cleartext passwords, especially for the rootdn, should
# be avoided.  See slappasswd(8) and slapd-config(5) for details.
# Use of strong authentication encouraged.
olcRootPW: {SSHA}X2wHvIWDk6G76CQyCMS1vDCvtICWgn0+
# The database directory MUST exist prior to running slapd AND
# should only be accessible by the slapd and slap tools.
# Mode 700 recommended.
olcDbDirectory:	/var/db/openldap-data
# Indices to maintain
olcDbIndex: objectClass eq</pre>
</div>
</div>
<div class="paragraph">
<p>该数据库托管了 LDAP 目录的实际内容。除了 <code>mdb</code> 之外，还有其他类型可用。它的超级用户（与全局用户不同）在这里进行配置： <code>olcRootDN</code> 中是一个（可能是自定义的）用户名， <code>olcRootPW</code> 中是密码哈希值；可以像以前一样使用 <span class="filename">slappasswd</span> 。</p>
</div>
<div class="paragraph">
<p>这个 [仓库](<a href="http://www.openldap.org/devel/gitweb.cgi" class="bare">http://www.openldap.org/devel/gitweb.cgi</a> ? p = openldap.git ; a = tree ; f = tests/data/regressions/its8444 ; h = 8a5e808e63b0de3d2bdaf2cf34fecca8577ca7fd ; hb = HEAD) 包含了四个 <span class="filename">slapd.ldif</span> 的示例。要将现有的 <span class="filename">slapd.conf</span> 转换为 <span class="filename">slapd.ldif</span> ，请参考 [此页面](<a href="http://www.openldap.org/doc/admin24/slapdconf2.html" class="bare">http://www.openldap.org/doc/admin24/slapdconf2.html</a>) （请注意，这可能会引入一些无用的选项）。</p>
</div>
<div class="paragraph">
<p>配置完成后，必须将 <span class="filename">slapd.ldif</span> 放置在一个空目录中。建议将其创建为：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mkdir /usr/local/etc/openldap/slapd.d/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>导入配置数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /usr/local/sbin/slapadd -n0 -F /usr/local/etc/openldap/slapd.d/ -l /usr/local/etc/openldap/slapd.ldif</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>启动 <span class="filename">slapd</span> 守护进程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># /usr/local/libexec/slapd -F /usr/local/etc/openldap/slapd.d/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用选项 <code>-d</code> 进行调试，如在 slapd(8) 中所指定的那样。要验证服务器是否正在运行和工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ldapsearch -x -b &#39;&#39; -s base &#39;(objectclass=*)&#39; namingContexts</span>
<span class="c"># extended LDIF</span>
<span class="c">#</span>
<span class="c"># LDAPv3</span>
<span class="c"># base &lt;&gt; with scope baseObject</span>
<span class="c"># filter: (objectclass=*)</span>
<span class="c"># requesting: namingContexts</span>
<span class="c">#</span>

<span class="c">#</span>
dn:
namingContexts: <span class="nv">dc</span><span class="o">=</span>domain,dc<span class="o">=</span>example

<span class="c"># search result</span>
search: 2
result: 0 Success

<span class="c"># numResponses: 2</span>
<span class="c"># numEntries: 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>服务器仍然必须是可信的。如果之前从未进行过此操作，请按照以下说明进行操作。安装 OpenSSL 软件包或端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install openssl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>从存储 <span class="filename">ca.crt</span> 的目录（在本例中为 <span class="filename">/usr/local/etc/openldap</span> ）中运行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># c_rehash .</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>CA 证书和服务器证书现在在各自的角色中被正确识别。要验证这一点，请从 <span class="filename">server.crt</span> 目录中运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># openssl verify -verbose -CApath . server.crt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果 <span class="filename">slapd</span> 正在运行，请重新启动它。如 <span class="filename">/usr/local/etc/rc.d/slapd</span> 中所述，为了在启动时正确运行 <span class="filename">slapd</span> ，必须将以下行添加到 <span class="filename">/etc/rc.conf</span> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>slapd_enable=&#34;YES&#34;
slapd_flags=&#39;-h &#34;ldapi://%2fvar%2frun%2fopenldap%2fldapi/
ldap://0.0.0.0/&#34;&#39;
slapd_sockets=&#34;/var/run/openldap/ldapi&#34;
slapd_cn_config=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">slapd</span> 在启动时不提供调试功能。请检查 <span class="filename">/var/log/debug.log</span> 、 <span class="filename">dmesg -a</span> 和 <span class="filename">/var/log/messages</span> 以进行调试。</p>
</div>
<div class="paragraph">
<p>以下示例将组 <code>team</code> 和用户 <code>john</code> 添加到仍为空的 <code>domain.example</code> LDAP 数据库中。首先，创建文件 <span class="filename">domain.ldif</span> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat domain.ldif</span>
dn: <span class="nv">dc</span><span class="o">=</span>domain,dc<span class="o">=</span>example
objectClass: dcObject
objectClass: organization
o: domain.example
dc: domain

dn: <span class="nv">ou</span><span class="o">=</span>groups,dc<span class="o">=</span>domain,dc<span class="o">=</span>example
objectClass: top
objectClass: organizationalunit
ou: groups

dn: <span class="nv">ou</span><span class="o">=</span>users,dc<span class="o">=</span>domain,dc<span class="o">=</span>example
objectClass: top
objectClass: organizationalunit
ou: users

dn: <span class="nv">cn</span><span class="o">=</span>team,ou<span class="o">=</span>groups,dc<span class="o">=</span>domain,dc<span class="o">=</span>example
objectClass: top
objectClass: posixGroup
cn: team
gidNumber: 10001

dn: <span class="nv">uid</span><span class="o">=</span>john,ou<span class="o">=</span>users,dc<span class="o">=</span>domain,dc<span class="o">=</span>example
objectClass: top
objectClass: account
objectClass: posixAccount
objectClass: shadowAccount
cn: John McUser
uid: john
uidNumber: 10001
gidNumber: 10001
homeDirectory: /home/john/
loginShell: /usr/bin/bash
userPassword: secret</code></pre>
</div>
</div>
<div class="paragraph">
<p>请参阅 OpenLDAP 文档以获取更多详细信息。使用 <span class="filename">slappasswd</span> 将明文密码 <code>secret</code> 替换为 <code>userPassword</code> 中的哈希值。在允许 <code>john</code> 登录的所有系统中，指定的路径 <code>loginShell</code> 必须存在。最后，使用 <code>mdb</code> 管理员来修改数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ldapadd -W -D &#34;cn=mdbadmin,dc=domain,dc=example&#34; -f domain.ldif</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>只有全局超级用户才能对_global configuration_部分进行修改。例如，假设最初指定了选项 <code>olcTLSCipherSuite: HIGH:MEDIUM:SSLv3</code> ，现在必须删除该选项。首先，创建一个包含以下内容的文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cat global_mod</span>
dn: <span class="nv">cn</span><span class="o">=</span>config
changetype: modify
delete: olcTLSCipherSuite</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，应用修改：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ldapmodify -f global_mod -x -D &#34;cn=config&#34; -W</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当被询问时，请提供在“配置后端”部分选择的密码。用户名不是必需的：在这里，“ cn = config ”表示要修改的数据库部分的 DN 。或者，使用“ ldapmodify ”删除数据库的单行，“ ldapdelete ”删除整个条目。</p>
</div>
<div class="paragraph">
<p>如果出现问题，或者全局超级用户无法访问配置后端，可以删除并重新编写整个配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rm -rf /usr/local/etc/openldap/slapd.d/</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以编辑并重新导入 <span class="filename">slapd.ldif</span> 文件。请在没有其他解决方案可用时才按照此步骤操作。</p>
</div>
<div class="paragraph">
<p>这仅是服务器的配置。同一台机器还可以托管一个 LDAP 客户端，具有独立的配置。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-dhcp">32.6. 动态主机配置协议（ DHCP ）<a class="anchor" href="#network-dhcp"></a></h3>
<div class="paragraph">
<p>动态主机配置协议（ DHCP ）允许系统连接到网络，以便为在该网络上进行通信所需的寻址信息分配地址。 FreeBSD 包含了 OpenBSD 版本的 <code>dhclient</code> ，客户端使用它来获取寻址信息。 FreeBSD 没有安装 DHCP 服务器，但在 FreeBSD Ports Collection 中提供了几个服务器可供选择。 DHCP 协议的完整描述可在 <a href="http://www.freesoft.org/CIE/RFC/2131/">RFC 2131</a> 中找到。还可以在 <a href="http://www.isc.org/downloads/dhcp/">isc.org/downloads/dhcp/</a> 上找到相关的信息资源。</p>
</div>
<div class="paragraph">
<p>本节介绍了如何使用内置的 DHCP 客户端。然后介绍了如何安装和配置 DHCP 服务器。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 FreeBSD 中， <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> 设备同时被 DHCP 服务器和 DHCP 客户端所需。这个设备已经包含在 FreeBSD 安装的 <span class="filename">GENERIC</span> 内核中。如果用户选择创建自定义内核，并且使用 DHCP ，需要保留这个设备。</p>
</div>
<div class="paragraph">
<p>需要注意的是， <span class="filename">bpf</span> 还允许特权用户在该系统上运行网络数据包嗅探器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_配置_dhcp_客户端">32.6.1. 配置 DHCP 客户端<a class="anchor" href="#_配置_dhcp_客户端"></a></h4>
<div class="paragraph">
<p>FreeBSD 安装程序中包含了 DHCP 客户端支持，这使得配置新安装的系统从现有的 DHCP 服务器自动获取网络地址信息变得非常容易。有关网络配置的示例，请参考 <a href="./#bsdinstall-post">帐户、时区、服务和加固</a> 。</p>
</div>
<div class="paragraph">
<p>当在客户端机器上执行 <code>dhclient</code> 命令时，它开始广播请求配置信息。默认情况下，这些请求使用 UDP 端口 68 。服务器在 UDP 端口 67 上回复，给客户端分配一个 IP 地址和其他相关的网络信息，如子网掩码、默认网关和 DNS 服务器地址。这些信息以 DHCP &#34;租约&#34;的形式存在，并且在可配置的时间内有效。这样可以自动重用不再连接到网络的客户端的过时 IP 地址。 DHCP 客户端可以从服务器获取大量信息。详细列表可在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhcp-options&amp;sektion=5&amp;format=html">dhcp-options(5)</a> 中找到。</p>
</div>
<div class="paragraph">
<p>默认情况下，当 FreeBSD 系统启动时，它的 DHCP 客户端在后台或异步运行。在 DHCP 过程完成时，其他启动脚本继续运行，从而加快了系统的启动速度。</p>
</div>
<div class="paragraph">
<p>背景 DHCP 在 DHCP 服务器快速响应客户端请求时运行良好。然而，在某些系统上， DHCP 可能需要很长时间才能完成。如果网络服务在 DHCP 分配网络地址信息之前尝试运行，它们将失败。使用同步模式的 DHCP 可以解决这个问题，因为它会暂停启动过程，直到 DHCP 配置完成。</p>
</div>
<div class="paragraph">
<p>这行代码在 <span class="filename">/etc/rc.conf</span> 文件中用于配置后台或异步模式：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_fxp0=&#34;DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果系统在安装过程中配置为使用 DHCP ，则此行可能已经存在。在这些示例中，将_fxp0_替换为要动态配置的接口的名称，如 <a href="./#config-network-setup">“设置网络接口卡”</a> 中所述。</p>
</div>
<div class="paragraph">
<p>要配置系统使用同步模式，并在启动过程中暂停，直到 DHCP 完成，请使用&#34;`SYNCDHCP`&#34;。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_fxp0=&#34;SYNCDHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>还有其他的客户端选项可用。在 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 中搜索 <code>dhclient</code> 以获取详细信息。</p>
</div>
<div class="paragraph">
<p>DHCP 客户端使用以下文件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="filename">/etc/dhclient.conf</span></p>
<div class="paragraph">
<p><code>dhclient</code> 使用的配置文件。通常，该文件只包含注释，因为默认设置适用于大多数客户端。该配置文件在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.conf&amp;sektion=5&amp;format=html">dhclient.conf(5)</a> 中有详细描述。</p>
</div>
</li>
<li>
<p><span class="filename">/sbin/dhclient</span></p>
<div class="paragraph">
<p>有关该命令本身的更多信息可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient&amp;sektion=8&amp;format=html">dhclient(8)</a> 中找到。</p>
</div>
</li>
<li>
<p><span class="filename">/sbin/dhclient-script</span></p>
<div class="paragraph">
<p>这是一个特定于 FreeBSD 的 DHCP 客户端配置脚本。它在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient-script&amp;sektion=8&amp;format=html">dhclient-script(8)</a> 中有详细描述，但是通常不需要用户进行任何修改以正常运行。</p>
</div>
</li>
<li>
<p><span class="filename">/var/db/dhclient.leases.interface</span></p>
<div class="paragraph">
<p>DHCP 客户端在此文件中保留了一个有效租约的数据库，该文件被写入为日志，并在 <a href="https://man.freebsd.org/cgi/man.cgi?query=dhclient.leases&amp;sektion=5&amp;format=html">dhclient.leases(5)</a> 中进行了描述。</p>
</div>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="network-dhcp-server">32.6.2. 安装和配置 DHCP 服务器<a class="anchor" href="#network-dhcp-server"></a></h4>
<div class="paragraph">
<p>本节演示了如何使用 Internet Systems Consortium (ISC) 实现的 DHCP 服务器将 FreeBSD 系统配置为 DHCP 服务器。可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/">net/isc-dhcp44-server</a> 软件包或端口安装此实现及其文档。</p>
</div>
<div class="paragraph">
<p>安装包： net/isc-dhcp44-server[] 将安装一个示例配置文件。将 <span class="filename">/usr/local/etc/dhcpd.conf.example</span> 复制到 <span class="filename">/usr/local/etc/dhcpd.conf</span> ，并对这个新文件进行任何编辑。</p>
</div>
<div class="paragraph">
<p>配置文件由子网和主机的声明组成，这些声明定义了提供给 DHCP 客户端的信息。例如，以下行配置了以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>option domain-name &#34;example.org&#34;;<i class="conum" data-value="1"></i><b>(1)</b>
option domain-name-servers ns1.example.org;<i class="conum" data-value="2"></i><b>(2)</b>
option subnet-mask 255.255.255.0;<i class="conum" data-value="3"></i><b>(3)</b>

default-lease-time 600;<i class="conum" data-value="4"></i><b>(4)</b>
max-lease-time 72400;<i class="conum" data-value="5"></i><b>(5)</b>
ddns-update-style none;<i class="conum" data-value="6"></i><b>(6)</b>

subnet 10.254.239.0 netmask 255.255.255.224 {
  range 10.254.239.10 10.254.239.20;<i class="conum" data-value="7"></i><b>(7)</b>
  option routers rtr-239-0-1.example.org, rtr-239-0-2.example.org;<i class="conum" data-value="8"></i><b>(8)</b>
}

host fantasia {
  hardware ethernet 08:00:07:26:c0:a5;<i class="conum" data-value="9"></i><b>(9)</b>
  fixed-address fantasia.fugue.com;<i class="conum" data-value="10"></i><b>(10)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>此选项指定将提供给客户端的默认搜索域。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=resolv.conf&amp;sektion=5&amp;format=html">resolv.conf(5)</a> 。 &lt;.&gt; 此选项指定客户端应使用的逗号分隔的 DNS 服务器列表。它们可以按照完全限定域名（ FQDN ）列出，如示例中所示，也可以按照它们的 IP 地址列出。 &lt;.&gt; 提供给客户端的子网掩码。 &lt;.&gt; 默认租约到期时间（以秒为单位）。客户端可以配置为覆盖此值。 &lt;.&gt; 租约的最大允许时间长度（以秒为单位）。如果客户端请求更长的租约，租约仍将发放，但仅在 <code>max-lease-time</code> 内有效。 &lt;.&gt; <code>none</code> 的默认值禁用动态 DNS 更新。将其更改为 <code>interim</code> 会配置 DHCP 服务器在发放租约时更新 DNS 服务器，以便 DNS 服务器知道哪些 IP 地址与网络中的哪些计算机相关联。除非已配置 DNS 服务器支持动态 DNS ，否则不要更改默认设置。 &lt;.&gt; 此行创建一个可用 IP 地址池，用于分配给 DHCP 客户端。地址范围必须对先前行中指定的网络或子网有效。 &lt;.&gt; 声明对于在开放的 <code>{</code> 括号之前指定的网络或子网有效的默认网关。 &lt;.&gt; 指定客户端的硬件 MAC 地址，以便 DHCP 服务器在其发出请求时能够识别客户端。 &lt;.&gt; 指定此主机始终应获得相同的 IP 地址。使用主机名是正确的，因为 DHCP 服务器将在返回租约信息之前解析主机名。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>此配置文件支持更多选项。有关详细信息和示例，请参阅与服务器一起安装的 dhcpd.conf(5) 。</p>
</div>
<div class="paragraph">
<p>完成 <span class="filename">dhcpd.conf</span> 的配置后，在 <span class="filename">/etc/rc.conf</span> 中启用 DHCP 服务器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dhcpd_enable=&#34;YES&#34;
dhcpd_ifaces=&#34;dc0&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>将 <code>dc0</code> 替换为 DHCP 服务器应该监听 DHCP 客户端请求的接口（或接口，用空格分隔）。</p>
</div>
<div class="paragraph">
<p>通过执行以下命令启动服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service isc-dhcpd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对服务器配置的任何未来更改都需要停止 dhcpd 服务，然后使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=service&amp;sektion=8&amp;format=html">service(8)</a> 启动。</p>
</div>
<div class="paragraph">
<p>DHCP 服务器使用以下文件。请注意，手册页面已与服务器软件一起安装。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><span class="filename">/usr/local/sbin/dhcpd</span></p>
<div class="paragraph">
<p>有关 dhcpd 服务器的更多信息可以在 dhcpd(8) 中找到。</p>
</div>
</li>
<li>
<p><span class="filename">/usr/local/etc/dhcpd.conf</span></p>
<div class="paragraph">
<p>服务器配置文件需要包含所有应提供给客户端的信息，以及有关服务器操作的信息。此配置文件在 dhcpd.conf(5) 中有详细描述。</p>
</div>
</li>
<li>
<p><span class="filename">/var/db/dhcpd.leases</span></p>
<div class="paragraph">
<p>DHCP 服务器将其发放的租约记录在此文件中，该文件被写入为日志。请参考 dhcpd.leases(5) ，其中提供了稍长一些的描述。</p>
</div>
</li>
<li>
<p><span class="filename">/usr/local/sbin/dhcrelay</span></p>
<div class="paragraph">
<p>这个守护进程用于高级环境中，其中一个 DHCP 服务器将客户端的请求转发到另一个位于不同网络上的 DHCP 服务器。如果需要这个功能，请安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-relay/">net/isc-dhcp44-relay</a> 包或端口。安装包括了提供更多详细信息的 dhcrelay(8) 。</p>
</div>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-dns">32.7. 域名系统（ DNS ）<a class="anchor" href="#network-dns"></a></h3>
<div class="paragraph">
<p>域名系统（ DNS ）是一种将域名映射到 IP 地址，反之亦然的协议。 DNS 通过一个相对复杂的系统来协调互联网上的域名，包括权威根域名服务器、顶级域名（ TLD ）和其他规模较小的名称服务器，这些服务器托管和缓存各个域名的信息。在系统上执行 DNS 查找时，不需要运行名称服务器。</p>
</div>
<div class="paragraph">
<p>下表描述了与 DNS 相关的一些术语：</p>
</div>
<table class="tableblock frame-none grid-all stretch">
<caption class="title">表 44. DNS 术语</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">术语</th>
<th class="tableblock halign-left valign-top">定义</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">正向 DNS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">主机名到 IP 地址的映射。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">起源</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">指的是特定区域文件中涵盖的域名。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">解析器</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">系统进程通过向名称服务器查询区域信息的方式进行。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">反向 DNS</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">IP 地址到主机名的映射。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">根区</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">互联网区域层次结构的起始点。所有区域都属于根区域，类似于文件系统中所有文件都属于根目录。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">区域</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">由同一管理机构管理的个人域、子域或 DNS 的一部分。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>区域的示例：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>“。”通常在文档中用来指代根区域。</p>
</li>
<li>
<p><code>org.</code> 是根域下的顶级域名（ TLD ）。</p>
</li>
<li>
<p><code>example.org.</code> 是 <code>org.</code> 顶级域名下的一个区域。</p>
</li>
<li>
<p><code>1.168.192.in-addr.arpa</code> 是一个区域，引用了所有属于 `192.168.1.*`IP 地址空间的 IP 地址。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>正如我们所看到的，主机名的更具体部分出现在其左侧。例如， <code>example.org.</code> 比 <code>org.</code> 更具体，而 <code>org.</code> 比根域更具体。主机名的每个部分的布局很像文件系统： <span class="filename">/dev</span> 目录位于根目录下，依此类推。</p>
</div>
<div class="sect3">
<h4 id="_运行名称服务器的原因">32.7.1. 运行名称服务器的原因<a class="anchor" href="#_运行名称服务器的原因"></a></h4>
<div class="paragraph">
<p>有许多原因可以选择运行名称服务器。以下是一些常见的原因：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>网络性能：通过运行自己的名称服务器，您可以提高网络性能。名称服务器可以缓存 DNS 查询结果，从而减少对外部 DNS 服务器的依赖，并加快域名解析的速度。</p>
</li>
<li>
<p>安全性：运行自己的名称服务器可以提高网络的安全性。您可以实施安全策略，例如阻止恶意域名或 IP 地址，并监控 DNS 查询以检测潜在的安全威胁。</p>
</li>
<li>
<p>私有网络：如果您拥有一个私有网络，运行自己的名称服务器可以提供更好的控制和管理。您可以自定义域名解析规则，并确保只有授权的设备可以访问您的网络资源。</p>
</li>
<li>
<p>自定义域名：运行自己的名称服务器可以让您创建自定义的域名，并将其映射到您的网络资源。这样，您可以使用自己的域名来访问您的网站、电子邮件服务器等。</p>
</li>
<li>
<p>网络稳定性：通过运行自己的名称服务器，您可以减少对外部 DNS 服务器的依赖，从而提高网络的稳定性。即使外部 DNS 服务器出现故障，您的网络仍然可以正常工作。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>总之，运行自己的名称服务器可以提供更好的网络性能、安全性和控制权。无论是个人用户还是企业用户，都可以从中受益。</p>
</div>
<div class="paragraph">
<p>名称服务器通常有两种形式：权威名称服务器和缓存（也称为解析）名称服务器。</p>
</div>
<div class="paragraph">
<p>当需要一个权威名称服务器时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>一个想要向世界提供 DNS 信息，并对查询进行权威回复的服务。</p>
</li>
<li>
<p>一个域名，比如 <code>example.org</code> ，已经注册，需要为其下的主机名分配 IP 地址。</p>
</li>
<li>
<p>一个 IP 地址块需要反向 DNS 条目（ IP 到主机名）。</p>
</li>
<li>
<p>备份或第二名称服务器，称为从服务器，将回复查询。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当需要缓存名称服务器时：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>本地 DNS 服务器可能比查询外部名称服务器更快地缓存和响应。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当查询 <code>www.FreeBSD.org</code> 时，解析器通常会查询上行 ISP 的名称服务器，并检索回复。使用本地缓存的 DNS 服务器，查询只需由缓存的 DNS 服务器向外部世界发起一次。由于信息被本地缓存，额外的查询将不需要离开本地网络。</p>
</div>
</div>
<div class="sect3">
<h4 id="_dns_服务器配置">32.7.2. DNS 服务器配置<a class="anchor" href="#_dns_服务器配置"></a></h4>
<div class="paragraph">
<p>Unbound 在 FreeBSD 基本系统中提供。默认情况下，它只为本地机器提供 DNS 解析。虽然基本系统包可以配置为提供超出本地机器的解析服务，但建议通过从 FreeBSD Ports Collection 安装 Unbound 来满足此类需求。</p>
</div>
<div class="paragraph">
<p>要启用 Unbound ，请将以下内容添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>local_unbound_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在新的 Unbound 配置中，任何已存在的名字服务器在 /etc/resolv.conf 文件中将被配置为转发器。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果列出的任何一个名称服务器不支持 DNSSEC ，本地 DNS 解析将失败。请确保测试每个名称服务器并删除测试失败的名称服务器。以下命令将显示运行在 <code>192.168.1.1</code> 上的名称服务器的信任树或失败情况：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>drill -S FreeBSD.org @192.168.1.1</code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一旦确认每个域名服务器都支持 DNSSEC ，启动 Unbound ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service local_unbound onestart</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这将负责更新 [/etc/resolv.conf](文件名) 以便查询 DNSSEC 安全域名能够正常工作。例如，运行以下命令来验证 FreeBSD.org 的 DNSSEC 信任树：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>drill -S FreeBSD.org
;; Number of trusted keys: 1
;; Chasing: freebsd.org. A

DNSSEC Trust tree:
freebsd.org. <span class="o">(</span>A<span class="o">)</span>
|---freebsd.org. <span class="o">(</span>DNSKEY keytag: 36786 alg: 8 flags: 256<span class="o">)</span>
    |---freebsd.org. <span class="o">(</span>DNSKEY keytag: 32659 alg: 8 flags: 257<span class="o">)</span>
    |---freebsd.org. <span class="o">(</span>DS keytag: 32659 digest <span class="nb">type</span>: 2<span class="o">)</span>
        |---org. <span class="o">(</span>DNSKEY keytag: 49587 alg: 7 flags: 256<span class="o">)</span>
            |---org. <span class="o">(</span>DNSKEY keytag: 9795 alg: 7 flags: 257<span class="o">)</span>
            |---org. <span class="o">(</span>DNSKEY keytag: 21366 alg: 7 flags: 257<span class="o">)</span>
            |---org. <span class="o">(</span>DS keytag: 21366 digest <span class="nb">type</span>: 1<span class="o">)</span>
            |   |---. <span class="o">(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class="o">)</span>
            |       |---. <span class="o">(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class="o">)</span>
            |---org. <span class="o">(</span>DS keytag: 21366 digest <span class="nb">type</span>: 2<span class="o">)</span>
                |---. <span class="o">(</span>DNSKEY keytag: 40926 alg: 8 flags: 256<span class="o">)</span>
                    |---. <span class="o">(</span>DNSKEY keytag: 19036 alg: 8 flags: 257<span class="o">)</span>
;; Chase successful</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_权威名称服务器配置">32.7.3. 权威名称服务器配置<a class="anchor" href="#_权威名称服务器配置"></a></h4>
<div class="paragraph">
<p>FreeBSD 在基本系统中不提供权威名称服务器软件。鼓励用户安装第三方应用程序，如 <a class="package" href="https://cgit.freebsd.org/ports/tree/dns/nsd/">dns/nsd</a> 或 <a class="package" href="https://cgit.freebsd.org/ports/tree/dns/bind918/">dns/bind918</a> 包或端口。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-apache">32.8. Apache HTTP Server 是一个开源的 Web 服务器软件，它是目前最流行的 Web 服务器之一。它由 Apache 软件基金会开发和维护，可运行在多种操作系统上，包括 Windows 、 Linux 和 Unix 等。 Apache HTTP Server 具有高度可扩展性和灵活性，支持多种模块和插件，可以实现各种功能，如动态内容生成、虚拟主机配置和安全性控制等。它还提供了丰富的文档和社区支持，使得用户能够轻松地学习和使用。无论是个人网站还是大型企业应用， Apache HTTP Server 都是一个可靠和强大的选择。<a class="anchor" href="#network-apache"></a></h3>
<div class="paragraph">
<p>开源的 Apache HTTP 服务器是最广泛使用的 Web 服务器。 FreeBSD 默认不安装这个 Web 服务器，但可以通过包 :www/apache24[] 包或端口进行安装。</p>
</div>
<div class="paragraph">
<p>本节概述了如何在 FreeBSD 上配置和启动 Apache HTTP Server 的 2.x 版本。有关 Apache 2.X 及其配置指令的更详细信息，请参阅 <a href="http://httpd.apache.org/">httpd.apache.org</a> 。</p>
</div>
<div class="sect3">
<h4 id="_配置和启动_apache">32.8.1. 配置和启动 Apache<a class="anchor" href="#_配置和启动_apache"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 中，主要的 Apache HTTP 服务器配置文件被安装在 [/usr/local/etc/apache2x/httpd.conf] ，其中_x_代表版本号。这个 ASCII 文本文件以 <code>#</code> 开头的行作为注释。最经常修改的指令有：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>ServerRoot &#34;/usr/local&#34;</code> 的译文为： <code>ServerRoot &#34;/usr/local&#34;</code></dt>
<dd>
<p>指定 Apache 安装的默认目录层次结构。二进制文件存储在服务器根目录的 <span class="filename">bin</span> 和 <span class="filename">sbin</span> 子目录中，配置文件存储在 <span class="filename">etc/apache2x</span> 子目录中。</p>
</dd>
<dt class="hdlist1"><code>ServerAdmin you @ example.com</code> 的中文翻译为： <code>ServerAdmin you @ example.com</code></dt>
<dd>
<p>将此更改为接收服务器问题的电子邮件地址。此地址还会出现在一些由服务器生成的页面上，例如错误文档。</p>
</dd>
<dt class="hdlist1"><code>ServerName www.example.com:80</code> 表示服务器的主机名为 www.example.com ，端口号为 80 。</dt>
<dd>
<p>允许管理员设置一个主机名，该主机名将发送给服务器的客户端。例如，可以使用 <code>www</code> 代替实际的主机名。如果系统没有注册的 DNS 名称，请输入其 IP 地址。如果服务器将监听一个替代端口，请将 <code>80</code> 更改为替代端口号。</p>
</dd>
<dt class="hdlist1"><code>DocumentRoot &#34;/usr/local/www/apache2_x_/data&#34;</code> 的译文为： ` 文档根目录 &#34;/usr/local/www/apache2_x_/data&#34;` 。</dt>
<dd>
<p>文档将被提供的目录。默认情况下，所有请求都从此目录获取，但可以使用符号链接和别名指向其他位置。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>在进行更改之前，始终将默认的 Apache 配置文件备份是一个好主意。当 Apache 的配置完成后，保存文件并使用 <code>apachectl</code> 验证配置。运行 <code>apachectl configtest</code> 应该返回 <code>Syntax OK</code> 。</p>
</div>
<div class="paragraph">
<p>要在系统启动时启动 Apache ，请将以下行添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>apache24_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果要使用非默认选项启动 Apache ，则可以将以下行添加到 [/etc/rc.conf]# 以指定所需的标志：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>apache24_flags=&#34;&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果 apachectl 没有报告配置错误，请立即启动 <code>httpd</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service apache24 start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以通过在 Web 浏览器中输入 <code>http://<em>localhost</em></code> 来测试 <code>httpd</code> 服务，将 <em>localhost</em> 替换为运行 <code>httpd</code> 的机器的完全限定域名。显示的默认网页是 <span class="filename">/usr/local/www/apache24/data/index.html</span> 。</p>
</div>
<div class="paragraph">
<p>在 <code>httpd</code> 运行时，可以使用以下命令测试 Apache 配置是否存在错误：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service apache24 configtest</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>需要注意的是， <code>configtest</code> 不是一个标准的 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a></code> ，并且不应该期望它能够适用于所有的启动脚本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_虚拟主机">32.8.2. 虚拟主机<a class="anchor" href="#_虚拟主机"></a></h4>
<div class="paragraph">
<p>虚拟主机允许多个网站在一个 Apache 服务器上运行。虚拟主机可以是基于 IP 的或基于名称的。基于 IP 的虚拟主机为每个网站使用不同的 IP 地址。基于名称的虚拟主机使用客户端的 HTTP/1.1 头部来确定主机名，这样可以让多个网站共享同一个 IP 地址。</p>
</div>
<div class="paragraph">
<p>要设置 Apache 使用基于名称的虚拟主机，为每个网站添加一个 <code>VirtualHost</code> 块。例如，对于名为 <code>www.domain.tld</code> 的 Web 服务器，其虚拟域为 <code>www.someotherdomain.tld</code> ，请将以下条目添加到 <span class="filename">httpd.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&lt;VirtualHost *&gt;
    ServerName www.domain.tld
    DocumentRoot /www/domain.tld
&lt;/VirtualHost&gt;

&lt;VirtualHost *&gt;
    ServerName www.someotherdomain.tld
    DocumentRoot /www/someotherdomain.tld
&lt;/VirtualHost&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>对于每个虚拟主机，请将 <code>ServerName</code> 和 <code>DocumentRoot</code> 的值替换为要使用的值。</p>
</div>
<div class="paragraph">
<p>有关设置虚拟主机的更多信息，请参阅官方 Apache 文档： <a href="http://httpd.apache.org/docs/vhosts/" class="bare">http://httpd.apache.org/docs/vhosts/</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_apache_模块">32.8.3. Apache 模块<a class="anchor" href="#_apache_模块"></a></h4>
<div class="paragraph">
<p>Apache 使用模块来增强基本服务器提供的功能。请参考 <a href="http://httpd.apache.org/docs/current/mod/" class="bare">http://httpd.apache.org/docs/current/mod/</a> ，了解可用模块的完整列表和配置细节。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，一些模块可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/apache24/">www/apache24</a> 端口进行编译。在 <span class="filename">/usr/ports/www/apache24</span> 目录下输入 <code>make config</code> 命令可以查看可用的模块以及默认启用的模块。如果模块没有与端口一起编译， FreeBSD Ports Collection 提供了一种简单的方法来安装许多模块。本节介绍了三个最常用的模块。</p>
</div>
<div class="sect4">
<h5 id="_ssl_支持">32.8.3.1. SSL 支持<a class="anchor" href="#_ssl_支持"></a></h5>
<div class="paragraph">
<p>在某个时间点上， Apache 中支持 SSL 需要一个名为 <span class="filename">mod_ssl</span> 的辅助模块。但现在情况已经改变， Apache 的默认安装中已经内置了 SSL 功能。在安装的文件中有一个示例，可以了解如何启用 SSL 网站支持，该文件位于 <span class="filename">/usr/local/etc/apache24/extra</span> 目录下的 <span class="filename">httpd-ssl.conf</span> 文件中。在这个目录中还有一个名为 <span class="filename">ssl.conf-sample</span> 的示例文件。建议同时评估这两个文件，以正确设置 Apache Web 服务器中的安全网站。</p>
</div>
<div class="paragraph">
<p>在 SSL 配置完成后，必须取消注释主要的 <span class="filename">http.conf</span> 文件中的以下行，以便在下次重新启动或重新加载 Apache 时激活更改：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#Include etc/apache24/extra/httpd-ssl.conf</pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>SSL 版本 2 和版本 3 存在已知的漏洞问题。强烈建议在旧的 SSL 选项之外启用 TLS 版本 1.2 和 1.3 。可以通过在 <span class="filename">ssl.conf</span> 中设置以下选项来实现：</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>SSLProtocol all -SSLv3 -SSLv2 +TLSv1.2 +TLSv1.3
SSLProxyProtocol all -SSLv2 -SSLv3 -TLSv1 -TLSv1.1</pre>
</div>
</div>
<div class="paragraph">
<p>为了完成 Web 服务器中 SSL 的配置，请取消以下行的注释，以确保在重新启动或重新加载期间将配置拉入 Apache 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Secure (SSL/TLS) connections
Include etc/apache24/extra/httpd-ssl.conf</pre>
</div>
</div>
<div class="paragraph">
<p>在 <span class="filename">httpd.conf</span> 文件中，还必须取消以下行的注释，以完全支持 Apache 中的 SSL ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>LoadModule authn_socache_module libexec/apache24/mod_authn_socache.so
LoadModule socache_shmcb_module libexec/apache24/mod_socache_shmcb.so
LoadModule ssl_module libexec/apache24/mod_ssl.so</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是与证书颁发机构合作，在系统上安装适当的证书。这将为网站建立一个信任链，防止出现自签名证书的警告。</p>
</div>
</div>
<div class="sect4">
<h5 id="_mod_perl">32.8.3.2. <span class="filename">mod_perl</span><a class="anchor" href="#_mod_perl"></a></h5>
<div class="paragraph">
<p><span class="filename">mod_perl</span> 模块使得可以用 Perl 编写 Apache 模块。此外，嵌入在服务器中的持久解释器避免了启动外部解释器的开销和 Perl 启动时间的惩罚。</p>
</div>
<div class="paragraph">
<p>可以使用包 :www/mod_perl2[] 包或端口安装 <span class="filename">mod_perl</span> 。有关使用此模块的文档可以在 <a href="http://perl.apache.org/docs/2.0/index.html">http://perl.apache.org/docs/2.0/index.html</a> 找到。</p>
</div>
</div>
<div class="sect4">
<h5 id="_mod_php">32.8.3.3. <span class="filename">mod_php</span><a class="anchor" href="#_mod_php"></a></h5>
<div class="paragraph">
<p><em>PHP: Hypertext Preprocessor</em>（ PHP ）是一种通用的脚本语言，特别适用于网页开发。它可以嵌入到 HTML 中，其语法借鉴了 C 、 Java™ 和 Perl ，旨在让网页开发人员能够快速编写动态生成的网页。</p>
</div>
<div class="paragraph">
<p>通过安装适当的端口，可以为 Apache 和任何其他用 PHP 编写的功能添加支持。</p>
</div>
<div class="paragraph">
<p>对于所有支持的版本，请使用 <code>pkg</code> 搜索软件包数据库：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg search php</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将显示一个列表，其中包括版本和它们提供的附加功能。这些组件是完全模块化的，这意味着通过安装适当的端口来启用功能。要为 Apache 安装 PHP 7.4 版本，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install mod_php74</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果需要安装任何依赖包，它们也将被安装。</p>
</div>
<div class="paragraph">
<p>默认情况下， PHP 将不会被启用。要使其生效，需要将以下行添加到位于 [/usr/local/etc/apache24] 目录中的 Apache 配置文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&lt;FilesMatch &#34;\.php$&#34;&gt;
    SetHandler application/x-httpd-php
&lt;/FilesMatch&gt;
&lt;FilesMatch &#34;\.phps$&#34;&gt;
    SetHandler application/x-httpd-php-source
&lt;/FilesMatch&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>此外，配置文件中的 <code>DirectoryIndex</code> 也需要更新，并且需要重新启动或重新加载 Apache 才能使更改生效。</p>
</div>
<div class="paragraph">
<p>使用 <code>pkg</code> 也可以安装许多 PHP 功能的支持。例如，要安装 XML 或 SSL 的支持，请安装它们各自的端口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install php74-xml php74-openssl</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>与之前一样，即使只是安装了一个模块，也需要重新加载 Apache 配置文件才能使更改生效。</p>
</div>
<div class="paragraph">
<p>要执行优雅重启以重新加载配置，请执行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># apachectl graceful</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>安装完成后，有两种方法可以获取已安装的 PHP 支持模块和构建的环境信息。第一种方法是安装完整的 PHP 二进制文件，并运行命令来获取信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install php74</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># php -i |less</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>需要将输出传递给一个分页器，比如 <code>more</code> 或 <code>less</code> ，以便更容易地处理大量的输出。</p>
</div>
<div class="paragraph">
<p>最后，要对 PHP 的全局配置进行任何更改，需要使用一个文档完善的文件，安装在 [/usr/local/etc/php.ini] 。在安装时，该文件不存在，因为有两个版本可供选择，一个是 [php.ini-development] ，另一个是 [php.ini-production] 。这些是管理员在部署过程中的起点。</p>
</div>
</div>
<div class="sect4">
<h5 id="_http2_支持">32.8.3.4. HTTP2 支持<a class="anchor" href="#_http2_支持"></a></h5>
<div class="paragraph">
<p>在使用 <code>pkg</code> 安装端口时，默认情况下， Apache 支持 HTTP2 协议。新版本的 HTTP 相比之前的版本有很多改进，包括利用单个连接访问网站，减少 TCP 连接的总往返次数。此外，数据包头部数据被压缩， HTTP2 默认要求加密。</p>
</div>
<div class="paragraph">
<p>当 Apache 配置为仅使用 HTTP2 时， Web 浏览器将需要安全的、加密的 HTTPS 连接。当 Apache 配置为同时使用两个版本时，如果在连接过程中出现任何问题， HTTP1.1 将被视为备选选项。</p>
</div>
<div class="paragraph">
<p>虽然这个变化确实需要管理员进行一些改动，但这些改动是积极的，并且对于每个人来说都意味着一个更安全的互联网。这些改动只需要对目前没有实施 SSL 和 TLS 的网站进行。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>此配置依赖于前面的部分，包括 TLS 支持。建议在继续进行此配置之前按照那些说明进行操作。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>通过取消注释 <span class="filename">/usr/local/etc/apache24/httpd.conf</span> 中的一行来启用 http2 模块，并将 mpm_prefork 模块替换为 mpm_event 模块，因为前者不支持 HTTP2 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>LoadModule http2_module libexec/apache24/mod_http2.so
LoadModule mpm_event_module libexec/apache24/mod_mpm_event.so</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>有一个单独的 <span class="filename">mod_http2</span> 端口可用。它的存在是为了更快地提供安全性和错误修复，而不是使用捆绑的 <span class="filename">apache24</span> 端口安装的模块。它不是必需的 HTTP2 支持，但可供选择。安装后，应在 Apache 配置中使用 <span class="filename">mod_h2.so</span> 替代 <span class="filename">mod_http2.so</span> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在 Apache 中实现 HTTP2 有两种方法；一种是全局应用于所有站点和系统上运行的每个 VirtualHost 。要在全局启用 HTTP2 ，请在 ServerName 指令下添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Protocols h2 http/1.1</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>要在明文上启用 HTTP2 ，请在 <code>.filename</code><mark>httpd.conf</mark> 中使用 <code>h2h2chttp/1.1</code> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>在这里使用 h2c 将允许明文的 HTTP2 数据在系统中传递，但不推荐这样做。此外，在这里使用 http/1.1 将允许系统在需要时回退到 HTTP1.1 版本的协议。</p>
</div>
<div class="paragraph">
<p>要为单个虚拟主机启用 HTTP2 ，请在 <span class="filename">httpd.conf</span> 或 <span class="filename">httpd-ssl.conf</span> 中的 VirtualHost 指令中添加相同的行。</p>
</div>
<div class="paragraph">
<p>使用 <code>apachectl</code><span class="parameter">reload</span> 命令重新加载配置，并在访问托管页面之后使用以下任一方法测试配置：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># grep &#34;HTTP/2.0&#34; /var/log/httpd-access.log</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该返回类似以下的内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>192.168.1.205 - - [18/Oct/2020:18:34:36 -0400] &#34;GET / HTTP/2.0&#34; 304 -
192.0.2.205 - - [18/Oct/2020:19:19:57 -0400] &#34;GET / HTTP/2.0&#34; 304 -
192.0.0.205 - - [18/Oct/2020:19:20:52 -0400] &#34;GET / HTTP/2.0&#34; 304 -
192.0.2.205 - - [18/Oct/2020:19:23:10 -0400] &#34;GET / HTTP/2.0&#34; 304 -</pre>
</div>
</div>
<div class="paragraph">
<p>另一种方法是使用网页浏览器内置的站点调试器或 <code>tcpdump</code> ；然而，使用任何一种方法都超出了本文档的范围。</p>
</div>
<div class="paragraph">
<p>通过使用 <span class="filename">mod_proxy_http2.so</span> 模块支持 HTTP2 反向代理连接。在配置 ProxyPass 或 RewriteRules [P] 语句时，应使用 h2:// 作为连接。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_动态网站">32.8.4. 动态网站<a class="anchor" href="#_动态网站"></a></h4>
<div class="paragraph">
<p>除了 mod_perl 和 mod_php 之外，还有其他语言可用于创建动态网页内容。这些包括 Django 和 Ruby on Rails 。</p>
</div>
<div class="sect4">
<h5 id="_django_是一个开源的_web_应用框架使用_python_编写它遵循了_mvc_模型_视图_控制器的设计模式提供了一套强大的工具和功能用于快速开发高质量的_web_应用程序_django_具有灵活的_url_路由模板系统表单处理数据库访问等功能使开发人员能够轻松构建功能丰富的网站它还提供了强大的管理后台用于管理网站的内容和数据_django_的设计理念是_dry_dont_repeat_yourself_通过提供一致的开发模式和自动化的任务帮助开发人员提高效率它也是一个非常受欢迎的框架被广泛应用于各种规模的_web_项目中">32.8.4.1. Django 是一个开源的 Web 应用框架，使用 Python 编写。它遵循了 MVC （模型 - 视图 - 控制器）的设计模式，提供了一套强大的工具和功能，用于快速开发高质量的 Web 应用程序。 Django 具有灵活的 URL 路由、模板系统、表单处理、数据库访问等功能，使开发人员能够轻松构建功能丰富的网站。它还提供了强大的管理后台，用于管理网站的内容和数据。 Django 的设计理念是 DRY （ Don’t Repeat Yourself ），通过提供一致的开发模式和自动化的任务，帮助开发人员提高效率。它也是一个非常受欢迎的框架，被广泛应用于各种规模的 Web 项目中。<a class="anchor" href="#_django_是一个开源的_web_应用框架使用_python_编写它遵循了_mvc_模型_视图_控制器的设计模式提供了一套强大的工具和功能用于快速开发高质量的_web_应用程序_django_具有灵活的_url_路由模板系统表单处理数据库访问等功能使开发人员能够轻松构建功能丰富的网站它还提供了强大的管理后台用于管理网站的内容和数据_django_的设计理念是_dry_dont_repeat_yourself_通过提供一致的开发模式和自动化的任务帮助开发人员提高效率它也是一个非常受欢迎的框架被广泛应用于各种规模的_web_项目中"></a></h5>
<div class="paragraph">
<p>Django 是一个 BSD 许可的框架，旨在让开发人员快速编写高性能、优雅的 Web 应用程序。它提供了一个对象关系映射器，使得数据类型可以作为 Python 对象进行开发。它还提供了一个丰富的动态数据库访问 API ，开发人员无需编写 SQL 语句即可对这些对象进行操作。此外，它还提供了一个可扩展的模板系统，使得应用程序的逻辑与 HTML 的呈现分离。</p>
</div>
<div class="paragraph">
<p>Django 依赖于 mod_python 和一个 SQL 数据库引擎。在 FreeBSD 中，包 www/py-django 的端口会自动安装 mod_python ，并支持 PostgreSQL 、 MySQL 或 SQLite 数据库，默认为 SQLite 。要更改数据库引擎，请在 /usr/ports/www/py-django 目录下输入 <code>make config</code> ，然后安装端口。</p>
</div>
<div class="paragraph">
<p>一旦安装了 Django ，应用程序将需要一个项目目录以及 Apache 配置，以便使用嵌入式 Python 解释器。该解释器用于调用站点上特定 URL 的应用程序。</p>
</div>
<div class="paragraph">
<p>要配置 Apache 将某些 URL 的请求传递给 Web 应用程序，请将以下内容添加到 <span class="filename">httpd.conf</span> ，并指定项目目录的完整路径：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>&lt;Location &#34;/&#34;&gt;
    SetHandler python-program
    PythonPath &#34;[&#39;/dir/to/the/django/packages/&#39;] + sys.path&#34;
    PythonHandler django.core.handlers.modpython
    SetEnv DJANGO_SETTINGS_MODULE mysite.settings
    PythonAutoReload On
    PythonDebug On
&lt;/Location&gt;</pre>
</div>
</div>
<div class="paragraph">
<p>请参考 <a href="https://docs.djangoproject.com">https://docs.djangoproject.com</a> 获取有关如何使用 Django 的更多信息。</p>
</div>
</div>
<div class="sect4">
<h5 id="_ruby_on_rails_是一种开发_web_应用程序的开源框架使用_ruby_编程语言它遵循_mvc_模型_视图_控制器架构模式提供了许多内置功能和约定使开发过程更加简单和高效_ruby_on_rails_具有简洁的语法和强大的功能可以快速构建可扩展和可维护的应用程序它被广泛用于构建各种类型的_web_应用程序从小型博客到大型电子商务平台">32.8.4.2. Ruby on Rails 是一种开发 Web 应用程序的开源框架，使用 Ruby 编程语言。它遵循 MVC （模型 - 视图 - 控制器）架构模式，提供了许多内置功能和约定，使开发过程更加简单和高效。 Ruby on Rails 具有简洁的语法和强大的功能，可以快速构建可扩展和可维护的应用程序。它被广泛用于构建各种类型的 Web 应用程序，从小型博客到大型电子商务平台。<a class="anchor" href="#_ruby_on_rails_是一种开发_web_应用程序的开源框架使用_ruby_编程语言它遵循_mvc_模型_视图_控制器架构模式提供了许多内置功能和约定使开发过程更加简单和高效_ruby_on_rails_具有简洁的语法和强大的功能可以快速构建可扩展和可维护的应用程序它被广泛用于构建各种类型的_web_应用程序从小型博客到大型电子商务平台"></a></h5>
<div class="paragraph">
<p>Ruby on Rails 是另一个开源的 Web 框架，提供了完整的开发堆栈。它经过优化，可以使 Web 开发人员更加高效和能够快速编写强大的应用程序。在 FreeBSD 上，可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/www/rubygem-rails/">www/rubygem-rails</a> 包或端口进行安装。</p>
</div>
<div class="paragraph">
<p>请参考 <a href="http://guides.rubyonrails.org">http://guides.rubyonrails.org</a> ，了解如何使用 Ruby on Rails 的更多信息。</p>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-ftp">32.9. 文件传输协议（ FTP ）<a class="anchor" href="#network-ftp"></a></h3>
<div class="paragraph">
<p>文件传输协议（ FTP ）为用户提供了一种简单的方式来在 FTP 服务器之间传输文件。 FreeBSD 在基本系统中包含了 FTP 服务器软件 ftpd 。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供了几个配置文件来控制对 FTP 服务器的访问。本节概述了这些文件。有关内置 FTP 服务器的更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> 。</p>
</div>
<div class="sect3">
<h4 id="_配置_2">32.9.1. 配置<a class="anchor" href="#_配置_2"></a></h4>
<div class="paragraph">
<p>最重要的配置步骤是决定哪些账户将被允许访问 FTP 服务器。 FreeBSD 系统有许多系统账户，不应该允许 FTP 访问。不允许任何 FTP 访问的用户列表可以在 [/etc/ftpusers] 中找到。默认情况下，它包括系统账户。可以添加其他不允许访问 FTP 的用户。</p>
</div>
<div class="paragraph">
<p>在某些情况下，可能希望限制某些用户的访问权限，而不完全阻止他们使用 FTP 。可以通过创建 <span class="filename">/etc/ftpchroot</span> 文件来实现，如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpchroot&amp;sektion=5&amp;format=html">ftpchroot(5)</a> 中所述。该文件列出了受 FTP 访问限制的用户和组。</p>
</div>
<div class="paragraph">
<p>要启用服务器的匿名 FTP 访问，请在 FreeBSD 系统上创建一个名为 <code>ftp</code> 的用户。然后用户将能够使用用户名 <code>ftp</code> 或 <code>anonymous</code> 登录到 FTP 服务器。当提示输入密码时，任何输入都将被接受，但按照惯例，应将电子邮件地址用作密码。当匿名用户登录时， FTP 服务器将调用 <a href="https://man.freebsd.org/cgi/man.cgi?query=chroot&amp;sektion=2&amp;format=html">chroot(2)</a> 来限制访问仅限于 <code>ftp</code> 用户的主目录。</p>
</div>
<div class="paragraph">
<p>有两个文本文件可以创建，用于指定要显示给 FTP 客户端的欢迎消息。 <span class="filename">/etc/ftpwelcome</span> 的内容将在用户到达登录提示之前显示给他们。成功登录后，将显示 <span class="filename">/etc/ftpmotd</span> 的内容。请注意，该文件的路径是相对于登录环境的，因此对于匿名用户，将显示 [.filename]# ~ ftp/etc/ftpmotd# 的内容。</p>
</div>
<div class="paragraph">
<p>一旦配置了 FTP 服务器，将适当的变量设置在 <span class="filename">/etc/rc.conf</span> 中，以便在启动时启动该服务：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ftpd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>立即启动服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ftpd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过输入以下命令来测试与 FTP 服务器的连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>ftp localhost</code></pre>
</div>
</div>
<div class="paragraph">
<p>ftpd 守护进程使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslog&amp;sektion=3&amp;format=html">syslog(3)</a> 来记录日志消息。默认情况下，系统日志守护进程将会将与 FTP 相关的消息写入到 [/var/log/xferlog] 文件中。 FTP 日志的位置可以通过修改 [/etc/syslog.conf] 文件中的以下行来进行更改：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ftp.info      /var/log/xferlog</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>注意运行匿名 FTP 服务器可能涉及的潜在问题。特别是，要三思而后行，是否允许匿名用户上传文件。可能会发现 FTP 站点成为非授权商业软件交易或更糟糕的场所。如果需要匿名 FTP 上传，则要验证权限，以便这些文件在被管理员审核之前不能被其他匿名用户读取。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-samba">32.10. 适用于 Microsoft® Windows® 客户端的文件和打印服务（ Samba ）<a class="anchor" href="#network-samba"></a></h3>
<div class="paragraph">
<p>Samba 是一个流行的开源软件包，使用 SMB/CIFS 协议提供文件和打印服务。该协议内置于 Microsoft® Windows® 系统中。通过安装 Samba 客户端库，它可以添加到非 Microsoft® Windows® 系统中。该协议允许客户端访问共享的数据和打印机。这些共享可以映射为本地磁盘驱动器，共享的打印机可以像本地打印机一样使用。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 上，可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/samba413/">net/samba413</a> 端口或包来安装 Samba 客户端库。该客户端提供了 FreeBSD 系统访问 Microsoft® Windows® 网络中的 SMB/CIFS 共享的能力。</p>
</div>
<div class="paragraph">
<p>通过安装相同的软件包： net/samba413[] ， FreeBSD 系统也可以配置为 Samba 服务器。这使得管理员可以在 FreeBSD 系统上创建 SMB/CIFS 共享，这些共享可以被运行 Microsoft® Windows® 或 Samba 客户端库的客户端访问。</p>
</div>
<div class="sect3">
<h4 id="_服务器配置">32.10.1. 服务器配置<a class="anchor" href="#_服务器配置"></a></h4>
<div class="paragraph">
<p>Samba 的配置文件位于 <code>/usr/local/etc/smb4.conf</code> 。在使用 Samba 之前，必须先创建该文件。</p>
</div>
<div class="paragraph">
<p>这里展示了一个简单的 <span class="filename">smb4.conf</span> 文件，用于在工作组中与 Windows® 客户端共享目录和打印机。对于涉及 LDAP 或 Active Directory 的更复杂设置，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=samba-tool&amp;sektion=8&amp;format=html">samba-tool(8)</a> 创建初始的 <span class="filename">smb4.conf</span> 更为简便。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[global]
workgroup = WORKGROUP
server string = Samba Server Version %v
netbios name = ExampleMachine
wins support = Yes
security = user
passdb backend = tdbsam

# Example: share /usr/src accessible only to &#39;developer&#39; user
[src]
path = /usr/src
valid users = developer
writable  = yes
browsable = yes
read only = no
guest ok = no
public = no
create mask = 0666
directory mask = 0755</pre>
</div>
</div>
<div class="sect4">
<h5 id="_全局设置">32.10.1.1. 全局设置<a class="anchor" href="#_全局设置"></a></h5>
<div class="paragraph">
<p>在 [/usr/local/etc/smb4.conf] 中添加描述网络的设置：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>workgroup</code> 是一个计算机网络术语，指的是一个小型的、自主管理的网络。在工作组中，多台计算机可以共享文件、打印机和其他资源，而无需依赖于集中式的服务器。工作组通常用于小型办公室或家庭网络中，提供简单的文件共享和协作功能。</dt>
<dd>
<p>要服务的工作组的名称。</p>
</dd>
<dt class="hdlist1"><code>netbios name</code> 是一个计算机网络中的参数，用于指定计算机在 NetBIOS 网络中的名称。 NetBIOS 是一种用于在局域网中进行通信的协议，它使用名称来标识计算机和资源。通过设置 <code>netbios name</code> 参数，可以为计算机指定一个唯一的名称，以便其他计算机可以通过该名称来访问它。</dt>
<dd>
<p>Samba 服务器所知的 NetBIOS 名称。默认情况下，它与主机的 DNS 名称的第一个组件相同。</p>
</dd>
<dt class="hdlist1"><code>server string</code> 指的是服务器字符串。</dt>
<dd>
<p>在 <code>net view</code> 和其他一些网络工具的输出中显示的字符串，这些工具旨在显示有关服务器的描述性文本。</p>
</dd>
<dt class="hdlist1"><code>wins support</code> 的中文翻译是 ` 获得支持 ` 。</dt>
<dd>
<p>Samba 是否将作为 WINS 服务器。请勿在网络上的多个服务器上启用对 WINS 的支持。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_安全设置">32.10.1.2. 安全设置<a class="anchor" href="#_安全设置"></a></h5>
<div class="paragraph">
<p><span class="filename">/usr/local/etc/smb4.conf</span> 中最重要的设置是安全模型和后端密码格式。这些指令控制以下选项：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>security</code> 的中文翻译是 ` 安全 ` 。</dt>
<dd>
<p>最常见的设置是 <code>security = share</code> 和 <code>security = user</code> 。如果客户端使用的用户名与其在 FreeBSD 机器上的用户名相同，则应使用用户级安全性。这是默认的安全策略，它要求客户端在访问共享资源之前先登录。</p>
<div class="paragraph">
<p>在共享级别安全中，客户端在尝试连接到共享资源之前不需要使用有效的用户名和密码登录服务器。这是旧版本 Samba 的默认安全模型。</p>
</div>
</dd>
<dt class="hdlist1"><code>passdb backend</code> 是一个计算机术语，指的是密码数据库后端。</dt>
<dd>
<p>Samba 有几种不同的后端身份验证模型。客户端可以使用 LDAP 、 NIS +、 SQL 数据库或修改后的密码文件进行身份验证。推荐的身份验证方法是 <code>tdbsam</code> ，适用于简单的网络环境，本文将介绍该方法。对于更大或更复杂的网络，推荐使用 <code>ldapsam</code> 。 <code>smbpasswd</code> 曾经是默认选项，但现在已经过时。</p>
</dd>
</dl>
</div>
</div>
<div class="sect4">
<h5 id="_samba_用户">32.10.1.3. Samba 用户<a class="anchor" href="#_samba_用户"></a></h5>
<div class="paragraph">
<p>为了让 Windows® 客户端能够访问共享文件夹， FreeBSD 用户账户必须映射到 <code>SambaSAMAccount</code> 数据库中。使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pdbedit&amp;sektion=8&amp;format=html">pdbedit(8)</a> 命令来映射已存在的 FreeBSD 用户账户。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pdbedit -a -u username</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>本节仅提及了最常用的设置。有关可用配置选项的其他信息，请参阅 <a href="https://wiki.samba.org">官方 Samba Wiki</a> 。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_启动_samba">32.10.2. 启动 Samba<a class="anchor" href="#_启动_samba"></a></h4>
<div class="paragraph">
<p>要在启动时启用 Samba ，请将以下行添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>samba_server_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>立即启动 Samba ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service samba_server start</span>
Performing sanity check on Samba configuration: OK
Starting nmbd.
Starting smbd.</code></pre>
</div>
</div>
<div class="paragraph">
<p>Samba 由三个独立的守护进程组成。 nmbd 和 smbd 守护进程都由 <code>samba_enable</code> 启动。如果还需要 winbind 名称解析，请设置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>winbindd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>可以随时通过键入以下命令停止 Samba ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service samba_server stop</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Samba 是一个复杂的软件套件，具有与 Microsoft® Windows® 网络广泛集成的功能。有关超出此处所描述的基本配置的功能的更多信息，请参阅 <a href="https://www.samba.org">https://www.samba.org</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-ntp">32.11. 使用 NTP 进行时钟同步<a class="anchor" href="#network-ntp"></a></h3>
<div class="paragraph">
<p>随着时间的推移，计算机的时钟容易偏离。这是一个问题，因为许多网络服务要求网络上的计算机共享相同准确的时间。准确的时间也需要确保文件时间戳保持一致。网络时间协议（ NTP ）是在网络中提供时钟准确性的一种方式。</p>
</div>
<div class="paragraph">
<p>FreeBSD 包含 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntpd&amp;sektion=8&amp;format=html">ntpd(8)</a> ，可以配置为查询其他 NTP 服务器以同步该机器上的时钟，或为网络中的其他计算机提供时间服务。</p>
</div>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 上配置 ntpd 。更多的文档可以在 HTML 格式的 <span class="filename">/usr/share/doc/ntp/</span> 中找到。</p>
</div>
<div class="sect3">
<h4 id="_ntp_配置">32.11.1. NTP 配置<a class="anchor" href="#_ntp_配置"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 上，可以使用内置的 ntpd 来同步系统的时钟。 ntpd 是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 变量和 <span class="filename">/etc/ntp.conf</span> 进行配置的，详细信息请参见以下章节。</p>
</div>
<div class="paragraph">
<p>ntpd 通过 UDP 数据包与其网络对等方进行通信。您的机器与其 NTP 对等方之间的任何防火墙都必须配置为允许端口 123 上的 UDP 数据包的进出。</p>
</div>
<div class="sect4">
<h5 id="_etcntp_conf_文件">32.11.1.1. <span class="filename">/etc/ntp.conf</span> 文件<a class="anchor" href="#_etcntp_conf_文件"></a></h5>
<div class="paragraph">
<p>ntpd 读取 /etc/ntp.conf 文件来确定要查询的 NTP 服务器。建议选择多个 NTP 服务器，以防其中一个服务器无法访问或其时钟不可靠。当 ntpd 接收到响应时，它会优先选择可靠的服务器而不是不可靠的服务器。被查询的服务器可以是本地网络的服务器、由 ISP 提供的服务器，或者从一个在线的公共可访问的 NTP 服务器列表中选择。选择公共 NTP 服务器时，选择地理位置接近的服务器并查看其使用政策。&#34;pool&#34;配置关键字从服务器池中选择一个或多个服务器。有一个在线的公共可访问的 NTP 池列表，按地理区域组织。此外， FreeBSD 提供了一个由项目赞助的池，即&#34;0.freebsd.pool.ntp.org&#34;。</p>
</div>
<div class="exampleblock">
<div class="title">例 37. 示例 <span class="filename">/etc/ntp.conf</span></div>
<div class="content">
<div class="paragraph">
<p>这是一个 <span class="filename">ntp.conf</span> 文件的简单示例。它可以直接使用；它包含了在公共可访问网络连接上操作的推荐 <code>restrict</code> 选项。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Disallow ntpq control/query access.  Allow peers to be added only
# based on pool and server statements in this file.
restrict default limited kod nomodify notrap noquery nopeer
restrict source  limited kod nomodify notrap noquery

# Allow unrestricted access from localhost for queries and control.
restrict 127.0.0.1
restrict ::1

# Add a specific server.
server ntplocal.example.com iburst

# Add FreeBSD pool servers until 3-6 good servers are available.
tos minclock 3 maxclock 6
pool 0.freebsd.pool.ntp.org iburst

# Use a local leap-seconds file.
leapfile &#34;/var/db/ntpd.leap-seconds.list&#34;</pre>
</div>
</div>
</div>
</div>
<div class="paragraph">
<p>该文件的格式在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> 中有描述。下面的描述仅提供了上面示例文件中使用的关键字的快速概述。</p>
</div>
<div class="paragraph">
<p>默认情况下， NTP 服务器对任何网络主机都是可访问的。 <code>restrict</code> 关键字用于控制哪些系统可以访问该服务器。支持多个 <code>restrict</code> 条目，每个条目都可以细化之前语句中给出的限制。示例中显示的值允许本地系统完全查询和控制访问，而只允许远程系统查询时间。有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ntp.conf&amp;sektion=5&amp;format=html">ntp.conf(5)</a> 中的“访问控制支持”子节。</p>
</div>
<div class="paragraph">
<p><code>server</code> 关键字指定要查询的单个服务器。文件可以包含多个 <code>server</code> 关键字，每行列出一个服务器。 <code>pool</code> 关键字指定服务器池。 ntpd 将根据需要从该池中添加一个或多个服务器，以达到使用 <code>tos minclock</code> 值指定的对等体数量。 <code>iburst</code> 关键字指示 ntpd 在首次建立联系时与服务器执行八次快速数据包交换，以帮助快速同步系统时间。</p>
</div>
<div class="paragraph">
<p><code>leapfile</code> 关键字指定了一个包含闰秒信息的文件的位置。该文件由 <a href="https://man.freebsd.org/cgi/man.cgi?query=periodic&amp;sektion=8&amp;format=html">periodic(8)</a> 自动更新。此关键字指定的文件位置必须与 <span class="filename">/etc/rc.conf</span> 中的 <code>ntp_db_leapfile</code> 变量设置的位置匹配。</p>
</div>
</div>
<div class="sect4">
<h5 id="_在_etcrc_conf_文件中的_ntp_条目">32.11.1.2. 在 /etc/rc.conf 文件中的 NTP 条目<a class="anchor" href="#_在_etcrc_conf_文件中的_ntp_条目"></a></h5>
<div class="paragraph">
<p>将 <code>ntpd_enable = YES</code> 设置为在启动时启动 ntpd 。一旦将 <code>ntpd_enable = YES</code> 添加到 [/etc/rc.conf](/etc/rc.conf) 文件中，可以通过输入以下命令立即启动 ntpd 而无需重新启动系统：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ntpd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>只需设置 <code>ntpd_enable</code> 就可以使用 ntpd 。下面列出的 <span class="filename">rc.conf</span> 变量也可以根据需要进行设置。</p>
</div>
<div class="paragraph">
<p>将 <code>ntpd_sync_on_start = YES</code> 设置为允许 ntpd 在启动时一次性调整时钟的任意量。通常情况下，如果时钟偏差超过 1000 秒， ntpd 会记录错误消息并退出。此选项在没有电池备份的实时时钟的系统上特别有用。</p>
</div>
<div class="paragraph">
<p>将 <code>ntpd_oomprotect = YES</code> 设置为保护 ntpd 守护进程免受系统尝试从内存不足（ OOM ）条件中恢复时被终止。</p>
</div>
<div class="paragraph">
<p>将 `ntpd_config = ` 设置为备用的 <span class="filename">ntp.conf</span> 文件的位置。</p>
</div>
<div class="paragraph">
<p>将 <code>ntpd_flags = ` 设置为包含所需的任何其他 ntpd 标志，但避免使用这些由 `/etc/rc.d/ntpd</code> 内部管理的标志。</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>-p</code> （ pid 文件位置）</p>
</li>
<li>
<p><code>-c</code> （使用 `ntpd_config = ` 代替）</p>
</li>
</ul>
</div>
</div>
<div class="sect4">
<h5 id="_ntpd_和非特权的_ntpd_用户">32.11.1.3. ntpd 和非特权的 <code>ntpd</code> 用户<a class="anchor" href="#_ntpd_和非特权的_ntpd_用户"></a></h5>
<div class="paragraph">
<p>在 FreeBSD 上， ntpd 可以作为非特权用户启动和运行。这需要使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a> 策略模块。 <span class="filename">/etc/rc.d/ntpd</span> 启动脚本首先检查 NTP 配置。如果可能，它会加载 <code>mac_ntpd</code> 模块，然后以非特权用户 <code>ntpd</code> （用户 ID 为 123 ）启动 ntpd 。为了避免文件和目录访问的问题，当配置中包含任何与文件相关的选项时，启动脚本不会自动以 <code>ntpd</code> 身份启动 ntpd 。</p>
</div>
<div class="paragraph">
<p>如果 <code>ntpd_flags</code> 中存在以下任何一项，则需要按照下面描述的手动配置来以 <code>ntpd</code> 用户身份运行：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>-f 或 --driftfile</p>
</li>
<li>
<p>-i 或 --jaildir</p>
</li>
<li>
<p>-k 或 --keyfile</p>
</li>
<li>
<p>-l 或 --logfile</p>
</li>
<li>
<p>-s 或 --statsdir</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在 <span class="filename">ntp.conf</span> 文件中出现以下关键字之一，需要按照下面描述的方式手动配置才能以 <code>ntpd</code> 用户身份运行：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>加密</p>
</li>
<li>
<p>漂移文件</p>
</li>
<li>
<p>key</p>
</li>
<li>
<p>日志目录</p>
</li>
<li>
<p>statsdir 是一个计算机术语，指的是统计数据存储目录。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>要手动配置 ntpd 以用户 <code>ntpd</code> 运行，您必须：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>确保 <code>ntpd</code> 用户可以访问配置中指定的所有文件和目录。</p>
</li>
<li>
<p>安排加载或编译 <code>mac_ntpd</code> 模块到内核中。详细信息请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=mac_ntpd&amp;sektion=4&amp;format=html">mac_ntpd(4)</a> 。</p>
</li>
<li>
<p>在 <span class="filename">/etc/rc.conf</span> 中设置 <code>ntpd_user =&#34;ntpd&#34;</code> 。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_ppp_连接的_ntp">32.11.2. 使用 PPP 连接的 NTP<a class="anchor" href="#_使用_ppp_连接的_ntp"></a></h4>
<div class="paragraph">
<p>ntpd 在正常运行时不需要与互联网保持永久连接。然而，如果配置了 PPP 连接以按需拨号，应该阻止 NTP 流量触发拨号或保持连接活动。这可以通过在 <code>/etc/ppp/ppp.conf</code> 文件中使用 <code>filter</code> 指令进行配置。例如：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>set filter dial 0 deny udp src eq 123
# Prevent NTP traffic from initiating dial out
set filter dial 1 permit 0 0
set filter alive 0 deny udp src eq 123
# Prevent incoming NTP traffic from keeping the connection open
set filter alive 1 deny udp dst eq 123
# Prevent outgoing NTP traffic from keeping the connection open
set filter alive 2 permit 0/0 0/0</pre>
</div>
</div>
<div class="paragraph">
<p>有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 中的 <code>PACKET FILTERING</code> 部分以及 [/usr/share/examples/ppp/] 中的示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些互联网接入提供商会阻止低编号端口的访问，这会导致 NTP 无法正常工作，因为回复无法到达目标机器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-iscsi">32.12. iSCSI 发起者和目标配置<a class="anchor" href="#network-iscsi"></a></h3>
<div class="paragraph">
<p>iSCSI 是一种通过网络共享存储的方式。与在文件系统级别工作的 NFS 不同， iSCSI 在块设备级别工作。</p>
</div>
<div class="paragraph">
<p>在 iSCSI 术语中，共享存储的系统被称为“目标”（ target ）。存储可以是物理磁盘，也可以是表示多个磁盘或物理磁盘部分的区域。例如，如果磁盘使用 ZFS 格式化，可以创建一个 zvol 作为 iSCSI 存储使用。</p>
</div>
<div class="paragraph">
<p>访问 iSCSI 存储的客户端被称为 <em>发起者</em>。对于发起者来说，通过 iSCSI 可用的存储看起来像一个未格式化的原始磁盘，称为逻辑单元 (LUN) 。磁盘的设备节点出现在 <span class="filename">/dev/</span> 中，设备必须单独进行格式化和挂载。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供了本地的基于内核的 iSCSI 目标和发起者。本节描述了如何将 FreeBSD 系统配置为目标或发起者。</p>
</div>
<div class="sect3">
<h4 id="network-iscsi-target">32.12.1. 配置 iSCSI 目标<a class="anchor" href="#network-iscsi-target"></a></h4>
<div class="paragraph">
<p>要配置一个 iSCSI 目标，需要创建一个名为 <code>/etc/ctl.conf</code> 的配置文件，然后在 <code>/etc/rc.conf</code> 中添加一行，以确保 <code>ctld[8]</code> 守护进程在启动时自动启动，最后启动守护进程。</p>
</div>
<div class="paragraph">
<p>以下是一个简单的 <span class="filename">/etc/ctl.conf</span> 配置文件的示例。有关此文件可用选项的更完整描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctl.conf&amp;sektion=5&amp;format=html">ctl.conf(5)</a> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group no-authentication
	portal-group pg0

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre>
</div>
</div>
<div class="paragraph">
<p>第一个条目定义了 <code>pg0</code> 门户组。门户组定义了 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 守护进程将监听哪些网络地址。 <code>discovery-auth-group no-authentication</code> 条目表示任何发起者都可以在没有身份验证的情况下执行 iSCSI 目标发现。第三和第四行配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 在默认端口 3260 上监听所有 IPv4 （ <code>listen 0.0.0.0</code> ）和 IPv6 （ <code>listen [::]</code> ）地址。</p>
</div>
<div class="paragraph">
<p>不需要定义一个门户组，因为有一个内置的门户组叫做 <code>default</code> 。在这种情况下， <code>default</code> 和 <code>pg0</code> 的区别在于，使用 <code>default</code> 时，目标发现始终被拒绝，而使用 <code>pg0</code> 时，目标发现始终被允许。</p>
</div>
<div class="paragraph">
<p>第二个条目定义了一个单一的目标。目标有两个可能的含义：一个用于提供 iSCSI 服务的机器，或者是一个命名的 LUN 组。这个示例使用了后者的含义，其中 <code>iqn.2012-06.com.example:target0</code> 是目标名称。这个目标名称适用于测试目的。实际使用时，将 <code>com.example</code> 更改为真实的域名，反转过来。 <code>2012-06</code> 代表获取该域名控制权的年份和月份，而 <code>target0</code> 可以是任何值。在这个配置文件中可以定义任意数量的目标。</p>
</div>
<div class="paragraph">
<p><code>auth-group no-authentication</code> 行允许所有发起者连接到指定的目标，而 <code>portal-group pg0</code> 则通过 <code>pg0</code> 门户组使目标可访问。</p>
</div>
<div class="paragraph">
<p>下一节定义了逻辑单元（ LUN ）。对于发起者来说，每个 LUN 将被视为一个独立的磁盘设备。每个目标可以定义多个 LUN 。每个 LUN 由一个数字标识，其中 LUN 0 是必需的。 <code>path /data/target0-0</code> 行定义了支持 LUN 的文件或 zvol 的完整路径。在启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 之前，该路径必须存在。第二行是可选的，用于指定 LUN 的大小。</p>
</div>
<div class="paragraph">
<p>接下来，为了确保 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 守护进程在启动时自动启动，请将以下行添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ctld_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> ，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ctld start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=ctld&amp;sektion=8&amp;format=html">ctld(8)</a> 守护进程时，它会读取 .filename#/etc/ctl.conf# 文件。如果在守护进程启动后编辑了此文件，请使用此命令使更改立即生效：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ctld reload</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_身份验证">32.12.1.1. 身份验证<a class="anchor" href="#_身份验证"></a></h5>
<div class="paragraph">
<p>前面的示例在本质上是不安全的，因为它没有使用身份验证，任何人都可以完全访问所有目标。为了要求使用用户名和密码来访问目标，请按以下方式修改配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>auth-group ag0 {
	chap username1 secretsecret
	chap username2 anothersecret
}

portal-group pg0 {
	discovery-auth-group no-authentication
	listen 0.0.0.0
	listen [::]
}

target iqn.2012-06.com.example:target0 {
	auth-group ag0
	portal-group pg0
	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>auth-group</code> 部分定义了用户名和密码对。试图连接到 <code>iqn.2012-06.com.example:target0</code> 的发起者必须首先指定一个已定义的用户名和密码。然而，目标发现仍然允许在没有身份验证的情况下进行。要求目标发现进行身份验证，请将 <code>discovery-auth-group</code> 设置为已定义的 <code>auth-group</code> 名称，而不是 <code>no-authentication</code> 。</p>
</div>
<div class="paragraph">
<p>通常为每个发起者定义一个单独的导出目标是很常见的。作为上述语法的简写，用户名和密码可以直接在目标条目中指定：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>target iqn.2012-06.com.example:target0 {
	portal-group pg0
	chap username1 secretsecret

	lun 0 {
		path /data/target0-0
		size 4G
	}
}</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="network-iscsi-initiator">32.12.2. 配置 iSCSI 发起者<a class="anchor" href="#network-iscsi-initiator"></a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>本节中描述的 iSCSI initiator 从 FreeBSD 10.0-RELEASE 开始得到支持。要使用旧版本中提供的 iSCSI initiator ，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=iscontrol&amp;sektion=8&amp;format=html">iscontrol(8)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>iSCSI initiator 要求 <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> 守护进程正在运行。该守护进程不使用配置文件。要在启动时自动启动它，请将以下行添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>iscsid_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>要启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> ，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service iscsid start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>连接到目标可以使用或不使用 <span class="filename">/etc/iscsi.conf</span> 配置文件。本节演示了两种类型的连接方式。</p>
</div>
<div class="sect4">
<h5 id="_无需配置文件连接到目标">32.12.2.1. 无需配置文件连接到目标<a class="anchor" href="#_无需配置文件连接到目标"></a></h5>
<div class="paragraph">
<p>要将发起者连接到单个目标，请指定门户的 IP 地址和目标的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要验证连接是否成功，请运行 <code>iscsictl</code> 命令，不带任何参数。输出应该类似于以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Connected: da0</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中， iSCSI 会话成功建立，其中 <span class="filename">/dev/da0</span> 代表已连接的逻辑单元（ LUN ）。如果 <code>iqn.2012-06.com.example:target0</code> 目标导出多个 LUN ，则输出的该部分将显示多个设备节点。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">Connected: da0 da1 da2.</code></pre>
</div>
</div>
<div class="paragraph">
<p>任何错误都将在输出中报告，以及系统日志中。例如，这个消息通常意味着 <a href="https://man.freebsd.org/cgi/man.cgi?query=iscsid&amp;sektion=8&amp;format=html">iscsid(8)</a> 守护进程未运行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Waiting for iscsid(8)</pre>
</div>
</div>
<div class="paragraph">
<p>以下消息提示存在网络问题，例如错误的 IP 地址或端口：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.11     Connection refused</pre>
</div>
</div>
<div class="paragraph">
<p>这条消息意味着指定的目标名称是错误的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Not found</pre>
</div>
</div>
<div class="paragraph">
<p>这条消息表示目标需要进行身份验证：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Target name                                     Target portal   State
iqn.2012-06.com.example:target0                 10.10.10.10     Authentication failed</pre>
</div>
</div>
<div class="paragraph">
<p>要指定 CHAP 用户名和密码，使用以下语法：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># iscsictl -A -p 10.10.10.10 -t iqn.2012-06.com.example:target0 -u user -s secretsecret</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_使用配置文件连接到目标">32.12.2.2. 使用配置文件连接到目标<a class="anchor" href="#_使用配置文件连接到目标"></a></h5>
<div class="paragraph">
<p>要使用配置文件进行连接，请创建一个名为 <code>/etc/iscsi.conf</code> 的文件，并将其内容设置为以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>t0 {
	TargetAddress   = 10.10.10.10
	TargetName      = iqn.2012-06.com.example:target0
	AuthMethod      = CHAP
	chapIName       = user
	chapSecret      = secretsecret
}</pre>
</div>
</div>
<div class="paragraph">
<p><code>t0</code> 指定了配置文件部分的别名。它将被发起者用来指定要使用的配置。其他行指定了连接过程中要使用的参数。 <code>TargetAddress</code> 和 <code>TargetName</code> 是必需的，而其他选项是可选的。在这个例子中，显示了 CHAP 用户名和密码。</p>
</div>
<div class="paragraph">
<p>要连接到定义的目标，请指定昵称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># iscsictl -An t0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>或者，要连接到配置文件中定义的所有目标，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># iscsictl -Aa</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使发起者自动连接到 [/etc/iscsi.conf] 中的所有目标，请将以下内容添加到 [/etc/rc.conf] 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>iscsictl_enable=&#34;YES&#34;
iscsictl_flags=&#34;-Aa&#34;</pre>
</div>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="firewalls">Chapter 33. 防火墙<a class="anchor" href="#firewalls"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="firewalls-intro">33.1. 简介<a class="anchor" href="#firewalls-intro"></a></h3>
<div class="paragraph">
<p>防火墙使得过滤通过系统流动的进出流量成为可能。防火墙可以使用一个或多个“规则”集来检查进出网络连接的网络数据包，并允许流量通过或阻止它。防火墙的规则可以检查数据包的一个或多个特征，如协议类型、源或目标主机地址以及源或目标端口。</p>
</div>
<div class="paragraph">
<p>防火墙可以增强主机或网络的安全性。它们可以用于执行以下一项或多项功能：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>保护和隔离内部网络中的应用程序、服务和机器，以防止来自公共互联网的不必要的流量。</p>
</li>
<li>
<p>限制或禁止内部网络主机访问公共互联网的服务。</p>
</li>
<li>
<p>支持网络地址转换（ NAT ），允许内部网络使用私有 IP 地址，并使用单个 IP 地址或共享的自动分配的公共地址池与公共互联网建立单一连接。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>FreeBSD 基本系统内置了三个防火墙： PF 、 IPFW 和 IPFILTER （也称为 IPF ）。 FreeBSD 还提供了两个流量整形器，用于控制带宽使用： <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> 。 ALTQ 通常与 PF 紧密关联，而 dummynet 与 IPFW 关联。每个防火墙使用规则来控制数据包对 FreeBSD 系统的访问，尽管它们的实现方式不同，并且每个防火墙都有不同的规则语法。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供多个防火墙，以满足各种用户的不同需求和偏好。每个用户应该评估哪个防火墙最适合他们的需求。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>如何定义数据包过滤规则。</p>
</li>
<li>
<p>FreeBSD 内置防火墙的区别。</p>
</li>
<li>
<p>如何使用和配置 PF 防火墙。</p>
</li>
<li>
<p>如何使用和配置 IPFW 防火墙。</p>
</li>
<li>
<p>如何使用和配置 IPFILTER 防火墙。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，你应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解基本的 FreeBSD 和互联网概念。</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>由于所有防火墙都是基于检查选定数据包控制字段的值，因此防火墙规则集的创建者必须了解 TCP/IP 的工作原理，数据包控制字段中不同值的含义，以及这些值在正常会话中的使用方式。对于一个很好的介绍，请参考 <a href="http://www.ipprimer.com">Daryl 的 TCP/IP 入门指南</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="firewalls-concepts">33.2. 防火墙概念<a class="anchor" href="#firewalls-concepts"></a></h3>
<div class="paragraph">
<p>一个规则集包含一组规则，根据数据包中包含的值来通过或阻止数据包。主机之间的双向数据包交换构成一个会话对话。防火墙规则集处理来自公共互联网的数据包以及系统作为对其响应而产生的数据包。每个 TCP/IP 服务都由其协议和监听端口预定义。目标为特定服务的数据包源自源地址使用非特权端口，并且目标地址上的特定服务端口。所有上述参数都可以用作选择条件来创建将通过或阻止服务的规则。</p>
</div>
<div class="paragraph">
<p>要查找未知的端口号，请参考 [/etc/services](/etc/services) 。或者，访问 [<a href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" class="bare">http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>](<a href="http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers" class="bare">http://en.wikipedia.org/wiki/List_of_TCP_and_UDP_port_numbers</a>) ，进行端口号查找以找到特定端口号的用途。</p>
</div>
<div class="paragraph">
<p>请查看此链接，了解 [Trojans 使用的端口号](<a href="http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php" class="bare">http://web.archive.org/web/20150803024617/http://www.sans.org/security-resources/idfaq/oddports.php</a>) 。</p>
</div>
<div class="paragraph">
<p>FTP 有两种模式：主动模式和被动模式。它们的区别在于数据通道的获取方式。被动模式更安全，因为数据通道是由原始的 FTP 会话请求者获取的。关于 FTP 和不同模式的详细解释，请参见 <a href="http://www.slacksite.com/other/ftp.html">http://www.slacksite.com/other/ftp.html</a> 。</p>
</div>
<div class="paragraph">
<p>防火墙规则集可以是“排他性”或“包容性”。排他性防火墙允许所有流量通过，除了与规则集匹配的流量。而包容性防火墙则相反，它只允许与规则匹配的流量通过，阻止其他所有流量。</p>
</div>
<div class="paragraph">
<p>一个包容性防火墙可以更好地控制出站流量，因此对于向公共互联网提供服务的系统来说是更好的选择。它还可以控制来自公共互联网的流量类型，以便访问私有网络。所有不符合规则的流量都会被阻止并记录。包容性防火墙通常比排他性防火墙更安全，因为它们显著降低了允许不需要的流量的风险。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>除非另有说明，本章中的所有配置和示例规则集都创建包容性防火墙规则集。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>可以使用“有状态防火墙”进一步加强安全性。这种类型的防火墙会跟踪打开的连接，并且只允许与现有连接匹配或打开新的允许连接的流量通过。</p>
</div>
<div class="paragraph">
<p>有状态过滤将流量视为会话中的双向数据包交换。当在匹配规则上指定状态时，防火墙会动态生成每个会话期间预期交换的数据包的内部规则。它具有足够的匹配能力来确定数据包是否适用于会话。任何不符合会话模板的数据包都会被自动拒绝。</p>
</div>
<div class="paragraph">
<p>当会话完成时，它将从动态状态表中移除。</p>
</div>
<div class="paragraph">
<p>有状态过滤允许我们专注于阻止 / 通过新的会话。如果新的会话被通过，所有后续的数据包将自动被允许通过，任何冒充的数据包将自动被拒绝。如果新的会话被阻止，它的所有后续数据包都将被禁止。有状态过滤提供了高级匹配能力，能够抵御攻击者使用的各种攻击方法。</p>
</div>
<div class="paragraph">
<p>NAT 代表网络地址转换。 NAT 功能使得防火墙后面的私有局域网能够共享一个由 ISP 分配的 IP 地址，即使该地址是动态分配的。 NAT 允许局域网中的每台计算机都能够访问互联网，而无需为多个互联网账户或 IP 地址向 ISP 付费。</p>
</div>
<div class="paragraph">
<p>NAT 会自动将局域网上每个系统的私有 LAN IP 地址转换为单个公共 IP 地址，以便在通过防火墙发送到公共互联网的数据包中使用。它还会对返回的数据包执行相反的转换。</p>
</div>
<div class="paragraph">
<p>根据 RFC 1918 ，以下 IP 地址范围被保留用于私有网络，这些地址将不会直接路由到公共互联网，因此可用于与 NAT 一起使用：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>10.0.0.0/8</code> 。</p>
</li>
<li>
<p><code>172.16.0.0/12</code> 。</p>
</li>
<li>
<p><code>192.168.0.0/16</code> 是一个 CIDR （无类别域间路由）表示法，用于表示一个 IP 地址范围。在这个表示法中， <code>192.168.0.0</code> 是网络地址， <code>16</code> 表示网络前缀的长度。这个 CIDR 表示的是一个包含 <code>192.168.0.0</code> 到 <code>192.168.255.255</code> 之间所有 IP 地址的网络。</p>
</li>
</ul>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在处理防火墙规则时，请非常小心。某些配置可能会将管理员锁在服务器外。为了安全起见，考虑从本地控制台执行初始防火墙配置，而不是通过 ssh 远程执行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect2">
<h3 id="firewalls-pf">33.3. PF 可以有多种含义，根据上下文不同可能指：<a class="anchor" href="#firewalls-pf"></a></h3>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>公共基金（ Public Fund ）</p>
</li>
<li>
<p>个人金融（ Personal Finance ）</p>
</li>
<li>
<p>个人文件（ Personal File ）</p>
</li>
<li>
<p>保护因子（ Protection Factor ）</p>
</li>
<li>
<p>电子邮件后缀（ Postfix ）
请提供更多上下文以便准确翻译。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>自从 FreeBSD 5.3 版本以来， OpenBSD 的 PF 防火墙的移植版本已经作为基本系统的一部分包含在其中。 PF 是一个完整的、功能齐全的防火墙，可选择性地支持 ALTQ （ Alternate Queuing ），提供了服务质量（ QoS ）功能。</p>
</div>
<div class="paragraph">
<p>OpenBSD 项目在 <a href="http://www.openbsd.org/faq/pf/">PF FAQ</a> 中维护了 PF 的权威参考。 Peter Hansteen 在 <a href="http://home.nuug.no/" class="bare">http://home.nuug.no/</a> \~ peter/pf/[<a href="http://home.nuug.no/" class="bare">http://home.nuug.no/</a> ~ peter/pf/] 上维护了一个详尽的 PF 教程。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>阅读 <a href="http://www.openbsd.org/faq/pf/">PF FAQ</a> 时，请记住多年来， FreeBSD 的 PF 版本与上游的 OpenBSD 版本有很大的差异。在 FreeBSD 上，不是所有的功能都与 OpenBSD 上的工作方式相同，反之亦然。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>{freebsd-pf} 是一个很好的地方，可以询问有关配置和运行 PF 防火墙的问题。在提问之前，请先查看邮件列表的存档，因为可能已经有人回答过了。</p>
</div>
<div class="paragraph">
<p>本手册的这一部分重点介绍了与 FreeBSD 相关的 PF 。它演示了如何启用 PF 和 ALTQ 。还提供了在 FreeBSD 系统上创建规则集的几个示例。</p>
</div>
<div class="sect3">
<h4 id="_启用_pf">33.3.1. 启用 PF<a class="anchor" href="#_启用_pf"></a></h4>
<div class="paragraph">
<p>要使用 PF ，首先必须加载其内核模块。本节描述了可以添加到 /etc/rc.conf 文件中以启用 PF 的条目。</p>
</div>
<div class="paragraph">
<p>首先，在 <span class="filename">/etc/rc.conf</span> 中添加 <code>pf_enable = yes</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc pf_enable=yes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当启动 PF 时，可以传递在 <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> 中描述的其他选项。在 .filename#/etc/rc.conf# 中添加或更改此条目，并在两个引号（ <code>&#34;&#34;</code> ）之间指定任何所需的标志。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pf_flags=&#34;&#34;                     # additional flags for pfctl startup</pre>
</div>
</div>
<div class="paragraph">
<p>如果 PF 无法找到其规则集配置文件，则不会启动。默认情况下， FreeBSD 不提供规则集，并且没有 /etc/pf.conf 文件。示例规则集可以在 /usr/share/examples/pf/ 中找到。如果已经将自定义规则集保存在其他位置，请在 /etc/rc.conf 文件中添加一行，指定文件的完整路径：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pf_rules=&#34;/path/to/pf.conf&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>PF 提供了日志记录支持，可以通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> 来查看。要启用日志记录支持，请将 <code>pflog_enable = yes</code> 添加到 <span class="filename">/etc/rc.conf</span> 文件中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc pflog_enable=yes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以添加以下行来更改日志文件的默认位置，或者指定在启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=pflog&amp;sektion=4&amp;format=html">pflog(4)</a> 时传递的任何其他标志：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pflog_logfile=&#34;/var/log/pflog&#34;  # where pflogd should store the logfile
pflog_flags=&#34;&#34;                  # additional flags for pflogd startup</pre>
</div>
</div>
<div class="paragraph">
<p>最后，如果防火墙后面有一个局域网，并且需要转发局域网上的计算机的数据包，或者需要进行网络地址转换（ NAT ），请启用以下选项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34;            # Enable as LAN gateway</pre>
</div>
</div>
<div class="paragraph">
<p>保存所需的编辑后，可以通过输入以下命令启动带有日志支持的 PF ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service pf start</span>
<span class="c"># service pflog start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>默认情况下， PF 从 [/etc/pf.conf] 读取其配置规则，并根据该文件中指定的规则或定义修改、丢弃或通过数据包。 FreeBSD 安装包含位于 [/usr/share/examples/pf/] 的几个示例文件。请参考 [PF FAQ] 以获取完整的 PF 规则集覆盖范围。</p>
</div>
<div class="paragraph">
<p>要控制 PF ，请使用 <code>pfctl</code> 命令。 <a href="#pfctl">有用的 <code>pfctl</code> 选项</a> 总结了一些对该命令有用的选项。有关所有可用选项的描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> 。</p>
</div>
<table id="pfctl" class="tableblock frame-none grid-all stretch">
<caption class="title">表 45. 有用的 <code>pfctl</code> 选项</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">命令</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pfctl -e</code> 是一个命令行工具，用于启用 PF （ Packet Filter ）防火墙。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">启用 PF 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pfctl -d</code> 是一个用于禁用 PF （ Packet Filter ）防火墙的命令。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">禁用 PF 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pfctl -F all -f /etc/pf.conf</code> 是一个用于在 BSD 操作系统中重置和重新加载 PF 防火墙规则的命令。它会清除所有当前的规则，并从指定的配置文件 <code>/etc/pf.conf</code> 中重新加载规则。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">清除所有的 NAT 、过滤、状态和表规则，并重新加载 /etc/pf.conf 文件。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">`pfctl -s [ rules | 网络地址转换（ Network Address Translation ）</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">状态 ]`</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">关于过滤规则、 NAT 规则或状态表的报告。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>pfctl -vnf /etc/pf.conf</code> 是一个命令，用于验证和加载位于 <code>/etc/pf.conf</code> 文件中的 PF 防火墙规则。</p></td>
</tr>
</tbody>
</table>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p><a class="package" href="https://cgit.freebsd.org/ports/tree/security/sudo/">security/sudo</a> 是用于运行需要提升权限的命令，例如 <code>pfctl</code> 。它可以从 Ports Collection 安装。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要监视通过 PF 防火墙的流量，请考虑安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/sysutils/pftop/">sysutils/pftop</a> 包或端口。安装完成后，可以运行 pftop 以查看类似于 <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 的格式的流量的实时快照。</p>
</div>
</div>
<div class="sect3">
<h4 id="pf-tutorial">33.3.2. PF 规则集<a class="anchor" href="#pf-tutorial"></a></h4>
<div class="paragraph">
<p>本节演示如何创建自定义规则集。它从最简单的规则集开始，并通过多个示例来构建其概念，以展示 PF 的许多功能在实际应用中的用法。</p>
</div>
<div class="paragraph">
<p>最简单的规则集适用于不运行任何服务且需要访问一个网络（可能是互联网）的单台机器。要创建这个最小的规则集，请编辑 <code>/etc/pf.conf</code> 文件，使其如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>block in all
pass out all keep state</pre>
</div>
</div>
<div class="paragraph">
<p>第一条规则默认拒绝所有传入流量。第二条规则允许由该系统创建的连接通过，并保留这些连接的状态信息。这些状态信息允许这些连接的返回流量通过，并且只应在可信任的机器上使用。可以使用以下命令加载规则集：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -e ; pfctl -f /etc/pf.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了保持状态， PF 还提供了可以在创建规则时定义和使用的“列表”和“宏”。宏可以包含列表，并且需要在使用之前进行定义。例如，在规则集的最顶部插入以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>PF 不仅可以识别端口号，还可以识别端口名称，只要这些名称在 [/etc/services] 文件中列出。这个例子创建了两个宏。第一个宏是一个包含七个 TCP 端口名称的列表，第二个宏是一个 UDP 端口名称。一旦定义了宏，就可以在规则中使用它们。在这个例子中，除了由该系统发起的与七个指定的 TCP 服务和一个指定的 UDP 服务相关的连接之外，所有流量都被阻止。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>tcp_services = &#34;{ ssh, smtp, domain, www, pop3, auth, pop3s }&#34;
udp_services = &#34;{ domain }&#34;
block all
pass out proto tcp to any port $tcp_services keep state
pass proto udp to any port $udp_services keep state</pre>
</div>
</div>
<div class="paragraph">
<p>尽管 UDP 被认为是一种无状态协议，但 PF 能够跟踪一些状态信息。例如，当传递一个 UDP 请求来询问域名服务器的域名时， PF 会监视响应并将其传递回去。</p>
</div>
<div class="paragraph">
<p>每当对规则集进行编辑时，必须加载新的规则，以便可以使用它们：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -f /etc/pf.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果没有语法错误， <code>pfctl</code> 在加载规则时不会输出任何消息。在尝试加载规则之前，也可以对规则进行测试：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -nf /etc/pf.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>包括 <code>-n</code> 会导致规则仅被解释而不被加载。这提供了纠正任何错误的机会。在任何时候，只有最后一个有效的规则集被加载，直到 PF 被禁用或加载了一个新的规则集。</p>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <code>pfctl</code> 规则集的验证或加载命令后添加 <code>-v</code> 参数，将会显示完全解析的规则，这些规则将会被加载。在调试规则时，这非常有用。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="pftut-gateway">33.3.2.1. 一个带有 NAT 的简单网关<a class="anchor" href="#pftut-gateway"></a></h5>
<div class="paragraph">
<p>本节演示了如何配置运行 PF 的 FreeBSD 系统，使其充当至少一台其他计算机的网关。网关需要至少两个网络接口，每个接口连接到不同的网络。在本示例中， .filename#xl0# 连接到互联网， .filename#xl1# 连接到内部网络。</p>
</div>
<div class="paragraph">
<p>首先，启用网关以使机器将其接收到的网络流量从一个接口转发到另一个接口。这个 sysctl 设置将转发 IPv4 数据包：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl net.inet.ip.forwarding=1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要转发 IPv6 流量，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysctl net.inet6.ip6.forwarding=1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在系统启动时启用这些设置，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysrc&amp;sektion=8&amp;format=html">sysrc(8)</a> 将它们添加到 [/etc/rc.conf] 文件中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc gateway_enable=yes</span>
<span class="c"># sysrc ipv6_gateway_enable=yes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>使用 <code>ifconfig</code> 命令验证两个接口是否都已启动并运行。</p>
</div>
<div class="paragraph">
<p>接下来，创建 PF 规则以允许网关传递流量。虽然以下规则允许来自内部网络主机的有状态流量通过网关，但 <code>to</code> 关键字不能保证从源到目的地的完全通过：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass in on xl1 from xl1:network to xl0:network port $ports keep state</pre>
</div>
</div>
<div class="paragraph">
<p>该规则只允许流量通过内部接口进入网关。要让数据包继续传递，需要一个匹配的规则：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass out on xl0 from xl1:network to xl0:network port $ports keep state</pre>
</div>
</div>
<div class="paragraph">
<p>虽然这两个规则可以工作，但这样具体的规则很少需要。对于忙碌的网络管理员来说，一个可读的规则集是更安全的规则集。本节的其余部分演示了如何尽可能简化规则以提高可读性。例如，这两个规则可以用一条规则来替代：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass from xl1:network to any port $ports keep state</pre>
</div>
</div>
<div class="paragraph">
<p>可以使用宏来替代 <code>interface:network</code> 表示法，使规则集更易读。例如，可以定义一个 ` $ localnet` 宏，表示直接连接到内部接口的网络（ ` $ xl1:network` ）。另外，也可以将 ` $ localnet` 的定义更改为_IP 地址 / 子网掩码_表示法来表示网络，例如 <code>192.168.100.1/24</code> 表示私有地址的子网。</p>
</div>
<div class="paragraph">
<p>如果需要的话， ` $ localnet` 甚至可以被定义为一个网络列表。无论具体需求如何，一个合理的 ` $ localnet` 定义可以在典型的通过规则中使用，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass from $localnet to any port $ports keep state</pre>
</div>
</div>
<div class="paragraph">
<p>以下示例规则集允许内部网络上的机器发起的所有流量。它首先定义了两个宏，用于表示网关的外部和内部 3COM 接口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于拨号用户，外部接口将使用 <span class="filename">tun0</span> 。对于 ADSL 连接，特别是使用以太网上的 PPP （ PPPoE ）的连接，正确的外部接口是 <span class="filename">tun0</span> ，而不是物理以太网接口。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ext_if = &#34;xl0&#34;	# macro for external interface - use tun0 for PPPoE
int_if = &#34;xl1&#34;	# macro for internal interface
localnet = $int_if:network
# ext_if IP address could be dynamic, hence ($ext_if)
nat on $ext_if from $localnet to any -&gt; ($ext_if)
block all
pass from { lo0, $localnet } to any keep state</pre>
</div>
</div>
<div class="paragraph">
<p>这个规则集引入了 <code>nat</code> 规则，用于处理内部网络中不可路由的地址到分配给外部接口的 IP 地址的网络地址转换。 nat 规则的最后部分周围的括号 <code>($ ext_if)</code> 是在外部接口的 IP 地址是动态分配时包含的。它确保即使外部 IP 地址发生变化，网络流量也能够正常运行而不会有严重的中断。</p>
</div>
<div class="paragraph">
<p>请注意，这个规则集可能允许更多的流量从网络中通过，而实际上并不需要这么多。一个合理的设置可以创建这个宏：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>client_out = &#34;{ ftp-data, ftp, ssh, domain, pop3, auth, nntp, http, \
    https, cvspserver, 2628, 5999, 8000, 8080 }&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>用于主要通行规则中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass inet proto tcp from $localnet to any port $client_out \
    flags S/SA keep state</pre>
</div>
</div>
<div class="paragraph">
<p>可能还需要一些其他的通行规则。这个规则允许在外部接口上使用 SSH ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass in inet proto tcp to $ext_if port ssh</pre>
</div>
</div>
<div class="paragraph">
<p>这个宏定义和规则允许内部客户端使用 DNS 和 NTP 服务。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>udp_services = &#34;{ domain, ntp }&#34;
pass quick inet proto { tcp, udp } to any port $udp_services keep state</pre>
</div>
</div>
<div class="paragraph">
<p>请注意这条规则中的 <code>quick</code> 关键字。由于规则集包含多个规则，因此了解规则集中规则之间的关系非常重要。规则按照从上到下的顺序进行评估，按照它们编写的顺序进行。对于每个由 PF 评估的数据包或连接，规则集中的 <em>最后一个匹配的规则</em> 是应用的规则。然而，当一个数据包匹配包含 <code>quick</code> 关键字的规则时，规则处理停止，数据包根据该规则进行处理。当需要对一般规则进行异常处理时，这非常有用。</p>
</div>
</div>
<div class="sect4">
<h5 id="pftut-ftp">33.3.2.2. 创建一个 FTP 代理<a class="anchor" href="#pftut-ftp"></a></h5>
<div class="paragraph">
<p>由于 FTP 协议的特性，配置工作中的 FTP 规则可能会出现问题。 FTP 在防火墙出现几十年之前就存在，并且在设计上存在不安全性。使用 FTP 的最常见问题包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>密码以明文形式传输。</p>
</li>
<li>
<p>该协议要求使用至少两个 TCP 连接（控制和数据），并且这两个连接要使用不同的端口。</p>
</li>
<li>
<p>当建立会话时，数据使用随机选择的端口进行通信。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在考虑客户端或服务器软件的潜在安全弱点之前，所有这些要点都提出了安全挑战。存在更安全的文件传输替代方案，例如 <a href="https://man.freebsd.org/cgi/man.cgi?query=sftp&amp;sektion=1&amp;format=html">sftp(1)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=scp&amp;sektion=1&amp;format=html">scp(1)</a> ，它们都具有身份验证和加密连接上的数据传输功能。</p>
</div>
<div class="paragraph">
<p>对于需要使用 FTP 的情况， PF 提供了将 FTP 流量重定向到一个名为 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> 的小型代理程序，该程序包含在 FreeBSD 的基本系统中。代理的作用是使用一组锚点动态插入和删除规则，以正确处理 FTP 流量。</p>
</div>
<div class="paragraph">
<p>要启用 FTP 代理，请将以下行添加到 /etc/rc.conf 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ftpproxy_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后通过运行以下命令启动代理：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="bash"><span class="c"># service ftp-proxy start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于基本配置，需要将三个元素添加到 [/etc/pf.conf] 文件中。首先是代理将用于插入生成的 FTP 会话规则的锚点：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>nat-anchor &#34;ftp-proxy/*&#34;
rdr-anchor &#34;ftp-proxy/*&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>其次，需要一个通过规则来允许 FTP 流量进入代理服务器。</p>
</div>
<div class="paragraph">
<p>第三，重定向和 NAT 规则需要在过滤规则之前定义。在 <code>nat</code> 规则之后立即插入以下 <code>rdr</code> 规则：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rdr pass on $int_if proto tcp from any to any port ftp -&gt; 127.0.0.1 port 8021</pre>
</div>
</div>
<div class="paragraph">
<p>最后，允许重定向的流量通过。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass out proto tcp from $proxy to any port ftp</pre>
</div>
</div>
<div class="paragraph">
<p>` $ proxy` 是代理守护程序绑定的地址的展开形式。</p>
</div>
<div class="paragraph">
<p>保存 <span class="filename">/etc/pf.conf</span> 文件，加载新的规则，并从客户端验证 FTP 连接是否正常工作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -f /etc/pf.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子涵盖了一个基本的设置，其中本地网络中的客户端需要联系其他地方的 FTP 服务器。这个基本配置应该适用于大多数 FTP 客户端和服务器的组合。如 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> 所示，通过在 `ftpproxy_flags = ` 行中添加选项，可以改变代理的行为。一些客户端或服务器可能有特定的问题，在配置中必须进行补偿，或者可能需要以特定的方式集成代理，例如将 FTP 流量分配给特定的队列。</p>
</div>
<div class="paragraph">
<p>要以 PF 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftp-proxy&amp;sektion=8&amp;format=html">ftp-proxy(8)</a> 保护的方式运行 FTP 服务器，可以配置一个独立的 <code>ftp-proxy</code> 以反向模式运行，使用 <code>-R</code> 选项，在一个独立的端口上，并具有自己的重定向通过规则。</p>
</div>
</div>
<div class="sect4">
<h5 id="pftut-icmp">33.3.2.3. 管理 ICMP<a class="anchor" href="#pftut-icmp"></a></h5>
<div class="paragraph">
<p>许多用于调试或故障排除 TCP/IP 网络的工具依赖于 Internet 控制消息协议（ ICMP ），该协议专门设计用于调试。</p>
</div>
<div class="paragraph">
<p>ICMP 协议在主机和网关之间发送和接收“控制消息”，主要是为了向发送方提供有关到目标主机的任何异常或困难条件的反馈。路由器使用 ICMP 来协商数据包大小和其他传输参数，这个过程通常被称为“路径 MTU 发现”。</p>
</div>
<div class="paragraph">
<p>从防火墙的角度来看，一些 ICMP 控制消息容易受到已知的攻击向量的攻击。此外，无条件地允许所有诊断流量通过可以使调试更容易，但也会使他人更容易提取有关网络的信息。因此，以下规则可能不是最佳选择：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass inet proto icmp from any to any</pre>
</div>
</div>
<div class="paragraph">
<p>一种解决方案是允许本地网络中的所有 ICMP 流量通过，同时阻止来自网络外部的所有探测。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass inet proto icmp from $localnet to any keep state
pass inet proto icmp from any to $ext_if keep state</pre>
</div>
</div>
<div class="paragraph">
<p>还有其他可用的选项，这些选项展示了 PF 的一些灵活性。例如，可以指定 <a href="https://man.freebsd.org/cgi/man.cgi?query=ping&amp;sektion=8&amp;format=html">ping(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> 使用的消息，而不是允许所有的 ICMP 消息。首先，定义一个用于该类型消息的宏：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>icmp_types = &#34;echoreq&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>和一个使用宏的规则：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre>
</div>
</div>
<div class="paragraph">
<p>如果需要其他类型的 ICMP 数据包，请将 <code>icmp_types</code> 扩展为这些数据包类型的列表。输入 <code>more /usr/src/sbin/pfctl/pfctl_parser.c</code> 以查看 PF 支持的 ICMP 消息类型列表。请参考 <a href="http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml">http://www.iana.org/assignments/icmp-parameters/icmp-parameters.xhtml</a> 以了解每个消息类型的解释。</p>
</div>
<div class="paragraph">
<p>由于 Unix 的 <code>traceroute</code> 默认使用 UDP ，因此需要添加另一条规则来允许 Unix 的 <code>traceroute</code> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># allow out the default range for traceroute(8):
pass out on $ext_if inet proto udp from any to any port 33433 &gt;&lt; 33626 keep state</pre>
</div>
</div>
<div class="paragraph">
<p>由于 Microsoft Windows 系统上的 <code>TRACERT.EXE</code> 使用 ICMP 回显请求消息，因此只需要第一个规则来允许来自这些系统的网络跟踪。 Unix 的 <code>traceroute</code> 也可以指示使用其他协议，并且如果使用了 <code>-I</code> 选项，它将使用 ICMP 回显请求消息。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> 手册页。</p>
</div>
<div class="sect5">
<h6 id="pftut-pathmtudisc">33.3.2.3.1. 路径最大传输单元发现<a class="anchor" href="#pftut-pathmtudisc"></a></h6>
<div class="paragraph">
<p>Internet 协议被设计为与设备无关，设备无关的一个结果是无法可靠地预测给定连接的最佳数据包大小。数据包大小的主要限制是“最大传输单元”（ MTU ），它设置了接口的数据包大小的上限。输入 <code>ifconfig</code> 命令可以查看系统网络接口的 MTU 值。</p>
</div>
<div class="paragraph">
<p>TCP/IP 使用一种称为路径 MTU 发现的过程来确定连接的正确数据包大小。该过程发送大小不同的数据包，并设置“不分片”标志，期望在达到上限时收到一个 ICMP 返回数据包，其类型为“ 3 型，代码 4 ”。类型 3 表示“目标不可达”，代码 4 表示“需要分片，但设置了不分片标志”。为了支持与其他 MTU 的连接，可以将“目标不可达”类型添加到“ icmp_types ”宏中，以允许路径 MTU 发现。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>icmp_types = &#34;{ echoreq, unreach }&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>由于 pass 规则已经使用了该宏，所以不需要修改 pass 规则来支持新的 ICMP 类型。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass inet proto icmp all icmp-type $icmp_types keep state</pre>
</div>
</div>
<div class="paragraph">
<p>PF 允许对所有 ICMP 类型和代码进行过滤。可能的类型和代码的列表在 <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp&amp;sektion=4&amp;format=html">icmp(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=icmp6&amp;sektion=4&amp;format=html">icmp6(4)</a> 中有文档记录。</p>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pftut-tables">33.3.2.4. 使用表格<a class="anchor" href="#pftut-tables"></a></h5>
<div class="paragraph">
<p>某些类型的数据在特定时间对过滤和重定向很重要，但它们的定义太长了，无法包含在规则集文件中。 PF 支持使用表格，这些表格是定义的列表，可以在不需要重新加载整个规则集的情况下进行操作，并且可以提供快速查找。表格名称始终用 <code>&lt; &gt;</code> 括起来，就像这样：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>table &lt;clients&gt; { 192.168.2.0/24, !192.168.2.5 }</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中， <code>192.168.2.0/24</code> 网络是表的一部分，除了地址 <code>192.168.2.5</code> ，它使用 ` ! ` 运算符被排除在外。还可以从文件中加载表，其中每个项目都在单独的行上，就像在这个例子中看到的那样 <span class="filename">/etc/clients</span> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>192.168.2.0/24
!192.168.2.5</pre>
</div>
</div>
<div class="paragraph">
<p>要引用该文件，请按照以下方式定义表格：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>table &lt;clients&gt; persist file &#34;/etc/clients&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>一旦表被定义，就可以通过规则进行引用：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass inet proto tcp from &lt;clients&gt; to any port $client_out flags S/SA keep state</pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code>pfctl</code> 实时操作表的内容。以下示例将另一个网络添加到表中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -t clients -T add 192.168.1.0/16</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，通过这种方式进行的任何更改将立即生效，这使它们非常适合测试，但在断电或重启后将不会保留。要使更改永久生效，可以修改规则集中表的定义或编辑表所引用的文件。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 作业来维护表的磁盘副本，该作业定期将表的内容转储到磁盘上，使用类似 <code>pfctl -t clients -T show &gt;/etc/clients</code> 的命令。或者，也可以使用 <span class="filename">/etc/clients</span> 更新内存中的表内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -t clients -T replace -f /etc/clients</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pftut-overload">33.3.2.5. 使用过载表保护 SSH<a class="anchor" href="#pftut-overload"></a></h5>
<div class="paragraph">
<p>那些在外部接口上运行 SSH 的人可能在身份验证日志中看到类似于以下内容的信息：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>Sep 26 03:12:34 skapet sshd[25771]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:34 skapet sshd[5279]: Failed password for root from 200.72.41.31 port 40992 ssh2
Sep 26 03:12:35 skapet sshd[5279]: Received disconnect from 200.72.41.31: 11: Bye Bye
Sep 26 03:12:44 skapet sshd[29635]: Invalid user admin from 200.72.41.31
Sep 26 03:12:44 skapet sshd[24703]: input_userauth_request: invalid user admin
Sep 26 03:12:44 skapet sshd[24703]: Failed password for invalid user admin from 200.72.41.31 port 41484 ssh2</pre>
</div>
</div>
<div class="paragraph">
<p>这表明正在进行一次暴力攻击，某人或某个程序正在尝试发现能够让他们进入系统的用户名和密码。</p>
</div>
<div class="paragraph">
<p>如果需要合法用户进行外部 SSH 访问，更改 SSH 使用的默认端口可以提供一定的保护。然而， PF 提供了一种更优雅的解决方案。通过 Pass 规则，可以限制连接主机的操作，并将违规者放入被拒绝某些或全部访问的地址表中。甚至可以断开超出限制的机器的所有现有连接。</p>
</div>
<div class="paragraph">
<p>要进行配置，请在规则集的表格部分创建此表格。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>table &lt;bruteforce&gt; persist</pre>
</div>
</div>
<div class="paragraph">
<p>然后，在规则集的早期位置添加规则，以阻止暴力访问，同时允许合法访问：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>block quick from &lt;bruteforce&gt;
pass inet proto tcp from any to $localnet port $tcp_services \
    flags S/SA keep state \
    (max-src-conn 100, max-src-conn-rate 15/5, \
    overload &lt;bruteforce&gt; flush global)</pre>
</div>
</div>
<div class="paragraph">
<p>括号中的部分定义了限制条件，数字应根据当地要求进行更改。可以按以下方式阅读：</p>
</div>
<div class="paragraph">
<p><code>max-src-conn</code> 是指允许来自一个主机的同时连接数。</p>
</div>
<div class="paragraph">
<p><code>max-src-conn-rate</code> 是指在每个指定的时间段（ 5 秒）内，允许来自单个主机（ 15 ）的新连接的速率。</p>
</div>
<div class="paragraph">
<p><code>overload &lt;bruteforce&gt;</code> 的意思是任何超过这些限制的主机都会将其地址添加到 <code>bruteforce</code> 表中。规则集会阻止来自 <code>bruteforce</code> 表中地址的所有流量。</p>
</div>
<div class="paragraph">
<p>最后， <code>flush global</code> 表示当一个主机达到限制时，该主机的所有连接 (<code>global</code>) 将被终止 (<code>flush</code>) 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>这些规则将 <em>不会</em> 阻止慢速暴力破解者，如 <a href="http://home.nuug.no/" class="bare">http://home.nuug.no/</a> \~ peter/hailmary2013/[<a href="http://home.nuug.no/" class="bare">http://home.nuug.no/</a> ~ peter/hailmary2013/] 中所描述的。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这个示例规则集主要是为了说明。例如，如果希望有大量的连接，但对于 ssh 的要求更加严格，可以在规则集的早期添加以下类似的规则来补充上面的规则：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>pass quick proto { tcp, udp } from any to any port ssh \
    flags S/SA keep state \
    (max-src-conn 15, max-src-conn-rate 5/3, \
    overload &lt;bruteforce&gt; flush global)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>不一定需要阻止所有超载器： *</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>值得注意的是，过载机制是一种通用技术，不仅适用于 SSH ，并且完全阻止来自违规者的所有流量并不总是最优的选择。</p>
</div>
<div class="paragraph">
<p>例如，可以使用过载规则来保护邮件服务或网络服务，并且可以在规则中使用过载表来将违规者分配到带有最小带宽分配的队列中，或者重定向到特定的网页。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>随着时间的推移，表格将被过载规则填满，其大小将逐渐增长，占用更多的内存。有时，被阻止的 IP 地址是一个动态分配的地址，后来被分配给了一个有合法理由与本地网络中的主机通信的主机。</p>
</div>
<div class="paragraph">
<p>对于这种情况， pfctl 提供了过期表项的功能。例如，以下命令将删除在 <code>86400</code> 秒内没有被引用的 <code>&lt;bruteforce&gt;</code> 表项：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -t bruteforce -T expire 86400</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>类似的功能由包： security/expiretable[] 提供，该包会删除在指定时间内未被访问的表条目。</p>
</div>
<div class="paragraph">
<p>安装完成后，可以运行 expiretable 来删除指定年龄之前的 <code>&lt;bruteforce&gt;</code> 表条目。以下示例将删除所有 24 小时之前的条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>/usr/local/sbin/expiretable -v -d -t 24h bruteforce</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pftut-spamd">33.3.2.6. 防止垃圾邮件的保护措施<a class="anchor" href="#pftut-spamd"></a></h5>
<div class="paragraph">
<p>不要将其与 spamassassin 捆绑的 spamd 守护程序混淆， <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/spamd/">mail/spamd</a> 可以通过配置 PF 来提供对垃圾邮件的外部防御。这个 spamd 通过一组重定向钩入 PF 配置。</p>
</div>
<div class="paragraph">
<p>垃圾邮件发送者往往发送大量的消息，垃圾邮件主要来自一些友好的垃圾邮件网络和大量被劫持的机器，这些都会被迅速报告给封锁列表。</p>
</div>
<div class="paragraph">
<p>当接收到来自黑名单中地址的 SMTP 连接时， spamd 会呈现其横幅，并立即切换到一种模式，以逐字节地回答 SMTP 流量。这种技术旨在尽可能浪费垃圾邮件发送者的时间，被称为“蜿蜒”。具体实现使用逐字节 SMTP 回复的方法通常被称为“口吃”。</p>
</div>
<div class="paragraph">
<p>这个示例演示了使用自动更新的屏蔽列表设置 spamd 的基本步骤。有关更多信息，请参考安装在 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/spamd/">mail/spamd</a> 中的 man 页面。</p>
</div>
<div class="sidebarblock procedure">
<div class="content">
<div class="olist arabic">
<div class="title">过程：配置 spamd</div>
<ol class="arabic">
<li>
<p>Open the configuration file for spamd. This file is typically located at /etc/spamassassin/spamd.conf.</p>
</li>
<li>
<p>Look for the following options in the configuration file:</p>
<div class="ulist">
<ul>
<li>
<p><code>allowed_ips</code>: This option allows you to specify a list of IP addresses or networks that are allowed to connect to spamd. You can use CIDR notation to specify networks.</p>
</li>
<li>
<p><code>listen</code>: This option specifies the IP address and port on which spamd should listen for incoming connections. By default , spamd listens on all available IP addresses and port 783.</p>
</li>
<li>
<p><code>max_children</code>: This option sets the maximum number of child processes that spamd can spawn to handle incoming connections. The default value is 5.</p>
</li>
<li>
<p><code>max_requests</code>: This option sets the maximum number of requests that a child process can handle before it is terminated. The default value is 20.</p>
</li>
<li>
<p><code>pidfile</code>: This option specifies the location of the file where spamd will write its process ID. By default , this file is located at /var/run/spamd.pid.</p>
</li>
</ul>
</div>
</li>
<li>
<p>Modify these options as needed and save the configuration file.</p>
</li>
<li>
<p>Restart the spamd service to apply the changes. The command to restart the service may vary depending on your operating system. For example , on a system using systemd , you can use the command <code>systemctl restart spamassassin</code>.</p>
</li>
<li>
<p>Verify that spamd is running and listening on the specified IP address and port. You can use the command <code>netstat -tuln | grep 783</code> to check if spamd is listening on port 783.</p>
</li>
<li>
<p>Test spamd by sending a test email to a user on your system. Check the email headers to see if spamd has processed the email and added any spam-related headers.</p>
</li>
<li>
<p>If necessary , adjust the spamd configuration further to meet your specific needs. Refer to the spamd documentation for more information on available options and their usage.</p>
</li>
<li>
<p>Monitor the spamd logs for any errors or issues. The logs are typically located at /var/log/maillog or /var/log/spamd.log.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>配置 spamd 的过程</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>打开 spamd 的配置文件。该文件通常位于 /etc/spamassassin/spamd.conf 。</p>
</li>
<li>
<p>在配置文件中查找以下选项：</p>
<div class="ulist">
<ul>
<li>
<p><code>allowed_ips</code> ：该选项允许您指定允许连接到 spamd 的 IP 地址或网络列表。您可以使用 CIDR 表示法指定网络。</p>
</li>
<li>
<p><code>listen</code> ：该选项指定 spamd 应在哪个 IP 地址和端口上监听传入连接。默认情况下， spamd 在所有可用的 IP 地址和端口 783 上监听。</p>
</li>
<li>
<p><code>max_children</code> ：该选项设置 spamd 可以生成的用于处理传入连接的子进程的最大数量。默认值为 5 。</p>
</li>
<li>
<p><code>max_requests</code> ：该选项设置子进程在终止之前可以处理的最大请求数。默认值为 20 。</p>
</li>
<li>
<p><code>pidfile</code> ：该选项指定 spamd 将写入其进程 ID 的文件的位置。默认情况下，该文件位于 /var/run/spamd.pid 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>根据需要修改这些选项并保存配置文件。</p>
</li>
<li>
<p>重新启动 spamd 服务以应用更改。重新启动服务的命令可能因操作系统而异。例如，在使用 systemd 的系统上，您可以使用命令 <code>systemctl restart spamassassin</code> 。</p>
</li>
<li>
<p>验证 spamd 是否正在运行并监听指定的 IP 地址和端口。您可以使用命令 <code>netstat -tuln | grep 783</code> 来检查 spamd 是否在端口 783 上监听。</p>
</li>
<li>
<p>通过向系统上的用户发送测试电子邮件来测试 spamd 。检查电子邮件头以查看 spamd 是否已处理电子邮件并添加了任何与垃圾邮件相关的头部。</p>
</li>
<li>
<p>如有必要，进一步调整 spamd 配置以满足您的特定需求。有关可用选项及其用法的更多信息，请参阅 spamd 文档。</p>
</li>
<li>
<p>监视 spamd 日志以查找任何错误或问题。日志通常位于 /var/log/maillog 或 /var/log/spamd.log 。</p>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>安装 <a class="package" href="https://cgit.freebsd.org/ports/tree/mail/spamd/">mail/spamd</a> 包或端口。要使用 spamd 的灰名单功能，必须在 <span class="filename">/dev/fd</span> 上挂载 <a href="https://man.freebsd.org/cgi/man.cgi?query=fdescfs&amp;sektion=5&amp;format=html">fdescfs(5)</a> 。将以下行添加到 <span class="filename">/etc/fstab</span> ：</p>
<div class="literalblock programlisting">
<div class="content">
<pre> fdescfs /dev/fd fdescfs rw 0 0</pre>
</div>
</div>
<div class="paragraph">
<p>然后，挂载文件系统：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#  mount fdescfs</pre>
</div>
</div>
</li>
<li>
<p>接下来，编辑 PF 规则集以包含以下内容：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>table &lt;spamd&gt; persist
table &lt;spamd-white&gt; persist
rdr pass on $ext_if inet proto tcp from &lt;spamd&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025
rdr pass on $ext_if inet proto tcp from !&lt;spamd-white&gt; to \
    { $ext_if, $localnet } port smtp -&gt; 127.0.0.1 port 8025</pre>
</div>
</div>
<div class="paragraph">
<p>两个表 <code>&lt;spamd&gt;</code> 和 <code>&lt;spamd-white&gt;</code> 是必需的。来自在 <code>&lt;spamd&gt;</code> 中列出但不在 <code>&lt;spamd-white&gt;</code> 中列出的地址的 SMTP 流量将被重定向到监听在端口 8025 的 spamd 守护进程。</p>
</div>
</li>
<li>
<p>下一步是在 <code>/usr/local/etc/spamd.conf</code> 中配置 spamd ，并添加一些 <code>rc.conf</code> 参数。</p>
<div class="paragraph">
<p>安装包： mail/spamd[] 包括一个示例配置文件（ <span class="filename">/usr/local/etc/spamd.conf.sample</span> ）和一个用于 <span class="filename">spamd.conf</span> 的 man 页面。请参考这些内容以获取超出本示例所示配置选项的其他配置选项。</p>
</div>
<div class="paragraph">
<p>配置文件中第一行不以“+ # +”注释符号开头的行包含了定义“ all ”列表的块，该列表指定要使用的列表：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>all:\
    :traplist:allowlist:</pre>
</div>
</div>
<div class="paragraph">
<p>此条目添加了所需的阻止列表，用冒号（ <code>:</code> ）分隔。要使用允许列表从阻止列表中减去地址，请在该阻止列表的名称之后立即添加允许列表的名称。例如： <code>: 阻止列表 : 允许列表 :</code> 。</p>
</div>
<div class="paragraph">
<p>接下来是指定块列表的定义：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>traplist:\
    :black:\
    :msg=&#34;SPAM. Your address %A has sent spam within the last 24 hours&#34;:\
    :method=http:\
    :file=www.openbsd.org/spamd/traplist.gz</pre>
</div>
</div>
<div class="paragraph">
<p>第一行是块列表的名称，第二行指定了列表类型。 <code>msg</code> 字段包含在 SMTP 对话期间显示给被列入块列表的发件人的消息。 <code>method</code> 字段指定了 spamd-setup 获取列表数据的方式；支持的方法有 <code>http</code> 、 <code>ftp</code> 、从挂载文件系统中的 <code>file</code> 文件和通过执行外部程序的 <code>exec</code> 。最后， <code>file</code> 字段指定了 spamd 期望接收的文件的名称。</p>
</div>
<div class="paragraph">
<p>指定允许列表的定义类似，但省略了 <code>msg</code> 字段，因为不需要消息。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>allowlist:\
    :white:\
    :method=file:\
    :file=/var/mail/allowlist.txt</pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="ulist">
<ul>
<li>
<p>谨慎选择数据源 :*<br/></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>使用样本中的所有屏蔽列表 <span class="filename">spamd.conf</span> 将会屏蔽大量的互联网区块。管理员需要编辑该文件，以创建一个最佳配置，使用适用的数据源，并在必要时使用自定义列表。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接下来，将此条目添加到 [/etc/rc.conf] 文件中。其他标志在由注释指定的 man 页面中有描述。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>spamd_flags=&#34;-v&#34; # use &#34;&#34; and see spamd-setup(8) for flags</pre>
</div>
</div>
<div class="paragraph">
<p>完成后，重新加载规则集，通过输入 <code>service obspamd start</code> 启动 spamd ，并使用 <code>spamd-setup</code> 完成配置。最后，创建一个 <a href="https://man.freebsd.org/cgi/man.cgi?query=cron&amp;sektion=8&amp;format=html">cron(8)</a> 任务，定期调用 <code>spamd-setup</code> 来更新表格。</p>
</div>
</li>
</ol>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="paragraph">
<p>在邮件服务器前的典型网关上，主机很快就会在几秒钟到几分钟内被困住。</p>
</div>
<div class="paragraph">
<p>PF 还支持&#34;灰名单&#34;，它会暂时拒绝来自未知主机的带有&#34;45n&#34;代码的消息。在合理的时间内再次尝试的灰名单主机的消息将被放行。符合 RFC 1123 和 RFC 2821 规定的发件人的流量将立即被放行。</p>
</div>
<div class="paragraph">
<p>关于灰名单技术的更多信息可以在 <a href="http://www.greylisting.org/">greylisting.org</a> 网站上找到。灰名单最令人惊讶的事情之一，除了它的简单性，就是它仍然有效。垃圾邮件发送者和恶意软件编写者一直非常慢地适应绕过这种技术。</p>
</div>
<div class="paragraph">
<p>配置灰名单的基本步骤如下：</p>
</div>
<div class="olist arabic procedure">
<div class="title">过程：配置灰名单</div>
<ol class="arabic">
<li>
<p>Install a greylisting software on your mail server. There are several options available , such as Postgrey , Greylistd , and Policyd-weight.</p>
</li>
<li>
<p>Configure the greylisting software by editing its configuration file. The exact steps may vary depending on the software you are using , but typically you will need to specify the IP address or domain of your mail server , as well as any whitelisted addresses or domains.</p>
</li>
<li>
<p>Enable greylisting on your mail server by restarting the mail server or reloading its configuration. This will activate the greylisting software and start applying greylisting to incoming emails.</p>
</li>
<li>
<p>Monitor the greylisting logs to ensure that legitimate emails are not being blocked. Greylisting works by temporarily rejecting incoming emails from unknown senders and then accepting them on subsequent delivery attempts. It is important to review the logs regularly to ensure that legitimate emails are not being mistakenly blocked.</p>
</li>
<li>
<p>Fine-tune the greylisting settings if necessary. Some greylisting software allows you to adjust parameters such as the length of the greylisting delay or the number of delivery attempts before accepting an email. Experiment with these settings to find the right balance between blocking spam and allowing legitimate emails through.</p>
</li>
<li>
<p>Periodically review the effectiveness of greylisting. Greylisting can be an effective tool in reducing spam , but it may also result in delayed delivery of legitimate emails. Monitor the impact of greylisting on your mail server’s performance and adjust the settings as needed.</p>
<div class="literalblock">
<div class="content">
<pre> By following these steps , you can configure greylisting on your mail server to help reduce spam and improve email security.
. 确保按照上一个步骤的说明，将 man:fdescfs[5] 挂载起来。
. 要以灰名单模式运行 spamd ，请将以下行添加到 /etc/rc.conf 文件中：</pre>
</div>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>spamd_grey=&#34;YES&#34;  # use spamd greylisting if YES</pre>
</div>
</div>
<div class="paragraph">
<p>请参考 spamd 手册，了解其他相关参数的描述。
. 完成灰名单设置的步骤：</p>
</div>
<div class="paragraph">
<p>+</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#  service obspamd restart
#  service obspamlogd start</pre>
</div>
</div>
</li>
</ol>
</div>
<div class="paragraph">
<p>在幕后， spamdb 数据库工具和 spamlogd 白名单更新程序为灰名单功能执行重要功能。 spamdb 是管理员通过 <span class="var/db/spamdb">/var/db/spamdb</span> 数据库的内容来管理阻止、灰名单和允许名单的主要界面。</p>
</div>
</div>
<div class="sect4">
<h5 id="pftut-hygiene">33.3.2.7. 网络卫生<a class="anchor" href="#pftut-hygiene"></a></h5>
<div class="paragraph">
<p>本节介绍了如何使用 <code>block-policy</code> 、 <code>scrub</code> 和 <code>antispoof</code> 来使规则集的行为正常。</p>
</div>
<div class="paragraph">
<p><code>block-policy</code> 是一个选项，可以在规则集的 <code>options</code> 部分中设置，该部分位于重定向和过滤规则之前。该选项确定了 PF 在规则阻止主机时发送的反馈信息（如果有的话）。该选项有两个可能的值： <code>drop</code> 会丢弃被阻止的数据包而不提供反馈， <code>return</code> 会返回一个状态码，例如 <code>Connection refused</code> 。</p>
</div>
<div class="paragraph">
<p>如果未设置，默认策略为“ drop ”。要更改“ block-policy ”，请指定所需的值：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>set block-policy return</pre>
</div>
</div>
<div class="paragraph">
<p>在 PF 中， <code>scrub</code> 是一个关键字，它可以启用网络数据包的规范化。该过程会重新组装分段的数据包，并且丢弃具有无效标志组合的 TCP 数据包。启用 <code>scrub</code> 可以提供一定程度的保护，防止基于数据包片段处理不正确的某些攻击。有许多选项可供选择，但最简单的形式适用于大多数配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>scrub in all</pre>
</div>
</div>
<div class="paragraph">
<p>一些服务，如 NFS ，需要特定的片段处理选项。有关更多信息，请参阅 <a href="https://home.nuug.no/" class="bare">https://home.nuug.no/</a> ~ peter/pf/en/scrub.html 。</p>
</div>
<div class="paragraph">
<p>这个例子重新组装片段，清除“不分片”位，并将最大分段大小设置为 1440 字节：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>scrub in all fragment reassemble no-df max-mss 1440</pre>
</div>
</div>
<div class="paragraph">
<p><code>antispoof</code> 机制通过阻止出现在逻辑上不可能的接口和方向上的数据包，主要保护免受伪造或伪装的 IP 地址的活动的影响。</p>
</div>
<div class="paragraph">
<p>这些规则可以过滤掉来自世界其他地方的伪造流量，以及源自本地网络的任何伪造数据包。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>antispoof for $ext_if
antispoof for $int_if</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="pftut-unrouteables">33.3.2.8. 处理非可路由地址<a class="anchor" href="#pftut-unrouteables"></a></h5>
<div class="paragraph">
<p>即使有一个正确配置的网关来处理网络地址转换，人们可能仍然需要弥补其他人的错误配置。常见的错误配置是允许非可路由地址的流量进入互联网。由于来自非可路由地址的流量可能参与多种拒绝服务攻击技术，建议通过外部接口明确地阻止非可路由地址的流量进入网络。</p>
</div>
<div class="paragraph">
<p>在这个例子中，定义了一个包含非可路由地址的宏，然后在阻止规则中使用。对这些地址的流量在网关的外部接口上被静默丢弃。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>martians = &#34;{ 127.0.0.0/8, 192.168.0.0/16, 172.16.0.0/12, \
	      10.0.0.0/8, 169.254.0.0/16, 192.0.2.0/24, \
	      0.0.0.0/8, 240.0.0.0/4 }&#34;

block drop in quick on $ext_if from $martians to any
block drop out quick on $ext_if from any to $martians</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_启用_altq">33.3.3. 启用 ALTQ<a class="anchor" href="#_启用_altq"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 上，可以使用 ALTQ 与 PF 一起提供服务质量（ QoS ）。一旦启用 ALTQ ，可以在规则集中定义队列，确定出站数据包的处理优先级。</p>
</div>
<div class="paragraph">
<p>在启用 ALTQ 之前，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> 以确定系统上安装的网络卡驱动程序是否支持它。</p>
</div>
<div class="paragraph">
<p>ALTQ 不可用作可加载的内核模块。如果系统的接口支持 ALTQ ，请按照 <a href="./#kernelconfig">配置 FreeBSD 内核</a> 中的说明创建自定义内核。以下内核选项可用。第一个选项用于启用 ALTQ 。其他选项中至少需要一个来指定队列调度算法：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options         ALTQ
options         ALTQ_CBQ        # Class Based Queuing (CBQ)
options         ALTQ_RED        # Random Early Detection (RED)
options         ALTQ_RIO        # RED In/Out
options         ALTQ_HFSC       # Hierarchical Packet Scheduler (HFSC)
options         ALTQ_PRIQ       # Priority Queuing (PRIQ)</pre>
</div>
</div>
<div class="paragraph">
<p>以下调度算法可用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">CBQ 是一种网络流量管理算法，用于在网络中对不同类型的流量进行优先级和带宽控制。 CBQ 代表分类优先队列，它通过将流量划分为不同的类别，并为每个类别分配带宽和优先级来实现流量管理。 CBQ 算法可以帮助网络管理员更好地管理网络流量，提高网络性能和服务质量。</dt>
<dd>
<p>基于类的排队（ CBQ ）用于将连接的带宽划分为不同的类别或队列，以根据过滤规则对流量进行优先级排序。</p>
</dd>
<dt class="hdlist1">红色</dt>
<dd>
<p>随机早期检测（ RED ）用于通过测量队列的长度并将其与队列的最小和最大阈值进行比较来避免网络拥塞。当队列超过最大阈值时，所有新的数据包将被随机丢弃。</p>
</dd>
<dt class="hdlist1">RIO</dt>
<dd>
<p>在随机早期检测输入输出（ RIO ）模式中， RED 维护多个平均队列长度和多个阈值，每个 QOS 级别对应一个阈值。</p>
</dd>
<dt class="hdlist1">HFSC 是一种网络流量调度算法，全称为 Hierarchical Fair Service Curve 。它是一种基于令牌桶算法的调度算法，用于在网络中实现公平的带宽分配。 HFSC 通过将网络流量划分为不同的类别，并为每个类别分配带宽和延迟目标，以实现对不同流量的优先级控制和公平分配。 HFSC 在计算机网络中被广泛应用，特别是在 QoS （ Quality of Service ）和流量控制方面。</dt>
<dd>
<p>层次公平服务曲线分组调度器（ HFSC ）的描述可以在 <a href="http://www-2.cs.cmu.edu/" class="bare">http://www-2.cs.cmu.edu/</a> ~ hzhang/HFSC/main.html[<a href="http://www-2.cs.cmu.edu/" class="bare">http://www-2.cs.cmu.edu/</a> ~ hzhang/HFSC/main.html] 找到。</p>
</dd>
<dt class="hdlist1">PRIQ 是一种优先级队列的数据结构，它根据元素的优先级来确定元素的顺序。优先级队列允许高优先级的元素先出队列，而低优先级的元素则后出队列。 PRIQ 通常用于解决需要按照优先级处理元素的问题，例如任务调度、事件处理等。</dt>
<dd>
<p>优先队列（ PRIQ ）始终首先传递位于较高队列中的流量。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>有关调度算法和示例规则集的更多信息，请访问 OpenBSD 的网络存档： <a href="https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html" class="bare">https://web.archive.org/web/20151109213426/http://www.openbsd.org/faq/pf/queueing.html</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="firewalls-ipfw">33.4. IPFW 是指 Internet 协议防火墙，是一种用于网络安全的技术。它可以通过过滤和监控网络流量来保护计算机和网络免受恶意攻击和未经授权的访问。 IPFW 可以根据预先定义的规则集来控制网络流量的进出，以实现对网络连接的管理和保护。它是一种常见的防火墙解决方案，被广泛应用于企业和个人网络环境中。<a class="anchor" href="#firewalls-ipfw"></a></h3>
<div class="paragraph">
<p>IPFW 是为 FreeBSD 编写的一种有状态防火墙，支持 IPv4 和 IPv6 。它由几个组件组成：内核防火墙过滤规则处理器及其集成的数据包计数功能、日志记录功能、 NAT 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> 流量整形器、转发功能、桥接功能和 ipstealth 功能。</p>
</div>
<div class="paragraph">
<p>FreeBSD 在 [/etc/rc.firewall] 中提供了一个示例规则集，该规则集定义了几种常见场景的防火墙类型，以帮助新手用户生成适当的规则集。 IPFW 提供了一个强大的语法，高级用户可以使用它来创建符合特定环境安全要求的自定义规则集。</p>
</div>
<div class="paragraph">
<p>本节介绍了如何启用 IPFW ，提供了其规则语法的概述，并演示了几个常见配置场景的规则集。</p>
</div>
<div class="sect3">
<h4 id="firewalls-ipfw-enable">33.4.1. 启用 IPFW<a class="anchor" href="#firewalls-ipfw-enable"></a></h4>
<div class="paragraph">
<p>IPFW 已经作为一个可加载的内核模块包含在基本的 FreeBSD 安装中，这意味着不需要自定义内核来启用 IPFW 。</p>
</div>
<div class="paragraph">
<p>对于那些希望将 IPFW 支持静态编译到自定义内核中的用户，请参阅 <a href="#firewalls-ipfw-kernelconfig">IPFW 内核选项</a> 。</p>
</div>
<div class="paragraph">
<p>要在启动时配置系统以启用 IPFW ，请将 <code>firewall_enable =&#34;YES&#34;</code> 添加到 <code>/etc/rc.conf</code> 文件中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc firewall_enable=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要使用 FreeBSD 提供的默认防火墙类型之一，请添加另一行来指定类型：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc firewall_type=&#34;open&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可用的类型有：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>open</code> ：允许通过所有流量。</p>
</li>
<li>
<p><code>client</code>: 仅保护本机。</p>
</li>
<li>
<p><code>simple</code> ：保护整个网络。</p>
</li>
<li>
<p><code>closed</code> ：完全禁用 IP 流量，除了回环接口之外。</p>
</li>
<li>
<p>` 工作站 ` ：使用有状态规则仅保护此计算机。</p>
</li>
<li>
<p><code>UNKNOWN</code> ：禁用防火墙规则的加载。</p>
</li>
<li>
<p><span class="filename">filename</span>: 包含防火墙规则集的文件的完整路径。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果 <code>firewall_type</code> 被设置为 <code>client</code> 或 <code>simple</code> ，请修改 <span class="filename">/etc/rc.firewall</span> 中的默认规则以适应系统的配置。</p>
</div>
<div class="paragraph">
<p>请注意， <code>filename</code> 类型用于加载自定义规则集。</p>
</div>
<div class="paragraph">
<p>加载自定义规则集的另一种方法是将 <code>firewall_script</code> 变量设置为包含 IPFW 命令的可执行脚本的绝对路径。本节中使用的示例假设 <code>firewall_script</code> 设置为 <code>/etc/ipfw.rules</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc firewall_script=&#34;/etc/ipfw.rules&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 启用日志记录，请包含以下行：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc firewall_logging=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>只有带有 <code>log</code> 选项的防火墙规则才会被记录。默认规则不包含此选项，必须手动添加。因此，建议编辑默认规则集以进行日志记录。此外，如果日志存储在单独的文件中，可能需要进行日志轮转。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>没有 <span class="filename">/etc/rc.conf</span> 变量来设置日志限制。要限制每个连接尝试中规则被记录的次数，请在 <span class="filename">/etc/sysctl.conf</span> 中使用以下行指定数字：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># echo &#34;net.inet.ip.fw.verbose_limit=5&#34; &gt;&gt; /etc/sysctl.conf</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要通过名为 <code>ipfw0</code> 的专用接口启用日志记录，请将以下行添加到 <span class="filename">/etc/rc.conf</span> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc firewall_logif=&#34;YES&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后使用 tcpdump 查看被记录的内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tcpdump -t -n -i ipfw0</span></code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>只有在附加了 tcpdump 时，才会出现由于日志记录而产生的额外开销。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>保存所需的编辑后，启动防火墙。要立即启用日志记录限制，还需设置上述 <code>sysctl</code> 值。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service ipfw start</span>
<span class="c"># sysctl net.inet.ip.fw.verbose_limit=5</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="firewalls-ipfw-rules">33.4.2. IPFW 规则语法<a class="anchor" href="#firewalls-ipfw-rules"></a></h4>
<div class="paragraph">
<p>当一个数据包进入 IPFW 防火墙时，它会与规则集中的第一条规则进行比较，并按顺序逐条进行，从上到下移动。当数据包与规则的选择参数匹配时，执行规则的动作，并终止该数据包的规则集搜索。这被称为“先中者胜”。如果数据包不匹配任何规则，则被强制 IPFW 默认规则号 65535 捕获，该规则拒绝所有数据包并将其静默丢弃。然而，如果数据包与包含 <code>count</code> 、 <code>skipto</code> 或 <code>tee</code> 关键字的规则匹配，搜索将继续进行。有关这些关键字如何影响规则处理的详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 。</p>
</div>
<div class="paragraph">
<p>创建 IPFW 规则时，关键字必须按照以下顺序编写。某些关键字是必需的，而其他关键字是可选的。大写字母表示变量，小写字母表示必须在其后出现的变量。 ` + # + ` 符号用于标记注释的开始，可以出现在规则的末尾或单独的一行上。空行将被忽略。</p>
</div>
<div class="paragraph">
<p><code><em>CMD RULE_NUMBER set SET_NUMBER ACTION log LOG_AMOUNT PROTO from SRC SRC_PORT to DST DST_PORT OPTIONS</em></code> 的中文翻译为： <code><em>CMD 规则编号设置 设置编号 动作 记录 日志数量 协议 源地址 源端口 到 目的地址 目的端口 选项</em></code></p>
</div>
<div class="paragraph">
<p>本节提供了这些关键字及其选项的概述。这不是一个详尽无遗的选项列表。有关创建 IPFW 规则时可用的规则语法的完整描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">CMD 是 Windows 操作系统中的命令行解释器。它允许用户通过键入命令来与计算机进行交互，并执行各种操作，如文件管理、进程控制和系统配置等。 CMD 提供了一系列的命令和参数，可以用于执行各种任务和操作。</dt>
<dd>
<p>每条规则都必须以 <code>ipfw add</code> 开头。</p>
</dd>
<dt class="hdlist1">规则编号</dt>
<dd>
<p>每个规则都与一个从 <code>1</code> 到 <code>65534</code> 的数字相关联。该数字用于指示规则处理的顺序。多个规则可以具有相同的数字，这种情况下它们按照添加的顺序应用。</p>
</dd>
<dt class="hdlist1">设置编号</dt>
<dd>
<p>每个规则与一个从 <code>0</code> 到 <code>31</code> 的集合编号相关联。可以单独禁用或启用集合，从而可以快速添加或删除一组规则。如果未指定 SET_NUMBER ，则规则将被添加到集合 <code>0</code> 中。</p>
</dd>
<dt class="hdlist1">行动</dt>
<dd>
<p>规则可以与以下动作之一关联。当数据包与规则的选择条件匹配时，将执行指定的动作。</p>
<div class="paragraph">
<p><code>allow | accept | pass | permit</code> ：这些关键字是等效的，允许匹配规则的数据包通过。</p>
</div>
<div class="paragraph">
<p><code>check-state</code> ：检查数据包是否与动态状态表匹配。如果找到匹配项，则执行与生成此动态规则相关联的操作，否则转到下一条规则。 <code>check-state</code> 规则没有选择条件。如果规则集中没有 <code>check-state</code> 规则，则在第一个 <code>keep-state</code> 或 <code>limit</code> 规则处检查动态规则表。</p>
</div>
<div class="paragraph">
<p><code>count</code> ：更新与规则匹配的所有数据包的计数器。搜索将继续进行下一个规则。</p>
</div>
<div class="paragraph">
<p><code>deny | drop</code> ：这两个词都表示静默丢弃与此规则匹配的数据包。</p>
</div>
<div class="paragraph">
<p>还有其他可用的操作。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 。</p>
</div>
</dd>
<dt class="hdlist1">日志数量</dt>
<dd>
<p>当一个数据包与带有 <code>log</code> 关键字的规则匹配时，将会向 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 记录一条消息，该消息的设施名称为 <code>SECURITY</code> 。只有在特定规则的记录的数据包数量不超过指定的 LOG_AMOUNT 时才会发生记录。如果没有指定 LOG_AMOUNT ，则限制值将从 <code>net.inet.ip.fw.verbose_limit</code> 的值中获取。值为零将移除记录限制。一旦达到限制，可以通过清除该规则的记录计数器或数据包计数器来重新启用记录，使用 <code>ipfw resetlog</code> 命令。</p>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在满足所有其他数据包匹配条件之后，进行日志记录，并在对数据包执行最终操作之前。管理员决定在哪些规则上启用日志记录。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</dd>
<dt class="hdlist1">PROTO</dt>
<dd>
<p>这个可选值可以用来指定在 [/etc/protocols](filename) 中找到的任何协议名称或编号。</p>
</dd>
<dt class="hdlist1">SRC 是指源代码（ Source Code ）的缩写，是计算机程序的原始形式，通常由程序员使用编程语言编写。源代码是计算机程序的一种文本形式，它包含了程序的逻辑结构和算法。通过编译或解释，源代码可以被转换成可执行文件或者在特定环境中运行。</dt>
<dd>
<p><code>from</code> 关键字后面必须跟着源地址或表示源地址的关键字。地址可以用 <code>any</code> 、 <code>me</code> （在此系统上配置的任何接口的地址）、 <code>me6</code> （在此系统上配置的任何 IPv6 地址）或 <code>table</code> 后跟包含地址列表的查找表的编号来表示。在指定 IP 地址时，可以选择性地跟着 CIDR 掩码或子网掩码。例如， <code>1.2.3.4/25</code> 或 <code>1.2.3.4:255.255.255.128</code> 。</p>
</dd>
<dt class="hdlist1">源端口</dt>
<dd>
<p>可以使用端口号或者从 [/etc/services] 中的名称来指定可选的源端口。</p>
</dd>
<dt class="hdlist1">DST 是夏令时（ Daylight Saving Time ）的缩写。</dt>
<dd>
<p><code>to</code> 关键字后面必须跟着目标地址或代表目标地址的关键字。在 SRC 部分描述的相同关键字和地址可以用来描述目标。</p>
</dd>
<dt class="hdlist1">目标端口</dt>
<dd>
<p>可以使用端口号或者从 [/etc/services] 文件中的名称来指定可选的目标端口。</p>
</dd>
<dt class="hdlist1">选项</dt>
<dd>
<p>源和目的地后面可以跟随几个关键字。顾名思义， OPTIONS 是可选的。常用的选项包括 <code>in</code> 或 <code>out</code> ，用于指定数据包流动的方向， <code>icmptypes</code> 后面跟随 ICMP 消息的类型，以及 <code>keep-state</code> 。</p>
<div class="paragraph">
<p>当匹配到 <code>keep-state</code> 规则时，防火墙将创建一个动态规则，该规则匹配源地址和目标地址以及端口之间的双向流量，使用相同的协议。</p>
</div>
<div class="paragraph">
<p>动态规则功能容易受到 SYN 洪水攻击的资源耗尽问题的影响，该攻击会打开大量的动态规则。为了使用 IPFW 来对抗这种类型的攻击，可以使用 <code>limit</code> 选项。该选项通过检查打开的动态规则，计算该规则和 IP 地址组合出现的次数，来限制同时会话的数量。如果该计数大于 <code>limit</code> 指定的值，数据包将被丢弃。</p>
</div>
<div class="paragraph">
<p>有数十种选项可供选择。有关每个可用选项的描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_示例规则集">33.4.3. 示例规则集<a class="anchor" href="#_示例规则集"></a></h4>
<div class="paragraph">
<p>本节演示了如何创建一个名为 <span class="filename">/etc/ipfw.rules</span> 的示例有状态防火墙规则脚本。在这个示例中，所有连接规则使用 <code>in</code> 或 <code>out</code> 来明确方向。它们还使用 <code>via</code> _interface-name_来指定数据包所经过的接口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在首次创建或测试防火墙规则集时，考虑临时设置此可调整项：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>net.inet.ip.fw.default_to_accept=&#34;1&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>这将将 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 的默认策略设置为比默认的 <code>deny ip from any to any</code> 更宽松，这样在重新启动后更难被系统锁定。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>防火墙脚本首先指示它是一个 Bourne shell 脚本，并清除任何现有的规则。然后它创建 <code>cmd</code> 变量，这样在每个规则的开头就不需要输入 <code>ipfw add</code> 。它还定义了 <code>pif</code> 变量，表示连接到互联网的接口的名称。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
# Flush out the list before we begin.
ipfw -q -f flush

# Set rules command prefix
cmd=&#34;ipfw -q add&#34;
pif=&#34;dc0&#34;     # interface name of NIC attached to Internet</pre>
</div>
</div>
<div class="paragraph">
<p>前两条规则允许在可信的内部接口和回环接口上的所有流量通过。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Change xl0 to LAN NIC interface name
$cmd 00005 allow all from any to any via xl0

# No restrictions on Loopback Interface
$cmd 00010 allow all from any to any via lo0</pre>
</div>
</div>
<div class="paragraph">
<p>下一个规则允许数据包通过，如果它与动态规则表中的现有条目匹配：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>$cmd 00101 check-state</pre>
</div>
</div>
<div class="paragraph">
<p>下面的规则集定义了内部系统可以与互联网上的主机建立哪些有状态连接：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Allow access to public DNS
# Replace x.x.x.x with the IP address of a public DNS server
# and repeat for each DNS server in /etc/resolv.conf
$cmd 00110 allow tcp from any to x.x.x.x 53 out via $pif setup keep-state
$cmd 00111 allow udp from any to x.x.x.x 53 out via $pif keep-state

# Allow access to ISP&#39;s DHCP server for cable/DSL configurations.
# Use the first rule and check log for IP address.
# Then, uncomment the second rule, input the IP address, and delete the first rule
$cmd 00120 allow log udp from any to any 67 out via $pif keep-state
#$cmd 00120 allow udp from any to x.x.x.x 67 out via $pif keep-state

# Allow outbound HTTP and HTTPS connections
$cmd 00200 allow tcp from any to any 80 out via $pif setup keep-state
$cmd 00220 allow tcp from any to any 443 out via $pif setup keep-state

# Allow outbound email connections
$cmd 00230 allow tcp from any to any 25 out via $pif setup keep-state
$cmd 00231 allow tcp from any to any 110 out via $pif setup keep-state

# Allow outbound ping
$cmd 00250 allow icmp from any to any out via $pif keep-state

# Allow outbound NTP
$cmd 00260 allow udp from any to any 123 out via $pif keep-state

# Allow outbound SSH
$cmd 00280 allow tcp from any to any 22 out via $pif setup keep-state

# deny and log all other outbound connections
$cmd 00299 deny log all from any to any out via $pif</pre>
</div>
</div>
<div class="paragraph">
<p>下一组规则控制来自互联网主机到内部网络的连接。它首先拒绝通常与攻击相关的数据包，然后明确允许特定类型的连接。所有从互联网发起的授权服务都使用“ limit ”来防止洪水攻击。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Deny all inbound traffic from non-routable reserved address spaces
$cmd 00300 deny all from 192.168.0.0/16 to any in via $pif     #RFC 1918 private IP
$cmd 00301 deny all from 172.16.0.0/12 to any in via $pif      #RFC 1918 private IP
$cmd 00302 deny all from 10.0.0.0/8 to any in via $pif         #RFC 1918 private IP
$cmd 00303 deny all from 127.0.0.0/8 to any in via $pif        #loopback
$cmd 00304 deny all from 0.0.0.0/8 to any in via $pif          #loopback
$cmd 00305 deny all from 169.254.0.0/16 to any in via $pif     #DHCP auto-config
$cmd 00306 deny all from 192.0.2.0/24 to any in via $pif       #reserved for docs
$cmd 00307 deny all from 204.152.64.0/23 to any in via $pif    #Sun cluster interconnect
$cmd 00308 deny all from 224.0.0.0/3 to any in via $pif        #Class D &amp; E multicast

# Deny public pings
$cmd 00310 deny icmp from any to any in via $pif

# Deny ident
$cmd 00315 deny tcp from any to any 113 in via $pif

# Deny all Netbios services.
$cmd 00320 deny tcp from any to any 137 in via $pif
$cmd 00321 deny tcp from any to any 138 in via $pif
$cmd 00322 deny tcp from any to any 139 in via $pif
$cmd 00323 deny tcp from any to any 81 in via $pif

# Deny fragments
$cmd 00330 deny all from any to any frag in via $pif

# Deny ACK packets that did not match the dynamic rule table
$cmd 00332 deny tcp from any to any established in via $pif

# Allow traffic from ISP&#39;s DHCP server.
# Replace x.x.x.x with the same IP address used in rule 00120.
#$cmd 00360 allow udp from any to x.x.x.x 67 in via $pif keep-state

# Allow HTTP connections to internal web server
$cmd 00400 allow tcp from any to me 80 in via $pif setup limit src-addr 2

# Allow inbound SSH connections
$cmd 00410 allow tcp from any to me 22 in via $pif setup limit src-addr 2

# Reject and log all other incoming connections
$cmd 00499 deny log all from any to any in via $pif</pre>
</div>
</div>
<div class="paragraph">
<p>最后一条规则记录所有不符合规则集中任何规则的数据包：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Everything else is denied and logged
$cmd 00999 deny log all from any to any</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="in-kernel-nat">33.4.4. 内核级网络地址转换（ In-kernel NAT ）<a class="anchor" href="#in-kernel-nat"></a></h4>
<div class="paragraph">
<p>FreeBSD 的 IPFW 防火墙有两种 NAT 实现：用户空间实现 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 和更近期的内核 NAT 实现。两者都与 IPFW 配合工作，提供网络地址转换功能。这可以用于提供 Internet 连接共享解决方案，使多台内部计算机可以使用单个公共 IP 地址连接到互联网。</p>
</div>
<div class="paragraph">
<p>要实现这一点，连接到互联网的 FreeBSD 机器必须充当网关。该系统必须具有两个网络接口卡（ NIC ），其中一个连接到互联网，另一个连接到内部局域网（ LAN ）。连接到 LAN 的每台机器应分配一个私有网络空间中的 IP 地址，如 <a href="https://www.ietf.org/rfc/rfc1918.txt">RFC 1918</a> 所定义。</p>
</div>
<div class="paragraph">
<p>为了启用 IPFW 内核中的 NAT 功能，需要进行一些额外的配置。要在启动时启用内核中的 NAT 支持，必须在 /etc/rc.conf 文件中设置以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34;
firewall_enable=&#34;YES&#34;
firewall_nat_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当设置了 <code>firewall_nat_enable</code> 但未设置 <code>firewall_enable</code> 时，它将不会产生任何效果和作用。这是因为内核中的 NAT 实现仅与 IPFW 兼容。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>当规则集包含有状态的规则时， NAT 规则的位置至关重要，并且使用 <code>skipto</code> 操作。 <code>skipto</code> 操作需要一个规则编号，以便知道要跳转到哪个规则。下面的示例基于前一节中显示的防火墙规则集进行构建。它添加了一些额外的条目并修改了一些现有规则，以便为内核中的 NAT 配置防火墙。首先添加一些额外的变量，这些变量表示要跳转到的规则编号， <code>keep-state</code> 选项以及将用于减少规则数量的 TCP 端口列表。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#!/bin/sh
ipfw -q -f flush
cmd=&#34;ipfw -q add&#34;
skip=&#34;skipto 1000&#34;
pif=dc0
ks=&#34;keep-state&#34;
good_tcpo=&#34;22,25,37,53,80,443,110&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>使用内核级别的 NAT 时，由于 <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a> 的架构，需要禁用 TCP 分段卸载（ TSO ）， <a href="https://man.freebsd.org/cgi/man.cgi?query=libalias&amp;sektion=3&amp;format=html">libalias(3)</a> 是一个作为内核模块实现的库，用于提供 IPFW 的内核级别 NAT 功能。可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 在每个网络接口上禁用 TSO ，也可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 在整个系统上禁用 TSO 。要在整个系统上禁用 TSO ，需要在 <span class="filename">/etc/sysctl.conf</span> 中设置以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>net.inet.tcp.tso=&#34;0&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>还将配置一个 NAT 实例。可以配置多个 NAT 实例，每个实例都有自己的配置。在这个例子中，只需要一个 NAT 实例，即 NAT 实例号 1 。配置可以包括一些选项，如： <code>if</code> 表示公共接口， <code>same_ports</code> 确保别名端口和本地端口号映射相同， <code>unreg_only</code> 将只处理未注册（私有）地址空间的 NAT 实例， <code>reset</code> 将帮助保持一个正常运行的 NAT 实例，即使 IPFW 机器的公共 IP 地址发生变化。有关可以传递给单个 NAT 实例配置的所有可能选项，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 。在配置有状态的 NAT 防火墙时，需要允许将已转换的数据包重新注入防火墙进行进一步处理。可以通过在防火墙脚本的开始处禁用 <code>one_pass</code> 行为来实现这一点。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipfw disable one_pass
ipfw -q nat 1 config if $pif same_ports unreg_only reset</pre>
</div>
</div>
<div class="paragraph">
<p>入站 NAT 规则被插入在允许所有受信任和回环接口上的所有流量的两个规则之后，并且在重新组装规则之后，但在 <code>check-state</code> 规则之前。在此示例中，为此 NAT 规则选择的规则编号（例如 <code>100</code> ）比前三个规则更高，但比 <code>check-state</code> 规则更低非常重要。此外，由于内核 NAT 的行为，建议在第一个 NAT 规则之前和允许受信任接口上的流量的规则之后放置一个重新组装规则。通常情况下，不应发生 IP 分段，但在处理 IPSEC/ESP/GRE 隧道流量时可能会发生，并且在将完整数据包交给内核 NAT 设备之前需要重新组装片段。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在使用用户空间的 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 时，不需要使用 reassemble 规则，因为 IPFW 的 <code>divert</code> 动作在将数据包传递到套接字之前已经负责重新组装数据包，这也在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 中有所说明。</p>
</div>
<div class="paragraph">
<p>在这个示例中使用的 NAT 实例和规则编号与由 <span class="filename">rc.firewall</span> 创建的默认 NAT 实例和规则编号不匹配。 <span class="filename">rc.firewall</span> 是一个设置 FreeBSD 中默认防火墙规则的脚本。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>$cmd 005 allow all from any to any via xl0  # exclude LAN traffic
$cmd 010 allow all from any to any via lo0  # exclude loopback traffic
$cmd 099 reass all from any to any in       # reassemble inbound packets
$cmd 100 nat 1 ip from any to any in via $pif # NAT any inbound packets
# Allow the packet through if it has an existing entry in the dynamic rules table
$cmd 101 check-state</pre>
</div>
</div>
<div class="paragraph">
<p>出站规则已经被修改，将 <code>allow</code> 操作替换为 ` $ skip` 变量，表示规则处理将继续在规则 <code>1000</code> 处。七个 <code>tcp</code> 规则已被替换为规则 <code>125</code> ，因为 ` $ good_tcpo` 变量包含了七个允许的出站端口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>请记住， IPFW 的性能主要取决于规则集中存在的规则数量。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Authorized outbound packets
$cmd 120 $skip udp from any to x.x.x.x 53 out via $pif $ks
$cmd 121 $skip udp from any to x.x.x.x 67 out via $pif $ks
$cmd 125 $skip tcp from any to any $good_tcpo out via $pif setup $ks
$cmd 130 $skip icmp from any to any out via $pif $ks</pre>
</div>
</div>
<div class="paragraph">
<p>入站规则保持不变，除了最后一条规则，它移除了 <code>via $ pif</code> ，以便捕获入站和出站规则。 NAT 规则必须跟随这个最后的出站规则，规则号必须比最后一条规则的号码更高，并且规则号必须被 <code>skipto</code> 动作引用。在这个规则集中，规则号为 <code>1000</code> 的规则处理将所有数据包传递给我们配置的实例进行 NAT 处理。下一条规则允许经过 NAT 处理的任何数据包通过。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>$cmd 999 deny log all from any to any
$cmd 1000 nat 1 ip from any to any out via $pif # skipto location for outbound stateful rules
$cmd 1001 allow ip from any to any</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，规则 <code>100</code> 、 <code>101</code> 、 <code>125</code> 、 <code>1000</code> 和 <code>1001</code> 控制出站和入站数据包的地址转换，以便动态状态表中的条目始终注册私有 LANIP 地址。</p>
</div>
<div class="paragraph">
<p>考虑一个内部的网络浏览器，它通过 80 端口初始化一个新的出站 HTTP 会话。当第一个出站数据包进入防火墙时，它不匹配规则 <code>100</code> ，因为它是向外而不是向内的。它通过规则 <code>101</code> ，因为这是第一个数据包，并且尚未被添加到动态状态表中。该数据包最终匹配规则 <code>125</code> ，因为它是在允许的端口上进行出站，并且具有来自内部局域网的源 IP 地址。匹配此规则后，会执行两个操作。首先， <code>keep-state</code> 操作将一个条目添加到动态状态表中，并执行指定的操作 <code>skipto rule 1000</code> 。接下来，数据包经过 NAT 处理并发送到互联网。该数据包到达目标 Web 服务器，生成并发送一个响应数据包。这个新的数据包进入规则集的顶部。它匹配规则 <code>100</code> ，并将其目标 IP 地址映射回原始的内部地址。然后，它经过 <code>check-state</code> 规则的处理，在表中被识别为一个现有的会话，并被释放到局域网。</p>
</div>
<div class="paragraph">
<p>在入站方面，规则集必须拒绝恶意数据包，并仅允许授权的服务。与入站规则匹配的数据包将被发布到动态状态表，并将数据包释放到局域网。作为响应生成的数据包被 <code>check-state</code> 规则识别为属于现有会话。然后，它将被发送到规则 <code>1000</code> 进行网络地址转换（ NAT ），然后释放到出站接口。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>从用户空间的 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 过渡到内核级别的 NAT 可能一开始看起来是无缝的，但有一个小问题。当使用 GENERIC 内核时，当在 /etc/rc.conf 中启用 firewall_nat_enable 时， IPFW 将加载 libalias.ko 内核模块。 libalias.ko 内核模块只提供基本的 NAT 功能，而用户空间实现的 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 在其用户空间库中提供了所有的 NAT 功能，无需任何额外配置。所有功能都指的是以下内核模块，除了标准的 libalias.ko 内核模块之外，还可以在需要时额外加载： alias_ftp.ko 、 alias_bbt.ko 、 skinny.ko 、 irc.ko 、 alias_pptp.ko 和 alias_smedia.ko ，使用 /etc/rc.conf 中的 kld_list 指令。如果使用自定义内核，可以使用 options LIBALIAS 将用户空间库的全部功能编译到内核中。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect4">
<h5 id="_端口重定向">33.4.4.1. 端口重定向<a class="anchor" href="#_端口重定向"></a></h5>
<div class="paragraph">
<p>NAT 的一般缺点是 LAN 客户端无法从互联网访问。 LAN 上的客户端可以向外部建立连接，但无法接收传入连接。如果尝试在 LAN 客户端机器上运行互联网服务，这将带来问题。一个简单的解决方法是将 NAT 提供机器上的选定互联网端口重定向到 LAN 客户端。</p>
</div>
<div class="paragraph">
<p>例如， IRC 服务器运行在客户端 <code>A</code> 上，而 Web 服务器运行在客户端 <code>B</code> 上。为了使其正常工作，必须将接收到的 6667 端口（ IRC ）和 80 端口（ HTTP ）的连接重定向到相应的机器上。</p>
</div>
<div class="paragraph">
<p>使用内核级别的 NAT ，所有配置都在 NAT 实例配置中完成。要查看内核级别 NAT 实例可以使用的所有选项，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 。 IPFW 的语法遵循 natd 的语法。 <code>redirect_port</code> 的语法如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>redirect_port proto targetIP:targetPORT[-targetPORT]
  [aliasIP:]aliasPORT[-aliasPORT]
  [remoteIP[:remotePORT[-remotePORT]]]</pre>
</div>
</div>
<div class="paragraph">
<p>要配置上述示例设置，参数应为：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_port tcp 192.168.0.3:80 80</pre>
</div>
</div>
<div class="paragraph">
<p>在上述规则集中将这些参数添加到 NAT 实例 1 的配置后， TCP 端口将被端口转发到运行 IRC 和 HTTP 服务的局域网客户机。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipfw -q nat 1 config if $pif same_ports unreg_only reset \
  redirect_port tcp 192.168.0.2:6667 6667 \
  redirect_port tcp 192.168.0.3:80 80</pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code>redirect_port</code> 指示端口范围而不是单个端口。例如，<em>tcp 192.168.0.2:2000-3000 2000-3000</em> 将会将所有在端口 2000 到 3000 上接收到的连接重定向到客户端 <code>A</code> 上的端口 2000 到 3000 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_地址重定向">33.4.4.2. 地址重定向<a class="anchor" href="#_地址重定向"></a></h5>
<div class="paragraph">
<p>如果有多个 IP 地址可用，地址重定向非常有用。每个局域网客户端可以通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 分配自己的外部 IP 地址，然后 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 将重写来自局域网客户端的出站数据包，使用正确的外部 IP 地址，并将所有进入特定 IP 地址的流量重定向回特定的局域网客户端。这也被称为静态 NAT 。例如，如果可用的 IP 地址为 <code>128.1.1.1</code> 、 <code>128.1.1.2</code> 和 <code>128.1.1.3</code> ，则 <code>128.1.1.1</code> 可以用作 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 机器的外部 IP 地址，而 <code>128.1.1.2</code> 和 <code>128.1.1.3</code> 则被转发回局域网客户端 <code>A</code> 和 <code>B</code> 。</p>
</div>
<div class="paragraph">
<p><code>redirect_addr</code> 的语法如下，其中 <code>localIP</code> 是局域网客户端的内部 IP 地址， <code>publicIP</code> 是与局域网客户端对应的外部 IP 地址。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>redirect_addr localIP publicIP</pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，参数将被读取为：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>redirect_addr 192.168.0.2 128.1.1.2
redirect_addr 192.168.0.3 128.1.1.3</pre>
</div>
</div>
<div class="paragraph">
<p>与 <code>redirect_port</code> 类似，这些参数也被放置在 NAT 实例配置中。通过地址重定向，不需要进行端口重定向，因为所有接收到的特定 IP 地址的数据都会被重定向。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 机器上的外部 IP 地址必须处于活动状态，并且必须与外部接口进行别名设置。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> 。</p>
</div>
</div>
<div class="sect4">
<h5 id="_用户空间_nat">33.4.4.3. 用户空间 NAT<a class="anchor" href="#_用户空间_nat"></a></h5>
<div class="paragraph">
<p>让我们从一个陈述开始：用户空间的 NAT 实现： <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> ，比内核中的 NAT 有更多的开销。为了让 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 翻译数据包，数据包必须从内核复制到用户空间，然后再返回，这带来了额外的开销，而内核中的 NAT 则没有这种开销。</p>
</div>
<div class="paragraph">
<p>要在启动时启用用户空间 NAT 守护进程 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> ，以下是在文件 <span class="filename">/etc/rc.conf</span> 中的最小配置。其中， <code>natd_interface</code> 设置为连接到互联网的网卡的名称。 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 的 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc&amp;sektion=8&amp;format=html">rc(8)</a> 脚本将自动检查是否使用动态 IP 地址，并配置自身以处理该地址。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34;
natd_enable=&#34;YES&#34;
natd_interface=&#34;rl0&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>通常情况下，上述内核 NAT 的规则集也可以与 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 一起使用。唯一的例外是内核 NAT 实例的配置 <code>(ipfw -q nat 1 config …​)</code> ，与重组规则 99 一起不需要，因为其功能已包含在 <code>divert</code> 操作中。规则编号 100 和 1000 需要稍作修改，如下所示。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>$cmd 100 divert natd ip from any to any in via $pif
$cmd 1000 divert natd ip from any to any out via $pif</pre>
</div>
</div>
<div class="paragraph">
<p>要配置端口或地址重定向，使用与内核 NAT 相似的语法。然而，现在，与内核 NAT 不同，我们不再在规则集脚本中指定配置，而是最好在配置文件中配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 。为了做到这一点，必须通过 <span class="filename">/etc/rc.conf</span> 传递一个额外的标志，指定配置文件的路径。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>natd_flags=&#34;-f /etc/natd.conf&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>指定的文件必须包含一行一个的配置选项列表。有关配置文件和可能的变量的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=natd&amp;sektion=8&amp;format=html">natd(8)</a> 。以下是两个示例条目，每行一个：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>redirect_port tcp 192.168.0.2:6667 6667
redirect_addr 192.168.0.3 128.1.1.3</pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect3">
<h4 id="firewalls-ipfw-cmd">33.4.5. IPFW 命令<a class="anchor" href="#firewalls-ipfw-cmd"></a></h4>
<div class="paragraph">
<p><code>ipfw</code> 可以在防火墙运行时手动添加或删除单个规则。使用这种方法的问题是，当系统重新启动时，所有更改都会丢失。建议将所有规则写入一个文件，并在启动时使用该文件加载规则，并在该文件更改时替换当前运行的防火墙规则。</p>
</div>
<div class="paragraph">
<p><code>ipfw</code> 是一种将运行中的防火墙规则显示到控制台屏幕的有用方法。 IPFW 计费功能会为每个规则动态创建一个计数器，用于计算与规则匹配的每个数据包。在测试规则的过程中，列出规则及其计数器是确定规则是否按预期工作的一种方式。</p>
</div>
<div class="paragraph">
<p>列出所有正在运行的规则的顺序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw list</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>列出所有正在运行的规则，并显示规则最后匹配的时间戳：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw -t list</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>下一个示例列出了匹配规则的会计信息和数据包计数，以及规则本身。第一列是规则编号，其后是匹配的数据包和字节数，然后是规则本身。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw -a list</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>除了静态规则外，列出动态规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw -d list</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了显示已过期的动态规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw -d -e list</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将计数器归零：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw zero</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>将编号为_NUM_的规则的计数器清零：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw zero NUM</span></code></pre>
</div>
</div>
<div class="sect4">
<h5 id="_记录防火墙消息">33.4.5.1. 记录防火墙消息<a class="anchor" href="#_记录防火墙消息"></a></h5>
<div class="paragraph">
<p>即使启用了日志功能， IPFW 也不会自动生成任何规则日志。防火墙管理员决定哪些规则将被记录，并在这些规则中添加&#34;log&#34;关键字。通常只有拒绝规则会被记录。习惯上，在规则集中将“ ipfw default deny everything ”规则复制一份，并在最后一条规则中包含&#34;log&#34;关键字。这样，就可以查看所有未匹配规则集中任何规则的数据包。</p>
</div>
<div class="paragraph">
<p>日志记录是一把双刃剑。如果不小心处理，过多的日志数据或者 DoS 攻击可能会填满磁盘的日志文件。日志消息不仅会被写入 syslogd ，还会显示在根控制台屏幕上，很快就会变得令人讨厌。</p>
</div>
<div class="paragraph">
<p><code>IPFIREWALL_VERBOSE_LIMIT = 5</code> 内核选项限制了发送给 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 的连续消息数量，这些消息涉及给定规则的数据包匹配。当内核中启用了这个选项时，关于特定规则的连续消息数量被限制在指定的数量上。 200 条相同的日志消息并没有什么好处。当这个选项设置为五时，关于特定规则的五条连续消息将被记录到 syslogd 中，其余相同的连续消息将被计数并以类似以下的短语发布到 syslogd 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>last message repeated 45 times</pre>
</div>
</div>
<div class="paragraph">
<p>所有已记录的数据包消息默认写入到 <span class="filename">/var/log/security</span> ，该路径在 <span class="filename">/etc/syslog.conf</span> 中定义。</p>
</div>
</div>
<div class="sect4">
<h5 id="firewalls-ipfw-rules-script">33.4.5.2. 构建规则脚本<a class="anchor" href="#firewalls-ipfw-rules-script"></a></h5>
<div class="paragraph">
<p>大多数经验丰富的 IPFW 用户会创建一个包含规则的文件，并以与脚本运行兼容的方式编码它们。这样做的主要好处是防火墙规则可以批量刷新，而无需重新启动系统来激活它们。这种方法在测试新规则时非常方便，因为可以根据需要执行该过程多次。作为脚本，可以使用符号替换来将常用值替换为多个规则中的值。</p>
</div>
<div class="paragraph">
<p>这个示例脚本与 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> shells 使用的语法兼容。符号替换字段以美元符号 ($) 为前缀。符号字段没有$前缀。用于填充符号字段的值必须用双引号 (&#34;&#34;) 括起来。</p>
</div>
<div class="paragraph">
<p>像这样开始规则文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>############### start of example ipfw rules script #############
#
ipfw -q -f flush       # Delete all rules
# Set defaults
oif=&#34;tun0&#34;             # out interface
odns=&#34;192.0.2.11&#34;      # ISP&#39;s DNS server IP address
cmd=&#34;ipfw -q add &#34;     # build rule prefix
ks=&#34;keep-state&#34;        # just too lazy to key this each time
$cmd 00500 check-state
$cmd 00502 deny all from any to any frag
$cmd 00501 deny tcp from any to any established
$cmd 00600 allow tcp from any to any 80 out via $oif setup $ks
$cmd 00610 allow tcp from any to $odns 53 out via $oif setup $ks
$cmd 00611 allow udp from any to $odns 53 out via $oif $ks
################### End of example ipfw rules script ############</pre>
</div>
</div>
<div class="paragraph">
<p>规则并不重要，因为这个例子的重点是如何填充符号替换字段。</p>
</div>
<div class="paragraph">
<p>如果上面的示例位于 <span class="filename">/etc/ipfw.rules</span> 文件中，则可以使用以下命令重新加载规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sh /etc/ipfw.rules</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><span class="filename">/etc/ipfw.rules</span> 可以位于任何位置，文件的名称也可以是任意的。</p>
</div>
<div class="paragraph">
<p>通过手动运行这些命令也可以实现相同的效果：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipfw -q -f flush</span>
<span class="c"># ipfw -q add check-state</span>
<span class="c"># ipfw -q add deny all from any to any frag</span>
<span class="c"># ipfw -q add deny tcp from any to any established</span>
<span class="c"># ipfw -q add allow tcp from any to any 80 out via tun0 setup keep-state</span>
<span class="c"># ipfw -q add allow tcp from any to 192.0.2.11 53 out via tun0 setup keep-state</span>
<span class="c"># ipfw -q add 00611 allow udp from any to 192.0.2.11 53 out via tun0 keep-state</span></code></pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="firewalls-ipfw-kernelconfig">33.4.6. IPFW 内核选项<a class="anchor" href="#firewalls-ipfw-kernelconfig"></a></h4>
<div class="paragraph">
<p>为了将 IPFW 支持静态编译到自定义内核中，请参考 <a href="./#kernelconfig ，配置 FreeBSD 内核"></a> 中的说明。以下选项可用于自定义内核配置文件：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options    IPFIREWALL			# enables IPFW
options    IPFIREWALL_VERBOSE		# enables logging for rules with log keyword to syslogd(8)
options    IPFIREWALL_VERBOSE_LIMIT=5	# limits number of logged packets per-entry
options    IPFIREWALL_DEFAULT_TO_ACCEPT # sets default policy to pass what is not explicitly denied
options    IPFIREWALL_NAT		# enables basic in-kernel NAT support
options    LIBALIAS			# enables full in-kernel NAT support
options    IPFIREWALL_NAT64		# enables in-kernel NAT64 support
options    IPFIREWALL_NPTV6		# enables in-kernel IPv6 NPT support
options    IPFIREWALL_PMOD		# enables protocols modification module support
options    IPDIVERT			# enables NAT through natd(8)</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>IPFW 可以作为内核模块加载：上述选项默认情况下被构建为模块，或者可以在运行时使用可调节参数进行设置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="firewalls-ipf">33.5. IPFILTER （ IPF ）<a class="anchor" href="#firewalls-ipf"></a></h3>
<div class="paragraph">
<p>IPFILTER ，也称为 IPF ，是一个跨平台的开源防火墙，已经移植到多个操作系统，包括 FreeBSD 、 NetBSD 、 OpenBSD 和 Solaris™ 。</p>
</div>
<div class="paragraph">
<p>IPFILTER 是一个位于内核的防火墙和 NAT 机制，可以由用户空间程序进行控制和监控。可以使用 ipf 设置或删除防火墙规则，使用 ipnat 设置或删除 NAT 规则，使用 ipfstat 打印 IPFILTER 内核部分的运行时统计信息，并可以使用 ipmon 将 IPFILTER 的操作记录到系统日志文件中。</p>
</div>
<div class="paragraph">
<p>IPF 最初使用“最后匹配规则获胜”的规则处理逻辑，并且只使用无状态规则。此后， IPF 已经进行了增强，包括了 <code>quick</code> 和 <code>keep state</code> 选项。</p>
</div>
<div class="paragraph">
<p>IPF FAQ 位于 <a href="http://www.phildev.net/ipf/index.html">http://www.phildev.net/ipf/index.html</a> 。 IPFilter 邮件列表的可搜索存档可在 <a href="http://marc.info/" class="bare">http://marc.info/</a> ? l = ipfilter[<a href="http://marc.info/" class="bare">http://marc.info/</a> ? l = ipfilter] 上找到。</p>
</div>
<div class="paragraph">
<p>本手册的这一部分重点介绍了与 FreeBSD 相关的 IPF 。它提供了包含 <code>quick</code> 和 <code>keep state</code> 选项的规则示例。</p>
</div>
<div class="sect3">
<h4 id="_启用_ipf">33.5.1. 启用 IPF<a class="anchor" href="#_启用_ipf"></a></h4>
<div class="paragraph">
<p>IPF 被包含在基本的 FreeBSD 安装中作为一个可加载的内核模块，这意味着不需要自定义内核来启用 IPF 。</p>
</div>
<div class="paragraph">
<p>对于喜欢将 IPF 支持静态编译到自定义内核中的用户，请参考 <a href="./#kernelconfig">配置 FreeBSD 内核</a> 中的说明。以下内核选项可用：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options IPFILTER
options IPFILTER_LOG
options IPFILTER_LOOKUP
options IPFILTER_DEFAULT_BLOCK</pre>
</div>
</div>
<div class="paragraph">
<p><code>options IPFILTER</code> 启用对 IPFILTER 的支持， <code>options IPFILTER_LOG</code> 启用使用 <span class="filename">ipl</span> 伪设备进行 IPF 日志记录，对于每个带有 <code>log</code> 关键字的规则， <code>IPFILTER_LOOKUP</code> 启用 IP 池以加快 IP 查找速度，而 <code>options IPFILTER_DEFAULT_BLOCK</code> 更改默认行为，使得任何不符合防火墙 <code>pass</code> 规则的数据包都被阻止。</p>
</div>
<div class="paragraph">
<p>要在启动时配置系统以启用 IPF ，请将以下条目添加到 [/etc/rc.conf] 文件中。这些条目还将启用日志记录和“ default pass all ”。要将默认策略更改为“ block all ”而无需编译自定义内核，请记住在规则集的末尾添加一个“ block all ”规则。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipfilter_enable=&#34;YES&#34;             # Start ipf firewall
ipfilter_rules=&#34;/etc/ipf.rules&#34;   # loads rules definition text file
ipv6_ipfilter_rules=&#34;/etc/ipf6.rules&#34; # loads rules definition text file for IPv6
ipmon_enable=&#34;YES&#34;                # Start IP monitor log
ipmon_flags=&#34;-Ds&#34;                 # D = start as daemon
                                  # s = log to syslog
                                  # v = log tcp window, ack, seq
                                  # n = map IP &amp; port to names</pre>
</div>
</div>
<div class="paragraph">
<p>如果需要 NAT 功能，还需要添加以下行：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34;              # Enable as LAN gateway
ipnat_enable=&#34;YES&#34;                # Start ipnat function
ipnat_rules=&#34;/etc/ipnat.rules&#34;    # rules definition file for ipnat</pre>
</div>
</div>
<div class="paragraph">
<p>然后，现在开始启动 IPF ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>#  service ipfilter start</pre>
</div>
</div>
<div class="paragraph">
<p>要加载防火墙规则，请使用 <code>ipf</code> 指定规则集文件的名称。可以使用以下命令替换当前运行的防火墙规则：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipf -Fa -f /etc/ipf.rules</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-Fa</code> 选项会清空所有内部规则表， <code>-f</code> 选项用于指定包含要加载的规则的文件。</p>
</div>
<div class="paragraph">
<p>这提供了对自定义规则集进行更改并使用最新的规则副本更新正在运行的防火墙的能力，而无需重新启动系统。这种方法对于测试新规则非常方便，因为可以根据需要执行该过程多次。</p>
</div>
<div class="paragraph">
<p>有关此命令可用的其他标志的详细信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=8&amp;format=html">ipf(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ipf_规则语法">33.5.2. IPF 规则语法<a class="anchor" href="#_ipf_规则语法"></a></h4>
<div class="paragraph">
<p>本节描述了用于创建有状态规则的 IPF 规则语法。在创建规则时，请记住，除非规则中出现了 <code>quick</code> 关键字，否则每个规则都会按顺序读取，应用的是_最后匹配的规则_。这意味着，即使第一个匹配数据包的规则是 <code>pass</code> ，如果后面有一个匹配的规则是 <code>block</code> ，数据包将被丢弃。示例规则集可以在 <span class="filename">/usr/share/examples/ipfilter</span> 中找到。</p>
</div>
<div class="paragraph">
<p>创建规则时，使用 <code>#</code> 字符来标记注释的开始，并且可以出现在规则的末尾，以解释该规则的功能，或者独占一行。任何空行都会被忽略。</p>
</div>
<div class="paragraph">
<p>在规则中使用的关键字必须按照特定的顺序从左到右进行编写。一些关键字是必需的，而其他一些是可选的。一些关键字具有子选项，这些子选项可能是关键字本身，并且还可以包含更多的子选项。关键字的顺序如下所示，其中大写字母表示变量，小写字母表示必须在其后面的变量之前出现的关键字：</p>
</div>
<div class="paragraph">
<p><code><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG | ICMP_TYPE keep state STATE</em></code> 的中文翻译如下： <code><em>ACTION DIRECTION OPTIONS proto PROTO_TYPE from SRC_ADDR SRC_PORT to DST_ADDR DST_PORT TCP_FLAG | ICMP_TYPE keep state STATE</em></code></p>
</div>
<div class="paragraph">
<p>本节描述了每个关键字及其选项。这不是一个详尽无遗的选项列表。有关在创建 IPF 规则和使用每个关键字的示例时可以使用的规则语法的完整描述，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> 。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">行动</dt>
<dd>
<p>action 关键字指示如果数据包与该规则匹配，应该采取什么操作。每个规则都 <strong> 必须 </strong> 有一个动作。以下动作被识别：</p>
<div class="paragraph">
<p><code>block</code> ：丢弃该数据包。</p>
</div>
<div class="paragraph">
<p><code>pass</code> ：允许数据包通过。</p>
</div>
<div class="paragraph">
<p><code>log</code> ：生成一条日志记录。</p>
</div>
<div class="paragraph">
<p><code>count</code> ：计算数据包和字节数的数量，可以提供规则使用频率的指示。</p>
</div>
<div class="paragraph">
<p><code>auth</code> ：将数据包排队，以便由另一个程序进一步处理。</p>
</div>
<div class="paragraph">
<p><code>call</code> ：提供对内置于 IPF 中的函数的访问，允许执行更复杂的操作。</p>
</div>
<div class="paragraph">
<p><code>decapsulate</code> ：移除任何头部以便处理数据包的内容。</p>
</div>
</dd>
<dt class="hdlist1">方向</dt>
<dd>
<p>接下来，每个规则必须明确指定流量的方向，使用以下关键字之一：</p>
<div class="paragraph">
<p><code>in</code> ：规则应用于入站数据包。</p>
</div>
<div class="paragraph">
<p><code>out</code>: 规则应用于出站数据包。</p>
</div>
<div class="paragraph">
<p><code>all</code>: 规则适用于任何方向。</p>
</div>
<div class="paragraph">
<p>如果系统有多个接口，可以在指定方向时同时指定接口。一个例子是 <code>in on fxp0</code> 。</p>
</div>
</dd>
<dt class="hdlist1">选项</dt>
<dd>
<p>选项是可选的。然而，如果指定了多个选项，则必须按照这里显示的顺序使用。</p>
<div class="paragraph">
<p><code>log</code> ：在执行指定的操作时，数据包头部的内容将被写入到 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipl&amp;sektion=4&amp;format=html">ipl(4)</a> 数据包日志伪设备中。</p>
</div>
<div class="paragraph">
<p><code>quick</code>: 如果一个数据包符合这个规则，那么规则指定的操作将会执行，并且对于这个数据包，不会再进行任何后续规则的处理。</p>
</div>
<div class="paragraph">
<p><code>on</code> ：必须跟随着 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a></code> 中显示的接口名称。只有当数据包通过指定的接口以指定的方向传输时，规则才会匹配。</p>
</div>
<div class="paragraph">
<p>使用 <code>log</code> 关键字时，可以按照以下顺序使用以下限定词：</p>
</div>
<div class="paragraph">
<p><code>body</code> ：表示在报文头部之后，将记录报文内容的前 128 个字节。</p>
</div>
<div class="paragraph">
<p><code>first</code> ：如果 <code>log</code> 关键字与 <code>keep state</code> 选项一起使用，建议使用此选项，以便仅记录触发的数据包，而不是与状态连接匹配的每个数据包。</p>
</div>
<div class="paragraph">
<p>还有其他选项可用于指定错误返回消息。有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> 。</p>
</div>
</dd>
<dt class="hdlist1">PROTO_TYPE 的中文翻译是&#34;原型&#34;。</dt>
<dd>
<p>协议类型是可选的。然而，如果规则需要指定 SRC_PORT 或 DST_PORT ，则协议类型是必需的，因为它定义了协议的类型。在指定协议类型时，使用 <code>proto</code> 关键字，后面跟着来自 [/etc/protocols](/etc/protocols) 的协议号或名称。示例协议名称包括 <code>tcp</code> 、 <code>udp</code> 或 <code>icmp</code> 。如果指定了 PROTO_TYPE ，但未指定 SRC_PORT 或 DST_PORT ，则该规则将匹配该协议的所有端口号。</p>
</dd>
<dt class="hdlist1">源地址</dt>
<dd>
<p><code>from</code> 关键字是必需的，并且后面跟着一个关键字，表示数据包的来源。来源可以是主机名、 IP 地址后跟 CIDR 掩码、地址池或关键字 <code>all</code> 。有关示例，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> 。</p>
<div class="paragraph">
<p>没有办法匹配那些不容易用点分十进制形式或掩码长度表示的 IP 地址范围。可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net-mgmt/ipcalc/">net-mgmt/ipcalc</a> 软件包或端口来简化 CIDR 掩码的计算。有关该实用程序的更多信息，请访问其网页： <a href="http://jodies.de/ipcalc">http://jodies.de/ipcalc</a> 。</p>
</div>
</dd>
<dt class="hdlist1">源端口</dt>
<dd>
<p>源端口号是可选的。但是，如果使用了源端口号，规则中必须首先定义 PROTO_TYPE 。端口号还必须在 <code>proto</code> 关键字之前。</p>
<div class="paragraph">
<p>支持多种不同的比较运算符： ` = ` （等于）， ` != ` （不等于）， <code>&lt;</code> （小于）， <code>&gt;</code> （大于）， `&lt; = ` （小于等于）和 `&gt; = ` （大于等于）。</p>
</div>
<div class="paragraph">
<p>要指定端口范围，请将两个端口号放在 <code>&lt;&gt;</code> （小于和大于）、 <code>&gt;&lt;</code> （大于和小于）或 <code>:</code> （大于或等于和小于或等于）之间。</p>
</div>
</dd>
<dt class="hdlist1">目标地址</dt>
<dd>
<p><code>to</code> 关键字是必需的，后面跟着一个关键字，表示数据包的目的地。与 SRC_ADDR 类似，它可以是主机名、 IP 地址后跟 CIDR 掩码、地址池或关键字 <code>all</code> 。</p>
</dd>
<dt class="hdlist1">目标端口</dt>
<dd>
<p>与 SRC_PORT 类似，目标端口号是可选的。然而，如果使用了目标端口号，规则中必须首先定义 PROTO_TYPE 。端口号还必须在 <code>proto</code> 关键字之前。</p>
</dd>
<dt class="hdlist1">TCP_FLAG | ICMP_TYPE</dt>
<dd>
<p>如果指定 <code>tcp</code> 作为 PROTO_TYPE ，那么可以使用字母来指定标志，其中每个字母代表用于确定连接状态的可能的 TCP 标志之一。可能的值包括： <code>S</code> （ SYN ）， <code>A</code> （ ACK ）， <code>P</code> （ PSH ）， <code>F</code> （ FIN ）， <code>U</code> （ URG ）， <code>R</code> （ RST ）， <code>C</code> （ CWN ）和 <code>E</code> （ ECN ）。</p>
<div class="paragraph">
<p>如果指定了 <code>icmp</code> 作为 PROTO_TYPE ，可以指定要匹配的 ICMP 类型。有关允许的类型，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> 。</p>
</div>
</dd>
<dt class="hdlist1">状态</dt>
<dd>
<p>如果一个 <code>pass</code> 规则包含 <code>keep state</code> ， IPF 将在其动态状态表中添加一个条目，并允许匹配连接的后续数据包。 IPF 可以跟踪 TCP 、 UDP 和 ICMP 会话的状态。任何 IPF 可以确定是活动会话的一部分的数据包，即使是不同的协议，也将被允许通过。</p>
<div class="paragraph">
<p>在 IPF 中，目标要通过连接到公共互联网的接口发送的数据包首先会与动态状态表进行匹配检查。如果数据包与活动会话对话的下一个预期数据包匹配，它将离开防火墙，并且会话对话流的状态将在动态状态表中更新。不属于已经活动会话的数据包将会与出站规则集进行检查。从连接到公共互联网的接口进入的数据包首先会与动态状态表进行匹配检查。如果数据包与活动会话的下一个预期数据包匹配，它将离开防火墙，并且会话对话流的状态将在动态状态表中更新。不属于已经活动会话的数据包将会与入站规则集进行检查。</p>
</div>
<div class="paragraph">
<p>在 <code>keep state</code> 之后可以添加几个关键字。如果使用了这些关键字，它们可以设置各种控制有状态过滤的选项，例如设置连接限制或连接时长。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> 以获取可用选项及其描述的列表。</p>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_示例规则集_2">33.5.3. 示例规则集<a class="anchor" href="#_示例规则集_2"></a></h4>
<div class="paragraph">
<p>本节演示如何创建一个示例规则集，该规则集仅允许与“ pass ”规则匹配的服务，并阻止所有其他服务。</p>
</div>
<div class="paragraph">
<p>FreeBSD 使用回环接口（ <span class="filename">lo0</span> ）和 IP 地址 <code>127.0.0.1</code> 进行内部通信。防火墙规则集必须包含允许这些内部使用的数据包自由传输的规则：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># no restrictions on loopback interface
pass in quick on lo0 all
pass out quick on lo0 all</pre>
</div>
</div>
<div class="paragraph">
<p>与互联网连接的公共接口用于授权和控制所有出站和入站连接的访问。如果一个或多个接口连接到私有网络，那些内部接口可能需要规则来允许源自局域网的数据包在内部网络之间或连接到互联网的接口之间流动。规则集应该分为三个主要部分：任何受信任的内部接口、通过公共接口的出站连接和通过公共接口的入站连接。</p>
</div>
<div class="paragraph">
<p>这两条规则允许所有流量通过一个名为 <span class="filename">xl0</span> 的受信任的局域网接口传输。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># no restrictions on inside LAN interface for private network
pass out quick on xl0 all
pass in quick on xl0 all</pre>
</div>
</div>
<div class="paragraph">
<p>公共接口的出站和入站部分的规则应该将最常匹配的规则放在不常匹配的规则之前，而该部分的最后一条规则应该阻止并记录该接口和方向的所有数据包。</p>
</div>
<div class="paragraph">
<p>这组规则定义了名为 <span class="filename">dc0</span> 的公共接口的出站部分。这些规则保持状态并标识内部系统被授权用于公共互联网访问的特定服务。所有规则都使用 <code>quick</code> 并指定适当的端口号和（如果适用）目标地址。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># interface facing Internet (outbound)
# Matches session start requests originating from or behind the
# firewall, destined for the Internet.

# Allow outbound access to public DNS servers.
# Replace x.x.x.x with address listed in /etc/resolv.conf.
# Repeat for each DNS server.
pass out quick on dc0 proto tcp from any to x.x.x.x port = 53 flags S keep state
pass out quick on dc0 proto udp from any to x.x.x.x port = 53 keep state

# Allow access to ISP&#39;s specified DHCP server for cable or DSL networks.
# Use the first rule, then check log for the IP address of DHCP server.
# Then, uncomment the second rule, replace z.z.z.z with the IP address,
# and comment out the first rule
pass out log quick on dc0 proto udp from any to any port = 67 keep state
#pass out quick on dc0 proto udp from any to z.z.z.z port = 67 keep state

# Allow HTTP and HTTPS
pass out quick on dc0 proto tcp from any to any port = 80 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 443 flags S keep state

# Allow email
pass out quick on dc0 proto tcp from any to any port = 110 flags S keep state
pass out quick on dc0 proto tcp from any to any port = 25 flags S keep state

# Allow NTP
pass out quick on dc0 proto tcp from any to any port = 37 flags S keep state

# Allow FTP
pass out quick on dc0 proto tcp from any to any port = 21 flags S keep state

# Allow SSH
pass out quick on dc0 proto tcp from any to any port = 22 flags S keep state

# Allow ping
pass out quick on dc0 proto icmp from any to any icmp-type 8 keep state

# Block and log everything else
block out log first quick on dc0 all</pre>
</div>
</div>
<div class="paragraph">
<p>公共接口入站部分的规则示例首先阻止所有不需要的数据包。这样可以减少最后一个规则记录的数据包数量。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># interface facing Internet (inbound)
# Block all inbound traffic from non-routable or reserved address spaces
block in quick on dc0 from 192.168.0.0/16 to any    #RFC 1918 private IP
block in quick on dc0 from 172.16.0.0/12 to any     #RFC 1918 private IP
block in quick on dc0 from 10.0.0.0/8 to any        #RFC 1918 private IP
block in quick on dc0 from 127.0.0.0/8 to any       #loopback
block in quick on dc0 from 0.0.0.0/8 to any         #loopback
block in quick on dc0 from 169.254.0.0/16 to any    #DHCP auto-config
block in quick on dc0 from 192.0.2.0/24 to any      #reserved for docs
block in quick on dc0 from 204.152.64.0/23 to any   #Sun cluster interconnect
block in quick on dc0 from 224.0.0.0/3 to any       #Class D &amp; E multicast

# Block fragments and too short tcp packets
block in quick on dc0 all with frags
block in quick on dc0 proto tcp all with short

# block source routed packets
block in quick on dc0 all with opt lsrr
block in quick on dc0 all with opt ssrr

# Block OS fingerprint attempts and log first occurrence
block in log first quick on dc0 proto tcp from any to any flags FUP

# Block anything with special options
block in quick on dc0 all with ipopts

# Block public pings and ident
block in quick on dc0 proto icmp all icmp-type 8
block in quick on dc0 proto tcp from any to any port = 113

# Block incoming Netbios services
block in log first quick on dc0 proto tcp/udp from any to any port = 137
block in log first quick on dc0 proto tcp/udp from any to any port = 138
block in log first quick on dc0 proto tcp/udp from any to any port = 139
block in log first quick on dc0 proto tcp/udp from any to any port = 81</pre>
</div>
</div>
<div class="paragraph">
<p>每当规则上有带有 <code>log first</code> 选项的日志消息时，运行 <code>ipfstat -hio</code> 来评估该规则被匹配的次数。大量的匹配可能表明系统正在遭受攻击。</p>
</div>
<div class="paragraph">
<p>入站部分的其余规则定义了允许从互联网发起的连接。最后一条规则拒绝了所有未在本节中明确允许的连接。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Allow traffic in from ISP&#39;s DHCP server. Replace z.z.z.z with
# the same IP address used in the outbound section.
pass in quick on dc0 proto udp from z.z.z.z to any port = 68 keep state

# Allow public connections to specified internal web server
pass in quick on dc0 proto tcp from any to x.x.x.x port = 80 flags S keep state

# Block and log only first occurrence of all remaining traffic.
block in log first quick on dc0 all</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_配置_nat">33.5.4. 配置 NAT<a class="anchor" href="#_配置_nat"></a></h4>
<div class="paragraph">
<p>要启用 NAT ，请将以下语句添加到 [/etc/rc.conf] 文件中，并指定包含 NAT 规则的文件的名称：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34;
ipnat_enable=&#34;YES&#34;
ipnat_rules=&#34;/etc/ipnat.rules&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>NAT 规则是灵活的，可以实现许多不同的功能，以满足商业和家庭用户的需求。这里介绍的规则语法已经简化，以展示常见用法。有关完整的规则语法描述，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipnat&amp;sektion=5&amp;format=html">ipnat(5)</a> 。</p>
</div>
<div class="paragraph">
<p>NAT 规则的基本语法如下所示，其中 <code>map</code> 开始规则，_IF_应替换为外部接口的名称：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>map IF LAN_IP_RANGE -&gt; PUBLIC_ADDRESS</pre>
</div>
</div>
<div class="paragraph">
<p>_LAN_IP_RANGE_是内部客户端使用的 IP 地址范围。通常情况下，它是一个私有地址范围，比如 <code>192.168.1.0/24</code> 。_PUBLIC_ADDRESS_可以是静态外部 IP 地址，也可以是关键字 <code>0/32</code> ，表示分配给_IF_的 IP 地址。</p>
</div>
<div class="paragraph">
<p>在 IPF 中，当一个数据包从局域网带有公共目的地到达防火墙时，它首先通过防火墙规则集的出站规则。然后，数据包被传递到 NAT 规则集，该规则集从上到下进行读取，第一个匹配的规则获胜。 IPF 会将每个 NAT 规则与数据包的接口名称和源 IP 地址进行测试。当数据包的接口名称与 NAT 规则匹配时，将检查数据包在私有局域网中的源 IP 地址是否落在_LAN_IP_RANGE_指定的 IP 地址范围内。如果匹配成功，数据包的源 IP 地址将被重写为_PUBLIC_ADDRESS_指定的公共 IP 地址。 IPF 会在其内部 NAT 表中发布一个条目，以便当数据包从互联网返回时，可以将其映射回原始的私有 IP 地址，然后将其传递给防火墙规则进行进一步处理。</p>
</div>
<div class="paragraph">
<p>对于拥有大量内部系统或多个子网的网络来说，将每个私有 IP 地址汇集到一个公共 IP 地址中的过程会成为一个资源问题。有两种方法可以解决这个问题。</p>
</div>
<div class="paragraph">
<p>第一种方法是分配一段端口作为源端口使用。通过添加 <code>portmap</code> 关键字，可以指示 NAT 仅使用指定范围内的源端口。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp 20000:60000</pre>
</div>
</div>
<div class="paragraph">
<p>或者，使用 <code>auto</code> 关键字，告诉 NAT 确定可用于使用的端口：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>map dc0 192.168.1.0/24 -&gt; 0/32 portmap tcp/udp auto</pre>
</div>
</div>
<div class="paragraph">
<p>第二种方法是使用一个公共地址池。当局域网地址太多无法适应单个公共地址，并且有一块公共 IP 地址可用时，这种方法非常有用。这些公共地址可以作为一个池， NAT 会从中选择一个 IP 地址，将数据包的地址映射为其外部传输时的地址。</p>
</div>
<div class="paragraph">
<p>公共 IP 地址的范围可以使用网络掩码或 CIDR 表示法来指定。这两个规则是等价的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>map dc0 192.168.1.0/24 -&gt; 204.134.75.0/255.255.255.0
map dc0 192.168.1.0/24 -&gt; 204.134.75.0/24</pre>
</div>
</div>
<div class="paragraph">
<p>常见做法是将公共可访问的 Web 服务器或邮件服务器隔离到内部网络段。这些服务器的流量仍然需要经过 NAT ，但需要进行端口重定向以将入站流量定向到正确的服务器。例如，要将使用内部地址 <code>10.0.10.25</code> 的 Web 服务器映射到其公共 IP 地址 <code>20.20.20.5</code> ，请使用以下规则：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rdr dc0 20.20.20.5/32 port 80 -&gt; 10.0.10.25 port 80</pre>
</div>
</div>
<div class="paragraph">
<p>如果它是唯一的 Web 服务器，这个规则也会起作用，因为它会将所有外部 HTTP 请求重定向到 <code>10.0.10.25</code> 。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>rdr dc0 0.0.0.0/0 port 80 -&gt; 10.0.10.25 port 80</pre>
</div>
</div>
<div class="paragraph">
<p>IPF 内置了一个可以与 NAT 一起使用的 FTP 代理。它监视所有出站流量，以检测主动或被动的 FTP 连接请求，并动态创建临时过滤规则，其中包含 FTP 数据通道使用的端口号。这样就不需要打开大范围的高阶端口来进行 FTP 连接。</p>
</div>
<div class="paragraph">
<p>在这个例子中，第一条规则调用代理来处理内部局域网的出站 FTP 流量。第二条规则将 FTP 流量从防火墙传递到互联网，第三条规则处理内部局域网的所有非 FTP 流量。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>map dc0 10.0.10.0/29 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 0.0.0.0/0 -&gt; 0/32 proxy port 21 ftp/tcp
map dc0 10.0.10.0/29 -&gt; 0/32</pre>
</div>
</div>
<div class="paragraph">
<p>FTP 的 <code>map</code> 规则在 NAT 规则之前，这样当一个数据包匹配到 FTP 规则时， FTP 代理会创建临时过滤规则，以便让 FTP 会话数据包通过并进行 NAT 。所有不是 FTP 的局域网数据包如果匹配到第三条规则，也会进行 NAT 处理。</p>
</div>
<div class="paragraph">
<p>如果没有 FTP 代理，将需要以下防火墙规则。请注意，如果没有代理，需要允许所有大于 <code>1024</code> 的端口：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Allow out LAN PC client FTP to public Internet
# Active and passive modes
pass out quick on rl0 proto tcp from any to any port = 21 flags S keep state

# Allow out passive mode data channel high order port numbers
pass out quick on rl0 proto tcp from any to any port &gt; 1024 flags S keep state

# Active mode let data channel in from FTP server
pass in quick on rl0 proto tcp from any to any port = 20 flags S keep state</pre>
</div>
</div>
<div class="paragraph">
<p>每当编辑包含 NAT 规则的文件时，运行 <code>ipnat</code> 命令并使用 <code>-CF</code> 选项来删除当前的 NAT 规则，并清空动态转换表的内容。同时，使用 <code>-f</code> 选项并指定要加载的 NAT 规则集的名称。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipnat -CF -f /etc/ipnat.rules</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>显示 NAT 统计信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipnat -s</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要列出 NAT 表的当前映射：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipnat -l</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要打开详细模式并显示与规则处理、活动规则和表项相关的信息：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ipnat -v</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_查看_ipf_统计信息">33.5.5. 查看 IPF 统计信息<a class="anchor" href="#_查看_ipf_统计信息"></a></h4>
<div class="paragraph">
<p>IPF 包括 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> ，可用于检索和显示统计信息，这些统计信息是在数据包通过防火墙时匹配规则时收集的。统计信息从上次启动防火墙或使用 <code>ipf -Z</code> 将其重置为零的上次重置以来累积。</p>
</div>
<div class="paragraph">
<p>默认的 <code>ipfstat</code> 输出如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">input packets: blocked 99286 passed 1255609 nomatch 14686 counted 0
 output packets: blocked 4200 passed 1284345 nomatch 14687 counted 0
 input packets logged: blocked 99286 passed 0
 output packets logged: blocked 0 passed 0
 packets logged: input 0 output 0
 log failures: input 3898 output 0
 fragment state<span class="o">(</span><span class="k">in</span><span class="o">)</span>: kept 0 lost 0
 fragment state<span class="o">(</span>out<span class="o">)</span>: kept 0 lost 0
 packet state<span class="o">(</span><span class="k">in</span><span class="o">)</span>: kept 169364 lost 0
 packet state<span class="o">(</span>out<span class="o">)</span>: kept 431395 lost 0
 ICMP replies: 0 TCP RSTs sent: 0
 Result cache hits<span class="o">(</span><span class="k">in</span><span class="o">)</span>: 1215208 <span class="o">(</span>out<span class="o">)</span>: 1098963
 IN Pullups succeeded: 2 failed: 0
 OUT Pullups succeeded: 0 failed: 0
 Fastroute successes: 0 failures: 0
 TCP cksum fails<span class="o">(</span><span class="k">in</span><span class="o">)</span>: 0 <span class="o">(</span>out<span class="o">)</span>: 0
 Packet log flags <span class="nb">set</span>: <span class="o">(</span>0<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>有几个选项可供选择。当使用 <code>-i</code> 参数表示入站规则，或使用 <code>-o</code> 参数表示出站规则时，该命令将检索并显示内核当前安装和使用的相应过滤规则列表。如果想要同时看到规则编号，可以加上 <code>-n</code> 参数。例如， <code>ipfstat -on</code> 将显示带有规则编号的出站规则表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">@1 pass out on xl0 from any to any
@2 block out on dc0 from any to any
@3 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre>
</div>
</div>
<div class="paragraph">
<p>在每个规则前加上匹配次数的计数，请使用 <code>-h</code> 选项。例如， <code>ipfstat -oh</code> 显示出站内部规则表，每个规则前都有它的使用次数计数。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">2451423 pass out on xl0 from any to any
354727 block out on dc0 from any to any
430918 pass out quick on dc0 proto tcp/udp from any to any keep state</code></pre>
</div>
</div>
<div class="paragraph">
<p>要以类似于 <a href="https://man.freebsd.org/cgi/man.cgi?query=top&amp;sektion=1&amp;format=html">top(1)</a> 的格式显示状态表，请使用 <code>ipfstat -t</code> 命令。当防火墙遭受攻击时，此选项可以识别和查看攻击数据包。可选的子标志提供了实时监控目标或源 IP 、端口或协议的能力。有关详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfstat&amp;sektion=8&amp;format=html">ipfstat(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ipf_logging_是一种记录和跟踪系统中发生的事件和活动的技术它可以帮助开发人员和系统管理员识别和解决问题监控系统性能并提供审计和合规性支持通过记录关键事件和错误信息_ipf_logging_可以提供有关系统运行状况的详细信息以便进行故障排除和分析它还可以帮助监控系统的安全性并提供对潜在威胁的警报和响应_ipf_logging_通常与其他监控和日志分析工具一起使用以提供全面的系统管理和监控功能">33.5.6. IPF Logging 是一种记录和跟踪系统中发生的事件和活动的技术。它可以帮助开发人员和系统管理员识别和解决问题，监控系统性能，并提供审计和合规性支持。通过记录关键事件和错误信息， IPF Logging 可以提供有关系统运行状况的详细信息，以便进行故障排除和分析。它还可以帮助监控系统的安全性，并提供对潜在威胁的警报和响应。 IPF Logging 通常与其他监控和日志分析工具一起使用，以提供全面的系统管理和监控功能。<a class="anchor" href="#_ipf_logging_是一种记录和跟踪系统中发生的事件和活动的技术它可以帮助开发人员和系统管理员识别和解决问题监控系统性能并提供审计和合规性支持通过记录关键事件和错误信息_ipf_logging_可以提供有关系统运行状况的详细信息以便进行故障排除和分析它还可以帮助监控系统的安全性并提供对潜在威胁的警报和响应_ipf_logging_通常与其他监控和日志分析工具一起使用以提供全面的系统管理和监控功能"></a></h4>
<div class="paragraph">
<p>IPF 提供了 <code>ipmon</code> 工具，可以将防火墙的日志信息以人类可读的格式写入。使用该工具需要首先按照 <a href="./#kernelconfig">配置 FreeBSD 内核</a> 中的说明，在自定义内核中添加 <code>options IPFILTER_LOG</code> 选项。</p>
</div>
<div class="paragraph">
<p>该命令通常以守护进程模式运行，以提供连续的系统日志文件，以便可以回顾过去事件的记录。由于 FreeBSD 内置了 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 设施来自动轮转系统日志，因此默认的 <span class="filename">rc.conf</span> <code>ipmon_flags</code> 语句使用了 <code>-Ds</code> 选项。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ipmon_flags=&#34;-Ds&#34; # D = start as daemon
                  # s = log to syslog
                  # v = log tcp window, ack, seq
                  # n = map IP &amp; port to names</pre>
</div>
</div>
<div class="paragraph">
<p>日志记录提供了事后审查的能力，可以查看诸如哪些数据包被丢弃、它们来自哪些地址以及它们的目的地是什么等信息。这些信息在追踪攻击者方面非常有用。</p>
</div>
<div class="paragraph">
<p>一旦在 <span class="filename">rc.conf</span> 中启用了日志记录功能，并使用 <code>service ipmon start</code> 启动后， IPF 将只记录包含 <code>log</code> 关键字的规则。防火墙管理员决定哪些规则应该被记录，通常只有拒绝规则会被记录。习惯上，在规则集中的最后一个规则中包含 <code>log</code> 关键字。这样可以查看所有未匹配规则集中任何规则的数据包。</p>
</div>
<div class="paragraph">
<p>默认情况下， <code>ipmon -Ds</code> 模式使用 <code>local0</code> 作为日志设施。以下日志级别可用于进一步分离记录的数据：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">LOG_INFO - packets logged using the <span class="s2">&#34;log&#34;</span> keyword as the action rather than pass or block.
LOG_NOTICE - packets logged which are also passed
LOG_WARNING - packets logged which are also blocked
LOG_ERR - packets which have been logged and which can be considered short due to an incomplete header</code></pre>
</div>
</div>
<div class="paragraph">
<p>为了将 IPF 设置为将所有数据记录到 [/var/log/ipfilter.log] 文件中，首先创建一个空文件：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># touch /var/log/ipfilter.log</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，要将所有记录的消息写入指定的文件，请将以下语句添加到 [/etc/syslog.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>local0.* /var/log/ipfilter.log</pre>
</div>
</div>
<div class="paragraph">
<p>要激活更改并指示 <a href="https://man.freebsd.org/cgi/man.cgi?query=syslogd&amp;sektion=8&amp;format=html">syslogd(8)</a> 读取修改后的 /etc/syslog.conf ，请运行 <code>service syslogd reload</code> 。</p>
</div>
<div class="paragraph">
<p>不要忘记编辑 <span class="filename">/etc/newsyslog.conf</span> 来轮转新的日志文件。</p>
</div>
<div class="paragraph">
<p><code>ipmon</code> 生成的消息由以空格分隔的数据字段组成。所有消息都包含以下共同字段：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>数据包接收日期。</p>
</li>
<li>
<p>数据包接收时间。格式为 HH:MM:SS.F ，表示小时、分钟、秒和秒的小数部分。</p>
</li>
<li>
<p>处理数据包的接口名称。</p>
</li>
<li>
<p>规则的组和规则编号的格式为 ` @ 0:17` 。</p>
</li>
<li>
<p>操作： <code>p</code> 表示通过， <code>b</code> 表示阻止， <code>S</code> 表示短数据包， <code>n</code> 表示未匹配任何规则， <code>L</code> 表示日志规则。</p>
</li>
<li>
<p>地址写作三个字段：源地址和端口由逗号分隔， → 符号，以及目标地址和端口。例如： <code>209.53.17.22 , 80 → 198.73.220.17 , 1722</code> 。</p>
</li>
<li>
<p>以协议名称或编号后跟 <code>PR</code> ：例如， <code>PR tcp</code> 。</p>
</li>
<li>
<p><code>len</code> 后面跟着数据包的头部长度和总长度：例如， <code>len 20 40</code> 。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>如果数据包是 TCP 数据包，则会有一个额外的字段，以连字符开头，后面跟着对应于设置的任何标志的字母。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipf&amp;sektion=5&amp;format=html">ipf(5)</a> 以获取字母和它们的标志列表。</p>
</div>
<div class="paragraph">
<p>如果数据包是一个 ICMP 数据包，那么在末尾将会有两个字段：第一个字段始终是&#34;icmp&#34;，下一个字段是 ICMP 消息和子消息类型，用斜杠分隔。例如：对于一个端口不可达的消息，表示为 <code>icmp 3/3</code> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="firewalls-blacklistd">33.6. 黑名单服务<a class="anchor" href="#firewalls-blacklistd"></a></h3>
<div class="paragraph">
<p>Blacklistd 是一个守护进程，监听套接字以接收来自其他守护进程的有关连接尝试失败或成功的通知。它最常用于阻止在开放端口上进行过多的连接尝试。一个典型的例子是在互联网上运行的 SSH 收到大量来自机器人或脚本的密码猜测和入侵尝试。使用 blacklistd ，守护进程可以通知防火墙在多次尝试后创建一个过滤规则，以阻止来自单个源的过多连接尝试。 Blacklistd 最初在 NetBSD 上开发，并在版本 7 中首次出现。 FreeBSD 11 从 NetBSD 导入了 blacklistd 。</p>
</div>
<div class="paragraph">
<p>本章介绍了如何设置和配置 blacklistd ，并提供了如何使用它的示例。读者应该熟悉基本的防火墙概念，如规则。有关详细信息，请参阅防火墙章节。示例中使用了 PF ，但在 FreeBSD 上可用的其他防火墙也应该能够与 blacklistd 一起使用。</p>
</div>
<div class="sect3">
<h4 id="_启用_blacklistd">33.6.1. 启用 Blacklistd<a class="anchor" href="#_启用_blacklistd"></a></h4>
<div class="paragraph">
<p>blacklistd 的主要配置存储在 <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> 中。还有一些命令行选项可用于更改 blacklistd 的运行时行为。重启后的持久配置应存储在 <span class="filename">/etc/blacklistd.conf</span> 中。要在系统启动时启用守护进程，请在 <span class="filename">/etc/rc.conf</span> 中添加一行 <code>blacklistd_enable</code> ，如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc blacklistd_enable=yes</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要手动启动服务，请运行以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service blacklistd start</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_创建一个_blacklistd_规则集">33.6.2. 创建一个 Blacklistd 规则集<a class="anchor" href="#_创建一个_blacklistd_规则集"></a></h4>
<div class="paragraph">
<p>黑名单规则在 <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> 中配置，每行一个条目。每个规则包含一个由空格或制表符分隔的元组。规则可以属于 <code>local</code> 或 <code>remote</code> ，分别适用于运行 blacklistd 的机器或外部来源。</p>
</div>
<div class="sect4">
<h5 id="_本地规则">33.6.2.1. 本地规则<a class="anchor" href="#_本地规则"></a></h5>
<div class="paragraph">
<p>一个本地规则的示例 blacklistd.conf 条目如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[local]
ssh             stream  *       *               *       3       24h</pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>[local]</code> 部分之后的所有规则都被视为本地规则（这是默认情况），适用于本地机器。当遇到 <code>[remote]</code> 部分时，其后的所有规则都被视为远程机器规则。</p>
</div>
<div class="paragraph">
<p>规则由七个字段组成，字段之间用制表符或空格分隔。前四个字段用于标识应该被加入黑名单的流量。接下来的三个字段定义了黑名单的行为。通配符用星号（ <code>*</code> ）表示，可以匹配该字段中的任何内容。第一个字段定义了位置，对于本地规则来说，这些是网络端口。位置字段的语法如下：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[address|interface][/mask][:port]</pre>
</div>
</div>
<div class="paragraph">
<p>地址可以以数字格式指定为 IPv4 ，也可以以方括号指定为 IPv6 。还可以使用类似“<em>em0</em>”的接口名称。</p>
</div>
<div class="paragraph">
<p>套接字类型由第二个字段定义。 TCP 套接字的类型是“ stream ”，而 UDP 则表示为“ dgram ”。上面的示例使用 TCP ，因为 SSH 正在使用该协议。</p>
</div>
<div class="paragraph">
<p>协议可以在 blacklistd 规则的第三个字段中使用。可以使用以下协议： <code>tcp</code> ， <code>udp</code> ， <code>tcp6</code> ， <code>udp6</code> 或数字。通常使用通配符（如示例中）来匹配所有协议，除非有理由通过特定协议区分流量。</p>
</div>
<div class="paragraph">
<p>在第四个字段中，定义了报告事件的守护进程的有效用户或所有者。可以在这里使用用户名或 UID ，也可以使用通配符（参见上面的示例规则）。</p>
</div>
<div class="paragraph">
<p>数据包过滤规则的名称由第五个字段声明，该字段开始规则的行为部分。默认情况下， blacklistd 将所有阻止的数据包放在名为 <code>blacklistd</code> 的 pf 锚点下，就像这样在 <span class="filename">pf.conf</span> 中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>anchor &#34;blacklistd/*&#34; in on $ext_if
block in
pass out</pre>
</div>
</div>
<div class="paragraph">
<p>对于单独的块列表，可以在此字段中使用锚点名称。在其他情况下，通配符就足够了。当名称以连字符（ <code>-</code> ）开头时，意味着应该使用带有默认规则名称前缀的锚点。使用连字符的修改示例如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ssh             stream  *       *               -ssh       3       24h</pre>
</div>
</div>
<div class="paragraph">
<p>有了这样的规则，任何新的阻止列表规则都会被添加到一个名为 <code>blacklistd-ssh</code> 的锚点中。</p>
</div>
<div class="paragraph">
<p>为了针对单个规则违规封锁整个子网，可以在规则名称中使用 <code>/</code> 。这会导致名称的剩余部分被解释为要应用于规则中指定的地址的掩码。例如，这个规则将封锁与 <code>/24</code> 相邻的每个地址。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>22              stream  tcp       *               */24    3       24h</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在这里指定正确的协议是很重要的。 IPv4 和 IPv6 对待 /24 的方式不同，这就是为什么在这个规则的第三个字段中不能使用“ * ”。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>这条规则定义了如果该网络中的任何一个主机表现不当，那么该网络上的其他所有内容也将被阻止。</p>
</div>
<div class="paragraph">
<p>第六个字段称为 <code>nfail</code> ，它设置了在特定远程 IP 被列入黑名单之前所需的登录失败次数。当在此位置使用通配符时，意味着永远不会发生阻止。在上面的示例规则中，定义了三次限制，这意味着在一次连接中尝试三次登录 SSH 后，该 IP 将被阻止。</p>
</div>
<div class="paragraph">
<p>在 blacklistd 规则定义中，最后一个字段指定了主机被加入黑名单的时间长度。默认单位是秒，但也可以使用后缀 <code>m</code> 、 <code>h</code> 和 <code>d</code> 分别指定分钟、小时和天。</p>
</div>
<div class="paragraph">
<p>整个示例规则的意思是，当通过 SSH 进行三次身份验证后，将为该主机生成一个新的 PF 阻止规则。规则匹配是通过首先按顺序检查本地规则来进行的，从最具体到最不具体。当发生匹配时，将应用“ remote ”规则，并且匹配的“ remote ”规则将更改名称、“ nfail ”和“ disable ”字段。</p>
</div>
</div>
<div class="sect4">
<h5 id="_远程规则">33.6.2.2. 远程规则<a class="anchor" href="#_远程规则"></a></h5>
<div class="paragraph">
<p>远程规则用于指定 blacklistd 根据当前评估的远程主机来改变其行为的方式。远程规则中的每个字段与本地规则中的字段相同，唯一的区别在于 blacklistd 使用它们的方式。为了解释这一点，我们使用以下示例规则：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>[remote]
203.0.113.128/25 *      *       *               =/25    =       48h</pre>
</div>
</div>
<div class="paragraph">
<p>地址字段可以是 IP 地址（ IPv4 或 IPv6 ），端口或两者兼有。这允许为特定的远程地址范围设置特殊规则，就像这个例子中一样。套接字类型、协议和所有者字段的解释与本地规则完全相同。</p>
</div>
<div class="paragraph">
<p>然而，名称字段是不同的：远程规则中的等号（ ` = ` ）告诉 blacklistd 使用匹配的本地规则的值。这意味着防火墙规则条目被采用，并添加了 <code>/25</code> 前缀（一个 <code>255.255.255.128</code> 的网络掩码）。当来自该地址范围的连接被列入黑名单时，整个子网都会受到影响。在这里也可以使用 PF 锚点名称，这样 blacklistd 将为该地址块添加到该名称的锚点的规则。当指定通配符时，将使用默认表。</p>
</div>
<div class="paragraph">
<p>可以为地址定义“ nfail ”列中的自定义失败次数。这对于特定规则的例外情况非常有用，可以允许某人对规则应用更宽松或更宽容的登录尝试。当在第六个字段中使用星号时，阻止功能将被禁用。</p>
</div>
<div class="paragraph">
<p>远程规则允许对登录尝试的限制进行更严格的执行，相比于来自本地网络（如办公室）的尝试。</p>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_黑名单客户端配置">33.6.3. 黑名单客户端配置<a class="anchor" href="#_黑名单客户端配置"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 中有几个软件包可以利用 blacklistd 的功能。其中最重要的两个是 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=sshd&amp;sektion=8&amp;format=html">sshd(8)</a> ，用于阻止过多的连接尝试。要在 SSH 守护程序中激活 blacklistd ，请将以下行添加到 <span class="filename">/etc/ssh/sshd_config</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>UseBlacklist yes</pre>
</div>
</div>
<div class="paragraph">
<p>在进行这些更改后，重新启动 sshd 以使其生效。</p>
</div>
<div class="paragraph">
<p>对于 <a href="https://man.freebsd.org/cgi/man.cgi?query=ftpd&amp;sektion=8&amp;format=html">ftpd(8)</a> 的黑名单功能已启用，可以使用 <code>-B</code> 选项，在 <span class="filename">/etc/inetd.conf</span> 文件中或者作为 <span class="filename">/etc/rc.conf</span> 文件中的一个标志来设置，如下所示：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ftpd_flags=&#34;-B&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>这就是使这些程序与 blacklistd 通信所需的全部内容。</p>
</div>
</div>
<div class="sect3">
<h4 id="_黑名单管理">33.6.4. 黑名单管理<a class="anchor" href="#_黑名单管理"></a></h4>
<div class="paragraph">
<p>Blacklistd 为用户提供了一个名为 <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistctl&amp;sektion=8&amp;format=html">blacklistctl(8)</a> 的管理工具。它显示由 <a href="https://man.freebsd.org/cgi/man.cgi?query=blacklistd.conf&amp;sektion=5&amp;format=html">blacklistd.conf(5)</a> 中定义的规则所屏蔽的地址和网络。要查看当前被屏蔽的主机列表，可以使用 <code>dump</code> 和 <code>-b</code> 组合，如下所示。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># blacklistctl dump -b</span>
      address/ma:port id      nfail   last access
213.0.123.128/25:22   OK      6/3     2019/06/08 14:30:19</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个例子显示，来自地址范围 <code>213.0.123.128/25</code> 的端口 22 上有 3 次允许的尝试中有 6 次失败。列出的尝试次数比允许的次数多，因为 SSH 允许客户端在单个 TCP 连接上尝试多次登录。正在进行中的连接不会被 blacklistd 停止。最后一次连接尝试在输出的 <code>last access</code> 列中列出。</p>
</div>
<div class="paragraph">
<p>要查看此主机在封锁列表上的剩余时间，请在上一个命令中添加 <code>-r</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># blacklistctl dump -br</span>
      address/ma:port id      nfail   remaining <span class="nb">time
</span>213.0.123.128/25:22   OK      6/3     36s</code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，还有 36 秒的时间，直到这个主机不再被阻止。</p>
</div>
</div>
<div class="sect3">
<h4 id="_从阻止列表中移除主机">33.6.5. 从阻止列表中移除主机<a class="anchor" href="#_从阻止列表中移除主机"></a></h4>
<div class="paragraph">
<p>有时候在剩余时间到期之前需要将主机从阻止列表中移除。不幸的是， blacklistd 中没有这样的功能。然而，可以使用 pfctl 将地址从 PF 表中移除。对于每个被阻止的端口，在 [/etc/pf.conf] 中的 blacklistd 锚点内定义了一个子锚点。例如，如果有一个用于阻止端口 22 的子锚点，它被称为 <code>blacklistd/22</code> 。在该子锚点内有一个包含被阻止地址的表。该表的名称是 port 加上端口号。在这个例子中，它将被称为 <code>port22</code> 。有了这些信息，现在可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=pfctl&amp;sektion=8&amp;format=html">pfctl(8)</a> 来显示所有列出的地址。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -a blacklistd/22 -t port22 -T show</span>
...
213.0.123.128/25
...</code></pre>
</div>
</div>
<div class="paragraph">
<p>在确定要从列表中解除阻止的地址之后，以下命令将其从列表中移除：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pfctl -a blacklistd/22 -t port22 -T delete 213.0.123.128/25</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>该地址现在已从 PF 中移除，但仍会显示在 blacklistctl 列表中，因为它不知道在 PF 中所做的任何更改。 blacklistd 数据库中的条目最终会过期并从其输出中删除。 如果主机再次匹配 blacklistd 中的阻止规则，则该条目将被再次添加。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="advanced-networking">Chapter 34. 高级网络<a class="anchor" href="#advanced-networking"></a></h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="advanced-networking-synopsis">34.1. 简介<a class="anchor" href="#advanced-networking-synopsis"></a></h3>
<div class="paragraph">
<p>本章涵盖了一些高级网络主题。</p>
</div>
<div class="paragraph">
<p>阅读完本章后，您将了解：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>网关和路由的基础知识。</p>
</li>
<li>
<p>如何设置 USB 网络共享。</p>
</li>
<li>
<p>如何设置 IEEE® 802.11 和 Bluetooth® 设备。</p>
</li>
<li>
<p>如何将 FreeBSD 配置为桥接模式。</p>
</li>
<li>
<p>如何设置网络 PXE 引导。</p>
</li>
<li>
<p>如何在 FreeBSD 中启用和利用 Common Address Redundancy Protocol (CARP) 的功能。</p>
</li>
<li>
<p>如何在 FreeBSD 上配置多个 VLAN 。</p>
</li>
<li>
<p>配置蓝牙耳机。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在阅读本章之前，你应该：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>了解 <span class="filename">/etc/rc</span> 脚本的基础知识。</p>
</li>
<li>
<p>熟悉基本的网络术语。</p>
</li>
<li>
<p>了解 FreeBSD 上的基本网络配置（交叉引用： network[network , FreeBSD 网络] ）。</p>
</li>
<li>
<p>了解如何配置和安装新的 FreeBSD 内核（参见： kernelconfig[kernelconfig ，配置 FreeBSD 内核] ）。</p>
</li>
<li>
<p>了解如何安装额外的第三方软件（参见：安装应用程序：软件包和端口）。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="network-routing">34.2. 网关和路由<a class="anchor" href="#network-routing"></a></h3>
<div class="paragraph">
<p><em>路由</em> 是一种机制，允许系统找到到另一个系统的网络路径。<em>路由</em> 是一对定义好的地址，表示&#34;目标&#34;和&#34;网关&#34;。路由指示当尝试到达指定的目标时，通过指定的网关发送数据包。目标有三种类型：单个主机、子网和&#34;默认&#34;。如果没有其他路由适用，将使用&#34;默认路由&#34;。网关也有三种类型：单个主机、接口（也称为链路）和以太网硬件（ MAC ）地址。已知的路由存储在路由表中。</p>
</div>
<div class="paragraph">
<p>本节提供了路由基础知识的概述。然后演示了如何将 FreeBSD 系统配置为路由器，并提供了一些故障排除技巧。</p>
</div>
<div class="sect3">
<h4 id="network-routing-default">34.2.1. 路由基础知识<a class="anchor" href="#network-routing-default"></a></h4>
<div class="paragraph">
<p>要查看 FreeBSD 系统的路由表，请使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> 命令。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>netstat -r
Routing tables

Internet:
Destination      Gateway            Flags     Refs     Use     Netif Expire
default          outside-gw         UGS        37      418       em0
localhost        localhost          UH          0      181       lo0
test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77
10.20.30.255     link#1             UHLW        1     2421
example.com      link#1             UC          0        0
host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0
host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 <span class="o">=</span>&gt;
host2.example.com link#1            UC          0        0
224              link#1             UC          0        0</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个示例中的条目如下：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">默认</dt>
<dd>
<p>这个表中的第一条路由指定了“默认”路由。当本地系统需要与远程主机建立连接时，它会检查路由表以确定是否存在已知路径。如果远程主机与表中的条目匹配，系统会检查是否可以使用该条目中指定的接口进行连接。</p>
<div class="paragraph">
<p>如果目标与任何条目都不匹配，或者所有已知路径都失败，则系统将使用默认路由的条目。对于局域网上的主机， 默认路由中的“网关”字段设置为直接连接到互联网的系统。在阅读此条目时，请验证“标志”列是否指示网关可用（ <code>UG</code> ）。</p>
</div>
<div class="paragraph">
<p>如果一台机器本身作为外部世界的网关，那么它的默认路由将是互联网服务提供商（ ISP ）的网关机器。</p>
</div>
</dd>
<dt class="hdlist1">本地主机</dt>
<dd>
<p>第二条路由是 <code>localhost</code> 路由。在 <code>Netif</code> 列中指定的接口为 <code>.filename</code><mark>lo0</mark> ，也被称为环回设备。这表示所有发送到该目的地的流量都应该是内部流量，而不是通过网络发送出去。</p>
</dd>
<dt class="hdlist1">MAC 地址</dt>
<dd>
<p>以 <code>0:e0:</code> 开头的地址是 MAC 地址。在 FreeBSD 中，它会自动识别本地以太网上的任何主机（例如 <code>test0</code> ），并在以太网接口（ <code>re0</code> ）上添加一个用于该主机的路由。这种类型的路由有一个超时时间，在 <code>Expire</code> 列中显示，如果主机在特定时间内没有响应，路由将被自动删除。这些主机是使用路由信息协议（ RIP ）进行识别的，该协议根据最短路径确定计算到本地主机的路由。</p>
</dd>
<dt class="hdlist1">子网</dt>
<dd>
<p>FreeBSD 会自动为本地子网添加子网路由。在这个例子中， <code>10.20.30.255</code> 是子网 <code>10.20.30</code> 的广播地址， <code>example.com</code> 是与该子网关联的域名。 <code>link#1</code> 表示机器上的第一个以太网卡。</p>
<div class="paragraph">
<p>本地网络主机和本地子网的路由由一个名为 <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> 的守护进程自动配置。如果该进程未运行，则只会存在由管理员静态定义的路由。</p>
</div>
</dd>
<dt class="hdlist1">主机</dt>
<dd>
<p><code>host1</code> 行是通过其以太网地址引用主机。由于它是发送主机， FreeBSD 知道要使用回环接口（ <span class="filename">lo0</span> ），而不是以太网接口。</p>
<div class="paragraph">
<p>两个 <code>host2</code> 行表示使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 创建的别名。在 <span class="filename">lo0</span> 接口之后的 ` = &gt;` 符号表示除了环回地址之外，还设置了一个别名。这样的路由只会出现在支持别名的主机上，而本地网络上的所有其他主机将会有一个 <code>link#1</code> 行用于这样的路由。</p>
</div>
</dd>
<dt class="hdlist1">224</dt>
<dd>
<p>最后一行（目标子网 <code>224</code> ）处理多播。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>每个路由的各种属性可以在“ Flags ”列中看到。 <a href="#routeflags">常见的路由表标志</a> 总结了一些这些标志及其含义：</p>
</div>
<table id="routeflags" class="tableblock frame-none grid-all stretch">
<caption class="title">表 46. 常见的路由表标志</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">标志</th>
<th class="tableblock halign-left valign-top">目的</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">U</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由已激活（上行）。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">你好！如何帮助您？</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由目的地是一个单独的主机。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">G</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">将任何东西发送到这个目的地，然后由这个网关决定从哪里发送。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">S</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">此路由是静态配置的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">C 是一种通用的编程语言，广泛用于开发各种应用程序和系统软件。它是一种高级语言，具有强大的表达能力和灵活性。 C 语言具有简洁的语法和丰富的库函数，使得开发者可以快速编写高效的代码。它还具有良好的可移植性，可以在不同的操作系统和硬件平台上运行。 C 语言在计算机科学和软件工程领域有着重要的地位，是学习和掌握计算机编程的基础。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">为机器连接克隆一个基于此路由的新路由。这种类型的路由通常用于本地网络。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">W</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">该路由是基于本地区域网络（克隆）路由进行自动配置的。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">L</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">路由涉及对以太网（链路）硬件的引用。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>在 FreeBSD 系统上，可以通过在 <code>/etc/rc.conf</code> 文件中指定默认网关的 IP 地址来定义默认路由：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>defaultrouter=&#34;10.20.30.1&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>还可以使用 <code>route</code> 命令手动添加路由：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># route add default 10.20.30.1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，手动添加的路由在重新启动后将不会保留。有关手动操作网络路由表的更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=route&amp;sektion=8&amp;format=html">route(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="network-static-routes">34.2.2. 使用静态路由配置路由器<a class="anchor" href="#network-static-routes"></a></h4>
<div class="paragraph">
<p>如果一个 FreeBSD 系统是一个双主机系统，它可以被配置为网络的默认网关或路由器。双主机系统是指至少连接在两个不同网络上的主机。通常，每个网络都连接到一个独立的网络接口，尽管可以使用 IP 别名来将多个地址绑定到一个物理接口上，每个地址位于不同的子网上。</p>
</div>
<div class="paragraph">
<p>为了使系统在接口之间转发数据包， FreeBSD 必须配置为路由器。互联网标准和良好的工程实践阻止了 FreeBSD 项目默认启用此功能，但可以通过将以下行添加到 [/etc/rc.conf] 来配置在启动时启动：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>gateway_enable=&#34;YES&#34;          # Set to YES if this host will be a gateway</pre>
</div>
</div>
<div class="paragraph">
<p>要立即启用路由功能，请将 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 变量 <code>net.inet.ip.forwarding</code> 设置为 <code>1</code> 。要停止路由功能，请将此变量重置为 <code>0</code> 。</p>
</div>
<div class="paragraph">
<p>路由器的路由表需要额外的路由，以便知道如何到达其他网络。路由可以通过手动添加静态路由或使用路由协议自动学习来添加。静态路由适用于小型网络，本节描述了如何为小型网络添加静态路由条目。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于大型网络来说，静态路由很快就变得不可扩展。 FreeBSD 附带了标准的 BSD 路由守护程序 <a href="https://man.freebsd.org/cgi/man.cgi?query=routed&amp;sektion=8&amp;format=html">routed(8)</a> ，它提供了 RIP 协议的版本 1 和 2 以及 IRDP 协议。可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/quagga/">net/quagga</a> 包或端口安装 BGP 和 OSPF 路由协议的支持。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>考虑以下网络：</p>
</div>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/advanced-networking/static-routes.png" alt="static routes"/>
</div>
</div>
<div class="paragraph">
<p>在这种情况下， <code>RouterA</code> 是一台充当互联网路由器的 FreeBSD 机器。它设置了一个默认路由到 <code>10.0.0.1</code> ，使其能够与外部世界连接。 <code>RouterB</code> 已经配置为使用 <code>192.168.1.1</code> 作为其默认网关。</p>
</div>
<div class="paragraph">
<p>在添加任何静态路由之前， <code>RouterA</code> 上的路由表如下所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>netstat -nr
Routing tables

Internet:
Destination        Gateway            Flags    Refs      Use  Netif  Expire
default            10.0.0.1           UGS         0    49378    xl0
127.0.0.1          127.0.0.1          UH          0        6    lo0
10.0.0.0/24        link#1             UC          0        0    xl0
192.168.1.0/24     link#2             UC          0        0    xl1</code></pre>
</div>
</div>
<div class="paragraph">
<p>根据当前的路由表， <code>RouterA</code> 没有到达 <code>192.168.2.0/24</code> 网络的路由。以下命令将使用 <code>192.168.1.2</code> 作为下一跳，将 <code>Internal Net 2</code> 网络添加到 <code>RouterA</code> 的路由表中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># route add -net 192.168.2.0/24 192.168.1.2</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在， <code>RouterA</code> 可以访问 <code>192.168.2.0/24</code> 网络上的任何主机。然而，如果 FreeBSD 系统重新启动，路由信息将不会持久化。如果需要静态路由持久化，将其添加到 <code>/etc/rc.conf</code> 文件中。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre># Add Internal Net 2 as a persistent static route
static_routes=&#34;internalnet2&#34;
route_internalnet2=&#34;-net 192.168.2.0/24 192.168.1.2&#34;</pre>
</div>
</div>
<div class="paragraph">
<p><code>static_routes</code> 配置变量是一个由空格分隔的字符串列表，其中每个字符串引用一个路由名称。变量 <code>route_internalnet2</code> 包含了该路由名称的静态路由。</p>
</div>
<div class="paragraph">
<p>在 <code>static_routes</code> 中使用多个字符串可以创建多个静态路由。以下是添加 <code>192.168.0.0/24</code> 和 <code>192.168.1.0/24</code> 网络的静态路由的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>static_routes=&#34;net1 net2&#34;
route_net1=&#34;-net 192.168.0.0/24 192.168.0.1&#34;
route_net2=&#34;-net 192.168.1.0/24 192.168.1.1&#34;</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="network-routing-troubleshooting">34.2.3. 故障排除<a class="anchor" href="#network-routing-troubleshooting"></a></h4>
<div class="paragraph">
<p>当一个地址空间被分配给一个网络时，服务提供商会配置他们的路由表，以便将所有网络流量发送到该站点的链路上。但是外部站点如何知道将其数据包发送到网络的 ISP 呢？</p>
</div>
<div class="paragraph">
<p>有一个系统负责跟踪所有分配的地址空间，并定义它们与互联网骨干网的连接点，即负责在国内外承载互联网流量的主干线路。每个骨干机器都有一个主表的副本，该表将特定网络的流量引导到特定的骨干运营商，然后通过服务提供商链路一直传递，直到到达特定的网络。</p>
</div>
<div class="paragraph">
<p>服务提供商的任务是向骨干站点宣传他们是连接点，从而为站点提供内部路径。这被称为路由传播。</p>
</div>
<div class="paragraph">
<p>有时候，路由传播存在问题，导致一些站点无法连接。也许最有用的用于尝试找出路由中断位置的命令是 <code>traceroute</code> 。当 <code>ping</code> 失败时，它非常有用。</p>
</div>
<div class="paragraph">
<p>使用 <code>traceroute</code> 命令时，需要指定要连接的远程主机的地址。输出结果将显示沿着尝试路径的网关主机，最终要么到达目标主机，要么因为连接不上而终止。更多信息，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=traceroute&amp;sektion=8&amp;format=html">traceroute(8)</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="network-routing-multicast">34.2.4. 多播考虑因素<a class="anchor" href="#network-routing-multicast"></a></h4>
<div class="paragraph">
<p>FreeBSD 原生支持多播应用程序和多播路由。在 FreeBSD 上运行多播应用程序不需要任何特殊配置。支持多播路由需要将以下选项编译到自定义内核中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>options MROUTING</pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/mrouted/">net/mrouted</a> 包或端口安装多播路由守护程序 mrouted 。该守护程序实现了 DVMRP 多播路由协议，并通过编辑 [/usr/local/etc/mrouted.conf] 来配置以设置隧道和 DVMRP 。安装 mrouted 还会安装 map-mbone 和 mrinfo ，以及它们的相关手册页。请参考这些手册页获取配置示例。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在许多多播安装中， DVMRP 协议大多被 PIM 协议取代。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=pim&amp;sektion=4&amp;format=html">pim(4)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="configtuning-virtual-hosts">34.3. 虚拟主机<a class="anchor" href="#configtuning-virtual-hosts"></a></h3>
<div class="paragraph">
<p>FreeBSD 的常见用途之一是虚拟站点托管，其中一个服务器在网络上表现为多个服务器。这是通过将多个网络地址分配给单个接口来实现的。</p>
</div>
<div class="paragraph">
<p>一个给定的网络接口有一个“真实”的地址，可以有任意数量的“别名”地址。这些别名通常是通过在 [/etc/rc.conf] 中添加别名条目来添加的，如下面的示例所示：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_fxp0_alias0=&#34;inet xxx.xxx.xxx.xxx netmask xxx.xxx.xxx.xxx&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>别名条目必须以 <code>alias<em>0</em></code> 开头，使用连续的数字，例如 <code>alias0</code> ， <code>alias1</code> 等等。配置过程将在第一个缺失的数字处停止。</p>
</div>
<div class="paragraph">
<p>别名网络掩码的计算非常重要。对于给定的接口，必须有一个地址能正确表示网络的网络掩码。任何其他落在该网络内的地址都必须具有全为“ 1 ”的网络掩码，可以表示为 <code>255.255.255.255</code> 或 <code>0xffffffff</code> 。</p>
</div>
<div class="paragraph">
<p>例如，考虑 <code>fxp0</code> 接口连接到两个网络的情况： <code>10.1.1.0</code> 的子网掩码为 <code>255.255.255.0</code> ， <code>202.0.75.16</code> 的子网掩码为 <code>255.255.255.240</code> 。系统需要配置为出现在范围 <code>10.1.1.1</code> 到 <code>10.1.1.5</code> 和 <code>202.0.75.17</code> 到 <code>202.0.75.20</code> 中。给定网络范围中只有第一个地址应具有真实的子网掩码。其余的地址（ <code>10.1.1.2</code> 到 <code>10.1.1.5</code> 和 <code>202.0.75.18</code> 到 <code>202.0.75.20</code> ）必须配置为子网掩码 <code>255.255.255.255</code> 。</p>
</div>
<div class="paragraph">
<p>以下是配置适配器以适应此场景的 [/etc/rc.conf](文件名) 条目：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_fxp0=&#34;inet 10.1.1.1 netmask 255.255.255.0&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias0=&#34;inet 10.1.1.2 netmask 255.255.255.255&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias1=&#34;inet 10.1.1.3 netmask 255.255.255.255&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias2=&#34;inet 10.1.1.4 netmask 255.255.255.255&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias3=&#34;inet 10.1.1.5 netmask 255.255.255.255&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias4=&#34;inet 202.0.75.17 netmask 255.255.255.240&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias5=&#34;inet 202.0.75.18 netmask 255.255.255.255&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias6=&#34;inet 202.0.75.19 netmask 255.255.255.255&#34;</span>
<span class="c"># sysrc ifconfig_fxp0_alias7=&#34;inet 202.0.75.20 netmask 255.255.255.255&#34;</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>用空格分隔的 IP 地址范围列表更简单地表达这个概念。第一个地址将使用指定的子网掩码，而其他地址将使用子网掩码 <code>255.255.255.255</code> 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sysrc ifconfig_fxp0_aliases=&#34;inet 10.1.1.1-5/24 inet 202.0.75.17-20/28&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-advanced-wireless">34.4. 无线高级认证<a class="anchor" href="#network-advanced-wireless"></a></h3>
<div class="paragraph">
<p>FreeBSD 支持多种连接无线网络的方式。本节介绍如何进行高级身份验证以连接无线网络。</p>
</div>
<div class="paragraph">
<p>要建立连接并进行基本身份验证以连接到无线网络，可以参考网络章节中的 <a href="./#wireless-authentication">Connection and Authentication to a Wireless Network</a> 部分来了解如何操作。</p>
</div>
<div class="sect3">
<h4 id="network-wireless-wpa-eap-tls">34.4.1. WPA 与 EAP-TLS<a class="anchor" href="#network-wireless-wpa-eap-tls"></a></h4>
<div class="paragraph">
<p>使用 WPA 的第二种方式是通过 802.1X 后端认证服务器。在这种情况下， WPA 被称为 WPA 企业版，以区别于较不安全的 WPA 个人版。 WPA 企业版中的认证是基于可扩展认证协议（ EAP ）的。</p>
</div>
<div class="paragraph">
<p>EAP 不带有加密方法。相反， EAP 被嵌入在一个加密隧道中。有许多 EAP 认证方法，但 EAP-TLS 、 EAP-TTLS 和 EAP-PEAP 是最常见的。</p>
</div>
<div class="paragraph">
<p>EAP 与传输层安全性（ EAP-TLS ）是一种得到广泛支持的无线认证协议，因为它是第一个被 <a href="http://www.wi-fi.org/">Wi-Fi 联盟</a> 认证的 EAP 方法。 EAP-TLS 需要三个证书来运行：安装在所有设备上的证书颁发机构（ CA ）的证书，用于认证服务器的服务器证书，以及每个无线客户端的一个客户端证书。在这种 EAP 方法中，认证服务器和无线客户端通过展示各自的证书来相互认证，然后验证这些证书是由组织的 CA 签名的。</p>
</div>
<div class="paragraph">
<p>与以前一样，配置是通过 [/etc/wpa_supplicant.conf] 进行的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;freebsdap&#34; <i class="conum" data-value="1"></i><b>(1)</b>
  proto=RSN  <i class="conum" data-value="2"></i><b>(2)</b>
  key_mgmt=WPA-EAP <i class="conum" data-value="3"></i><b>(3)</b>
  eap=TLS <i class="conum" data-value="4"></i><b>(4)</b>
  identity=&#34;loader&#34; <i class="conum" data-value="5"></i><b>(5)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class="conum" data-value="6"></i><b>(6)</b>
  client_cert=&#34;/etc/certs/clientcert.pem&#34; <i class="conum" data-value="7"></i><b>(7)</b>
  private_key=&#34;/etc/certs/clientkey.pem&#34; <i class="conum" data-value="8"></i><b>(8)</b>
  private_key_passwd=&#34;freebsdmallclient&#34; <i class="conum" data-value="9"></i><b>(9)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个字段表示网络名称（ SSID ）。 &lt;.&gt; 这个示例使用了 RSN IEEE® 802.11i 协议，也被称为 WPA2 。 &lt;.&gt; <code>key_mgmt</code> 行指定了要使用的密钥管理协议。在这个示例中，使用的是使用 EAP 认证的 WPA 。 &lt;.&gt; 这个字段表示连接的 EAP 方法。 &lt;.&gt; <code>identity</code> 字段包含了 EAP 的身份字符串。 &lt;.&gt; <code>ca_cert</code> 字段指定了 CA 证书文件的路径名。这个文件用于验证服务器证书。 &lt;.&gt; <code>client_cert</code> 行给出了客户端证书文件的路径名。这个证书是每个无线客户端的独特证书。 &lt;.&gt; <code>private_key</code> 字段是客户端证书私钥文件的路径名。 &lt;.&gt; <code>private_key_passwd</code> 字段包含了私钥的密码短语。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>然后，将以下行添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是启动界面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal <span class="k">in </span>300 seconds.
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant&amp;sektion=8&amp;format=html">wpa_supplicant(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 手动启动接口。</p>
</div>
</div>
<div class="sect3">
<h4 id="network-wireless-wpa-eap-ttls">34.4.2. WPA 与 EAP-TTLS<a class="anchor" href="#network-wireless-wpa-eap-ttls"></a></h4>
<div class="paragraph">
<p>使用 EAP-TLS ，认证服务器和客户端都需要证书。使用 EAP-TTLS ，客户端证书是可选的。这种方法类似于一个 Web 服务器，即使访问者没有客户端证书，也会创建一个安全的 SSL 隧道。 EAP-TTLS 使用加密的 TLS 隧道来安全传输认证数据。</p>
</div>
<div class="paragraph">
<p>所需的配置可以添加到 [/etc/wpa_supplicant.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=TTLS <i class="conum" data-value="1"></i><b>(1)</b>
  identity=&#34;test&#34; <i class="conum" data-value="2"></i><b>(2)</b>
  password=&#34;test&#34; <i class="conum" data-value="3"></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class="conum" data-value="4"></i><b>(4)</b>
  phase2=&#34;auth=MD5&#34; <i class="conum" data-value="5"></i><b>(5)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个字段指定了连接的 EAP 方法。 &lt;.&gt; <code>identity</code> 字段包含了在加密的 TLS 隧道内进行 EAP 身份验证的身份字符串。 &lt;.&gt; <code>password</code> 字段包含了 EAP 身份验证的密码。 &lt;.&gt; <code>ca_cert</code> 字段指示 CA 证书文件的路径名。这个文件用于验证服务器证书。 &lt;.&gt; 这个字段指定了在加密的 TLS 隧道中使用的身份验证方法。在这个例子中，使用了 EAP 和 MD5-Challenge 。&#34;内部身份验证&#34;阶段通常被称为&#34;第二阶段&#34;。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>接下来，将以下行添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一步是启动界面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal <span class="k">in </span>300 seconds.
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="network-wireless-wpa-eap-peap">34.4.3. WPA 与 EAP-PEAP<a class="anchor" href="#network-wireless-wpa-eap-peap"></a></h4>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>PEAPv0/EAP-MSCHAPv2 是最常见的 PEAP 方法。在本章中，术语 PEAP 用于指代该方法。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Protected EAP （ PEAP ）是作为 EAP-TTLS 的替代方案而设计的，在 EAP-TLS 之后是最常用的 EAP 标准。在一个混合操作系统的网络中， PEAP 应该是仅次于 EAP-TLS 的最受支持的标准。</p>
</div>
<div class="paragraph">
<p>PEAP 与 EAP-TTLS 类似，它使用服务器端证书来通过在客户端和认证服务器之间创建加密的 TLS 隧道来验证客户端，从而保护后续的认证信息交换。 PEAP 认证与 EAP-TTLS 不同之处在于，它以明文方式广播用户名，只有密码在加密的 TLS 隧道中发送。而 EAP-TTLS 将同时使用 TLS 隧道传输用户名和密码。</p>
</div>
<div class="paragraph">
<p>将以下行添加到 <span class="filename">/etc/wpa_supplicant.conf</span> 以配置 EAP-PEAP 相关设置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>network={
  ssid=&#34;freebsdap&#34;
  proto=RSN
  key_mgmt=WPA-EAP
  eap=PEAP <i class="conum" data-value="1"></i><b>(1)</b>
  identity=&#34;test&#34; <i class="conum" data-value="2"></i><b>(2)</b>
  password=&#34;test&#34; <i class="conum" data-value="3"></i><b>(3)</b>
  ca_cert=&#34;/etc/certs/cacert.pem&#34; <i class="conum" data-value="4"></i><b>(4)</b>
  phase1=&#34;peaplabel=0&#34; <i class="conum" data-value="5"></i><b>(5)</b>
  phase2=&#34;auth=MSCHAPV2&#34; <i class="conum" data-value="6"></i><b>(6)</b>
}</pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>这个字段指定了连接的 EAP 方法。 &lt;.&gt; <code>identity</code> 字段包含了在加密的 TLS 隧道内进行 EAP 认证的身份字符串。 &lt;.&gt; <code>password</code> 字段包含了 EAP 认证的密码。 &lt;.&gt; <code>ca_cert</code> 字段指示了 CA 证书文件的路径名。这个文件用于验证服务器证书。 &lt;.&gt; 这个字段包含了第一阶段认证的参数，即 TLS 隧道。根据使用的认证服务器，指定一个特定的标签进行认证。大多数情况下，标签将是&#34;client EAP encryption&#34;，可以通过使用 <code>peaplabel = 0</code> 来设置。更多信息可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=wpa_supplicant.conf&amp;sektion=5&amp;format=html">wpa_supplicant.conf(5)</a> 中找到。 &lt;.&gt; 这个字段指定了在加密的 TLS 隧道中使用的认证协议。在 PEAP 的情况下，它是 <code>auth = MSCHAPV2</code> 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>将以下内容添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA DHCP&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后，启动界面：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service netif start</span>
Starting wpa_supplicant.
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15
DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21
DHCPACK from 192.168.0.20
bound to 192.168.0.254 -- renewal <span class="k">in </span>300 seconds.
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; mtu 1500
      ether 00:11:95:d5:43:62
      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255
      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g
      status: associated
      ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF
      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan
      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS
      wme burst roaming MANUAL</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="wireless-ad-hoc-mode">34.5. 无线自组网模式<a class="anchor" href="#wireless-ad-hoc-mode"></a></h3>
<div class="paragraph">
<p>IBSS 模式，也称为自组网模式，旨在用于点对点连接。例如，要在机器 A 和 B 之间建立一个自组网，选择两个 IP 地址和一个 SSID 。</p>
</div>
<div class="paragraph">
<p>在 <code>A</code> 上：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class="c"># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap</span>
<span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class="o">(</span>2417 Mhz 11g<span class="o">)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>adhoc</code> 参数表示接口正在以 IBSS 模式运行。</p>
</div>
<div class="paragraph">
<p><code>B</code> 现在应该能够检测到 <code>A</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 wlanmode adhoc</span>
<span class="c"># ifconfig wlan0 up scan</span>
  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME</code></pre>
</div>
</div>
<div class="paragraph">
<p>输出中的 <code>I</code> 确认了 <code>A</code> 处于即席模式。现在，将 <code>B</code> 配置为不同的 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;adhoc&gt;
	  status: running
	  ssid freebsdap channel 2 <span class="o">(</span>2417 Mhz 11g<span class="o">)</span> bssid 02:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst</code></pre>
</div>
</div>
<div class="paragraph">
<p>现在， <code>A</code> 和 <code>B</code> 都准备好交换信息了。</p>
</div>
<div class="sect3">
<h4 id="network-wireless-ap">34.5.1. FreeBSD 主机访问点<a class="anchor" href="#network-wireless-ap"></a></h4>
<div class="paragraph">
<p>FreeBSD 可以充当访问点（ AP ），从而无需购买硬件 AP 或运行自组网。当 FreeBSD 机器充当网关连接到另一个网络（如互联网）时，这一点尤其有用。</p>
</div>
<div class="sect4">
<h5 id="network-wireless-ap-basic">34.5.1.1. 基本设置<a class="anchor" href="#network-wireless-ap-basic"></a></h5>
<div class="paragraph">
<p>在将 FreeBSD 机器配置为 AP 之前，必须为无线网卡配置适当的网络支持和所使用的安全协议。有关更多详细信息，请参阅 <a href="#network-wireless-basic">[network-wireless-basic]</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>目前，用于 Windows® 驱动程序的 NDIS 驱动程序包装器不支持 AP 操作。只有原生的 FreeBSD 无线驱动程序支持 AP 模式。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>一旦加载了无线网络支持，检查无线设备是否支持主机模式接入点模式，也称为 hostap 模式：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0</span>
<span class="c"># ifconfig wlan0 list caps</span>
<span class="nv">drivercaps</span><span class="o">=</span>6f85edc1&lt;STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG&gt;
<span class="nv">cryptocaps</span><span class="o">=</span>1f&lt;WEP,TKIP,AES,AES_CCM,TKIPMIC&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>此输出显示了该卡的功能。 <code>HOSTAP</code> 一词确认了该无线网卡可以充当 AP 。还列出了各种支持的加密算法： WEP 、 TKIP 和 AES 。这些信息表明可以在 AP 上使用哪些安全协议。</p>
</div>
<div class="paragraph">
<p>在创建网络伪设备时，无线设备只能被设置为 hostap 模式，因此必须先销毁先前创建的设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 destroy</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在设置其他参数之前，使用正确的选项重新生成。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 wlanmode hostap</span>
<span class="c"># ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>再次使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 命令查看 wlan0 接口的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:c3:0d:ac
	  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g &lt;hostap&gt;
	  status: running
	  ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60
	  protmode CTS wme burst dtimperiod 1 -dfs</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>hostap</code> 参数表示接口正在以基于主机的访问点模式运行。</p>
</div>
<div class="paragraph">
<p>可以通过在 <span class="filename">/etc/rc.conf</span> 文件中添加以下行来在启动时自动进行接口配置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>wlans_ath0=&#34;wlan0&#34;
create_args_wlan0=&#34;wlanmode hostap&#34;
ifconfig_wlan0=&#34;inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1&#34;</pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_无身份验证或加密的基于主机的接入点">34.5.1.2. 无身份验证或加密的基于主机的接入点<a class="anchor" href="#_无身份验证或加密的基于主机的接入点"></a></h5>
<div class="paragraph">
<p>虽然不建议在没有任何身份验证或加密的情况下运行 AP ，但这是检查 AP 是否工作的简单方法。这种配置对于调试客户端问题也很重要。</p>
</div>
<div class="paragraph">
<p>一旦配置了 AP ，从另一台无线机器上发起扫描以找到 AP ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0</span>
<span class="c"># ifconfig wlan0 up scan</span>
SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS
freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME</code></pre>
</div>
</div>
<div class="paragraph">
<p>客户端机器找到了 AP 并且可以与其关联：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap</span>
<span class="c"># ifconfig wlan0</span>
  wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	  ether 00:11:95:d5:43:62
	  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255
	  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g
	  status: associated
	  ssid freebsdap channel 1 <span class="o">(</span>2412 Mhz 11g<span class="o">)</span> bssid 00:11:95:c3:0d:ac
	  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7
	  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7
	  roam:rate 5 protmode CTS wme burst</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="network-wireless-ap-wpa">34.5.1.3. WPA2 基于主机的接入点<a class="anchor" href="#network-wireless-ap-wpa"></a></h5>
<div class="paragraph">
<p>本节重点介绍使用 WPA2 安全协议设置 FreeBSD 访问点。有关 WPA 和基于 WPA 的无线客户端配置的更多详细信息，请参阅 <a href="#network-wireless-wpa">[network-wireless-wpa]</a> 。</p>
</div>
<div class="paragraph">
<p>hostapd[8] 守护进程用于处理 WPA2 启用的访问点上的客户端身份验证和密钥管理。</p>
</div>
<div class="paragraph">
<p>在充当 AP 的 FreeBSD 机器上执行以下配置操作。一旦 AP 正确工作，可以在启动时通过在 <code>/etc/rc.conf</code> 文件中添加以下行来自动启动 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a></code> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostapd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在尝试配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> 之前，请先配置 <a href="#network-wireless-ap-basic">基本设置</a> 中介绍的基本设置。</p>
</div>
<div class="sect5">
<h6 id="_wpa2_psk_是一种_wi_fi_网络安全协议它使用预共享密钥_psk_来进行身份验证和加密">34.5.1.3.1. WPA2-PSK 是一种 Wi-Fi 网络安全协议，它使用预共享密钥（ PSK ）来进行身份验证和加密。<a class="anchor" href="#_wpa2_psk_是一种_wi_fi_网络安全协议它使用预共享密钥_psk_来进行身份验证和加密"></a></h6>
<div class="paragraph">
<p>WPA2-PSK 适用于无法或不希望使用后端认证服务器的小型网络。</p>
</div>
<div class="paragraph">
<p>配置是在 [/etc/hostapd.conf] 中完成的：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>interface=wlan0                  <i class="conum" data-value="1"></i><b>(1)</b>
debug=1                          <i class="conum" data-value="2"></i><b>(2)</b>
ctrl_interface=/var/run/hostapd  <i class="conum" data-value="3"></i><b>(3)</b>
ctrl_interface_group=wheel       <i class="conum" data-value="4"></i><b>(4)</b>
ssid=freebsdap                   <i class="conum" data-value="5"></i><b>(5)</b>
wpa=2                            <i class="conum" data-value="6"></i><b>(6)</b>
wpa_passphrase=freebsdmall       <i class="conum" data-value="7"></i><b>(7)</b>
wpa_key_mgmt=WPA-PSK             <i class="conum" data-value="8"></i><b>(8)</b>
wpa_pairwise=CCMP                <i class="conum" data-value="9"></i><b>(9)</b></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tbody><tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>用于访问点的无线接口。 &lt;.&gt; 在执行 <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> 期间使用的详细程度。值为 <code>1</code> 表示最低级别。 &lt;.&gt; <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> 用于存储与外部程序（如 <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd_cli&amp;sektion=8&amp;format=html">hostapd_cli(8)</a> ）通信的域套接字文件的路径名。在此示例中使用默认值。 &lt;.&gt; 允许访问控制接口文件的组。 &lt;.&gt; 将出现在无线扫描中的无线网络名称或 SSID 。 &lt;.&gt; 启用 WPA 并指定所需的 WPA 身份验证协议。值为 <code>2</code> 配置 AP 为 WPA2 ，推荐使用。仅在需要过时的 WPA 时设置为 <code>1</code> 。 &lt;.&gt; 用于 WPA 身份验证的 ASCII 密码。 &lt;.&gt; 要使用的密钥管理协议。此示例设置为 WPA-PSK 。 &lt;.&gt; 访问点接受的加密算法。在此示例中，仅接受 CCMP （ AES ）密码。 CCMP 是 TKIP 的替代方案，在可能的情况下强烈推荐使用。仅当有无法使用 CCMP 的设备时才应允许使用 TKIP 。</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>下一步是启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=hostapd&amp;sektion=8&amp;format=html">hostapd(8)</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service hostapd forcestart</span></code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0</span>
wlan0: <span class="nv">flags</span><span class="o">=</span>8943&lt;UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether 04:f0:21:16:8e:10
	inet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9
	nd6 <span class="nv">options</span><span class="o">=</span>21&lt;PERFORMNUD,AUTO_LINKLOCAL&gt;
	media: IEEE 802.11 Wireless Ethernet autoselect mode 11na &lt;hostap&gt;
	status: running
	ssid No5ignal channel 36 <span class="o">(</span>5180 MHz 11a ht/40+<span class="o">)</span> bssid 04:f0:21:16:8e:10
	country US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2
	AES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6
	scanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst
	dtimperiod 1 -dfs
	groups: wlan</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦 AP 运行起来，客户端就可以与其关联。更多详细信息请参见 <a href="#network-wireless-wpa">[network-wireless-wpa]</a> 。可以使用 <code>ifconfig <em>wlan0</em> list sta</code> 命令查看与 AP 关联的设备。</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-usb-tethering">34.6. USB 网络共享<a class="anchor" href="#network-usb-tethering"></a></h3>
<div class="paragraph">
<p>许多手机提供通过 USB 共享数据连接的选项（通常称为“网络共享”）。此功能使用 RNDIS 、 CDC 或自定义的 Apple® iPhone®/iPad® 协议之一。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Android™ 设备通常使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=urndis&amp;sektion=4&amp;format=html">urndis(4)</a> 驱动程序。</p>
</li>
<li>
<p>Apple® 设备使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipheth&amp;sektion=4&amp;format=html">ipheth(4)</a> 驱动程序。</p>
</li>
<li>
<p>较旧的设备通常使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=cdce&amp;sektion=4&amp;format=html">cdce(4)</a> 驱动程序。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>在连接设备之前，将适当的驱动程序加载到内核中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload if_urndis</span>
<span class="c"># kldload if_cdce</span>
<span class="c"># kldload if_ipheth</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦设备连接上， <code>ue</code><em>0</em> 将可用于像普通网络设备一样使用。请确保设备上已启用“ USB 网络共享”选项。</p>
</div>
<div class="paragraph">
<p>要使此更改永久生效并在启动时将驱动程序作为模块加载，将以下适当的行放置在 <span class="filename">/boot/loader.conf</span> 中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="nv">if_urndis_load</span><span class="o">=</span><span class="s2">&#34;YES&#34;</span>
<span class="nv">if_cdce_load</span><span class="o">=</span><span class="s2">&#34;YES&#34;</span>
<span class="nv">if_ipheth_load</span><span class="o">=</span><span class="s2">&#34;YES&#34;</span></code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-bluetooth">34.7. 蓝牙<a class="anchor" href="#network-bluetooth"></a></h3>
<div class="paragraph">
<p>蓝牙是一种无线技术，用于在 2.4 GHz 无线频段中创建个人网络，其范围为 10 米。网络通常是由便携设备（如手机、手持设备和笔记本电脑）自动形成的。与 Wi-Fi 无线技术不同，蓝牙提供更高级的服务配置文件，例如类似 FTP 的文件服务器、文件推送、语音传输、串行线仿真等。</p>
</div>
<div class="paragraph">
<p>本节描述了在 FreeBSD 系统上使用 USB 蓝牙适配器的方法。然后，它介绍了各种蓝牙协议和实用工具。</p>
</div>
<div class="sect3">
<h4 id="_加载蓝牙支持">34.7.1. 加载蓝牙支持<a class="anchor" href="#_加载蓝牙支持"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 中，蓝牙堆栈是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=netgraph&amp;sektion=4&amp;format=html">netgraph(4)</a> 框架实现的。 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> 支持各种各样的蓝牙 USB 适配器。基于 Broadcom BCM2033 的蓝牙设备由 <a href="https://man.freebsd.org/cgi/man.cgi?query=ubtbcmfw&amp;sektion=4&amp;format=html">ubtbcmfw(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> 驱动程序支持。 3Com 蓝牙 PC 卡 3CRWB60-A 由 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bt3c&amp;sektion=4&amp;format=html">ng_bt3c(4)</a> 驱动程序支持。基于串口和 UART 的蓝牙设备由 <a href="https://man.freebsd.org/cgi/man.cgi?query=sio&amp;sektion=4&amp;format=html">sio(4)</a> 、 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_h4&amp;sektion=4&amp;format=html">ng_h4(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=hcseriald&amp;sektion=8&amp;format=html">hcseriald(8)</a> 驱动程序支持。</p>
</div>
<div class="paragraph">
<p>在连接设备之前，确定设备使用的是上述驱动程序中的哪一个，然后加载该驱动程序。例如，如果设备使用的是 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_ubt&amp;sektion=4&amp;format=html">ng_ubt(4)</a> 驱动程序：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload ng_ubt</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果在系统启动期间将蓝牙设备连接到系统上，可以通过将驱动程序添加到 [/boot/loader.conf] 来配置系统在引导时加载模块。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ng_ubt_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>一旦驱动程序加载完成，插入 USB dongle 。如果驱动程序加载成功，类似以下内容的输出将出现在控制台和 [/var/log/messages] 文件中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2
ubt0: Interface 0 endpoints: <span class="nv">interrupt</span><span class="o">=</span>0x81, bulk-in<span class="o">=</span>0x82, bulk-out<span class="o">=</span>0x2
ubt0: Interface 1 <span class="o">(</span>alt.config 5<span class="o">)</span> endpoints: isoc-in<span class="o">=</span>0x83, isoc-out<span class="o">=</span>0x3,
      <span class="nv">wMaxPacketSize</span><span class="o">=</span>49, <span class="nv">nframes</span><span class="o">=</span>6, buffer <span class="nv">size</span><span class="o">=</span>294</code></pre>
</div>
</div>
<div class="paragraph">
<p>要启动和停止蓝牙堆栈，请使用其启动脚本。在拔下设备之前停止堆栈是一个好主意。启动蓝牙堆栈可能需要启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> 。启动堆栈时，输出应类似于以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service bluetooth start ubt0</span>
BD_ADDR: 00:02:72:00:d4:1a
Features: 0xff 0xff 0xf 00 00 00 00 00
<span class="gp">&lt;3-Slot&gt; </span>&lt;5-Slot&gt; &lt;Encryption&gt; &lt;Slot offset&gt;
&lt;Timing accuracy&gt; &lt;Switch&gt; &lt;Hold mode&gt; &lt;Sniff mode&gt;
&lt;Park mode&gt; &lt;RSSI&gt; &lt;Channel quality&gt; &lt;SCO link&gt;
&lt;HV2 packets&gt; &lt;HV3 packets&gt; &lt;u-law log&gt; &lt;A-law log&gt; &lt;CVSD&gt;
&lt;Paging scheme&gt; &lt;Power control&gt; &lt;Transparent SCO data&gt;
Max. ACL packet size: 192 bytes
Number of ACL packets: 8
Max. SCO packet size: 64 bytes
Number of SCO packets: 8</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_查找其他蓝牙设备">34.7.2. 查找其他蓝牙设备<a class="anchor" href="#_查找其他蓝牙设备"></a></h4>
<div class="paragraph">
<p>主机控制器接口（ HCI ）提供了一种统一的方法来访问蓝牙基带功能。在 FreeBSD 中，为每个蓝牙设备创建一个 netgraph HCI 节点。有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_hci&amp;sektion=4&amp;format=html">ng_hci(4)</a> 。</p>
</div>
<div class="paragraph">
<p>发现 RF 附近的蓝牙设备是最常见的任务之一。这个操作被称为“查询”。查询和其他 HCI 相关的操作是使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=hccontrol&amp;sektion=8&amp;format=html">hccontrol(8)</a> 完成的。下面的示例显示了如何查找在范围内的蓝牙设备。设备列表应该在几秒钟内显示出来。请注意，只有在远程设备设置为“可发现”模式时，它才会回答查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>hccontrol -n ubt0hci inquiry
Inquiry result, <span class="nv">num_responses</span><span class="o">=</span>1
Inquiry result <span class="c">#0</span>
       BD_ADDR: 00:80:37:29:19:a4
       Page Scan Rep. Mode: 0x1
       Page Scan Period Mode: 00
       Page Scan Mode: 00
       Class: 52:02:04
       Clock offset: 0x78ef
Inquiry complete. Status: No error <span class="o">[</span>00]</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>BD_ADDR</code> 是蓝牙设备的唯一地址，类似于网络卡的 MAC 地址。这个地址在与设备进行进一步通信时是必需的，并且可以为 <code>BD_ADDR</code> 分配一个可读的名称。已知的蓝牙主机的信息包含在 [/etc/bluetooth/hosts] 文件中。以下示例显示了如何获取分配给远程设备的可读名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4
BD_ADDR: 00:80:37:29:19:a4
Name: Pav<span class="s1">&#39;s T39</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>如果对远程蓝牙设备进行查询，将会以&#34;your.host.name (ubt0)&#34;的形式找到计算机。本地设备的名称可以随时更改。</p>
</div>
<div class="paragraph">
<p>远程设备可以在 [/etc/bluetooth/hosts](/etc/bluetooth/hosts) 中分配别名。有关 [/etc/bluetooth/hosts](/etc/bluetooth/hosts) 文件的更多信息可以在 <a href="https://man.freebsd.org/cgi/man.cgi?query=bluetooth.hosts&amp;sektion=5&amp;format=html">bluetooth.hosts(5)</a> 中找到。</p>
</div>
<div class="paragraph">
<p>蓝牙系统提供了两个蓝牙设备之间的点对点连接，或者在多个蓝牙设备之间共享的点对多点连接。以下示例展示了如何创建与远程设备的连接：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>hccontrol -n ubt0hci create_connection BT_ADDR</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>create_connection</code> 函数接受 <code>BT_ADDR</code> 和主机别名作为参数，在 <code>/etc/bluetooth/hosts</code> 文件中定义。</p>
</div>
<div class="paragraph">
<p>以下示例显示了如何获取本地设备的活动基带连接列表：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>hccontrol -n ubt0hci read_connection_list
Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State
00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN</code></pre>
</div>
</div>
<div class="paragraph">
<p>当需要终止基带连接时，_连接句柄_非常有用，尽管通常不需要手动执行此操作。堆栈会自动终止不活动的基带连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hccontrol -n ubt0hci disconnect 41</span>
Connection handle: 41
Reason: Connection terminated by <span class="nb">local </span>host <span class="o">[</span>0x16]</code></pre>
</div>
</div>
<div class="paragraph">
<p>输入 <code>hccontrol help</code> 以获取可用 HCI 命令的完整列表。大多数 HCI 命令不需要超级用户权限。</p>
</div>
</div>
<div class="sect3">
<h4 id="_设备配对">34.7.3. 设备配对<a class="anchor" href="#_设备配对"></a></h4>
<div class="paragraph">
<p>默认情况下，蓝牙通信不需要进行身份验证，任何设备都可以与其他设备进行通信。蓝牙设备（如手机）可以选择要求进行身份验证以提供特定服务。蓝牙身份验证通常使用一个最长为 16 个字符的 ASCII 字符串作为_PIN 码_。用户需要在两台设备上输入相同的 PIN 码。用户输入 PIN 码后，两台设备将生成一个_链接密钥_。之后，链接密钥可以存储在设备或持久存储中。下次，两台设备将使用先前生成的链接密钥。这个过程称为_配对_。请注意，如果链接密钥被任一设备丢失，配对必须重新进行。</p>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> 守护进程负责处理蓝牙认证请求。默认的配置文件是 /etc/bluetooth/hcsecd.conf 。下面是一个示例部分，其中手机的 PIN 码设置为 <code>1234</code> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device {
        bdaddr  00:80:37:29:19:a4;
        name    &#34;Pav&#39;s T39&#34;;
        key     nokey;
        pin     &#34;1234&#34;;
      }</pre>
</div>
</div>
<div class="paragraph">
<p>对于 PIN 码，唯一的限制是长度。一些设备，如蓝牙耳机，可能有一个固定的内置 PIN 码。 <code>-d</code> 开关强制 <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> 保持在前台，以便可以清楚地看到发生了什么。将远程设备设置为接收配对并启动与远程设备的蓝牙连接。远程设备应指示接受配对并请求 PIN 码。输入与 <span class="filename">hcsecd.conf</span> 中列出的相同的 PIN 码。现在计算机和远程设备已配对。或者，可以在远程设备上启动配对。</p>
</div>
<div class="paragraph">
<p>可以将以下行添加到 <span class="filename">/etc/rc.conf</span> 中，以配置 <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> 在系统启动时自动启动：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hcsecd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>以下是 <a href="https://man.freebsd.org/cgi/man.cgi?query=hcsecd&amp;sektion=8&amp;format=html">hcsecd(8)</a> 守护进程输出的示例：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hcsecd[16484]: Got Link_Key_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, link key doesn&#39;t exist
hcsecd[16484]: Sending Link_Key_Negative_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Got PIN_Code_Request event from &#39;ubt0hci&#39;, remote bdaddr 0:80:37:29:19:a4
hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name &#39;Pav&#39;s T39&#39;, PIN code exists
hcsecd[16484]: Sending PIN_Code_Reply to &#39;ubt0hci&#39; for remote bdaddr 0:80:37:29:19:a4</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_使用_ppp_配置文件的网络访问">34.7.4. 使用 PPP 配置文件的网络访问<a class="anchor" href="#_使用_ppp_配置文件的网络访问"></a></h4>
<div class="paragraph">
<p>可以使用拨号网络（ DUN ）配置文件将手机配置为无线调制解调器，以连接到拨号上网服务器。它还可以用于配置计算机接收来自手机的数据呼叫。</p>
</div>
<div class="paragraph">
<p>使用 PPP 配置文件进行网络访问可以为单个蓝牙设备或多个蓝牙设备提供局域网访问。它还可以使用 PPP 网络通过串行电缆仿真实现 PC 与 PC 之间的连接。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，这些配置文件是通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=ppp&amp;sektion=8&amp;format=html">ppp(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> 包装器实现的，该包装器将蓝牙连接转换为 PPP 可以使用的内容。在使用配置文件之前，必须在 <span class="filename">/etc/ppp/ppp.conf</span> 中创建一个新的 PPP 标签。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> 中的示例。</p>
</div>
<div class="paragraph">
<p>在这个例子中，使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> 来打开与远程设备的连接，其 <code>BD_ADDR</code> 为 <code>00:80:37:29:19:a4</code> ，在一个 DUNRFCOMM 通道上。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>实际的通道号将通过使用 SDP 协议从远程设备获取。可以手动指定 RFCOMM 通道，在这种情况下， <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> 将不执行 SDP 查询。使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> 来查找远程设备上的 RFCOMM 通道。</p>
</div>
<div class="paragraph">
<p>为了使用 PPPLAN 服务提供网络访问，必须运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> 并在 <span class="filename">/etc/ppp/ppp.conf</span> 中创建一个新的 LAN 客户端条目。请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> 中的示例。最后，在有效的 RFCOMM 通道号上启动 RFCOMMPPP 服务器。 RFCOMMPPP 服务器将自动在本地 SDP 守护进程中注册蓝牙 LAN 服务。下面的示例显示了如何启动 RFCOMMPPP 服务器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rfcomm_pppd -s -C 7 -l rfcomm-server</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_蓝牙协议">34.7.5. 蓝牙协议<a class="anchor" href="#_蓝牙协议"></a></h4>
<div class="paragraph">
<p>本节提供了各种蓝牙协议的概述，包括它们的功能和相关工具。</p>
</div>
<div class="sect4">
<h5 id="_逻辑链路控制和适配协议_l2cap">34.7.5.1. 逻辑链路控制和适配协议（ L2CAP ）<a class="anchor" href="#_逻辑链路控制和适配协议_l2cap"></a></h5>
<div class="paragraph">
<p>逻辑链路控制和适配协议（ L2CAP ）为上层协议提供面向连接和无连接的数据服务。 L2CAP 允许更高级的协议和应用程序传输和接收最长为 64 千字节的 L2CAP 数据包。</p>
</div>
<div class="paragraph">
<p>L2CAP 基于“通道”概念。通道是在基带连接之上的逻辑连接，每个通道以多对一的方式绑定到单个协议上。多个通道可以绑定到同一个协议，但一个通道不能绑定到多个协议。在通道上接收到的每个 L2CAP 数据包都会被传递给相应的高层协议。多个通道可以共享同一个基带连接。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，为每个蓝牙设备创建一个 netgraph L2CAP 节点。该节点通常连接到下游的蓝牙 HCI 节点和上游的蓝牙套接字节点。 L2CAP 节点的默认名称为&#34;devicel2cap&#34;。有关更多详细信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_l2cap&amp;sektion=4&amp;format=html">ng_l2cap(4)</a> 。</p>
</div>
<div class="paragraph">
<p>一个有用的命令是 <a href="https://man.freebsd.org/cgi/man.cgi?query=l2ping&amp;sektion=8&amp;format=html">l2ping(8)</a> ，它可以用来 ping 其他设备。一些蓝牙实现可能不会返回所有发送给它们的数据，所以在下面的示例中 <code>0 bytes</code> 是正常的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># l2ping -a 00:80:37:29:19:a4</span>
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>0 <span class="nb">time</span><span class="o">=</span>48.633 ms <span class="nv">result</span><span class="o">=</span>0
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>1 <span class="nb">time</span><span class="o">=</span>37.551 ms <span class="nv">result</span><span class="o">=</span>0
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>2 <span class="nb">time</span><span class="o">=</span>28.324 ms <span class="nv">result</span><span class="o">=</span>0
0 bytes from 0:80:37:29:19:a4 <span class="nv">seq_no</span><span class="o">=</span>3 <span class="nb">time</span><span class="o">=</span>46.150 ms <span class="nv">result</span><span class="o">=</span>0</code></pre>
</div>
</div>
<div class="paragraph">
<p><a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> 实用程序用于对 L2CAP 节点执行各种操作。此示例演示了如何获取本地设备的逻辑连接（通道）列表和基带连接列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>l2control -a 00:02:72:00:d4:1a read_channel_list
L2CAP channels:
Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State
00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN
<span class="gp">% </span>l2control -a 00:02:72:00:d4:1a read_connection_list
L2CAP connections:
Remote BD_ADDR    Handle Flags Pending State
00:07:e0:00:0b:ca     41 O           0 OPEN</code></pre>
</div>
</div>
<div class="paragraph">
<p>另一个诊断工具是 <a href="https://man.freebsd.org/cgi/man.cgi?query=btsockstat&amp;sektion=1&amp;format=html">btsockstat(1)</a> 。它类似于 <a href="https://man.freebsd.org/cgi/man.cgi?query=netstat&amp;sektion=1&amp;format=html">netstat(1)</a> ，但用于蓝牙网络相关的数据结构。下面的示例显示了与上面的 <a href="https://man.freebsd.org/cgi/man.cgi?query=l2control&amp;sektion=8&amp;format=html">l2control(8)</a> 相同的逻辑连接。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>btsockstat
Active L2CAP sockets
PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State
c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN
Active RFCOMM sessions
L2PCB    PCB      Flag MTU   Out-Q DLCs State
c2afe900 c2b53380 1    127   0     Yes  OPEN
Active RFCOMM sockets
PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State
c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN</code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_无线电频率通信_rfcomm">34.7.5.2. 无线电频率通信（ RFCOMM ）<a class="anchor" href="#_无线电频率通信_rfcomm"></a></h5>
<div class="paragraph">
<p>RFCOMM 协议通过 L2CAP 协议提供串口的仿真。 RFCOMM 是一个简单的传输协议，还提供了模拟 RS-232 （ EIATIA-232-E ）串口的 9 个电路的附加功能。它支持两个蓝牙设备之间的最多 60 个同时连接（ RFCOMM 通道）。</p>
</div>
<div class="paragraph">
<p>对于 RFCOMM 而言，一个完整的通信路径涉及到两个在通信端点上运行的应用程序，它们之间有一个通信段。 RFCOMM 旨在覆盖利用设备串口的应用程序。通信段是从一个设备直接连接到另一个设备的蓝牙链路。</p>
</div>
<div class="paragraph">
<p>RFCOMM 只关注直接连接情况下设备之间的连接，或者设备与网络情况下的调制解调器之间的连接。 RFCOMM 可以支持其他配置，例如通过蓝牙无线技术在一侧进行通信并在另一侧提供有线接口的模块。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中， RFCOMM 是在蓝牙套接字层实现的。</p>
</div>
</div>
<div class="sect4">
<h5 id="_服务发现协议_sdp">34.7.5.3. 服务发现协议（ SDP ）<a class="anchor" href="#_服务发现协议_sdp"></a></h5>
<div class="paragraph">
<p>服务发现协议（ SDP ）提供了客户端应用程序发现由服务器应用程序提供的服务的存在以及这些服务的属性的方法。服务的属性包括提供的服务类型或类别以及利用该服务所需的机制或协议信息。</p>
</div>
<div class="paragraph">
<p>SDP 涉及 SDP 服务器和 SDP 客户端之间的通信。服务器维护一个描述与服务器相关的服务特性的服务记录列表。每个服务记录包含有关单个服务的信息。客户端可以通过发出 SDP 请求从 SDP 服务器维护的服务记录中检索信息。如果客户端或与客户端相关的应用程序决定使用某个服务，则必须打开与服务提供者的单独连接以利用该服务。 SDP 提供了一种发现服务及其属性的机制，但不提供利用这些服务的机制。</p>
</div>
<div class="paragraph">
<p>通常， SDP 客户端根据服务的某些期望特征来搜索服务。然而，有时候希望在没有关于服务的任何先前信息的情况下，发现 SDP 服务器的服务记录描述了哪些类型的服务。这个寻找任何提供的服务的过程被称为“浏览”。</p>
</div>
<div class="paragraph">
<p>蓝牙 SDP 服务器（ <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> ）和命令行客户端（ <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpcontrol&amp;sektion=8&amp;format=html">sdpcontrol(8)</a> ）已包含在标准的 FreeBSD 安装中。以下示例展示了如何执行 SDP 浏览查询。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sdpcontrol -a 00:01:03:fc:6e:ec browse
Record Handle: 00000000
Service Class ID List:
        Service Discovery Server <span class="o">(</span>0x1000<span class="o">)</span>
Protocol Descriptor List:
        L2CAP <span class="o">(</span>0x0100<span class="o">)</span>
                Protocol specific parameter <span class="c">#1: u/int/uuid16 1</span>
                Protocol specific parameter <span class="c">#2: u/int/uuid16 1</span>

Record Handle: 0x00000001
Service Class ID List:
        Browse Group Descriptor <span class="o">(</span>0x1001<span class="o">)</span>

Record Handle: 0x00000002
Service Class ID List:
        LAN Access Using PPP <span class="o">(</span>0x1102<span class="o">)</span>
Protocol Descriptor List:
        L2CAP <span class="o">(</span>0x0100<span class="o">)</span>
        RFCOMM <span class="o">(</span>0x0003<span class="o">)</span>
                Protocol specific parameter <span class="c">#1: u/int8/bool 1</span>
Bluetooth Profile Descriptor List:
        LAN Access Using PPP <span class="o">(</span>0x1102<span class="o">)</span> ver. 1.0</code></pre>
</div>
</div>
<div class="paragraph">
<p>请注意，每个服务都有一系列属性，例如 RFCOMM 通道。根据服务的不同，用户可能需要注意其中一些属性。某些蓝牙实现不支持服务浏览，并可能返回一个空列表。在这种情况下，可以搜索特定的服务。下面的示例演示了如何搜索 OBEX 对象推送（ OPUSH ）服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 FreeBSD 上为蓝牙客户端提供服务是通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> 服务器完成的。可以将以下行添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>sdpd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后可以使用以下命令启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> 守护进程：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service sdpd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>希望为远程客户端提供蓝牙服务的本地服务器应用程序将在本地 SDP 守护进程中注册该服务。这样的应用程序示例是 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_pppd&amp;sektion=8&amp;format=html">rfcomm_pppd(8)</a> 。一旦启动，它将在本地 SDP 守护进程中注册蓝牙局域网服务。</p>
</div>
<div class="paragraph">
<p>可以通过在本地控制通道上发出 SDP 浏览查询来获取注册到本地 SDP 服务器的服务列表。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># sdpcontrol -l browse</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_obex_对象推送_opush">34.7.5.4. OBEX 对象推送（ OPUSH ）<a class="anchor" href="#_obex_对象推送_opush"></a></h5>
<div class="paragraph">
<p>Object Exchange （ OBEX ）是一种广泛使用的协议，用于移动设备之间的简单文件传输。它主要用于红外通信，用于笔记本电脑或个人数字助理（ PDA ）之间的通用文件传输，以及在手机和其他具有个人信息管理（ PIM ）应用程序的设备之间发送名片或日历条目。</p>
</div>
<div class="paragraph">
<p>OBEX 服务器和客户端是由 obexapp 实现的，可以使用 comms/obexapp[] 软件包或端口进行安装。</p>
</div>
<div class="paragraph">
<p>OBEX 客户端用于从 OBEX 服务器推送和 / 或拉取对象。一个示例对象可以是名片或约会。 OBEX 客户端可以通过 SDP 从远程设备获取 RFCOMM 通道号。这可以通过指定服务名称而不是 RFCOMM 通道号来完成。支持的服务名称有： <code>IrMC</code> ， <code>FTRN</code> 和 <code>OPUSH</code> 。还可以将 RFCOMM 通道指定为数字。下面是一个 OBEX 会话的示例，其中从手机中提取设备信息对象，并将一个新对象，名片，推送到手机的目录中。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>obexapp -a 00:80:37:29:19:a4 -C IrMC
<span class="gp">obex&gt; </span>get telecom/devinfo.txt devinfo-t39.txt
Success, response: OK, Success <span class="o">(</span>0x20<span class="o">)</span>
<span class="gp">obex&gt; </span>put new.vcf
Success, response: OK, Success <span class="o">(</span>0x20<span class="o">)</span>
<span class="gp">obex&gt; </span>di
Success, response: OK, Success <span class="o">(</span>0x20<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>为了提供 OPUSH 服务，必须运行 <a href="https://man.freebsd.org/cgi/man.cgi?query=sdpd&amp;sektion=8&amp;format=html">sdpd(8)</a> 并创建一个根文件夹，用于存储所有传入的对象。根文件夹的默认路径是 [/var/spool/obex] 。最后，在有效的 RFCOMM 通道号上启动 OBEX 服务器。 OBEX 服务器将自动在本地 SDP 守护进程中注册 OPUSH 服务。下面的示例显示了如何启动 OBEX 服务器。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># obexapp -s -C 10</span></code></pre>
</div>
</div>
</div>
<div class="sect4">
<h5 id="_串口配置文件_spp">34.7.5.5. 串口配置文件（ SPP ）<a class="anchor" href="#_串口配置文件_spp"></a></h5>
<div class="paragraph">
<p>串口配置文件（ SPP ）允许蓝牙设备执行串行电缆仿真。该配置文件允许传统应用程序通过虚拟串口抽象将蓝牙用作电缆替代品。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中， <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> 实现了 SPP ，并且使用伪终端作为虚拟串口抽象。下面的示例展示了如何连接到远程设备的串口服务。 <a href="https://man.freebsd.org/cgi/man.cgi?query=rfcomm_sppd&amp;sektion=1&amp;format=html">rfcomm_sppd(1)</a> 不需要指定 RFCOMM 通道，它可以通过 SDP 从远程设备获取。如果要覆盖这个行为，可以在命令行上指定一个 RFCOMM 通道。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># rfcomm_sppd -a 00:07:E0:00:0B:CA -t</span>
rfcomm_sppd[94692]: Starting on /dev/pts/6...
/dev/pts/6</code></pre>
</div>
</div>
<div class="paragraph">
<p>一旦连接成功，伪终端可以被用作串口。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cu -l /dev/pts/6</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>伪终端（ pseudo tty ）会被打印到标准输出，并可以被包装脚本读取。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`
cu -l $PTS</pre>
</div>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_故障排除_3">34.7.6. 故障排除<a class="anchor" href="#_故障排除_3"></a></h4>
<div class="paragraph">
<p>默认情况下，当 FreeBSD 接受新连接时，它会尝试执行角色切换并成为主设备。一些不支持角色切换的较旧的蓝牙设备将无法连接。由于角色切换是在建立新连接时执行的，因此无法询问远程设备是否支持角色切换。然而，有一个 HCI 选项可以在本地禁用角色切换：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># hccontrol -n ubt0hci write_node_role_switch 0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要显示蓝牙数据包，请使用第三方软件包 hcidump ，可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/comms/hcidump/">comms/hcidump</a> 软件包或端口进行安装。该实用程序类似于 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> ，可用于在终端上显示蓝牙数据包的内容，并将蓝牙数据包转储到文件中。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-bridging">34.8. 桥接<a class="anchor" href="#network-bridging"></a></h3>
<div class="paragraph">
<p>有时候，将一个网络（比如以太网段）划分为网络段，而无需创建 IP 子网并使用路由器将这些网络段连接起来，是非常有用的。以这种方式连接两个网络的设备被称为“桥接器”。</p>
</div>
<div class="paragraph">
<p>桥接器通过学习每个网络接口上设备的 MAC 地址来工作。只有当源 MAC 地址和目标 MAC 地址位于不同的网络上时，它才会在网络之间转发流量。在许多方面，桥接器类似于只有很少端口的以太网交换机。可以配置具有多个网络接口的 FreeBSD 系统来充当桥接器。</p>
</div>
<div class="paragraph">
<p>桥接在以下情况下非常有用：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">连接网络</dt>
<dd>
<p>桥接的基本操作是连接两个或多个网络段。使用主机级桥接而不是网络设备有许多原因，例如布线限制或防火墙。桥接还可以将以 hostap 模式运行的无线接口连接到有线网络，并充当访问点。</p>
</dd>
<dt class="hdlist1">过滤 / 流量整形防火墙</dt>
<dd>
<p>当需要防火墙功能而不需要路由或网络地址转换（ NAT ）时，可以使用桥接。</p>
<div class="paragraph">
<p>一个例子是一个通过 DSL 或 ISDN 连接到 ISP 的小公司。 ISP 提供了 13 个公共 IP 地址，网络上有 10 台计算机。在这种情况下，由于子网划分问题，使用基于路由器的防火墙是困难的。而基于桥接的防火墙可以在没有任何 IP 地址问题的情况下进行配置。</p>
</div>
</dd>
<dt class="hdlist1">网络分流器</dt>
<dd>
<p>桥接器可以连接两个网络段，以便使用桥接接口上的 <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcpdump&amp;sektion=1&amp;format=html">tcpdump(1)</a> 来检查它们之间传递的所有以太网帧，或者通过将所有帧的副本发送到一个额外的接口，即监控端口。</p>
</dd>
<dt class="hdlist1">第二层虚拟专用网络（ Layer 2 VPN ）</dt>
<dd>
<p>通过将网络桥接到 EtherIP 隧道或基于 <a href="https://man.freebsd.org/cgi/man.cgi?query=tap&amp;sektion=4&amp;format=html">tap(4)</a> 的解决方案（如 OpenVPN ），可以通过 IP 链接将两个以太网网络连接起来。</p>
</dd>
<dt class="hdlist1">第二层冗余</dt>
<dd>
<p>一个网络可以通过多个链路连接在一起，并使用生成树协议（ STP ）来阻塞冗余路径。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>本节介绍了如何使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> 将 FreeBSD 系统配置为桥接模式。还提供了 netgraph 桥接驱动程序的配置方法，详见 <a href="https://man.freebsd.org/cgi/man.cgi?query=ng_bridge&amp;sektion=4&amp;format=html">ng_bridge(4)</a> 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>数据包过滤可以与任何钩入 <a href="https://man.freebsd.org/cgi/man.cgi?query=pfil&amp;sektion=9&amp;format=html">pfil(9)</a> 框架的防火墙软件包一起使用。桥接可以与 <a href="https://man.freebsd.org/cgi/man.cgi?query=altq&amp;sektion=4&amp;format=html">altq(4)</a> 或 <a href="https://man.freebsd.org/cgi/man.cgi?query=dummynet&amp;sektion=4&amp;format=html">dummynet(4)</a> 一起用作流量整形器。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="_启用桥接功能">34.8.1. 启用桥接功能<a class="anchor" href="#_启用桥接功能"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 中， <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> 是一个内核模块，当创建一个桥接接口时， <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 会自动加载它。也可以通过在自定义内核配置文件中添加 <code>device if_bridge</code> 来编译桥接支持到自定义内核中。</p>
</div>
<div class="paragraph">
<p>使用接口克隆来创建桥接。要创建桥接接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge create</span>
bridge0
<span class="c"># ifconfig bridge0</span>
bridge0: <span class="nv">flags</span><span class="o">=</span>8802&lt;BROADCAST,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0</code></pre>
</div>
</div>
<div class="paragraph">
<p>当创建一个桥接接口时，它会自动分配一个随机生成的以太网地址。 <code>maxaddr</code> 和 <code>timeout</code> 参数控制桥接将保留多少个 MAC 地址在其转发表中，以及每个条目在最后一次被检测到后多少秒后被删除。其他参数控制 STP 的操作方式。</p>
</div>
<div class="paragraph">
<p>接下来，指定要添加为桥接成员的网络接口。为了使桥接转发数据包，所有成员接口和桥接都需要处于启动状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 addm fxp0 addm fxp1 up</span>
<span class="c"># ifconfig fxp0 up</span>
<span class="c"># ifconfig fxp1 up</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>桥接器现在可以在 fxp0 和 fxp1 之间转发以太网帧。在 /etc/rc.conf 中添加以下行，以便在启动时创建桥接器：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>cloned_interfaces=&#34;bridge0&#34;
ifconfig_bridge0=&#34;addm fxp0 addm fxp1 up&#34;
ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>如果桥接主机需要一个 IP 地址，请在桥接接口上设置，而不是在成员接口上设置。该地址可以静态设置或通过 DHCP 设置。以下示例设置了一个静态 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>还可以将 IPv6 地址分配给桥接口。要使更改永久生效，请将寻址信息添加到 /etc/rc.conf 文件中。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>当启用数据包过滤时，桥接的数据包将通过过滤器从桥接接口的原始接口进入，并通过适当的接口出去。任何一个阶段都可以被禁用。当数据包流向很重要时，最好在成员接口上设置防火墙，而不是在桥接本身上设置。</p>
</div>
<div class="paragraph">
<p>该桥接器具有多个可配置的设置，用于传递非 IP 和 IP 数据包，并使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ipfw&amp;sektion=8&amp;format=html">ipfw(8)</a> 进行第二层防火墙设置。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=if_bridge&amp;sektion=4&amp;format=html">if_bridge(4)</a> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</div>
<div class="sect3">
<h4 id="_启用生成树">34.8.2. 启用生成树<a class="anchor" href="#_启用生成树"></a></h4>
<div class="paragraph">
<p>为了使以太网网络正常运行，两个设备之间只能存在一条活动路径。 STP 协议可以检测到环路，并将冗余链路置于阻塞状态。如果其中一条活动链路失败， STP 会计算出一棵不同的树，并启用一条被阻塞的路径，以恢复网络中所有节点的连接。</p>
</div>
<div class="paragraph">
<p>快速生成树协议（ RSTP 或 802.1w ）与传统的生成树协议（ STP ）向后兼容。 RSTP 提供更快的收敛速度，并与相邻交换机交换信息，以便快速转换到转发模式，而不会创建环路。 FreeBSD 支持 RSTP 和 STP 作为操作模式，其中 RSTP 是默认模式。</p>
</div>
<div class="paragraph">
<p>可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 在成员接口上启用 STP 。对于具有 .fxpo 和 .fxpl 作为当前接口的桥接，可以使用以下命令启用 STP ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 stp fxp0 stp fxp1</span>
bridge0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether d6:cf:d5:a0:94:6d
        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0
        member: fxp0 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 3 priority 128 path cost 200000 proto rstp
                role designated state forwarding
        member: fxp1 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre>
</div>
</div>
<div class="paragraph">
<p>这个桥的生成树 ID 是 <code>00:01:02:4b:d4:50</code> ，优先级是 <code>32768</code> 。由于根 ID 相同，这表明这是生成树的根桥。</p>
</div>
<div class="paragraph">
<p>网络上的另一座桥梁也启用了 STP ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">bridge0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        ether 96:3d:4b:f1:79:7a
        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15
        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200
        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4
        member: fxp0 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 4 priority 128 path cost 200000 proto rstp
                role root state forwarding
        member: fxp1 <span class="nv">flags</span><span class="o">=</span>1c7&lt;LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP&gt;
                port 5 priority 128 path cost 200000 proto rstp
                role designated state forwarding</code></pre>
</div>
</div>
<div class="paragraph">
<p>该行 <code>root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4</code> 显示根桥为 <code>00:01:02:4b:d4:50</code> ，从该桥到根桥的路径成本为 <code>400000</code> 。到达根桥的路径通过 <code>port 4</code> ，即 <span class="filename">fxp0</span> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_桥接接口参数">34.8.3. 桥接接口参数<a class="anchor" href="#_桥接接口参数"></a></h4>
<div class="paragraph">
<p>几个 <code>ifconfig</code> 参数是专门用于桥接接口的。本节概述了这些参数的一些常见用法。完整的可用参数列表在 <a href="https://man.freebsd.org/cgi/man.cgi?query=ifconfig&amp;sektion=8&amp;format=html">ifconfig(8)</a> 中有描述。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">私有的</dt>
<dd>
<p>私有接口不会将任何流量转发到其他被指定为私有接口的端口。流量会被无条件地阻塞，因此不会转发任何以太网帧，包括 ARP 数据包。如果需要选择性地阻止流量，应该使用防火墙。</p>
</dd>
<dt class="hdlist1">跨度</dt>
<dd>
<p>一个 SPAN 端口会传输桥接器接收到的每个以太网帧的副本。一个桥接器上配置的 SPAN 端口数量是无限的，但是如果一个接口被指定为 SPAN 端口，它就不能再被用作常规的桥接端口。这对于在连接到桥接器的 SPAN 端口之一的另一台主机上被动地监听桥接网络非常有用。例如，要将所有帧的副本发送到名为 <span class="filename">fxp4</span> 的接口上。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 span fxp4</span></code></pre>
</div>
</div>
</dd>
<dt class="hdlist1">粘性</dt>
<dd>
<p>如果桥接成员接口被标记为粘性（ sticky ），动态学习的地址条目将被视为转发缓存中的静态条目。粘性条目不会因为地址在不同接口上出现而被清除或替换。这提供了静态地址条目的好处，而无需预先填充转发表。在桥接的特定段上学习的客户端不能漫游到另一个段。</p>
<div class="paragraph">
<p>使用粘性地址的一个例子是将桥接器与 VLAN 结合使用，以便在不浪费 IP 地址空间的情况下隔离客户网络。假设 <code>CustomerA</code> 位于 <code>vlan100</code> ， <code>CustomerB</code> 位于 <code>vlan101</code> ，桥接器的地址为 <code>192.168.0.1</code> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101</span>
<span class="c"># ifconfig bridge0 inet 192.168.0.1/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，两个客户端都将 <code>192.168.0.1</code> 视为它们的默认网关。由于桥接缓存是粘性的，一个主机无法伪造另一个客户的 MAC 地址以拦截其流量。</p>
</div>
<div class="paragraph">
<p>可以使用防火墙或私有接口来阻止 VLAN 之间的任何通信，就像在这个例子中所看到的那样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 private vlan100 private vlan101</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>客户之间完全隔离，可以分配整个 <code>/24</code> 地址范围而无需进行子网划分。</p>
</div>
<div class="paragraph">
<p>接口后面的唯一源 MAC 地址数量可以被限制。一旦达到限制，具有未知源地址的数据包将被丢弃，直到现有的主机缓存条目过期或被删除。</p>
</div>
<div class="paragraph">
<p>以下示例将 <code>vlan100</code> 上 <code>CustomerA</code> 的以太网设备的最大数量设置为 10 ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 ifmaxaddr vlan100 10</span></code></pre>
</div>
</div>
</dd>
</dl>
</div>
<div class="paragraph">
<p>桥接接口还支持监控模式，在 <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> 处理后丢弃数据包，不再进行进一步处理或转发。这可以用于将两个或多个接口的输入多路复用到单个 <a href="https://man.freebsd.org/cgi/man.cgi?query=bpf&amp;sektion=4&amp;format=html">bpf(4)</a> 流中。这对于重构通过两个独立接口传输 RX/TX 信号的网络监听器的流量非常有用。例如，要将四个网络接口的输入作为一个流进行读取：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up</span>
<span class="c"># tcpdump -i bridge0</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_snmp_监控">34.8.4. SNMP 监控<a class="anchor" href="#_snmp_监控"></a></h4>
<div class="paragraph">
<p>桥接接口和 STP 参数可以通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> 进行监控，该工具包含在 FreeBSD 基本系统中。导出的桥接 MIB 符合 IETF 标准，因此可以使用任何 SNMP 客户端或监控软件来检索数据。</p>
</div>
<div class="paragraph">
<p>要在桥接器上启用监控，请取消注释 <span class="filename">/etc/snmpd.config</span> 中的此行，即删除开头的 <code>#</code> 符号：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>begemotSnmpdModulePath.&#34;bridge&#34; = &#34;/usr/lib/snmp_bridge.so&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>其他配置设置，如社区名称和访问列表，可能需要在此文件中进行修改。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=snmp_bridge&amp;sektion=3&amp;format=html">snmp_bridge(3)</a> 。保存这些编辑后，将此行添加到 <span class="filename">/etc/rc.conf</span> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>bsnmpd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后，启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=bsnmpd&amp;sektion=1&amp;format=html">bsnmpd(1)</a> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service bsnmpd start</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>以下示例使用 Net-SNMP 软件（软件包： net-mgmt/net-snmp[] ）从客户端系统查询桥接。也可以使用软件包： net-mgmt/bsnmptools[] 端口。从运行 Net-SNMP 的 SNMP 客户端，在 [.filename]# $ HOME/.snmp/snmp.conf# 中添加以下行以导入桥接 MIB 定义：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>mibdirs +/usr/share/snmp/mibs
mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB</pre>
</div>
</div>
<div class="paragraph">
<p>使用 IETF BRIDGE-MIB （ RFC4188 ）监控单个桥接设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge
BRIDGE-MIB::dot1dBaseBridgeAddress.0 <span class="o">=</span> STRING: 66:fb:9b:6e:5c:44
BRIDGE-MIB::dot1dBaseNumPorts.0 <span class="o">=</span> INTEGER: 1 ports
BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 <span class="o">=</span> Timeticks: <span class="o">(</span>189959<span class="o">)</span> 0:31:39.59 centi-seconds
BRIDGE-MIB::dot1dStpTopChanges.0 <span class="o">=</span> Counter32: 2
BRIDGE-MIB::dot1dStpDesignatedRoot.0 <span class="o">=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
...
BRIDGE-MIB::dot1dStpPortState.3 <span class="o">=</span> INTEGER: forwarding<span class="o">(</span>5<span class="o">)</span>
BRIDGE-MIB::dot1dStpPortEnable.3 <span class="o">=</span> INTEGER: enabled<span class="o">(</span>1<span class="o">)</span>
BRIDGE-MIB::dot1dStpPortPathCost.3 <span class="o">=</span> INTEGER: 200000
BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 <span class="o">=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedCost.3 <span class="o">=</span> INTEGER: 0
BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 <span class="o">=</span> Hex-STRING: 80 00 00 01 02 4B D4 50
BRIDGE-MIB::dot1dStpPortDesignatedPort.3 <span class="o">=</span> Hex-STRING: 03 80
BRIDGE-MIB::dot1dStpPortForwardTransitions.3 <span class="o">=</span> Counter32: 1
RSTP-MIB::dot1dStpVersion.0 <span class="o">=</span> INTEGER: rstp<span class="o">(</span>2<span class="o">)</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>dot1dStpTopChanges.0</code> 的值为 2 ，表示 STP 桥接拓扑已经发生了两次变化。拓扑变化意味着网络中的一个或多个链路发生了变化或故障，并重新计算了新的树形结构。 <code>dot1dStpTimeSinceTopologyChange.0</code> 的值将显示这一事件发生的时间。</p>
</div>
<div class="paragraph">
<p>要监控多个桥接口，可以使用私有的 BEGEMOT-BRIDGE-MIB 。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>snmpwalk -v 2c -c public bridge1.example.com
enterprises.fokus.begemot.begemotBridge
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> STRING: bridge0
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> STRING: bridge2
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> STRING: e:ce:3b:5a:9e:13
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> STRING: 12:5e:4d:74:d:fc
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> INTEGER: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> INTEGER: 1
...
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> Timeticks: <span class="o">(</span>116927<span class="o">)</span> 0:19:29.27 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> Timeticks: <span class="o">(</span>82773<span class="o">)</span> 0:13:47.73 centi-seconds
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> Counter32: 1
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class="s2">&#34;bridge0&#34;</span> <span class="o">=</span> Hex-STRING: 80 00 00 40 95 30 5E 31
BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.<span class="s2">&#34;bridge2&#34;</span> <span class="o">=</span> Hex-STRING: 80 00 00 50 8B B8 C6 A9</code></pre>
</div>
</div>
<div class="paragraph">
<p>要通过 <code>mib-2.dot1dBridge</code> 子树更改被监视的桥接口：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">% </span>snmpset -v 2c -c private bridge1.example.com
BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-aggregation">34.9. 链路聚合和故障转移<a class="anchor" href="#network-aggregation"></a></h3>
<div class="paragraph">
<p>FreeBSD 提供了 <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> 接口，可以将多个网络接口聚合成一个虚拟接口，以实现故障转移和链路聚合。故障转移允许流量在至少一个聚合网络接口建立连接时继续传输。链路聚合在支持 LACP 的交换机上效果最佳，因为该协议可以在双向传输流量的同时响应单个链路的故障。</p>
</div>
<div class="paragraph">
<p>lagg 接口支持的聚合协议决定了哪些端口用于出站流量，以及特定端口是否接受入站流量。 <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> 支持以下协议：</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">故障转移</dt>
<dd>
<p>这种模式只通过主端口发送和接收流量。如果主端口不可用，将使用下一个活动端口。添加到虚拟接口的第一个接口是主端口，随后添加的接口将用作故障转移设备。如果故障转移到非主端口，原始端口在再次可用时将恢复为主端口。</p>
</dd>
<dt class="hdlist1">负载均衡</dt>
<dd>
<p>这提供了一个静态设置，并且不与对等方协商聚合或交换帧以监视链路。如果交换机支持 LACP ，则应使用该协议。</p>
</dd>
<dt class="hdlist1">LACP （ Link Aggregation Control Protocol ）是一种用于组合多个物理链路形成逻辑链路的网络协议。它允许将多个物理链路捆绑在一起，形成一个高带宽、高可靠性的逻辑链路，提供更好的网络性能和冗余备份。 LACP 通过协商和管理链路聚合组（ LAG ）来实现链路的动态添加和删除，以及链路的负载均衡和故障恢复。 LACP 常用于数据中心、企业网络和运营商网络等场景，以提供更高的带宽和可靠性。</dt>
<dd>
<p>IEEE® 802.3ad 链路聚合控制协议（ LACP ）与对等方协商一组可聚合的链路，形成一个或多个链路聚合组（ LAG ）。每个 LAG 由相同速度的端口组成，设置为全双工操作，并且流量在 LAG 中的端口之间进行平衡，以获得最大总速度。通常，只有一个包含所有端口的 LAG 。在物理连接发生变化时， LACP 将迅速收敛到新的配置。</p>
<div class="paragraph">
<p>LACP 根据哈希协议头信息平衡传出流量，并从任何活动端口接受传入流量。哈希包括以太网源地址和目的地址，如果可用，还包括 VLAN 标签以及 IPv4 或 IPv6 源地址和目的地址。</p>
</div>
</dd>
<dt class="hdlist1">轮询</dt>
<dd>
<p>这种模式通过循环调度器将出站流量分发到所有活动端口，并接受来自任何活动端口的入站流量。由于这种模式违反了以太网帧的顺序，因此应谨慎使用。</p>
</dd>
<dt class="hdlist1">广播</dt>
<dd>
<p>该模式将出站流量发送到 lagg 接口上配置的所有端口，并在任何端口上接收帧。</p>
</dd>
</dl>
</div>
<div class="sect3">
<h4 id="_配置示例">34.9.1. 配置示例<a class="anchor" href="#_配置示例"></a></h4>
<div class="paragraph">
<p>本节演示了如何配置 Cisco® 交换机和 FreeBSD 系统以实现 LACP 负载均衡。然后，它展示了如何配置两个以故障转移模式工作的以太网接口，以及如何在以太网接口和无线接口之间配置故障转移模式。</p>
</div>
<div id="networking-lacp-aggregation-cisco" class="exampleblock">
<div class="title">例 38. 使用 Cisco® 交换机进行 LACP 聚合</div>
<div class="content">
<div class="paragraph">
<p>这个例子将一个 FreeBSD 机器上的两个 <a href="https://man.freebsd.org/cgi/man.cgi?query=fxp&amp;sektion=4&amp;format=html">fxp(4)</a> 以太网接口连接到 Cisco® 交换机的前两个以太网端口，作为一个负载均衡和容错链接。可以添加更多接口以增加吞吐量和容错性。请根据本地配置替换示例中显示的 Cisco® 端口名称、以太网设备、通道组号和 IP 地址的名称。</p>
</div>
<div class="paragraph">
<p>以太网链路上的帧排序是强制性的，任何两个站点之间的流量总是通过同一物理链路传输，这限制了最大速度为一个接口的速度。传输算法尝试使用尽可能多的信息来区分不同的流量，并在可用接口之间平衡流量。</p>
</div>
<div class="paragraph">
<p>在 Cisco® 交换机上，将_FastEthernet0/1_和_FastEthernet0/2_接口添加到通道组_1_中：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell">interface FastEthernet0/1
 channel-group 1 mode active
 channel-protocol lacp
!
interface FastEthernet0/2
 channel-group 1 mode active
 channel-protocol lacp</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 FreeBSD 系统上，使用物理接口_fxp0_和_fxp1_创建 <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> 接口，并使用 IP 地址_10.0.0.3/24_将接口启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig fxp0 up</span>
<span class="c"># ifconfig fxp1 up</span>
<span class="c"># ifconfig lagg0 create</span>
<span class="c"># ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>接下来，验证虚拟接口的状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig lagg0</span>
lagg0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class="nv">options</span><span class="o">=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto lacp
        laggport: fxp1 <span class="nv">flags</span><span class="o">=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;
        laggport: fxp0 <span class="nv">flags</span><span class="o">=</span>1c&lt;ACTIVE,COLLECTING,DISTRIBUTING&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>标记为“ ACTIVE ”的端口是与远程交换机协商的链路聚合组（ LAG ）的一部分。通过这些活动端口传输和接收流量。在上述命令中添加“ -v ”以查看 LAG 标识符。</p>
</div>
<div class="paragraph">
<p>查看 Cisco® 交换机上的端口状态：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="gp">switch# </span>show lacp neighbor
Flags:  S - Device is requesting Slow LACPDUs
        F - Device is requesting Fast LACPDUs
        A - Device is <span class="k">in </span>Active mode       P - Device is <span class="k">in </span>Passive mode

Channel group 1 neighbors

Partner<span class="s1">&#39;s information:

                  LACP port                        Oper    Port     Port
Port      Flags   Priority  Dev ID         Age     Key     Number   State
Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D
Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要获取更详细的信息，请输入 <code>show lacp neighbor detail</code> 。</p>
</div>
<div class="paragraph">
<p>要在重新启动后保留此配置，请将以下条目添加到 FreeBSD 系统上的 <code>/etc/rc.conf</code> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24&#34;</pre>
</div>
</div>
</div>
</div>
<div id="networking-lagg-failover" class="exampleblock">
<div class="title">例 39. 故障转移模式</div>
<div class="content">
<div class="paragraph">
<p>如果主接口丢失连接，可以使用故障转移模式切换到备用接口。要配置故障转移，请确保底层物理接口正常工作，然后创建 <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> 接口。在这个例子中，<em>fxp0_是主接口，_fxp1_是备用接口，虚拟接口被分配了一个 IP 地址为_10.0.0.15/24</em>。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig fxp0 up</span>
<span class="c"># ifconfig fxp1 up</span>
<span class="c"># ifconfig lagg0 create</span>
<span class="c"># ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虚拟接口应该类似于这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig lagg0</span>
lagg0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class="nv">options</span><span class="o">=</span>8&lt;VLAN_MTU&gt;
        ether 00:05:5d:71:8d:b8
        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255
        media: Ethernet autoselect
        status: active
        laggproto failover
        laggport: fxp1 <span class="nv">flags</span><span class="o">=</span>0&lt;&gt;
        laggport: fxp0 <span class="nv">flags</span><span class="o">=</span>5&lt;MASTER,ACTIVE&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>流量将在 <em>fxp0</em> 上进行传输和接收。如果 <em>fxp0</em> 上的连接丢失，<em>fxp1</em> 将成为活动连接。如果主接口上的连接恢复，它将再次成为活动连接。</p>
</div>
<div class="paragraph">
<p>要在重新启动后保留此配置，请将以下条目添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_fxp0=&#34;up&#34;
ifconfig_fxp1=&#34;up&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24&#34;</pre>
</div>
</div>
</div>
</div>
<div id="networking-lagg-wired-and-wireless" class="exampleblock">
<div class="title">例 40. 以太网和无线接口之间的故障转移模式</div>
<div class="content">
<div class="paragraph">
<p>对于笔记本电脑用户来说，通常希望将无线设备配置为次要设备，仅在以太网连接不可用时使用。通过使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> ，可以配置故障转移，优先选择以太网连接，以提高性能和安全性，同时保持通过无线连接传输数据的能力。</p>
</div>
<div class="paragraph">
<p>这是通过使用无线接口的 MAC 地址覆盖以太网接口的 MAC 地址来实现的。</p>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>理论上，以太网或无线网络的 MAC 地址都可以更改以匹配另一个。然而，一些常用的无线接口不支持覆盖 MAC 地址。因此，我们建议为此目的覆盖以太网的 MAC 地址。</p>
</div>
</div>
</div>
<div class="sidebarblock">
<div class="content">
<div class="paragraph">
<p>如果在 <code>GENERIC</code> 或自定义内核中没有加载无线接口的驱动程序，并且计算机正在运行 FreeBSD 12.1 ，则可以通过在 <code>/boot/loader.conf</code> 文件中添加 <code><strong>driver_load =&#34;YES&#34;</strong></code> 来加载相应的 <code>.ko</code> 文件，并重新启动计算机。另一种更好的方法是通过将驱动程序添加到 <code>/etc/rc.conf</code> 文件中的 <code>kld_list</code> （详见 <a href="https://man.freebsd.org/cgi/man.cgi?query=rc.conf&amp;sektion=5&amp;format=html">rc.conf(5)</a> ）并重新启动来加载驱动程序。这是必需的，因为否则在设置 <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> 接口时驱动程序尚未加载。</p>
</div>
</div>
</div>
<div class="paragraph">
<p>在这个例子中，以太网接口_re0_是主接口，无线接口_wlan0_是备份接口。_wlan0_接口是从_ath0_物理无线接口创建的，并且以太网接口将配置无线接口的 MAC 地址。首先，将无线接口启动（将_FR_替换为您自己的两个字母的国家代码），但不设置 IP 地址。将_wlan0_替换为与系统的无线接口名称匹配的名称：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0 create wlandev ath0 country FR ssid my_router up</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>现在您可以确定无线接口的 MAC 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig wlan0</span>
wlan0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
	ether b8:ee:65:5b:32:59
	groups: wlan
	ssid Bbox-A3BD2403 channel 6 <span class="o">(</span>2437 MHz 11g ht/20<span class="o">)</span> bssid 00:37:b7:56:4b:60
	regdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON
	deftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60
	protmode CTS ampdulimit 64k ampdudensity 8 shortgi -stbctx stbcrx
	-ldpc wme burst roaming MANUAL
	media: IEEE 802.11 Wireless Ethernet MCS mode 11ng
	status: associated
	nd6 <span class="nv">options</span><span class="o">=</span>29&lt;PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>ether</code> 行将包含指定接口的 MAC 地址。现在，将以太网接口的 MAC 地址更改为匹配的地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig re0 ether b8:ee:65:5b:32:59</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>确保_re0_接口处于启动状态，然后使用_re0_作为主接口创建 <a href="https://man.freebsd.org/cgi/man.cgi?query=lagg&amp;sektion=4&amp;format=html">lagg(4)</a> 接口，并设置故障转移至_wlan0_。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig re0 up</span>
<span class="c"># ifconfig lagg0 create</span>
<span class="c"># ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>虚拟接口应该类似于这样：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig lagg0</span>
lagg0: <span class="nv">flags</span><span class="o">=</span>8843&lt;UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST&gt; metric 0 mtu 1500
        <span class="nv">options</span><span class="o">=</span>8&lt;VLAN_MTU&gt;
        ether b8:ee:65:5b:32:59
        laggproto failover lagghash l2,l3,l4
        laggport: re0 <span class="nv">flags</span><span class="o">=</span>5&lt;MASTER,ACTIVE&gt;
        laggport: wlan0 <span class="nv">flags</span><span class="o">=</span>0&lt;&gt;
        groups: lagg
        media: Ethernet autoselect
        status: active</code></pre>
</div>
</div>
<div class="paragraph">
<p>然后，启动 DHCP 客户端以获取 IP 地址：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># dhclient lagg0</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在重新启动后保留此配置，请将以下条目添加到 <span class="filename">/etc/rc.conf</span> 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>ifconfig_re0=&#34;ether b8:ee:65:5b:32:59&#34;
wlans_ath0=&#34;wlan0&#34;
ifconfig_wlan0=&#34;WPA&#34;
create_args_wlan0=&#34;country FR&#34;
cloned_interfaces=&#34;lagg0&#34;
ifconfig_lagg0=&#34;up laggproto failover laggport re0 laggport wlan0 DHCP&#34;</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-diskless">34.10. 使用 PXE 进行无盘操作<a class="anchor" href="#network-diskless"></a></h3>
<div class="paragraph">
<p>Intel® Preboot eXecution Environment (PXE) 允许操作系统通过网络引导。例如， FreeBSD 系统可以通过网络引导并在没有本地磁盘的情况下运行，使用从 NFS 服务器挂载的文件系统。 PXE 支持通常在 BIOS 中可用。要在机器启动时使用 PXE ，在 BIOS 设置中选择“从网络引导”选项或在系统初始化期间键入功能键。</p>
</div>
<div class="paragraph">
<p>为了提供操作系统在网络上启动所需的文件， PXE 设置还需要正确配置的 DHCP 、 TFTP 和 NFS 服务器，其中：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>初始参数，如 IP 地址、可执行的引导文件名和位置、服务器名称和根路径，是从 DHCP 服务器获取的。</p>
</li>
<li>
<p>操作系统加载程序文件使用 TFTP 进行引导。</p>
</li>
<li>
<p>文件系统使用 NFS 加载。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>当计算机进行 PXE 引导时，它通过 DHCP 接收关于获取初始引导加载程序文件的信息。主机计算机接收到这些信息后，通过 TFTP 下载引导加载程序，然后执行引导加载程序。在 FreeBSD 中，引导加载程序文件是 [/boot/pxeboot] 。在 [/boot/pxeboot] 执行后， FreeBSD 内核被加载，随后进行 FreeBSD 的引导过程，如 <a href="./#boot">The FreeBSD Booting Process</a> 中所述。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>对于基于 UEFI PXE 的引导，要使用的实际引导加载程序文件是 <span class="filename">/boot/loader.efi</span> 。请参阅下面的章节 <a href="./#_debugging_pxe_problems">调试 PXE 问题</a> ，了解如何使用 <span class="filename">/boot/loader.efi</span> 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 系统上配置这些服务，以便其他系统可以通过 PXE 引导进入 FreeBSD 。有关更多信息，请参阅 <a href="https://man.freebsd.org/cgi/man.cgi?query=diskless&amp;sektion=8&amp;format=html">diskless(8)</a> 。</p>
</div>
<div class="admonitionblock caution">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如上所述，提供这些服务的系统是不安全的。它应该存在于网络的受保护区域，并且其他主机不应信任它。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="sect3">
<h4 id="network-pxe-nfs">34.10.1. 设置 PXE 环境<a class="anchor" href="#network-pxe-nfs"></a></h4>
<div class="paragraph">
<p>本节中显示的步骤配置了内置的 NFS 和 TFTP 服务器。下一节演示了如何安装和配置 DHCP 服务器。在本示例中，用于 PXE 用户的文件的目录是 <span class="filename">/b/tftpboot/FreeBSD/install</span> 。重要的是，该目录存在，并且在 <span class="filename">/etc/inetd.conf</span> 和 <span class="filename">/usr/local/etc/dhcpd.conf</span> 中设置了相同的目录名。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>下面的命令示例假设使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> shell 。 <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=tcsh&amp;sektion=1&amp;format=html">tcsh(1)</a> 用户需要启动一个 <a href="https://man.freebsd.org/cgi/man.cgi?query=sh&amp;sektion=1&amp;format=html">sh(1)</a> shell 或者根据 <a href="https://man.freebsd.org/cgi/man.cgi?query=csh&amp;sektion=1&amp;format=html">csh(1)</a> 语法调整命令。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="olist arabic procedure">
<ol class="arabic">
<li>
<p>创建根目录，该目录将包含一个要进行 NFS 挂载的 FreeBSD 安装。</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># export NFSROOTDIR=/b/tftpboot/FreeBSD/install</span>
<span class="c"># mkdir -p ${NFSROOTDIR}</span></code></pre>
</div>
</div>
</li>
<li>
<p>通过将以下行添加到 <span class="filename">/etc/rc.conf</span> 来启用 NFS 服务器：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>nfs_server_enable=&#34;YES&#34;</pre>
</div>
</div>
</li>
<li>
<p>通过将以下内容添加到 [/etc/exports] ，将无磁盘根目录通过 NFS 导出：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>/b -ro -alldirs -maproot=root</pre>
</div>
</div>
</li>
<li>
<p>启动 NFS 服务器：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service nfsd start</span></code></pre>
</div>
</div>
</li>
<li>
<p>通过将以下行添加到 <span class="filename">/etc/rc.conf</span> 来启用 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> ：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>inetd_enable=&#34;YES&#34;</pre>
</div>
</div>
</li>
<li>
<p>请取消注释 <span class="filename">/etc/inetd.conf</span> 中的以下行，确保它不以 <code>#</code> 符号开头：</p>
<div class="literalblock programlisting">
<div class="content">
<pre>tftp dgram udp wait root /usr/libexec/tftpd tftpd blocksize 1468 -l -s /b/tftpboot</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>指定的 tftp 块大小，例如 1468 字节，替换了默认大小 512 字节。某些 PXE 版本要求使用 TCP 版本的 TFTP 。在这种情况下，取消注释包含 <code>stream tcp</code> 的第二个 <code>tftp</code> 行。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
</li>
<li>
<p>启动 <a href="https://man.freebsd.org/cgi/man.cgi?query=inetd&amp;sektion=8&amp;format=html">inetd(8)</a> ：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service inetd start</span></code></pre>
</div>
</div>
</li>
<li>
<p>将基本系统安装到 [$ {NFSROOTDIR}]# $ {NFSROOTDIR}# 中，可以通过解压官方存档或重新构建 FreeBSD 内核和用户空间来完成（有关更详细的说明，请参阅 <a href="./#makeworld ，“从源代码更新 FreeBSD ”"></a> ，但在运行 <code>make installkernel</code> 和 <code>make installworld</code> 命令时不要忘记添加 <code>DESTDIR =<em>$ {NFSROOTDIR}</em></code> 。</p>
</li>
<li>
<p>测试 TFTP 服务器是否正常工作，并且能够通过 PXE 下载引导加载程序：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tftp localhost</span>
<span class="gp">tftp&gt; </span>get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class="k">in </span>0.1 seconds</code></pre>
</div>
</div>
</li>
<li>
<p>编辑 [.filename]# $ {NFSROOTDIR}/etc/fstab# 并创建一个条目以通过 NFS 挂载根文件系统：</p>
<div class="literalblock programlisting">
<div class="content">
<pre># Device                                         Mountpoint    FSType   Options  Dump Pass
myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0</pre>
</div>
</div>
<div class="paragraph">
<p>将 <em>myhost.example.com</em> 替换为 NFS 服务器的主机名或 IP 地址。在这个例子中，根文件系统以只读方式挂载，以防止 NFS 客户端可能删除根文件系统的内容。</p>
</div>
</li>
<li>
<p>为通过 PXE 引导的客户机在 PXE 环境中设置根密码：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chroot ${NFSROOTDIR}</span>
<span class="c"># passwd</span></code></pre>
</div>
</div>
</li>
<li>
<p>如有需要，通过编辑 ` $ {NFSROOTDIR}/etc/ssh/sshd_config` 文件并启用 <code>PermitRootLogin</code> 选项，可以为使用 PXE 引导的客户机启用 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=ssh&amp;sektion=1&amp;format=html">ssh(1)</a></code> 根登录。该选项在 <code><a href="https://man.freebsd.org/cgi/man.cgi?query=sshd_config&amp;sektion=5&amp;format=html">sshd_config(5)</a></code> 中有详细说明。</p>
</li>
<li>
<p>在 [.filename]# $ {NFSROOTDIR}# 中进行任何其他所需的 PXE 环境自定义。这些自定义可能包括安装软件包或使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=vipw&amp;sektion=8&amp;format=html">vipw(8)</a> 编辑密码文件。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>当从 NFS 根卷引导时， [/etc/rc] 检测到 NFS 引导并运行 [/etc/rc.initdiskless] 。在这种情况下， [/etc] 和 [/var] 需要是内存支持的文件系统，以便这些目录可写，但 NFS 根目录是只读的。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># chroot ${NFSROOTDIR}</span>
<span class="c"># mkdir -p conf/base</span>
<span class="c"># tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc</span>
<span class="c"># tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>当系统启动时，将创建并挂载 <span class="filename">/etc</span> 和 <span class="filename">/var</span> 的内存文件系统，并将 <span class="filename">cpio.gz</span> 文件的内容复制到其中。默认情况下，这些文件系统的最大容量为 5 兆字节。如果您的存档不适合，通常是 <span class="filename">/var</span> 安装了二进制包的情况下，可以通过在 [.filename]# $ {NFSROOTDIR}/conf/base/etc/md_size# 和 [.filename]# $ {NFSROOTDIR}/conf/base/var/md_size# 文件中放入所需的 512 字节扇区数（例如， 5 兆字节为 10240 扇区）来请求更大的大小，分别用于 <span class="filename">/etc</span> 和 <span class="filename">/var</span> 文件系统。</p>
</div>
</div>
<div class="sect3">
<h4 id="network-pxe-setting-up-dhcp">34.10.2. 配置 DHCP 服务器<a class="anchor" href="#network-pxe-setting-up-dhcp"></a></h4>
<div class="paragraph">
<p>DHCP 服务器不需要与 TFTP 和 NFS 服务器位于同一台机器上，但它需要在网络中可访问。</p>
</div>
<div class="paragraph">
<p>DHCP 不是 FreeBSD 基本系统的一部分，但可以使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/isc-dhcp44-server/">net/isc-dhcp44-server</a> 端口或包进行安装。</p>
</div>
<div class="paragraph">
<p>安装完成后，编辑配置文件 <span class="filename">/usr/local/etc/dhcpd.conf</span> 。根据以下示例配置 <code>next-server</code> 、 <code>filename</code> 和 <code>root-path</code> 设置：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>subnet 192.168.0.0 netmask 255.255.255.0 {
   range 192.168.0.2 192.168.0.3 ;
   option subnet-mask 255.255.255.0 ;
   option routers 192.168.0.1 ;
   option broadcast-address 192.168.0.255 ;
   option domain-name-servers 192.168.35.35, 192.168.35.36 ;
   option domain-name &#34;example.com&#34;;

   # IP address of TFTP server
   next-server 192.168.0.1 ;

   # path of boot loader obtained via tftp
   filename &#34;FreeBSD/install/boot/pxeboot&#34; ;

   # pxeboot boot loader will try to NFS mount this directory for root FS
   option root-path &#34;192.168.0.1:/b/tftpboot/FreeBSD/install/&#34; ;

}</pre>
</div>
</div>
<div class="paragraph">
<p><code>next-server</code> 指令用于指定 TFTP 服务器的 IP 地址。</p>
</div>
<div class="paragraph">
<p><code>filename</code> 指令定义了路径为 <span class="filename">/boot/pxeboot</span> 的文件名。使用的是相对路径，这意味着路径中不包括 <span class="filename">/b/tftpboot</span> 。</p>
</div>
<div class="paragraph">
<p><code>root-path</code> 选项定义了 NFS 根文件系统的路径。</p>
</div>
<div class="paragraph">
<p>在保存编辑后，通过将以下行添加到 <span class="filename">/etc/rc.conf</span> 来在启动时启用 DHCP ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>dhcpd_enable=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>然后启动 DHCP 服务：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># service isc-dhcpd start</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_调试_pxe_问题">34.10.3. 调试 PXE 问题<a class="anchor" href="#_调试_pxe_问题"></a></h4>
<div class="paragraph">
<p>一旦所有服务都配置并启动完成， PXE 客户端应该能够通过网络自动加载 FreeBSD 。如果某个特定的客户端无法连接，当该客户端机器启动时，进入 BIOS 配置菜单并确认其设置为从网络启动。</p>
</div>
<div class="paragraph">
<p>本节介绍了一些故障排除技巧，用于确定配置问题的根源，以防止任何客户端无法进行 PXE 引导。</p>
</div>
<div class="sidebarblock procedure">
<div class="content">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>使用 <a class="package" href="https://cgit.freebsd.org/ports/tree/net/wireshark/">net/wireshark</a> 包或端口来调试 PXE 引导过程中涉及的网络流量，如下图所示。</p>
<div class="imageblock">
<div class="content">
<img src="../../../../images/books/handbook/advanced-networking/pxe-nfs.png" alt="pxe nfs"/>
</div>
<div class="title">图 61. PXE 引导过程与 NFS 根目录挂载</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>客户端广播一个 DHCPDISCOVER 消息。</p>
</li>
<li>
<p>DHCP 服务器响应 IP 地址、 next-server 、 filename 和 root-path 的值。</p>
</li>
<li>
<p>客户端向 next-server 发送一个 TFTP 请求，请求检索文件名。</p>
</li>
<li>
<p>TFTP 服务器响应并向客户端发送文件名。</p>
</li>
<li>
<p>客户端执行文件名为 pxeboot(8) ，然后加载内核。当内核执行时，通过 root-path 指定的根文件系统将通过 NFS 挂载。</p>
</li>
</ol>
</div>
</li>
<li>
<p>在 TFTP 服务器上，读取 [/var/log/xferlog] 以确保从正确的位置检索到 [pxeboot] 。要测试此示例配置：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># tftp 192.168.0.1</span>
<span class="gp">tftp&gt; </span>get FreeBSD/install/boot/pxeboot
Received 264951 bytes <span class="k">in </span>0.1 seconds</code></pre>
</div>
</div>
<div class="paragraph">
<p>在 <a href="https://man.freebsd.org/cgi/man.cgi?query=tftpd&amp;sektion=8&amp;format=html">tftpd(8)</a> 和 <a href="https://man.freebsd.org/cgi/man.cgi?query=tftp&amp;sektion=1&amp;format=html">tftp(1)</a> 中的 <code>BUGS</code> 部分记录了 TFTP 的一些限制。</p>
</div>
</li>
<li>
<p>确保可以通过 NFS 挂载根文件系统。要测试此示例配置，请执行以下操作：</p>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt</span></code></pre>
</div>
</div>
</li>
<li>
<p>对于基于 UEFI PXE 的引导，请将 <span class="filename">boot/pxeboot</span> 文件替换为 <span class="filename">boot/loader.efi</span> 文件：</p>
</li>
</ol>
</div>
<div class="literalblock">
<div class="content">
<pre># chroot ${NFSROOTDIR}
# mv boot/pxeboot boot/pxeboot.original
# cp boot/loader.efi boot/pxeboot</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="carp">34.11. 常见地址冗余协议（ CARP ）<a class="anchor" href="#carp"></a></h3>
<div class="paragraph">
<p>通用地址冗余协议（ CARP ）允许多个主机共享相同的 IP 地址和虚拟主机 ID （ VHID ），以提供一个或多个服务的高可用性。这意味着一个或多个主机可能会失败，而其他主机将自动接管，使用户无法看到服务中断。</p>
</div>
<div class="paragraph">
<p>除了共享的 IP 地址外，每个主机还有自己的 IP 地址用于管理和配置。共享同一个 IP 地址的所有机器具有相同的 VHID 。每个虚拟 IP 地址的 VHID 必须在网络接口的广播域中是唯一的。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 中，使用 CARP 实现高可用性是内置的，尽管根据 FreeBSD 的版本不同，配置步骤可能略有不同。本节提供了适用于 FreeBSD 10 版本之前、以及等于或之后版本的相同示例配置。</p>
</div>
<div class="paragraph">
<p>这个示例配置了三个主机的故障转移支持，每个主机都有唯一的 IP 地址，但提供相同的网页内容。它有两个不同的主服务器，分别命名为 <code>hosta.example.org</code> 和 <code>hostb.example.org</code> ，还有一个共享备份命名为 <code>hostc.example.org</code> 。</p>
</div>
<div class="paragraph">
<p>这些机器使用循环轮询 DNS 配置进行负载均衡。主备机器的配置完全相同，只是主机名和管理 IP 地址不同。这些服务器必须具有相同的配置并运行相同的服务。当发生故障切换时，只有当备份服务器可以访问相同的内容时，才能正确地回答共享 IP 地址上的服务请求。备份机器还有两个额外的 CARP 接口，分别用于主内容服务器的每个 IP 地址。当发生故障时，备份服务器将接管失败的主机器的 IP 地址。</p>
</div>
<div class="sect3">
<h4 id="carp-10x">34.11.1. 在 FreeBSD 10 及更高版本上使用 CARP<a class="anchor" href="#carp-10x"></a></h4>
<div class="paragraph">
<p>通过在 <code>/boot/loader.conf</code> 中为 <code>carp.ko</code> 内核模块添加条目，启用 CARP 的启动时支持。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>carp_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>立即加载模块而无需重新启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload carp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于喜欢使用自定义内核的用户，请在自定义内核配置文件中包含以下行，并按照 <a href="./#kernelconfig">Configuring the FreeBSD Kernel</a> 中描述的方式编译内核。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device	carp</pre>
</div>
</div>
<div class="paragraph">
<p>主机名、管理 IP 地址和子网掩码、共享 IP 地址以及 VHID 都是通过向 <span class="filename">/etc/rc.conf</span> 添加条目来设置的。以下示例适用于 <code>hosta.example.org</code> ：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hosta.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 pass testpass alias 192.168.1.50/32&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>下一组条目是针对 <code>hostb.example.org</code> 的。由于它代表了第二个主机，所以它使用了不同的共享 IP 地址和 VHID 。然而，使用 <code>pass</code> 指定的密码必须相同，因为 CARP 只会监听和接受来自具有正确密码的机器的广告。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hostb.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 2 pass testpass alias 192.168.1.51/32&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>第三台机器 <code>hostc.example.org</code> 配置为处理来自任一主机的故障转移。该机器配置了两个 CARPVHID ，一个用于处理每个主机的虚拟 IP 地址。 CARP 广告偏差 <code>advskew</code> 被设置为确保备份主机比主机广告晚，因为 <code>advskew</code> 控制多个备份服务器时的优先顺序。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hostc.example.org&#34;
ifconfig_em0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
ifconfig_em0_alias0=&#34;inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32&#34;
ifconfig_em0_alias1=&#34;inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>配置了两个 CARPVHID 意味着 <code>hostc.example.org</code> 将会注意到主服务器中的任何一个不可用。如果主服务器在备份服务器之前无法进行广告宣传，备份服务器将会接管共享 IP 地址，直到主服务器再次可用。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>如果原始主服务器再次可用， <code>hostc.example.org</code> 不会自动将虚拟 IP 地址释放给它。要实现这一点，必须启用抢占功能。该功能默认情况下是禁用的，可以通过 <code>net.inet.carp.preempt</code> 变量来控制。管理员可以强制备份服务器将 IP 地址返回给主服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig em0 vhid 1 state backup</span></code></pre>
</div>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>配置完成后，要么重新启动网络，要么重新启动每个系统。高可用性现在已启用。</p>
</div>
<div class="paragraph">
<p>CARP 功能可以通过 <a href="https://man.freebsd.org/cgi/man.cgi?query=sysctl&amp;sektion=8&amp;format=html">sysctl(8)</a> 变量来控制，这些变量在 <a href="https://man.freebsd.org/cgi/man.cgi?query=carp&amp;sektion=4&amp;format=html">carp(4)</a> 手册页中有详细说明。还可以使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=devd&amp;sektion=8&amp;format=html">devd(8)</a> 来触发 CARP 事件的其他操作。</p>
</div>
</div>
<div class="sect3">
<h4 id="carp-9x">34.11.2. 在 FreeBSD 9 及更早版本上使用 CARP<a class="anchor" href="#carp-9x"></a></h4>
<div class="paragraph">
<p>这些版本的 FreeBSD 的配置与前一节中描述的类似，只是首先必须创建一个 CARP 设备并在配置中引用它。</p>
</div>
<div class="paragraph">
<p>通过在 [/boot/loader.conf] 中加载 <span class="filename">if_carp.ko</span> 内核模块，启用 CARP 的启动时支持。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>if_carp_load=&#34;YES&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>立即加载模块而无需重新启动：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># kldload carp</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于喜欢使用自定义内核的用户，请在自定义内核配置文件中包含以下行，并按照 <a href="./#kernelconfig">Configuring the FreeBSD Kernel</a> 中描述的方式编译内核。</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>device	carp</pre>
</div>
</div>
<div class="paragraph">
<p>接下来，在每台主机上创建一个 CARP 设备：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig carp0 create</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>通过在 <span class="filename">/etc/rc.conf</span> 中添加所需的行，设置主机名、管理 IP 地址、共享 IP 地址和 VHID 。由于使用虚拟 CARP 设备而不是别名，所以使用实际的子网掩码 <code>/24</code> 而不是 <code>/32</code> 。以下是 <code>hosta.example.org</code> 的条目：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hosta.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.3 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 1 pass testpass 192.168.1.50/24&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>在 <code>hostb.example.org</code> 上：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hostb.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.4 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0&#34;
ifconfig_carp0=&#34;vhid 2 pass testpass 192.168.1.51/24&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>第三台机器 <code>hostc.example.org</code> 配置为处理来自任一主机的故障转移：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>hostname=&#34;hostc.example.org&#34;
ifconfig_fxp0=&#34;inet 192.168.1.5 netmask 255.255.255.0&#34;
cloned_interfaces=&#34;carp0 carp1&#34;
ifconfig_carp0=&#34;vhid 1 advskew 100 pass testpass 192.168.1.50/24&#34;
ifconfig_carp1=&#34;vhid 2 advskew 100 pass testpass 192.168.1.51/24&#34;</pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在 <span class="filename">GENERIC</span> FreeBSD 内核中禁用了抢占。如果使用自定义内核启用了抢占， <code>hostc.example.org</code> 可能无法将 IP 地址释放回原始内容服务器。管理员可以使用以下命令强制备份服务器将 IP 地址返回给主服务器：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig carp0 down &amp;&amp; ifconfig carp0 up</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>这应该在与正确主机对应的 <span class="filename">carp</span> 接口上完成。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>配置完成后，要么重新启动网络，要么重新启动每个系统。高可用性现在已启用。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="network-vlan">34.12. 虚拟局域网（ VLANs ）<a class="anchor" href="#network-vlan"></a></h3>
<div class="paragraph">
<p>VLAN （虚拟局域网）是一种将网络虚拟分割成许多不同子网络的方法，也被称为分段。每个分段都有自己的广播域，并与其他 VLAN 隔离开来。</p>
</div>
<div class="paragraph">
<p>在 FreeBSD 上， VLAN 必须由网络适配器驱动程序支持。要查看哪些驱动程序支持 VLAN ，请参考 <a href="https://man.freebsd.org/cgi/man.cgi?query=vlan&amp;sektion=4&amp;format=html">vlan(4)</a> 手册页。</p>
</div>
<div class="paragraph">
<p>配置 VLAN 时，需要了解一些信息。首先，是哪个网络接口？其次， VLAN 标签是什么？</p>
</div>
<div class="paragraph">
<p>要在运行时配置 VLAN ，使用网卡 <code>em0</code> 和 VLAN 标签 <code>5</code> ，命令如下：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24</span></code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>看到接口名称包括了网卡驱动名称和 VLAN 标签，用句点分隔吗？这是一种最佳实践，可以在一个机器上存在多个 VLAN 时，方便维护 VLAN 配置。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>要在启动时配置 VLAN ，必须更新 <code>/etc/rc.conf</code> 文件。要复制上述配置，需要添加以下内容：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vlans_em0=&#34;5&#34;
ifconfig_em0_5=&#34;inet 192.168.20.20/24&#34;</pre>
</div>
</div>
<div class="paragraph">
<p>可以通过简单地将标签添加到 <code>vlans_em0</code> 字段，并添加一行额外的配置网络的代码来添加其他 VLAN 。</p>
</div>
<div class="paragraph">
<p>为了在关联的硬件发生更改时只需要更新少量配置变量，给接口分配一个符号名称是很有用的。例如，安全摄像头需要在 <code>em0</code> 上运行 VLAN 1 。如果以后将 <code>em0</code> 卡替换为使用 <a href="https://man.freebsd.org/cgi/man.cgi?query=ixgb&amp;sektion=4&amp;format=html">ixgb(4)</a> 驱动程序的卡，所有对 <code>em0.1</code> 的引用都不需要更改为 <code>ixgb0.1</code> 。</p>
</div>
<div class="paragraph">
<p>要配置 VLAN <code>5</code> ，在网卡 <code>em0</code> 上分配接口名称 <code>cameras</code> ，并为接口分配 IP 地址 <code><em>192.168.20.20</em></code> ，使用 <code>24</code> 位前缀，使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet 192.168.20.20/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>对于名为 <code>video</code> 的接口，请使用以下内容：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># ifconfig video.5 create vlan 5 vlandev video name cameras inet 192.168.20.20/24</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要在启动时应用更改，请将以下行添加到 [/etc/rc.conf] 文件中：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>vlans_video=&#34;cameras&#34;
create_args_cameras=&#34;vlan 5&#34;
ifconfig_cameras=&#34;inet 192.168.20.20/24&#34;</pre>
</div>
</div>
</div>
</div>
</div>
<h1 id="appendices" class="sect0">Part V: 附录<a class="anchor" href="#appendices"></a></h1>
<div class="sect1">
<h2 id="_获取_freebsd">附录 A: 获取 FreeBSD<a class="anchor" href="#_获取_freebsd"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>您可以通过以下方式获取 FreeBSD ：
:doctype: book
:toc: macro
:toclevels: 1
:icons: font
:sectnums:
:sectnumlevels: 6
:sectnumoffset: A
:partnums:
:source-highlighter: rouge
:experimental:
:images-path: books/handbook/mirrors/</p>
</div>
<div class="sect2">
<h3 id="mirrors">镜像<a class="anchor" href="#mirrors"></a></h3>
<div class="paragraph">
<p>FreeBSD 项目的官方镜像由项目集群管理员操作的多台机器组成，并且通过 GeoDNS 进行管理，以将用户引导到最近的可用镜像。当前的镜像位置包括澳大利亚、巴西、德国、日本（两个站点）、马来西亚、南非、台湾、英国和美国（加利福尼亚州、新泽西州和华盛顿州）。</p>
</div>
<div class="paragraph">
<p>官方镜像服务：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 60%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">服务名称</th>
<th class="tableblock halign-left valign-top">协议</th>
<th class="tableblock halign-left valign-top">更多信息</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>docs.FreeBSD.org</strong> 是一个提供 FreeBSD 操作系统文档的网站。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://docs.FreeBSD.org/" class="bare">https://docs.FreeBSD.org/</a></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FreeBSD 文档门户网站。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>download.FreeBSD.org</strong> 是一个提供 FreeBSD 操作系统下载的网站。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://download.FreeBSD.org/" class="bare">https://download.FreeBSD.org/</a> [https] 链接： <a href="ftp://download.FreeBSD.org/pub/FreeBSD/" class="bare">ftp://download.FreeBSD.org/pub/FreeBSD/</a> [ftp]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">与 <code>ftp.FreeBSD.org</code> 相同的内容， <code>ftp</code> 是一个遗留的名称；推荐使用 <code>download.FreeBSD.org</code> 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>git.FreeBSD.org</strong> 是一个用于 FreeBSD 操作系统的 Git 代码托管服务。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 <code>https</code> 和 <code>ssh</code> 使用 git</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">更多详细信息请参考链接： <a href="https://docs.freebsd.org/en/books/handbook/mirrors/#git">使用 git</a> 部分。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>pkg.FreeBSD.org</strong> 是一个用于 FreeBSD 操作系统的软件包管理系统。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 可以通过 <code>http</code> 和 <code>https</code> 进行下载。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="https://man.freebsd.org/cgi/man.cgi?query=pkg&amp;sektion=8&amp;format=html">pkg(8)</a> 程序使用的官方 FreeBSD 软件包仓库。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>vuxml.FreeBSD.org</strong> / <strong>www.VuXML.org</strong> 是一个网站，用于发布和维护 FreeBSD 操作系统的安全漏洞信息。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://www.vuxml.org/" class="bare">https://www.vuxml.org/</a> [https]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FreeBSD 项目的 VuXML 网页。 <code>pkg audit</code> 从该服务获取漏洞列表。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock"><strong>www.FreeBSD.org</strong></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://www.FreeBSD.org/" class="bare">https://www.FreeBSD.org/</a> [https]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">FreeBSD 网站。</p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>所有官方镜像都支持 IPv4 和 IPv6 。</p>
</div>
<div class="paragraph">
<p><a href="http://ftp-archive.FreeBSD.org" class="bare">http://ftp-archive.FreeBSD.org</a> 不在 GeoDNS 基础设施中，只托管在一个地点（美国）。</p>
</div>
<div class="paragraph">
<p>该项目正在寻找新的场地；愿意赞助的人，请联系集群管理员团队获取更多信息。</p>
</div>
<div class="paragraph">
<p>由社区和其他公司维护的镜像列表：</p>
</div>
<table class="tableblock frame-all grid-all stretch">
<colgroup>
<col style="width: 20%;"/>
<col style="width: 20%;"/>
<col style="width: 60%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">国家</th>
<th class="tableblock halign-left valign-top">主机名</th>
<th class="tableblock halign-left valign-top">协议</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">澳大利亚图标： envelope[link = mailto:hostmaster@au.FreeBSD.org , title =&#34;镜像联系&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.au.FreeBSD.org 是一个位于澳大利亚的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.au.FreeBSD.org/pub/FreeBSD">http</a> 链接： <a href="http://ftp.au.FreeBSD.org/pub/FreeBSD">http_v6</a> 链接： rsync://ftp.au.FreeBSD.org[rsync] 链接： rsync://ftp.au.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp3.au.FreeBSD.org 是一个位于澳大利亚的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp3.au.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp3.au.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp3.au.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp3.au.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp3.au.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp3.au.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp3.au.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp3.au.FreeBSD.org/pub/FreeBSD</a>)
链接： [rsync://ftp3.au.FreeBSD.org](rsync://ftp3.au.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">奥地利图标： envelope[link = mailto:hostmaster@at.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.at.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.at.FreeBSD.org/pub/FreeBSD/">http</a>
链接： <a href="http://ftp.at.FreeBSD.org/pub/FreeBSD/">http_v6</a>
链接： <a href="ftp://ftp.at.FreeBSD.org/pub/FreeBSD/">ftp</a>
链接： <a href="ftp://ftp.at.FreeBSD.org/pub/FreeBSD/">ftp_v6</a>
链接： rsync://ftp.at.FreeBSD.org/pub/FreeBSD/[rsync]
链接： rsync://ftp.at.FreeBSD.org/pub/FreeBSD/[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">巴西图标： envelope[link = mailto:hostmaster@br.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.br.FreeBSD.org 是一个位于巴西的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp2.br.FreeBSD.org/FreeBSD">http</a>
链接： rsync://ftp2.br.FreeBSD.org[rsync]
链接： rsync://ftp2.br.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp3.br.FreeBSD.org 是一个位于巴西的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp3.br.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp3.br.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp3.br.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp3.br.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp3.br.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp3.br.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp3.br.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp3.br.FreeBSD.org/pub/FreeBSD</a>)
链接： [rsync://ftp3.br.FreeBSD.org](rsync://ftp3.br.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">保加利亚图标： envelope[link = mailto:mirror@telepoint.bg , title =&#34;镜像联系人&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.bg.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="ftp://ftp.bg.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： <a href="ftp://ftp.bg.FreeBSD.org/pub/FreeBSD">ftp_v6</a> 链接： rsync://ftp.bg.FreeBSD.org[rsync] 链接： rsync://ftp.bg.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">捷克共和国图标： envelope[link = mailto:hostmaster@cz.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.cz.FreeBSD.org 是一个位于捷克共和国的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.cz.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp.cz.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： rsync://ftp.cz.FreeBSD.org[rsync]
链接： rsync://ftp.cz.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">丹麦图标： envelope[link = mailto:staff@dotsrc.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.dk.FreeBSD.org 是一个位于丹麦的 FreeBSD 软件的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.dk.FreeBSD.org/FreeBSD/">http</a>
链接： <a href="http://ftp.dk.FreeBSD.org/FreeBSD/">http_v6</a>
链接： <a href="ftp://ftp.dk.FreeBSD.org/FreeBSD/">ftp</a>
链接： <a href="ftp://ftp.dk.FreeBSD.org/FreeBSD/">ftp_v6</a>
链接： rsync://ftp.dk.FreeBSD.org/FreeBSD/[rsync]
链接： rsync://ftp.dk.FreeBSD.org/FreeBSD/[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">芬兰图标： envelope[link = mailto:hostmaster@fi.FreeBSD.org , title =&#34;镜像联系人&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.fi.FreeBSD.org 是一个位于芬兰的 FreeBSD 软件下载站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="ftp://ftp.fi.FreeBSD.org/pub/FreeBSD">ftp</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">法国图标： envelope[link = mailto:hostmaster@fr.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.fr.FreeBSD.org 是一个位于法国的 FTP 服务器，用于下载 FreeBSD 操作系统和相关软件。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.fr.FreeBSD.org/pub/FreeBSD">http</a> 链接： <a href="http://ftp.fr.FreeBSD.org/pub/FreeBSD">http_v6</a> 链接： <a href="ftp://ftp.fr.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： <a href="ftp://ftp.fr.FreeBSD.org/pub/FreeBSD">ftp_v6</a> 链接： rsync://ftp.fr.FreeBSD.org[rsync] 链接： rsync://ftp.fr.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp3.fr.FreeBSD.org 是一个位于法国的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="ftp://ftp3.fr.FreeBSD.org/pub/FreeBSD">ftp</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp6.fr.FreeBSD.org 是一个位于法国的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和更新。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp6.fr.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp6.fr.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp6.fr.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp6.fr.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp6.fr.FreeBSD.org/pub/FreeBSD</a>)
链接： [rsync://ftp6.fr.FreeBSD.org](rsync://ftp6.fr.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">德国图标： envelope[link = mailto:de-bsd-hubs@de.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.de.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接 : <a href="ftp://ftp.de.FreeBSD.org/pub/FreeBSD">ftp</a> 链接 : <a href="ftp://ftp.de.FreeBSD.org/pub/FreeBSD">ftp_v6</a> 链接 : rsync://ftp.de.FreeBSD.org[rsync] 链接 : rsync://ftp.de.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp1.de.FreeBSD.org 是一个位于德国的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp1.de.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp1.de.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp1.de.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp1.de.FreeBSD.org/pub/FreeBSD">ftp_v6</a>
链接： rsync://ftp1.de.FreeBSD.org[rsync]
链接： rsync://ftp1.de.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.de.FreeBSD.org 是一个位于德国的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp2.de.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp2.de.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp2.de.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp2.de.FreeBSD.org/pub/FreeBSD">ftp_v6</a>
链接： rsync://ftp2.de.FreeBSD.org[rsync]
链接： rsync://ftp2.de.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp5.de.FreeBSD.org 是一个位于德国的 FreeBSD 软件下载站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接 : <a href="ftp://ftp5.de.FreeBSD.org/pub/FreeBSD">ftp</a> 链接 : <a href="ftp://ftp5.de.FreeBSD.org/pub/FreeBSD">ftp_v6</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp7.de.FreeBSD.org 是一个位于德国的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp7.de.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp7.de.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp7.de.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp7.de.FreeBSD.org/pub/FreeBSD">ftp_v6</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">希腊图标： envelope[link = mailto:hostmaster@gr.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.gr.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.gr.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp.gr.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp.gr.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp.gr.FreeBSD.org/pub/FreeBSD">ftp_v6</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.gr.FreeBSD.org 是一个用于下载 FreeBSD 操作系统的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp2.gr.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp2.gr.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp2.gr.FreeBSD.org/pub/FreeBSD">ftp_v6</a>
链接： rsync://ftp2.gr.FreeBSD.org[rsync]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">日本图标： envelope[link = mailto:hostmaster@jp.FreeBSD.org , title =&#34;镜像联系&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.jp.FreeBSD.org 是一个位于日本的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和更新。用户可以通过该服务器访问和获取 FreeBSD 的安装镜像、软件包和补丁等资源。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.jp.FreeBSD.org/pub/FreeBSD">http</a> 链接： <a href="http://ftp.jp.FreeBSD.org/pub/FreeBSD">http_v6</a> 链接： <a href="ftp://ftp.jp.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： <a href="ftp://ftp.jp.FreeBSD.org/pub/FreeBSD">ftp_v6</a> 链接： rsync://ftp.jp.FreeBSD.org[rsync] 链接： rsync://ftp.jp.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.jp.FreeBSD.org 是一个位于日本的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="ftp://ftp2.jp.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： rsync://ftp2.jp.FreeBSD.org[rsync] 链接： rsync://ftp2.jp.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp3.jp.FreeBSD.org 是一个位于日本的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp3.jp.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp3.jp.FreeBSD.org/pub/FreeBSD</a> [http]
链接： rsync://ftp3.jp.FreeBSD.org [rsync]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp4.jp.FreeBSD.org 是一个位于日本的 FreeBSD 软件镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="ftp://ftp4.jp.FreeBSD.org/pub/FreeBSD">ftp</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp6.jp.FreeBSD.org 是一个位于日本的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和更新。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp6.jp.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp6.jp.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp6.jp.FreeBSD.org/pub/FreeBSD">ftp_v6</a>
链接： rsync://ftp6.jp.FreeBSD.org[rsync]
链接： rsync://ftp6.jp.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">哈萨克斯坦图标： envelope[link = mailto:support @ ps.kz , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">镜像 .ps.kz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><a href="http://mirror.ps.kz/freebsd">http</a> 链接： <a href="ftp://mirror.ps.kz/freebsd">ftp</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">镜像 .neolabs.kz</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://mirror.neolabs.kz/freebsd" class="bare">http://mirror.neolabs.kz/freebsd</a>](<a href="http://mirror.neolabs.kz/freebsd" class="bare">http://mirror.neolabs.kz/freebsd</a>)
链接： [<a href="ftp://mirror.neolabs.kz/freebsd" class="bare">ftp://mirror.neolabs.kz/freebsd</a>](<a href="ftp://mirror.neolabs.kz/freebsd" class="bare">ftp://mirror.neolabs.kz/freebsd</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">韩国图标： envelope[link = mailto:hostmaster@kr.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.kr.FreeBSD.org 是一个位于韩国的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.kr.FreeBSD.org/pub/FreeBSD">http</a> 链接： <a href="https://ftp.kr.FreeBSD.org/pub/FreeBSD">https</a> 链接： <a href="ftp://ftp.kr.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： rsync://ftp.kr.FreeBSD.org[rsync]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.kr.FreeBSD.org 是一个位于韩国的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： rsync://ftp2.kr.FreeBSD.org[rsync]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">拉脱维亚图标： envelope[link = mailto:hostmaster@lv.FreeBSD.org , title =&#34;镜像联系人&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.lv.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp.lv.FreeBSD.org/freebsd" class="bare">http://ftp.lv.FreeBSD.org/freebsd</a>](<a href="http://ftp.lv.FreeBSD.org/freebsd" class="bare">http://ftp.lv.FreeBSD.org/freebsd</a>)
链接： [<a href="ftp://ftp.lv.FreeBSD.org/freebsd" class="bare">ftp://ftp.lv.FreeBSD.org/freebsd</a>](<a href="ftp://ftp.lv.FreeBSD.org/freebsd" class="bare">ftp://ftp.lv.FreeBSD.org/freebsd</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">荷兰图标： envelope[link = mailto:hostmaster@nl.FreeBSD.org , title =&#34;镜像联系人&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.nl.FreeBSD.org 是一个位于荷兰的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.nl.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp.nl.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp.nl.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp.nl.FreeBSD.org/pub/FreeBSD">ftp_v6</a>
链接： rsync://ftp.nl.FreeBSD.org[rsync]
链接： rsync://ftp.nl.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.nl.FreeBSD.org 是一个位于荷兰的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp2.nl.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp2.nl.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp2.nl.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp2.nl.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp2.nl.FreeBSD.org/pub/FreeBSD</a>)
链接： [rsync://ftp2.nl.FreeBSD.org](rsync://ftp2.nl.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">mirror.nl.altushost.com 是一个网站的镜像地址。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://mirror.nl.altushost.com/FreeBSD">https</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">新西兰图标： envelope[link = mailto:hostmaster@nz.FreeBSD.org , title =&#34;镜像联系人&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.nz.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp.nz.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.nz.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp.nz.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.nz.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp.nz.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.nz.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp.nz.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.nz.FreeBSD.org/pub/FreeBSD</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">挪威图标： envelope[link = mailto:hostmaster@no.FreeBSD.org , title =&#34;镜像联系人&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.no.FreeBSD.org 是一个免费的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="ftp://ftp.no.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： <a href="ftp://ftp.no.FreeBSD.org/pub/FreeBSD">ftp_v6</a> 链接： rsync://ftp.no.FreeBSD.org[rsync] 链接： rsync://ftp.no.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">波兰图标： envelope[link = mailto:hostmaster@pl.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.pl.FreeBSD.org 是一个用于下载 FreeBSD 操作系统的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp.pl.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.pl.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp.pl.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.pl.FreeBSD.org/pub/FreeBSD</a>)
链接： [http_v6://ftp.pl.FreeBSD.org/pub/FreeBSD](http_v6://ftp.pl.FreeBSD.org/pub/FreeBSD)
链接： [<a href="ftp://ftp.pl.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.pl.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp.pl.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.pl.FreeBSD.org/pub/FreeBSD</a>)
链接： [rsync://ftp.pl.FreeBSD.org](rsync://ftp.pl.FreeBSD.org)
链接： [rsync_v6://ftp.pl.FreeBSD.org](rsync_v6://ftp.pl.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">俄罗斯图标： envelope[link = mailto:hostmaster@ru.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.ru.FreeBSD.org 是一个免费的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.ru.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp.ru.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp.ru.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp.ru.FreeBSD.org/pub/FreeBSD">ftp_v6</a>
链接： rsync://ftp.ru.FreeBSD.org[rsync]
链接： rsync://ftp.ru.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.ru.FreeBSD.org 是一个免费的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://ftp2.ru.FreeBSD.org/pub/FreeBSD">https</a> 链接： <a href="ftp://ftp2.ru.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： rsync://ftp2.ru.FreeBSD.org[rsync]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">斯洛文尼亚图标： envelope[link = mailto:hostmaster@si.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.si.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.si.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp.si.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp.si.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp.si.FreeBSD.org/pub/FreeBSD">ftp_v6</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">南非图标： envelope[link = mailto:hostmaster@za.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.za.FreeBSD.org 是一个用于下载 FreeBSD 操作系统的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://ftp.za.FreeBSD.org/pub/FreeBSD">https</a> 链接： <a href="https://ftp.za.FreeBSD.org/pub/FreeBSD">https_v6</a> 链接： rsync://ftp.za.FreeBSD.org[rsync] 链接： rsync://ftp.za.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.za.FreeBSD.org 是一个免费的 FTP 服务器，用于提供 FreeBSD 操作系统的下载和访问。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp2.za.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp2.za.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp2.za.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp2.za.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="http://ftp2.za.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp2.za.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp2.za.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp2.za.FreeBSD.org/pub/FreeBSD</a>) （ IPv6 ）
链接： [<a href="ftp://ftp2.za.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp2.za.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp2.za.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp2.za.FreeBSD.org/pub/FreeBSD</a>) （ IPv6 ）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp4.za.FreeBSD.org 是一个位于南非的 FreeBSD 软件下载站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp4.za.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp4.za.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp4.za.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp4.za.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp4.za.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp4.za.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp4.za.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp4.za.FreeBSD.org/pub/FreeBSD</a>)
链接： [rsync://ftp4.za.FreeBSD.org](rsync://ftp4.za.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">瑞典图标： envelope[link = mailto:hostmaster@se.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.se.FreeBSD.org 是一个位于瑞典的 FreeBSD 软件的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp.se.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.se.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp.se.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.se.FreeBSD.org/pub/FreeBSD</a>)
链接： [http_v6://ftp.se.FreeBSD.org/pub/FreeBSD](http_v6://ftp.se.FreeBSD.org/pub/FreeBSD)
链接： [<a href="ftp://ftp.se.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.se.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp.se.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.se.FreeBSD.org/pub/FreeBSD</a>)
链接： [ftp_v6://ftp.se.FreeBSD.org/pub/FreeBSD](ftp_v6://ftp.se.FreeBSD.org/pub/FreeBSD)
链接： [rsync://ftp.se.FreeBSD.org](rsync://ftp.se.FreeBSD.org)
链接： [rsync_v6://ftp.se.FreeBSD.org](rsync_v6://ftp.se.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">镜像地址： mirror.se.altushost.com</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://mirror.se.altushost.com/FreeBSD">https</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">台湾图标： envelope[link = mailto:hostmaster@tw.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp4.tw.FreeBSD.org 是一个位于台湾的 FreeBSD 软件下载站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="https://ftp4.tw.FreeBSD.org/pub/FreeBSD">https</a> 链接： <a href="ftp://ftp4.tw.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： rsync://ftp4.tw.FreeBSD.org[rsync]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp5.tw.FreeBSD.org 是一个位于台湾的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp5.tw.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp5.tw.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp5.tw.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp5.tw.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp5.tw.FreeBSD.org/pub/FreeBSD</a>)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">乌克兰图标： envelope[link = mailto:hostmaster@ua.FreeBSD.org , title =&#34;镜像联系方式&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.ua.FreeBSD.org 是一个提供 FreeBSD 操作系统下载的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： [<a href="http://ftp.ua.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.ua.FreeBSD.org/pub/FreeBSD</a>](<a href="http://ftp.ua.FreeBSD.org/pub/FreeBSD" class="bare">http://ftp.ua.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp.ua.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.ua.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp.ua.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.ua.FreeBSD.org/pub/FreeBSD</a>)
链接： [<a href="ftp://ftp.ua.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.ua.FreeBSD.org/pub/FreeBSD</a>](<a href="ftp://ftp.ua.FreeBSD.org/pub/FreeBSD" class="bare">ftp://ftp.ua.FreeBSD.org/pub/FreeBSD</a>)
链接： [rsync://ftp.ua.FreeBSD.org](rsync://ftp.ua.FreeBSD.org)
链接： [rsync://ftp.ua.FreeBSD.org](rsync://ftp.ua.FreeBSD.org)</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">英国图标： envelope[link = mailto:hostmaster@uk.FreeBSD.org , title =&#34;镜像联系人&#34;]</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp.uk.FreeBSD.org 是一个位于英国的 FreeBSD 软件下载站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp.uk.FreeBSD.org/pub/FreeBSD">http</a> 链接： <a href="http://ftp.uk.FreeBSD.org/pub/FreeBSD">http_v6</a> 链接： <a href="ftp://ftp.uk.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： <a href="ftp://ftp.uk.FreeBSD.org/pub/FreeBSD">ftp_v6</a> 链接： rsync://ftp.uk.FreeBSD.org[rsync] 链接： rsync://ftp.uk.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp2.uk.FreeBSD.org 是一个位于英国的 FreeBSD 镜像站点。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp2.uk.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp2.uk.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="https://ftp2.uk.FreeBSD.org/pub/FreeBSD">https</a>
链接： <a href="https://ftp2.uk.FreeBSD.org/pub/FreeBSD">https_v6</a>
链接： <a href="ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp2.uk.FreeBSD.org/pub/FreeBSD">ftp_v6</a></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">美利坚合众国 <span class="icon"><a class="image" href="mailto:hostmaster@us.FreeBSD.org"><i class="fa fa-envelope" title="镜像联系方式"></i></a></span></p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp11.FreeBSD.org 是一个用于下载 FreeBSD 操作系统的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp11.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp11.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp11.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp11.FreeBSD.org/pub/FreeBSD">ftp_v6</a>
链接： rsync://ftp11.FreeBSD.org[rsync]
链接： rsync://ftp11.FreeBSD.org[rsync_v6]</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp14.FreeBSD.org 是一个用于下载 FreeBSD 操作系统的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="ftp://ftp14.FreeBSD.org/pub/FreeBSD">ftp</a> 链接： rsync://ftp14.FreeBSD.org[rsync] （前官方一级镜像）</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">ftp5.FreeBSD.org 是一个用于下载 FreeBSD 操作系统的 FTP 服务器。</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock">链接： <a href="http://ftp5.FreeBSD.org/pub/FreeBSD">http</a>
链接： <a href="http://ftp5.FreeBSD.org/pub/FreeBSD">http_v6</a>
链接： <a href="ftp://ftp5.FreeBSD.org/pub/FreeBSD">ftp</a>
链接： <a href="ftp://ftp5.FreeBSD.org/pub/FreeBSD">ftp_v6</a></p></td>
</tr>
</tbody>
</table>
<div class="paragraph">
<p>社区镜像支持的协议列表最近更新于 2022 年 1 月 31 日，但不保证实时更新。</p>
</div>
</div>
<div class="sect2">
<h3 id="git">使用 Git<a class="anchor" href="#git"></a></h3>
<div class="sect3">
<h4 id="git-intro">介绍<a class="anchor" href="#git-intro"></a></h4>
<div class="paragraph">
<p>截至 2020 年 12 月， FreeBSD 使用 git 作为存储所有 FreeBSD 基础源代码和文档的主要版本控制系统。截至 2021 年 4 月， FreeBSD 使用 git 作为存储所有 FreeBSD Ports 集合的唯一版本控制系统。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Git 通常是开发者工具。用户可能更喜欢使用 <code>freebsd-update</code> （参见： cutting-edge[updating-upgrading-freebsdupdate ，“ FreeBSD Update ”] ）来更新 FreeBSD 基本系统，以及使用 <code>git</code> （参见： ports[ports-using ，“使用 Ports Collection ”] ）来更新 FreeBSD Ports Collection 。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本节演示了如何在 FreeBSD 系统上安装 Git ，并使用它创建一个 FreeBSD 源代码仓库的本地副本。</p>
</div>
</div>
<div class="sect3">
<h4 id="git-install">安装<a class="anchor" href="#git-install"></a></h4>
<div class="paragraph">
<p>Git 可以从 Ports Collection 安装，也可以作为一个软件包安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install git</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="git-usage">运行 Git<a class="anchor" href="#git-usage"></a></h4>
<div class="paragraph">
<p>要将源代码的干净副本获取到本地目录中，使用 <code>git clone</code> 命令。这个文件目录被称为 <em>工作树</em>。</p>
</div>
<div class="paragraph">
<p>Git 使用 URL 来指定一个仓库。有三个不同的仓库， <code>src</code> 用于 FreeBSD 系统源代码， <code>doc</code> 用于文档， <code>ports</code> 用于 FreeBSD Ports 集合。这三个仓库都可以通过两种不同的协议访问： HTTPS 和 SSH 。例如， URL <code><a href="https://git.FreeBSD.org/src.git" class="bare">https://git.FreeBSD.org/src.git</a></code> 指定了 <code>src</code> 仓库的主分支，使用 <code>https</code> 协议。</p>
</div>
<table id="git-url-table" class="tableblock frame-all grid-all stretch">
<caption class="title">表 47. FreeBSD Git 仓库 URL 表格</caption>
<colgroup>
<col style="width: 50%;"/>
<col style="width: 50%;"/>
</colgroup>
<thead>
<tr>
<th class="tableblock halign-left valign-top">项目</th>
<th class="tableblock halign-left valign-top">Git URL 是指指向 Git 仓库的统一资源定位符。</th>
</tr>
</thead>
<tbody>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 HTTPS 访问只读源代码仓库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="https://git.FreeBSD.org/src.git" class="bare">https://git.FreeBSD.org/src.git</a></code></p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过匿名 SSH 只读访问源代码仓库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssh://anongit @ git.FreeBSD.org/src.git</code> 是一个指向 FreeBSD 源代码仓库的 SSH 链接。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 HTTPS 访问的只读文档仓库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="https://git.FreeBSD.org/doc.git" class="bare">https://git.FreeBSD.org/doc.git</a></code> 是一个指向 FreeBSD 文档存储库的 URL 。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过匿名 SSH 访问的只读文档仓库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssh://anongit @ git.FreeBSD.org/doc.git</code> 是一个指向 FreeBSD 文档仓库的 SSH 链接。</p></td>
</tr>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过 HTTPS 访问只读端口的代码仓库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code><a href="https://git.FreeBSD.org/ports.git" class="bare">https://git.FreeBSD.org/ports.git</a></code> 是一个指向 FreeBSD ports 仓库的 URL 。</p></td>
</tr>
</tbody>
<tfoot>
<tr>
<td class="tableblock halign-left valign-top"><p class="tableblock">通过匿名 SSH 访问只读端口的代码仓库</p></td>
<td class="tableblock halign-left valign-top"><p class="tableblock"><code>ssh://anongit @ git.FreeBSD.org/ports.git</code> 是一个指向 FreeBSD 软件包集合的 Git 仓库的 SSH 链接。</p></td>
</tr>
</tfoot>
</table>
<div class="paragraph">
<p>项目成员维护的外部镜像也可用；请参考 <a href="#external-mirrors">外部镜像源</a> 部分。</p>
</div>
<div class="paragraph">
<p>要克隆 FreeBSD 系统源代码仓库的副本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># git clone -o freebsd https://git.FreeBSD.org/src.git /usr/src</span></code></pre>
</div>
</div>
<div class="paragraph">
<p><code>-o freebsd</code> 选项指定了源；按照 FreeBSD 文档的约定，源被假定为 <code>freebsd</code> 。由于初始检出必须下载远程存储库的完整分支，可能需要一些时间。请耐心等待。</p>
</div>
<div class="paragraph">
<p>最初，工作树包含了与 CURRENT 对应的 <code>main</code> 分支的源代码。要切换到 13-STABLE 分支，可以执行以下操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># git checkout stable/13</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>可以使用 <code>git pull</code> 命令更新工作树。要更新上面示例中创建的文件 <code>/usr/src</code> ，请使用：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># git pull --rebase</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>更新比检出要快得多，只传输已更改的文件。</p>
</div>
</div>
<div class="sect3">
<h4 id="_基于_web_的代码仓库浏览器">基于 Web 的代码仓库浏览器<a class="anchor" href="#_基于_web_的代码仓库浏览器"></a></h4>
<div class="paragraph">
<p>FreeBSD 项目使用 cgit 作为基于 Web 的存储库浏览器： <a href="https://cgit.FreeBSD.org/">https://cgit.FreeBSD.org/</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="_开发者指南">开发者指南<a class="anchor" href="#_开发者指南"></a></h4>
<div class="paragraph">
<p>有关对存储库的写访问权限的信息，请参阅 <a href="{committers-guide}#git-mini-primer">Committer’s Guide</a> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="external-mirrors">外部镜像源<a class="anchor" href="#external-mirrors"></a></h4>
<div class="paragraph">
<p>这些镜像不托管在 FreeBSD.org 上，但仍由项目成员维护。用户和开发者可以在这些镜像上拉取或浏览存储库。 <code>doc</code> 和 <code>src</code> GitHub 存储库的拉取请求正在接受；否则，与这些镜像的项目工作流程仍在讨论中。</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">Codeberg 是一个基于 Git 的开源代码托管平台。它提供了类似于 GitHub 的功能，允许开发者在上面创建和管理代码仓库，并与其他开发者进行协作。 Codeberg 致力于保护用户的隐私和数据安全，并且完全开放源代码。它是一个社区驱动的平台，旨在为开源项目提供一个自由、开放和可持续的托管解决方案。</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>文档： <a href="https://codeberg.org/FreeBSD/freebsd-doc" class="bare">https://codeberg.org/FreeBSD/freebsd-doc</a></p>
</li>
<li>
<p>端口： <a href="https://codeberg.org/FreeBSD/freebsd-ports" class="bare">https://codeberg.org/FreeBSD/freebsd-ports</a></p>
</li>
<li>
<p>源代码： <a href="https://codeberg.org/FreeBSD/freebsd-src" class="bare">https://codeberg.org/FreeBSD/freebsd-src</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">GitHub 是一个基于云端的代码托管平台，它提供了版本控制、协作功能和项目管理工具。开发者可以使用 GitHub 来存储、管理和共享他们的代码，并与其他开发者进行协作。 GitHub 还提供了一系列的功能，如问题跟踪、代码审查和持续集成，以帮助开发者更好地管理和维护他们的项目。</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>文档： <a href="https://github.com/freebsd/freebsd-doc" class="bare">https://github.com/freebsd/freebsd-doc</a></p>
</li>
<li>
<p>端口： <a href="https://github.com/freebsd/freebsd-ports" class="bare">https://github.com/freebsd/freebsd-ports</a></p>
</li>
<li>
<p>源代码： <a href="https://github.com/freebsd/freebsd-src" class="bare">https://github.com/freebsd/freebsd-src</a></p>
</li>
</ul>
</div>
</dd>
<dt class="hdlist1">GitLab 是一个基于 Web 的 Git 仓库管理工具，它提供了版本控制、问题跟踪、持续集成等功能。 GitLab 是一个开源项目，可以自己搭建私有的 Git 仓库，也可以使用 GitLab 提供的托管服务。它是一个功能强大且易于使用的工具，被广泛用于软件开发团队的协作和代码管理。</dt>
<dd>
<div class="ulist">
<ul>
<li>
<p>文档： <a href="https://gitlab.com/FreeBSD/freebsd-doc" class="bare">https://gitlab.com/FreeBSD/freebsd-doc</a></p>
</li>
<li>
<p>端口： <a href="https://gitlab.com/FreeBSD/freebsd-ports" class="bare">https://gitlab.com/FreeBSD/freebsd-ports</a></p>
</li>
<li>
<p>源代码： <a href="https://gitlab.com/FreeBSD/freebsd-src" class="bare">https://gitlab.com/FreeBSD/freebsd-src</a></p>
</li>
</ul>
</div>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="_邮件列表">邮件列表<a class="anchor" href="#_邮件列表"></a></h4>
<div class="paragraph">
<p>FreeBSD 项目中用于一般使用和关于 git 的问题的主要邮件列表是 <a href="https://lists.freebsd.org/subscription/freebsd-git">freebsd-git</a> 。有关更多详细信息，包括提交消息列表，请参阅 <a href="./#eresources-mail ，邮件列表"></a> 章节。</p>
</div>
</div>
<div class="sect3">
<h4 id="_ssh_主机密钥">SSH 主机密钥<a class="anchor" href="#_ssh_主机密钥"></a></h4>
<div class="ulist">
<ul>
<li>
<p>gitrepo.FreeBSD.org 主机的指纹：</p>
<div class="ulist">
<ul>
<li>
<p>ECDSA 密钥指纹为 <code>SHA256:seWO5D27ySURcx4bknTNKlC1mgai0whP443PAKEvvZA</code> 。</p>
</li>
<li>
<p>ED25519 密钥指纹为 <code>SHA256:lNR6i4BEOaaUhmDHBA1WJsO7H3KtvjE2r5q4sOxtIWo</code> 。</p>
</li>
<li>
<p>RSA 密钥指纹为 <code>SHA256:f453CUEFXEJAXlKeEHV + ajJfeEfx9MdKQUD7lIscnQI</code> 。</p>
</li>
</ul>
</div>
</li>
<li>
<p>git.FreeBSD.org 主机密钥指纹：</p>
<div class="ulist">
<ul>
<li>
<p>ECDSA 密钥指纹为 <code>SHA256:/UlirUAsGiitupxmtsn7f9b7zCWd0vCs4Yo/tpVWP9w</code> 。</p>
</li>
<li>
<p>ED25519 密钥指纹为 <code>SHA256:y1ljKrKMD3lDObRUG3xJ9gXwEIuqnh306tSyFd1tuZE</code> 。</p>
</li>
<li>
<p>RSA 密钥指纹为 <code>SHA256:jBe6FQGoH4HjvrIVM23dcnLZk9kmpdezR/CvQzm7rJM</code> 。</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>这些也被发布为 DNS 中的 SSHFP 记录。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="svn">使用 Subversion<a class="anchor" href="#svn"></a></h3>
<div class="sect3">
<h4 id="svn-intro">介绍<a class="anchor" href="#svn-intro"></a></h4>
<div class="paragraph">
<p>截至 2020 年 12 月， FreeBSD 使用 git 作为主要版本控制系统，用于存储所有 FreeBSD 的源代码和文档。从 git 仓库的 <code>stable/11</code> 、 <code>stable/12</code> 和相关的 releng 分支中导出的更改将被导入到 Subversion 仓库中。这种导出将在这些分支的生命周期内继续进行。从 2012 年 7 月到 2021 年 3 月， FreeBSD 使用 Subversion 作为存储所有 FreeBSD Ports Collection 的唯一版本控制系统。截至 2021 年 4 月， FreeBSD 使用 git 作为存储所有 FreeBSD Ports Collection 的唯一版本控制系统。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Subversion 通常是开发人员工具。用户可能更喜欢使用 <code>freebsd-update</code> （参见： cutting-edge[updating-upgrading-freebsdupdate ，“ FreeBSD Update ”] ）来更新 FreeBSD 基本系统，以及使用 <code>git</code> （参见： ports[ports-using ，“ Using the Ports Collection ”] ）来更新 FreeBSD Ports Collection 。 2021 年 3 月之后， Subversion 仅用于旧版本分支（ <code>stable/11</code> 和 <code>stable/12</code> ）。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>本节介绍了如何在 FreeBSD 系统上安装 Subversion ，并使用它创建一个 FreeBSD 仓库的本地副本。还包括有关使用 Subversion 的其他信息。</p>
</div>
</div>
<div class="sect3">
<h4 id="svn-svnlite">Svnlite<a class="anchor" href="#svn-svnlite"></a></h4>
<div class="paragraph">
<p>在 FreeBSD 上已经安装了 Subversion 的轻量级版本 <code>svnlite</code> 。只有在需要 Python 或 Perl API ，或者需要更高版本的 Subversion 时，才需要使用端口或软件包版本的 Subversion 。</p>
</div>
<div class="paragraph">
<p>与正常的 Subversion 使用唯一的区别是命令名称为 <code>svnlite</code> 。</p>
</div>
</div>
<div class="sect3">
<h4 id="svn-install">安装<a class="anchor" href="#svn-install"></a></h4>
<div class="paragraph">
<p>如果 <code>svnlite</code> 不可用或者需要完整版本的 Subversion ，则必须安装它。</p>
</div>
<div class="paragraph">
<p>Subversion 可以从 Ports Collection 安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/ports/devel/subversion</span>
<span class="c"># make install clean</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>Subversion 也可以作为一个软件包进行安装：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># pkg install subversion</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="svn-usage">运行 Subversion<a class="anchor" href="#svn-usage"></a></h4>
<div class="paragraph">
<p>要将源代码的干净副本获取到本地目录中，请使用 <code>svn</code> 命令。这个目录中的文件被称为“本地工作副本”。</p>
</div>
<div class="admonitionblock warning">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>在首次使用 <code>checkout</code> 之前，移动或删除现有的目标目录。在现有的非 <code>svn</code> 目录上进行 <code>checkout</code> 可能会导致现有文件与从存储库中带入的文件之间发生冲突。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>Subversion 使用 URL 来指定一个仓库，其格式为_protocol://hostname/path_。路径的第一个组件是要访问的 FreeBSD 仓库。有三个不同的仓库， <code>base</code> 用于 FreeBSD 基本系统源代码， <code>ports</code> 用于 Ports Collection ， <code>doc</code> 用于文档。例如， URL <code><a href="https://svn.FreeBSD.org/base/head/" class="bare">https://svn.FreeBSD.org/base/head/</a></code> 指定了 src 仓库的主分支，使用 <code>https</code> 协议。</p>
</div>
<div class="paragraph">
<p>使用类似以下命令从给定的代码库中进行检出操作：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># svn checkout https://svn.FreeBSD.org/repository/branch lwcdir</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>在哪里：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><em>repository</em> 是项目的一个仓库： <code>base</code> 、 <code>ports</code> 或 <code>doc</code> 。</p>
</li>
<li>
<p><code><em>branch</em></code> 的依赖取决于所使用的代码库。 <code>ports</code> 和 <code>doc</code> 主要在 <code>head</code> 分支中进行更新，而 <code>base</code> 则在 <code>head</code> 下维护了最新版本的 -CURRENT ，并在 <code>stable/11</code> （ 11.<em>x</em>）和 <code>stable/12</code> （ 12.<em>x</em>）下维护了相应的最新版本的 -STABLE 分支。</p>
</li>
<li>
<p><em>lwcdir</em> 是指定分支的内容应放置的目标目录。通常情况下，对于 <code>ports</code> 来说，目标目录是 <span class="filename">/usr/ports</span> ，对于 <code>base</code> 来说，目标目录是 <span class="filename">/usr/src</span> ，对于 <code>doc</code> 来说，目标目录是 <span class="filename">/usr/doc</span> 。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>这个例子使用 HTTPS 协议从 FreeBSD 仓库检出源代码树，将本地工作副本放在 [/usr/src] 目录下。如果 [/usr/src] 目录已经存在但不是由 <code>svn</code> 创建的，请在检出之前重命名或删除它。</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># svn checkout https://svn.FreeBSD.org/base/head /usr/src</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>由于初始检出需要下载远程仓库的完整分支，可能需要一些时间。请耐心等待。</p>
</div>
<div class="paragraph">
<p>在初始检出之后，可以通过运行以下命令来更新本地工作副本：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># svn update lwcdir</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>要更新上面示例中创建的 <code>/usr/src</code> 文件，请使用以下命令：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># svn update /usr/src</span></code></pre>
</div>
</div>
<div class="paragraph">
<p>更新比检出要快得多，只传输已更改的文件。</p>
</div>
<div class="paragraph">
<p>在检出之后，更新本地工作副本的另一种方法是通过 <span class="filename">/usr/ports</span> 、 <span class="filename">/usr/src</span> 和 <span class="filename">/usr/doc</span> 目录中的 <span class="filename">Makefile</span> 提供的。设置 <code>SVN_UPDATE</code> 并使用 <code>update</code> 目标。例如，要更新 <span class="filename">/usr/src</span> ：</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="rouge highlight"><code data-lang="shell"><span class="c"># cd /usr/src</span>
<span class="c"># make update SVN_UPDATE=yes</span></code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="svn-mirrors">Subversion 镜像站点<a class="anchor" href="#svn-mirrors"></a></h4>
<div class="paragraph">
<p>FreeBSD 的 Subversion 仓库是：</p>
</div>
<div class="literalblock programlisting">
<div class="content">
<pre>svn.FreeBSD.org</pre>
</div>
</div>
<div class="paragraph">
<p>这是一个公开可访问的镜像网络，使用 GeoDNS 来选择合适的后端服务器。要通过浏览器查看 FreeBSD Subversion 存储库，请使用 <a href="https://svnweb.FreeBSD.org/" class="bare">https://svnweb.FreeBSD.org/</a> 。</p>
</div>
<div class="paragraph">
<p>HTTPS 是首选的协议，但是需要安装 <span class="filename">security/ca_root_nss</span> 软件包以便自动验证证书。</p>
</div>
</div>
<div class="sect3">
<h4 id="_更多信息请参考_2">更多信息请参考<a class="anchor" href="#_更多信息请参考_2"></a></h4>
<div class="paragraph">
<p>关于使用 Subversion 的其他信息，请参阅名为 <a href="http://svnbook.red-bean.com/">《 Subversion Book 》</a> 的书籍，或者 <a href="http://subversion.apache.org/docs/">Subversion 文档</a> 。</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="mirrors-cdrom">CD 和 DVD 套装<a class="anchor" href="#mirrors-cdrom"></a></h3>
<div class="paragraph">
<p>FreeBSD CD 和 DVD 套装可从多家在线零售商购买：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>FreeBSD Mall , Inc. + 1164 Claremont Dr + Brentwood , CA + 94513 + 美国 + 电话：+ 1 925 240-6652 + 传真：+ 1 925 674-0821 + 电子邮件： info @ freebsdmall.com + 网站： <a href="https://www.freebsdmall.com" class="bare">https://www.freebsdmall.com</a></p>
</li>
<li>
<p>Getlinux + 网站： <a href="https://www.getlinux.fr/" class="bare">https://www.getlinux.fr/</a></p>
</li>
<li>
<p>Dr. Hinner EDV + Sch ä ftlarnstr. 10 // 4. Stock + D-81371 M ü nchen + 德国 + 电话：+ 49 171 417 544 6 + 电子邮件： infow @ hinner.de + 网站： <a href="http://www.hinner.de/linux/freebsd.html" class="bare">http://www.hinner.de/linux/freebsd.html</a></p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="bibliography">附录 B: 参考文献<a class="anchor" href="#bibliography"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>虽然手册为 FreeBSD 操作系统的各个组件提供了确切的参考，但它们很少说明如何将这些组件组合起来以使整个操作系统顺利运行。因此，没有什么能替代一本关于 UNIX® 系统管理的好书或用户手册。</p>
</div>
<div class="sect2">
<h3 id="bibliography-freebsd">B.1. FreeBSD 参考文献<a class="anchor" href="#bibliography-freebsd"></a></h3>
<div class="ulist">
<ul>
<li>
<p>《绝对 FreeBSD ： FreeBSD 完全指南》，第三版，由 <a href="https://nostarch.com/absfreebsd3">No Starch Press</a> 出版， 2018 年。 ISBN ： 978-1593278922 。</p>
</li>
<li>
<p>《 FreeBSD Mastery: 存储基础》是由 Tilted Windmill Press 于 2014 年出版的图书。 ISBN 号为 978-1642350098 。</p>
</li>
<li>
<p>《 FreeBSD Mastery: Specialty Filesystems 》是由 Tilted Windmill Press 于 2015 年出版的图书。 ISBN 号为 978-1642350111 。</p>
</li>
<li>
<p>《 FreeBSD Mastery: ZFS 》是由 Tilted Windmill Press 于 2015 年出版的图书。 ISBN 号为 978-1642350005 。</p>
</li>
<li>
<p>《 FreeBSD Mastery: Advanced ZFS 》是由 Tilted Windmill Press 于 2016 年出版的图书。 ISBN 号为 978-0692688687 。</p>
</li>
<li>
<p>《 FreeBSD Mastery: Jails 》是由 Tilted Windmill Press 于 2019 年出版的图书。 ISBN 号为 978-1642350241 。</p>
</li>
<li>
<p>《 FreeBSD 设备驱动程序：勇敢者指南》是由 No Starch Press 于 2012 年出版的。 ISBN ： 978-1593272043 。</p>
</li>
<li>
<p>《 Freebsd 操作系统的设计与实现》第二版，由 Pearson Education , Inc. 于 2014 年出版。 ISBN ： 978-0321968975 。</p>
</li>
<li>
<p>《 UNIX 和 Linux 系统管理手册》，第五版，由 Pearson Education , Inc. 出版， 2017 年。 ISBN ： 978-0134277554 。</p>
</li>
<li>
<p>《设计 BSD Rootkits 》，由 No Starch Press 于 2007 年出版。 ISBN ： 978-1593271428 。</p>
</li>
<li>
<p><strong>FreeBSD 使用 VNET 的 Jails</strong> ，发布在 [gumroad](<a href="https://rderik.gumroad.com/l/uwOLZ" class="bare">https://rderik.gumroad.com/l/uwOLZ</a>) 上。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bibliography-security">B.2. 安全参考<a class="anchor" href="#bibliography-security"></a></h3>
<div class="ulist">
<ul>
<li>
<p>《 PF 之书： OpenBSD 防火墙的无废话指南》第三版，由 No Starch Press 于 2014 年出版。 ISBN ： 978-1593275891 。</p>
</li>
<li>
<p>《 SSH 精通： OpenSSH 、 PuTTY 、隧道和密钥》，第二版， 2018 年。 ISBN ： 978-1642350029</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bibliography-history">B.3. UNIX® 历史<a class="anchor" href="#bibliography-history"></a></h3>
<div class="ulist">
<ul>
<li>
<p>狮子，约翰 <em>狮子对 UNIX 的评论，第 6 版，附源代码</em>. ITP 媒体集团， 1996 年。 ISBN 1573980137</p>
</li>
<li>
<p>Raymond , Eric S. 《新黑客词典，第三版》。 MIT 出版社， 1996 年。 ISBN 0-262-68092-0 。也被称为 <a href="http://www.catb.org/" class="bare">http://www.catb.org/</a> ~ esr/jargon/html/index.html[Jargon File] 。</p>
</li>
<li>
<p>Salus , Peter H. 《 UNIX 的四分之一个世纪》。 Addison-Wesley 出版公司， 1994 年。 ISBN 0-201-54777-5 。</p>
</li>
<li>
<p>Simon Garfinkel , Daniel Weise , Steven Strassmann. 《 UNIX-HATERS 手册》。 IDG Books Worldwide , Inc. ， 1994 年。 ISBN 1-56884-203-1 。已绝版，但可在 <a href="http://www.simson.net/ref/ugh.pdf">在线</a> 获取。</p>
</li>
<li>
<p>Don Libes ， Sandy Ressler 《与 UNIX 共度的生活》 - 特别版。 Prentice-Hall ， Inc. ， 1989 年。 ISBN 0-13-536657-7</p>
</li>
<li>
<p><em>BSD 家族树</em>. 在 FreeBSD 机器上，可以通过链接 <a href="https://cgit.freebsd.org/src/tree/share/misc/bsd-family-tree">https://cgit.freebsd.org/src/tree/share/misc/bsd-family-tree</a> 或链接 <a href="file://localhost/usr/share/misc/bsd-family-tree">/usr/share/misc/bsd-family-tree</a> 来查看。</p>
</li>
<li>
<p>网络化的计算机科学技术报告库。</p>
</li>
<li>
<p>计算机系统研究组（ CSRG ）的旧版 BSD 发布。 <a href="http://www.mckusick.com/csrg/" class="bare">http://www.mckusick.com/csrg/</a> ：这套 4CD 包含了从 1BSD 到 4.4BSD 和 4.4BSD-Lite2 的所有 BSD 版本（不包括 2.11BSD ，遗憾）。最后一张光盘还包含了最终的源代码和 SCCS 文件。</p>
</li>
<li>
<p>Kernighan , Brian <em>Unix: A History and a Memoir</em>. Kindle Direct Publishing , 2020. ISBN 978-169597855-3</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="bibliography-journals">B.4. 期刊、杂志和期刊<a class="anchor" href="#bibliography-journals"></a></h3>
<div class="ulist">
<ul>
<li>
<p><a href="https://www.admin-magazin.de/" class="bare">https://www.admin-magazin.de/</a> [Admin Magazin] （德语），由 Medialinx AG 出版。 ISSN ： 2190-1066</p>
</li>
<li>
<p><a href="https://www.bsdnow.tv/" class="bare">https://www.bsdnow.tv/</a> 【 BSD Now - 视频播客】，由 Jupiter Broadcasting LLC 发布</p>
</li>
<li>
<p>[FreeBSD Journal] ，由 S &amp; W Publishing 出版，由 FreeBSD Foundation 赞助。 ISBN ： 978-0-615-88479-0 。</p>
</li>
</ul>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="eresources">附录 C: 互联网资源<a class="anchor" href="#eresources"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>FreeBSD 的发展速度对于纸质媒体来说太快了，无法实现及时向人们传递信息的目的。为了了解最新的发展动态，电子媒体是最佳选择。</p>
</div>
<div class="paragraph">
<p>FreeBSD 用户社区提供了很多技术支持，其中论坛、聊天和电子邮件是最受欢迎和有效的沟通方式。</p>
</div>
<div class="paragraph">
<p>下面概述了最重要的联系点。链接： <a href="https://wiki.freebsd.org/Community">社区维基区域</a> 可能更加更新。</p>
</div>
<div class="paragraph">
<p>请将任何冗余或尚未在下面列出的资源告知 {freebsd-doc} 。</p>
</div>
<div class="sect2">
<h3 id="eresources-www">C.1. 网站<a class="anchor" href="#eresources-www"></a></h3>
<div class="ulist">
<ul>
<li>
<p>链接： <a href="https://forums.FreeBSD.org/" class="bare">https://forums.FreeBSD.org/</a> [FreeBSD 论坛] 提供了一个基于 Web 的讨论论坛，用于讨论 FreeBSD 的问题和技术。</p>
</li>
<li>
<p>链接： <a href="https://wiki.FreeBSD.org/">FreeBSD Wiki</a> 提供了一些尚未包含在手册中的各种信息。</p>
</li>
<li>
<p>链接： <a href="https://docs.FreeBSD.org/" class="bare">https://docs.FreeBSD.org/</a> [文档门户] 不仅提供了 FreeBSD 手册，还有超过四十本书籍和文章。</p>
</li>
<li>
<p>链接： <a href="https://freebsdfoundation.org/our-work/journal/browser-based-edition/" class="bare">https://freebsdfoundation.org/our-work/journal/browser-based-edition/</a> [FreeBSD Journal] 是由 [The FreeBSD Foundation] 发布的免费、经过专业编辑的双月刊技术杂志。</p>
</li>
<li>
<p>链接： <a href="http://www.youtube.com/bsdconferences">BSDConferences YouTube 频道</a> 提供了来自世界各地 BSD 会议的高质量视频集合。这是观看关键开发人员就 FreeBSD 的新工作进行演示的绝佳方式。</p>
</li>
<li>
<p>链接： <a href="https://www.freebsd.org/status/" class="bare">https://www.freebsd.org/status/</a> [FreeBSD 状态报告] 每三个月发布一次，跟踪 FreeBSD 开发的进展情况。</p>
</li>
<li>
<p>这里有一个链接： [FreeBSD 专注的 Reddit 小组](<a href="https://www.reddit.com/r/freebsd/" class="bare">https://www.reddit.com/r/freebsd/</a>) ，位于 r/freebsd 。</p>
</li>
<li>
<p>链接： [Super User](<a href="https://superuser.com/questions/tagged/freebsd" class="bare">https://superuser.com/questions/tagged/freebsd</a>) 和 [Server Fault](<a href="https://serverfault.com/questions/tagged/freebsd" class="bare">https://serverfault.com/questions/tagged/freebsd</a>) ，这是面向系统管理员的 Stack Exchange 服务。</p>
</li>
<li>
<p>链接： <a href="https://wiki.freebsd.org/Discord">FreeBSD Discord 服务器</a> ，是一个用于交流和建立社区的服务， FreeBSD 社区成员可以在这里社交、获取支持或支持他人、学习、贡献、合作，并及时了解与 FreeBSD 相关的一切。</p>
</li>
<li>
<p>链接： <a href="https://wiki.freebsd.org/IRC/Channels">IRC 频道</a> ，是一种广泛实施、技术成熟、开放标准的文本聊天方式。</p>
</li>
</ul>
</div>
</div>
<div class="sect2">
<h3 id="eresources-mail">C.2. 邮件列表<a class="anchor" href="#eresources-mail"></a></h3>
<div class="paragraph">
<p>邮件列表是向集中的 FreeBSD 受众提问或开展技术讨论的最直接方式。有许多不同的 FreeBSD 主题的邮件列表。将问题发送到最合适的邮件列表将无疑能够获得更快速和更准确的回复。</p>
</div>
<div class="paragraph">
<p>技术列表线程应保持技术性。</p>
</div>
<div class="paragraph">
<p>所有 FreeBSD 的用户和开发者都应该订阅 {freebsd-announce} 。</p>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>为了测试 FreeBSD 邮件列表的功能，请发送到 {freebsd-test} 。请不要向其他列表发送测试消息。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果对于应该将问题发布到哪个列表感到困惑，请参阅 <a href="{freebsd-questions-article}">如何从 FreeBSD-questions 邮件列表中获得最佳结果</a> 。</p>
</div>
<div class="paragraph">
<p>在发布到任何列表之前，请：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>通过阅读邮件列表常见问题（ FAQ ）文档，了解如何最好地使用邮件列表，例如如何避免频繁重复的讨论。</p>
</li>
<li>
<p>搜索存档，以确定是否有其他人已经发布了你打算发布的内容。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>存档搜索界面包括：</p>
</div>
<div class="ulist">
<ul>
<li>
<p><a href="https://lists.freebsd.org/search" class="bare">https://lists.freebsd.org/search</a> （ FreeBSD ，实验性）</p>
</li>
<li>
<p><a href="https://www.freebsd.org/search/" class="bare">https://www.freebsd.org/search/</a> (DuckDuckGo)</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>请注意，这也意味着发送到 FreeBSD 邮件列表的消息将永久存档。当保护隐私是一个问题时，考虑使用一次性的次要电子邮件地址，并且只发布公共信息。</p>
</div>
<div class="paragraph">
<p>FreeBSD 提供的存档文件：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>不要将链接呈现为链接。</p>
</li>
<li>
<p>不要呈现内联图片。</p>
</li>
<li>
<p>不要呈现 HTML 消息的 HTML 内容。</p>
</li>
</ul>
</div>
<div id="eresources-summary" class="paragraph">
<p>FreeBSD 公共邮件列表可以在这里查看： [邮件列表链接] 。</p>
</div>
<div class="sect3">
<h4 id="eresources-subscribe">C.2.1. 如何订阅或取消订阅<a class="anchor" href="#eresources-subscribe"></a></h4>
<div class="paragraph">
<p>在 {mailing-lists-url} 上，点击列表的名称以显示其选项。</p>
</div>
<div class="paragraph">
<p>订阅后，要发帖，请发送邮件至 <code>listname @ FreeBSD.org</code> 。该消息将会重新分发给订阅该列表的成员。</p>
</div>
</div>
<div class="sect3">
<h4 id="eresources-charters">C.2.2. 列表基本规则<a class="anchor" href="#eresources-charters"></a></h4>
<div class="paragraph">
<p>所有的 FreeBSD 邮件列表都有一些基本规则，任何使用它们的人都必须遵守。如果不遵守这些准则，将会收到两封来自 FreeBSD 邮件管理员 mailto:postmaster @ FreeBSD.org[postmaster @ FreeBSD.org] 的书面警告。在第三次违规后，该发帖人将被从所有 FreeBSD 邮件列表中移除，并被过滤以阻止进一步的发帖。我们很遗憾这些规则和措施是必要的，但如今的互联网环境相当恶劣，许多人未能意识到其中一些机制是多么脆弱。</p>
</div>
<div class="paragraph">
<p>道路规则：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>任何帖子的主题都应符合其所发布到的列表的基本描述。如果列表是关于技术问题的，帖子应包含技术讨论。持续的无关废话或争吵只会削弱邮件列表对所有人的价值，这是不可容忍的。对于没有特定主题的自由讨论，可以自由使用 {freebsd-chat} 。</p>
</li>
<li>
<p>不应该在超过 2 个邮件列表上发布帖子，只有在明确且明显需要同时发布到两个列表时才可以。对于大多数列表来说，已经有很多订阅者重叠，除非是最奇特的组合（比如“ -stable 和 -scsi ”），否则没有理由同时在多个列表上发布。如果收到一封带有多个邮件列表的 <code>Cc</code> 行的消息，请在回复之前修剪 <code>Cc</code> 行。<em>无论发起者是谁，回复的人仍然负责跨列表发布。</em></p>
</li>
<li>
<p>在争论的背景下，不允许进行人身攻击和使用粗俗语言，这适用于用户和开发者。严重违反网络礼仪的行为，比如在未经允许的情况下摘录或转发私人邮件，虽然不会受到特别的强制执行，但会受到谴责。</p>
</li>
<li>
<p>严禁宣传与 FreeBSD 无关的产品或服务，如果明显违反垃圾邮件广告的行为，将立即被封禁。</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="eresources-mailfiltering">C.2.3. 在邮件列表上进行过滤<a class="anchor" href="#eresources-mailfiltering"></a></h4>
<div class="paragraph">
<p>FreeBSD 邮件列表通过多种方式进行过滤，以避免分发垃圾邮件、病毒和其他不需要的电子邮件。本节中描述的过滤操作并不包括用于保护邮件列表的所有操作。</p>
</div>
<div class="paragraph">
<p>邮件列表只允许特定类型的附件。在将电子邮件分发到邮件列表之前，将删除在下面列表中找不到的 MIME 内容类型的所有附件。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>application/octet-stream</p>
</li>
<li>
<p>application/pdf</p>
</li>
<li>
<p>application/pgp-signature</p>
</li>
<li>
<p>application/x-pkcs7-signature</p>
</li>
<li>
<p>message/rfc822</p>
</li>
<li>
<p>multipart/alternative</p>
</li>
<li>
<p>multipart/related</p>
</li>
<li>
<p>multipart/signed</p>
</li>
<li>
<p>text/html</p>
</li>
<li>
<p>text/plain</p>
</li>
<li>
<p>text/x-diff</p>
</li>
<li>
<p>text/x-patch</p>
</li>
</ul>
</div>
<div class="admonitionblock note">
<table>
<tbody><tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>一些邮件列表可能允许附件包含其他 MIME 内容类型，但上述列表适用于大多数邮件列表。</p>
</div>
</td>
</tr>
</tbody></table>
</div>
<div class="paragraph">
<p>如果一个多部分消息包含 text/plain 和 text/html 部分：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>收件人将收到两个部分。</p>
</li>
<li>
<p>lists.freebsd.org 将以 text/plain 格式呈现，同时提供查看原始文本的选项（包括源代码和其中的原始 HTML ）。</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>如果 text/plain 不附带 text/html：</p>
</div>
<div class="ulist">
<ul>
<li>
<p>将会从 HTML 转换为纯文本。</p>
</li>
</ul>
</div>
</div>
</div>
<div class="sect2">
<h3 id="eresources-news">C.3. Usenet 新闻组<a class="anchor" href="#eresources-news"></a></h3>
<div class="paragraph">
<p>除了两个特定于 FreeBSD 的新闻组外，还有许多其他讨论 FreeBSD 或与 FreeBSD 用户相关的新闻组。</p>
</div>
<div class="sect3">
<h4 id="_bsd_特定的新闻组">C.3.1. BSD 特定的新闻组<a class="anchor" href="#_bsd_特定的新闻组"></a></h4>
<div class="paragraph">
<p>以下是一些与 BSD 操作系统相关的特定新闻组：</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>comp.unix.bsd - 讨论与 BSD 操作系统相关的问题和话题。</p>
</li>
<li>
<p>comp.unix.bsd.freebsd.misc - 专门讨论 FreeBSD 操作系统的问题和话题。</p>
</li>
<li>
<p>comp.unix.bsd.netbsd.misc - 专门讨论 NetBSD 操作系统的问题和话题。</p>
</li>
<li>
<p>comp.unix.bsd.openbsd.misc - 专门讨论 OpenBSD 操作系统的问题和话题。</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>这些新闻组是 BSD 用户和开发者之间交流和讨论的重要平台。无论是寻求帮助、分享经验还是讨论最新的开发动态，这些新闻组都是获取 BSD 相关信息的有价值资源。</p>
</div>
<div class="ulist">
<ul>
<li>
<p>链接： news:comp.unix.bsd.freebsd.announce[comp.unix.bsd.freebsd.announce]</p>
</li>
<li>
<p>链接： news:comp.unix.bsd.freebsd.misc[comp.unix.bsd.freebsd.misc]</p>
</li>
<li>
<p>链接： news:de.comp.os.unix.bsd[de.comp.os.unix.bsd] （德语）</p>
</li>
<li>
<p>链接： news:fr.comp.os.bsd[fr.comp.os.bsd] （法语）</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_其他感兴趣的_unix_新闻组">C.3.2. 其他感兴趣的 UNIX® 新闻组<a class="anchor" href="#_其他感兴趣的_unix_新闻组"></a></h4>
<div class="ulist">
<ul>
<li>
<p>链接 :news:comp.unix[comp.unix]</p>
</li>
<li>
<p>链接 :news:comp.unix.questions[comp.unix.questions]</p>
</li>
<li>
<p>链接： news:comp.unix.admin[comp.unix.admin]</p>
</li>
<li>
<p>链接： news:comp.unix.programmer[comp.unix.programmer]</p>
</li>
<li>
<p>链接： news:comp.unix.shell[comp.unix.shell]</p>
</li>
<li>
<p>链接： news:comp.unix.misc[comp.unix.misc]</p>
</li>
<li>
<p>链接： news:comp.unix.bsd[comp.unix.bsd]</p>
</li>
</ul>
</div>
</div>
<div class="sect3">
<h4 id="_x_window_system">C.3.3. X Window System<a class="anchor" href="#_x_window_system"></a></h4>
<div class="ulist">
<ul>
<li>
<p>链接： news:comp.windows.x[comp.windows.x]</p>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="pgpkeys">附录 D: OpenPGP 密钥<a class="anchor" href="#pgpkeys"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>这里显示了 <code>FreeBSD.org</code> 官员的 OpenPGP 密钥。这些密钥可用于验证签名或向其中一位官员发送加密电子邮件。 FreeBSD OpenPGP 密钥的完整列表可在 <a href="{pgpkeys}">PGP Keys</a> 文章中找到。完整的密钥环可以在 <a href="https://docs.FreeBSD.org/pgpkeys/pgpkeys.txt">pgpkeyring.txt</a> 下载。</p>
</div>
<div class="sect2">
<h3 id="pgpkeys-officers">D.1. 官员们<a class="anchor" href="#pgpkeys-officers"></a></h3>
<div class="sect3">
<h4 id="_security_officer_name_security_officer_email">D.1.1. {security-officer-name} <code>&lt;{security-officer-email}&gt;</code><a class="anchor" href="#_security_officer_name_security_officer_email"></a></h4>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>pub   rsa4096/D9AD2A18057474CB 2022-12-11 [C] [expires: 2026-01-24]
      Key fingerprint = 0BE3 3275 D74C 953C 79F8  1107 D9AD 2A18 0574 74CB
uid                            FreeBSD Security Officer &lt;security-officer@freebsd.org&gt;
sub   rsa4096/6E58DE901F001AEF 2022-12-11 [S] [expires: 2024-01-05]
sub   rsa4096/46DB26D62F6039B7 2022-12-11 [E] [expires: 2024-01-05]</pre>
</div>
</div>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGOVdeUBEADHF5VGg1iPbACB+7lomX6aDytUf0k2k2Yc/Kp6lfYv7JKU+1nr
TcNF7Gt1YkajPSeWRKNZw/X94g4w5TEOHbJ6QQWx9g+N7RjEq75actQ/r2N5zY4S
ujfFTepbvgR55mLTxlxGKFBmNrfNbpHRyh4GwFRgPlxf5Jy9SB+0m54yFS4QlSd0
pIzO0CLkjHUFy/8S93oSK2zUkgok5gLWruBXom+8VC3OtBElkWswPkE1pKZvMQCv
VyM+7BS+MCFXSdZczDZZoEzpQJGhUYFsdg0KqlLv6z1rP+HsgUYKTkRpcrumDQV0
MMuCE4ECU6nFDDTnbR8Wn3LF5oTt0GtwS0nWf+nZ1SFTDURcSPR4Lp/PKjuDAkOS
P8BaruCNx1ItHSwcnXw0gS4+h8FjtWNZpsawtzjjgApcl+m9KP6dkBcbN+i1DHm6
NG6YQVtVWyN8aOKmoC/FEm1CWh1bv+ri9XOkF2EqT/ktbjbT1hFoFGBkS9/35y1G
3KKyWtwKcyF4OXcArl6sQwGgiYnZEG3sUMaGrwQovRtMf7le3cAYsMkXyiAnEufa
deuabYLD8qp9L/eNo+9aZmhJqQg4EQb+ePH7bGPNDZ+M5oGUwReX857FoWaPhs4L
dAKQ1YwASxdKKh8wnaamjIeZSGP5TCjurH7pADAIaB3/D+ZNl2a7od+C1wARAQAB
tDdGcmVlQlNEIFNlY3VyaXR5IE9mZmljZXIgPHNlY3VyaXR5LW9mZmljZXJAZnJl
ZWJzZC5vcmc+iQJSBBMBCgA8AhsBBAsJCAcEFQoJCAUWAgMBAAIeBQIXgBYhBAvj
MnXXTJU8efgRB9mtKhgFdHTLBQJjlXeQBQkF3u+rAAoJENmtKhgFdHTLOVoQALS3
cj7rqYkHiV4zDYrgPEp9O1kAyGI8VdfGAMkDVTqr+wP4v/o7LIUrgwZl5qxesVFB
VknFr0Wp5g9h0iAjasoI5sDd6tH2SmumhBHXFVdftzDQhrugxH6fWRhHs0SaFYCk
Qt5nFbcpUfWgtQ35XTbsL8iENdYpjKXsSFQrJneGSwxIjWYTFn6ps/AI3gwR8+Bn
OffEFdYugJ049O6Vu6YBFJHrnMO7NbF4v95dVYuLtpMIaXWM+V9KITmhaBzFz5fM
Q7UOzcLlbxOYKNIWcp8QQk429mayKW5VUeUExUD1ZzBHn+P6ZG7QTMDu/RmBqiHo
ewCMVz4n9uXT5BiOngE4CvS0WQwHzK+k9MLpG2u/Bo9+LT0Ceh9Ou1rfU5+0tRwl
GyOFFjf3INS7I7gkcAwxQ7dzDItN/UQPZpg8y9mABU2x4enz0AvTnb61d/1dnTEr
tdNgU433he0ZnD1HurZCjBEWC656wv6iMdWcD8gjhMbmEpPmjvXcYlTO6zhEygSM
DiwdQCWK2W4++YJerA6ULBi3niNWBpofOFH8XylV56ruhjtHCo7+/3carcMoPOJv
lVZ1zCKxLro3TRBT15JTFBGqblRyTopFK3PuxW//GTnZOtpQEOV6yL4RAXcWeC1d
1hb5k/YxUmRF6XsDNEH4b08T8ZO8dV3dAV43Wh1oiQEzBBABCAAdFiEEuyjUCzYO
7pNq7RVv5fe8y6O93fgFAmObXVYACgkQ5fe8y6O93fiBlwf/W8y1XXJIx1ZA3n6u
f7aS70rbP9KFPr4U0dixwKE/gbtIQ9ckeNXrDDWz0v0NCz4qS+33IPiJg1WcY3vR
W90e7QgAueCo5TdZPImPbCs42vadpa5byMXS4Pw+xyT+d/yp2oLKYbj3En4bg1GM
w71DezIjvV+e01UR++u1t9yZ8LOWM5Kumz1zyQLZDZ8qIKt1bBfpa+E0cEqtNQWu
iGhQE3AHI8eWV+jBkg5y2zHRIevbWb1UPsj43lgkFtAGHk9rrM8Rmgr4AXr531iD
srBwauKZ/MElcF3MINuLH+gkPPaFHw/YIpLRLaZXZVsw3Xi1RNXI2n2ea29dvs/C
Lcf1vYkCMwQQAQgAHRYhBPwOh4rlr+eIAo1jVdOXkvSep+XCBQJjm14FAAoJENOX
kvSep+XC0DcP/1ZB7k9p1T+9QbbZZE1PJiHby3815ccH3XKexbNmmakHIn3L6Cet
F891Kqt9ssbhFRMNtyZ/k/8y8Hv5bKxVep5/HMyK+8aqfDFN0WMrqZh0/CiR6DJh
gnAmPNw/hAVHMHaYGII9kCrFfPFJ02FKoc81g9F08odb7TV+UlvRjkErhRxF+dGS
wQoO0RCbf0Z1cs7nd0Vb2z4IJh4XMxBjWc/uQ2Q9dH/0uRzwpAnR4YX+MG5YrX7Z
zBvDyR0r76iQwRSDKgioNgkr6R3rq1NZGdaj+8b0LzdOqtzKJ/eupDe3+H67e/EN
qymtreGjrubpiU9bKvYArisUqhE5KtguryvR6Qz9bj87nPg33DT3WWGVrwFRxBox
dbWzjQFv0wug8m4GAwVF7fPR5/eW7IHw8zvgn0vSPcZz7MZ4e6Y5jN4kA5/xWJYZ
Sps54qQWB+FA30unIXN68KqdIzONIbtaY3W4/JjJUCm4T+wEjKaH+wJX8w1DMjlg
mkTmGh/UrTyC1vXbPgk9Sy3cRTICR1T9z7W8UlmTtnKrUklrjlFR7SXzrEXzLGOX
Fm+NEHpHNXqzcm6c3QfzY/yQ9HSAQ/t7SUQ9caRePbDz3/msyPxtGFor9roQv6VN
wRXCyRgkH4Y5tPhJAQ8G/FxX+VXFb93QL0lfelb23/BBu6cUwW63SRn5uQINBGOV
dskBEADqo8z6TFAhrvHhJV5wHdj67guoYvpXP8gvdCqos8SLluqi0AWgJEwlqu7L
mKQ6qMoJ+2DN6y+dEtvOVgBAgF63LLf3FQKq9FB/3uqeIiQlCIl3H43f8KttEZzf
/lbry4Y6QhS2OXM31Ut9Q+1IfTGwvs1E8/J1U4jQrAGqNKknXyQyMweJ0jvvcSLJ
nv3S7COUJVOT3cTgVeh3RIQlFzqK2rSQmygDpS8bT8MjCsZr+KGezKpbddKXio4a
QW/e6nCMyYR8bo0GQ9DpsyAOsaENnkghncQhA7GdPZK9xLMNQMCp0OdcZlqRVjRZ
OutuzNW6PPoczs/NQq02YWK4BPtSV7+ldS9gPZTLIpnRNQRzcnA0vnQTqSAfasVw
sAGm+MpH7zcaMf2Tw1K08u7+5gyObgzUzQmGLCgo9VIncnDis0s4gfTmtrr5jCeV
7LYDQX+2fApMtXbVXeKJem1PS+Z6LPbW2HklxYuG5nFgewCYlQjKujfiwW1Clhi4
JQeE1Naobbaar99V/VeoHrOYAEWP0bkUyrFcocLJ+0g3KpjSkctIptgGGpMBKe4U
9O7pWoTki8Yz/uYQn/p0iZcG8SfKM8I4283jdsi5SUiNNJJZCBQTVA7d8MxUVv5+
qpX/v5XqYM3pHza2DLXzwfAE9O2dgN1OMZYIld+OnWcpm2PxIwARAQABiQRyBBgB
CgAmFiEEC+MydddMlTx5+BEH2a0qGAV0dMsFAmOVdskCGwIFCQICKQACQAkQ2a0q
GAV0dMvBdCAEGQEKAB0WIQS2FSd+gQh991yBgztuWN6QHwAa7wUCY5V2yQAKCRBu
WN6QHwAa77gbEADpUBT14cesITuMsOWYsyEtNmB4UlTFWCktk/YzyCotasZxIhMP
Xih9G1tDo9ExIWT8jNjSSA+w0Viua/PirDLvI8JtX1JiK3nwMenwlXwlkRAk9TJW
y944YegHF/5ytntwZ/L4BMYc3MztyZbw+sDwnNBZKYmO8gwfYobtfoGxOR4Onb37
bbUVw62xHQIn2zafSmMQ4oMXZTm9EteIYwgcrC1h+Urv5IXCJZHrqmXCPE5g5XZ1
G9jqkwlaRYWjcLD0qxwc5m9LNrF6OBS9N6S7DncIYt9VupI5OCr1uRSqzqaBMFDC
lTTH+dAx3b6J1KFB0UiHP3FeTalFh8L3NE+dN9apNAgkUWv/v4oo/6dkRu3NZse2
RAo/o2X5r40qk/lhydQRZTSTFsiuH3VUWVsgmqAHnHW7pMMw8FAlKhyRSFnhbW7r
e0jj8XMIO7G5yjQKQCnYuPdXbx++bP1PzsEWDv9j/sph5arcosdo6tEXklWHED17
MEPIton1+NRfsU0peEVggQXlwdTcZN/h7FeCZ56dcwCWdCpSlv6CcWzRXSNUyJpK
a9qfIqBX/monjy7w5IHmhvLwAYI6IoT11h1QDEfGfhrwWPwOjnXsaYm5E7wv8w69
PxMbOJbMpWSg8L7xW3LXKR1VwXggUC1+b3y67E5Ggi1hf0lfTnTMpL2ClO2QD/oC
hMIafhzxbjh2WzgYahVHZH3gpHc1/0Bnc07s9+Pa6EYYM9r0XzezLW7bswOjVloR
FreQ3FIF/2OSN0OGdm7dyYl0OliTIDDDlwK/l8bcckUcpHNR1dw0P3KvDlmLmzZy
G4HmzzSBa9jiFirEfcg2rnGc6Zi382jGVALuYVplPXyMOUiChp0AAQZzTIYpXw/g
pBE6em2k740yuK6WqG4yXXgk67FoH10TQvMd4Q73K4zw+9DMpThlUHcfBmAoViZw
il7C0xl+ysHX8ZI3JU8s1r3XAnpqdHi4Wpixm/ctXbVnTSA3FQr2SctJYqR1VHRW
GMW+Ii2SQDS+t9bZTzOgAPLDtfy+JqhBpwCB1a1EHftkJEojpfZipaYGkf3yc+vN
wUeUHp/csF9CT7Qbqaj1t7fVWzv7jcVKpRwngIT4vTSzqbo6WC34FuUAH0t7tJ5K
eZ625AqEFLmtqtDo+ydJhZrVrXBNXPfkx5hSVW/I9hvckMNwA3t0KfQC2sz+Z1Q1
a4vDWQYRytfyrgZkWGbXMn6l1JyqIolgJZuax2kYs7Vu3t8KptqCbv0ZBAGoMm7r
RLgVodhI9voA8YxCirSChrueJYn+JKk8MIyk3DdXpBoocMIAjFJAUgXjV5NQpZMy
xR8BEiQnBcHRIKVWEEyhbLtHpmCEsnKNyKVGoxs31LkCDQRjlXcHARAAykVVzNmj
1k82yBbv3VRbmjrCeud3Wcg75LitzfurZMTPwoYcK7Gjk3B99na3oufTgEjniltq
mDXtvtrSE+RrfscWQvbyfhXIx3HQKwCbdAR9Sx0rrHApXZK5xh5VytXW6lw3g91c
Puy7Ujv8DgJZcUkbTjvMnRnz2UlmJASICruCG8SiKcLSyb7Rrpqj+hyoKBYIozXI
I87LMleV5Gu/b1JGdjOIxH6rZTTH3GD1eXoYzBSYXBslz2c5FW8sft9tTr927wSC
gBiuCUU4Vkb9NKiVIZZFIyJq/PQlIP+L6sQ3hohPhZ8F74v1bLUCas3GIA77MqbM
dC7clLEOdyv7L6Fx35bSCrDXQWgj2NYtwvuRH7prSI6O4lJdKimraXcNp+I/G0IW
avgIZCHMEczp7j+/8013cXRelVsnpFCmHuWR+9/PyraW9SUeF7MnSnXFeaF9/0Ie
N1UyGYCbPn6KYEBeTaai2018pvSkUR6fXFjcr9Q8DiD6g+xKPj3kyy8iD14gwJwL
f/PRIRQxYf+y3LInM+p+nJ8bBl5NwiP2+Daj5Gca+ZwtVgD8QZOg+T3TmS/9wrve
jLxtnI4HTMyDtP09paAtQ7SyqOqjQzDeScXJKDehFeVyKU9C9891fQm/Aulz0NaW
vX7UaQJcnTyVa6Alz3oIlC6kpFvUhsLShRcAEQEAAYkCPAQYAQoAJhYhBAvjMnXX
TJU8efgRB9mtKhgFdHTLBQJjlXcHAhsMBQkCAikAAAoJENmtKhgFdHTLDC0P/AgO
YRwd0WXIVFOiZQGNt4ra7NxkiGSSAvnyVzrdQ+V7mInYUG+ZhL7StBLnexUSxxyf
kp+Q7BOvIqWW9ZuXQjO6Kp9rDEAtx9al9kkfNMxKcMd+Be847IUxCu6pEMAcCvs8
0LQKdtPSwQXZkXNp3wz18uq2RdTHiaAQI0YngJWqDvkpjy5TO/8GZHAR/nzsVPn+
IAh53kyMUHZUUNf0YAFy9NNsfEJkjGfGXdyzXlLFPSUCh9na55TqRZhZlJcV5oQz
/jKY8nCzaaZXQCRsmCEtcKf0zHedfo1Nln0dqtuu75HNbf8eDcNl3Qn2+Sjw9p8/
SXU1a2DJfvgKq9OCPNPFdOeqtFfNxzMrt+FwLa7iLSms+1ddzLKLtLCmguKRpkIs
UWFSY7H6ZLlOO2AXIVkE3Gc7uIDCTN9xNwL2w+hZoWaJB/qrkQhjMb5ZCmdyPzSb
GXcdY4/qgWP+FklFix4p4yS8nMtOjzusV0zoKwysvARNHp75pYzRu08WKXWtdUAI
06OzLRvFNXw4kR/LGdibKO+cG8HSR2JpUQN1WHGBKrMsBfiaBdrj39Xoz+7Myv6f
f8DUl2ThXp9WbxLlwUhfGhRq3dwHjEZpP05YPejU0+vp5L1WjQSwmVGXzVIbrx9L
5C2TZ9fbtPrxgbgBrfMx9nFSxW4Uu1O5BtEL58mk
=tw96
-----END PGP PUBLIC KEY BLOCK-----</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_core_secretary_name_core_secretaryfreebsd_org">D.1.2. {core-secretary-name} <code>&lt;<a href="mailto:core-secretary@FreeBSD.org">core-secretary@FreeBSD.org</a>&gt;</code><a class="anchor" href="#_core_secretary_name_core_secretaryfreebsd_org"></a></h4>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>pub   rsa4096/BE3DF7A86914D607 2022-07-29 [SC] [expires: 2024-07-28]
      Key fingerprint = E0C0 73CF 01A2 A902 800C  3680 BE3D F7A8 6914 D607
uid                            FreeBSD Core Team Secretary &lt;core-secretary@freebsd.org&gt;
sub   rsa4096/7882C7A2CA320B52 2022-07-29 [E] [expires: 2024-07-28]
      Key fingerprint = 7828 1422 F522 802B 00AE  0410 7882 C7A2 CA32 0B52</pre>
</div>
</div>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQINBGLkULYBEACsS9RbAv8gIyZWtIWgBeK6+ircHRW0LsetvHqQYlY6gfRWDLN+
467o0dHwAz4c1jyq7Or+1gy2Kr2VpcPZr1kjNTx5NbvoybQJMIMs77o9LS3Q2pA0
3Dpi8LSaM77rCmIXFmKEspbuPyjjTjKUtpOmzvwMDq8ke7ZHrqkJOessKQVGUSJc
o+4hcN6S4gGRgzRHLOuPtDqIfxFuHjr+4ZEGeispJHZqtl+HwBOEdoG966hKo/Ae
eyIRMB1vioqf8GHuiVHZ3YJbbcLN/4oMMtN/aIgucfspKo2O95zUETkimGTBlEl0
RVFXF5kq3gq2p7+7Sl3OQ3Kw8LQ9ueinWNJ5/3X06UowsRbOxtx7Jtp4DFwhpHj/
LTdEUSjiVzeZKiqDOqvgjq2ZN4hLHEZYan3mv55AUnwzwzMD04P42mNHetCJnuNP
ZGGL/wmABc8X4tx/fGddECKBzCM8hHBG7WQkDUnMTpODhBXCcC+rm6Vz7FS1zv67
CftMneqWnDDZtf/XclnHI6iOJZPcY/ljV+QxGs+oLvn2mlR6xzHu9osYfGuozA6x
PIxrSgB7PWFSuSvqtN7fSwAiXOAI5zFpZ4HP8wjFt7SWfMaovc/FR8rzYaZSZYAk
0l+FmsMbBGvkHNdPyk/4CWqj3dg4HCFAeqUWVLo3qKHdTOQaTqavyYYBCwARAQAB
tDhGcmVlQlNEIENvcmUgVGVhbSBTZWNyZXRhcnkgPGNvcmUtc2VjcmV0YXJ5QGZy
ZWVic2Qub3JnPokCVAQTAQoAPhYhBODAc88BoqkCgAw2gL4996hpFNYHBQJi5FC2
AhsDBQkDwmcABQsJCAcDBRUKCQgLBRYDAgEAAh4FAheAAAoJEL4996hpFNYHPRwP
/R5lWY8RcsAxAwXqzCRww1N2D6aRVUK+wJfxlMYRFjT9o0phmlSQxhORJATbjLm3
prLkpFBsMOScDmG7kWttPSHoQFKBiA7IznVeT4hka9c3Id21EL54GEjjDyp6AFev
G5kNCu8vS6SxmyUD9U2Q7PiEiEq7907tfydJfJ5BEzS5Az6KTOITaZ716qxQVQFR
6i6ChMCBABT059QngTiRp0sY2TPzTepHxEyrE//8M0mgyBsaRWPQP712sVujjx82
/3fXMxKwnJTGRhy0qR+DbIeSK/OiU4OJISG1XG/IkAQEqPwG6UilXy60l5PectJD
FAGRgky/Jmh9QTL4lhFLmpEyQhjVOZANZ1lqfD6lEjsf/Adr3stcKLNMLT8xewKo
LrFzSWMXh35HsSM/ZJng9CiJlAckGNBwuYp+5z49vBWaUXj9/KzK+0uKO6OspDIG
sF7M33BOqOP48ssIZWdJihwMA8qSX+ZFq+yMn8YdPmszXcEe4H4U1curdGWMm7IF
DwUl9cMEfYiPhvuO5taJBDerEbynyMI6oYbFnfl3Bb4rknlatiCzKXrzR1OuRtho
RkAPVSnEru0FTgCHToRdj81qyAwa6VMsEtVvqhNtsWBvr8W9Bdj1zZUV0hCJOzZN
UfAmlRXkud8lK4UyxBHUrNSy4ufGRjMNOhuUmBZVwrTSiQIzBBABCgAdFiEES2Tp
4L3ps+zAa1xm2MjIO0nybxcFAmLkVMoACgkQ2MjIO0nybxdeBBAAhCqcnsVVUpL6
w9CQV71kkSoT0649GkbWeG+ob1XgXvjxCSRb7mxSx7KCiUkLtnzVUOe+qp15pbAm
o9zlHZ/yQQxA3pUX5npIIiWXSWknA3DGNKE52RJ1tbpIVhFjrseXa4gsrxrUVtCF
dHsCFl/G6Zr1h+OutL6DHxQH0ZI2OmxRQFxE0Bwjyx3HdLmtKCEZVYUuhMoCya9m
5Uu98nQOMH7jDMbj8za7JJiwZwjKNZfiNck8Ekq0DEXr3CKSueobHr3JqSLt9VKV
WzaGKDQ/sVQz4L7GZfR1yMAJQlWulsTvxGG4SWxnFsus9GNydQIEmkTfDLmBXkl4
PNNsTirNir3ld7KEIY07jffqK88uV3nZ+Cc2VUdM4GRddH4LdJnKyY+O8AXrEAse
9aUmWGmesbOSAV0ATLGfFM96eFuGMdgwxl25W3RxKlLABAdLRd5smW5RCDOSyrqZ
0F3mpqCGMG84Us93/G5hdYsULuJxlufMur4SO5kRp6h/+tuDR1TAzkAoHut16ODD
fnto8OhmLk1W3yfddh8i5e5jBU1NZkmHSYOKhs0iBcSBR0t594E3xNCUQYNZswlZ
rVNCL7o1HEuln0p+qrcOVWqQ9ovb4mE5qupRydr4+moxmJy6y5bQp3QaIxentHnY
1aq8A8o2OV8sFNbH70p7+fB+W1HeviS5Ag0EYuRQtgEQAMT6Pik/xPzARb/UjjVS
Wvo7AQjtLC3yKNg1yAey3T0gp6YKYs5vlMJckS48LDZagiqgcDucly52nk2sMWqu
+yllgBLrwm+SY4g7hqrDgXrOspZUyLysKB5fyF60qOGcjfmZgAFPh8MN4Zym/tD1
3dThrSsBJJ9jrX8OCBLlV5sXbbpx6jwtLe4wzeJOfMctW+U3U6zmJw8ZOYU7cG/M
5xSh1s9W1iju4DXo63gOtnyYad27BexHu19e/nAwxQwLaofDX9R9Y0pORFHI1SuO
IrQIHXhwgZHVRBNulPtM2zVVN1jWC5X9YLu4rc/F01BO0B4GQosYtlmcK7Rm7obx
Dm+o0pPw3xyFnl1vOXWsmRDUP6qATk3YKuHdYRe33SxFPm7iWEB+rVL41dqquMRO
L7HIt9ho9MWTac2a9jHIX17xK9Q/P/zy6ZLjwtcyirPezct4GWvIPJ+mdrmI39nn
Y/TFcBZ3G0BtwasFnuFjHbkjcBlqvtHc1Zg/hISaEDTbSDr0TMLpxG2OpT5xqMkq
PO8S04IpMtKWd1aRliv9vE65UHAGHVe8EOVmGT7Tk9cCqFxrxpwE8n+KU5JGUGTc
BnpuCedT3txnZZc90d/+yMotJPpLUmOdndj782Y4B5y5JXpTefvxN2lBOorVN1xu
zH43SkAA7lvuN0x4QpmzWJoLABEBAAGJAjwEGAEKACYWIQTgwHPPAaKpAoAMNoC+
PfeoaRTWBwUCYuRQtgIbDAUJA8JnAAAKCRC+PfeoaRTWB/RdD/94yvoMl/VtJqTR
Lc7Qu41y/SdczDAfCGPts49uu56xRqCfcLZOLr4PNXh49x0UWFroTcpcFlcsS++D
EOoR2DoyxB1+KKRhceBo1CmQ8Y7RQ0LpQzYPkqBmzVEZK/I5dKf+RX83E7sa5L28
UpCrsDSsp7dVrxmwdiiOsJBD1vA5vIGgtgTGewMNmPO4wbhmjFTIxPnSND6wRYyW
SBgKkEz5lnA6zHOMYiXabKI/oY23xq4YRu2UOVoZMUkXoqR09McwrqMI4+XJBSwC
c2G6FI4uEO6YIDGXlUZhCGDGwE+HVcP6/jshyi1HOtUpcemle//YSvyrp6N/8XkZ
RX/dvUNIBl+ykIE/wb75PWI7QTNLWkJmCU/ft9m1KEHAwccyxHJxXWurnBbMgMan
VfLYH4uJ0eH/O65zTIzRdZcMO4kY1vVllAKXY9Httxpdua0n+4rHplxL4ZfRL7Y4
5h7/Xiz5xfGcYxPd5/ezfYzcvfDr4danX8fBe7U9F2VaO/QOhcgCLV8TevR1Ku/0
GUOfPAH6rhZaLqqz92Y2hOX1QQ6MabB92DUFZh+5SUxCzqI6cAiH60Rbf9ZI579s
L32GpxZ6BPISnsy69SNAVBiczw8EthEY1KhdN9QOuHppqcGsOlIz8cKVojqzILwj
GT6wtOZXl/ri7I8x3Fr89V3sUvmg1w==
=2Il1
-----END PGP PUBLIC KEY BLOCK-----</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_portmgr_secretary_name_portmgr_secretary_email">D.1.3. {portmgr-secretary-name} <code>&lt;{portmgr-secretary-email}&gt;</code><a class="anchor" href="#_portmgr_secretary_name_portmgr_secretary_email"></a></h4>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>pub   ed25519/E3C401F60D709D59 2023-03-06 [SC] [expires: 2027-03-05]
      Key fingerprint = BED4 A1D3 6555 B681 2E9F  ABDA E3C4 01F6 0D70 9D59
uid                            FreeBSD Ports Management Team Secretary &lt;portmgr-secretary@FreeBSD.org&gt;
sub   cv25519/2C92B55E27A641C3 2023-03-06 [E] [expires: 2027-03-05]</pre>
</div>
</div>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mDMEZAXJvxYJKwYBBAHaRw8BAQdASFAC20WL3R1T6uNyGMZbfJCxDkcP4C5vi3Op
tcZ2fbq0R0ZyZWVCU0QgUG9ydHMgTWFuYWdlbWVudCBUZWFtIFNlY3JldGFyeSA8
cG9ydG1nci1zZWNyZXRhcnlARnJlZUJTRC5vcmc+iJYEExYKAD4WIQS+1KHTZVW2
gS6fq9rjxAH2DXCdWQUCZAXJvwIbAwUJB4TOAAULCQgHAwUVCgkICwUWAwIBAAIe
BQIXgAAKCRDjxAH2DXCdWYN1AP43TjyfZtZ3DLYT++g0+SuPsoO/3yWVybA+UmFL
zb8MngEA+LLNUfvEwCuXS/soh+ww5bpfmi3UUmeGiQEAXug3iA+JATMEEAEKAB0W
IQT7N0XIbxXo7ayBMvzYKU7Du8TX1QUCZAXLkwAKCRDYKU7Du8TX1XHMB/9R1MX4
6zMgpKqPPt76GOI+eGEdBK6bY8aJZjQGdqTh9f6VtXVoTGIG7cvhc9X8tDBoB0PT
2KZWheF51AV1+NHU4HwLAQ1BMebrFvWSfkw4xg4fBGwDhz9/GN85No+Js772V5ey
8lRiL6meRVWxMlLyWcxGd8JjcC5yX/iAUQ3SBGCLqW7unWjjg7CTd+AMBwcqPGrv
ax8q6eFVguJcHJAjMnKf6HAy4cpK3s+uMoUBCGnszSN12B3ysKfyC4pNO/pix5tA
Q5v8aRqTeFPh5zmNhWo0KGPzplTPqRQSHDl7GDQC8Ru3MhzFkeWzHsexjZVwS6W2
DPcYpuuAsA0XOZIZiQIzBBABCgAdFiEEEBpxaxYrAOVb7eoFrbv4YQo3ibcFAmQF
0u0ACgkQrbv4YQo3ibccwg/9F2Xuic3nhKxRbB3mJeDo6SYQETa/Gh1qQ34+8zlt
8UMazOx67gnYQfy+pXjro6eQ2up0a4eUYezcNOudqAQD21nRz3HA6EQVNcE/TzEA
xl5CJntTaLOt7S+EDXFW5BuQIvhhoMGgm8+WNVgA0EJ7tfL0OcYBSvr19fqwChEn
9c14cSk6mgHSsleP5NvskYN053pxHwy0LTSb8YBBv52th37t/CRFC1363rS5q+D7
JixFopd1O5pKpA5ipvE4gGgRjPtwjx0SjjepwK/3fuhEJQQyKzTIKlMfu2Dj/iR2
Li1Sfccau5LQXOj9fUITU3u1YG7yrm8VGzT7ao4d+KRwgMLjd2pLqiGIbbJwGBiP
FRmtilWQoeIlmSlFX4obAA517DOK0pW1mH8+eEn4EJd3SekT3yzFyKTASv0J48Z8
3F928xg+eZvHxVC0t1J+J5IG0gt3EEncuWKIPQGR7PiQbti6R3FQVTz6WfMWOebP
Qi0E9F/Aqakr6Vj2sKGrDq+ebpaF5G8Yw1YrUl2IDiPzkCegp3ZbI0wh11Xvzhi8
LXPQGK4jBQas4G8cegfitzmtdGRHYrbMv0R9I4mvaL+WlOuD2AvyVG28lguqVhnN
AZP+ohdquYyX2CNCVvbKWAtXo6Ur0vWG8BL8m6defAtEkIwVBALaOHQOSI3aNUz4
lwy4OARkBcm/EgorBgEEAZdVAQUBAQdAsefmSfxEOdOr02+K/6noYCuJ1FeAWVz6
jFYQ+9w6jggDAQgHiH4EGBYKACYWIQS+1KHTZVW2gS6fq9rjxAH2DXCdWQUCZAXJ
vwIbDAUJB4TOAAAKCRDjxAH2DXCdWRl4AP9h5ot212BK29S6ZcMBhHvmtF5PG1oD
c7LnZycSRmbFiwEAndCMpAGOhDW8iVgDd0wLQq/ZMPe+xccfG1b3zFH2EgE=
=iiAT
-----END PGP PUBLIC KEY BLOCK-----</pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="_doceng_secretaryfreebsd_org_是一个占位符表示文档工程部门秘书的电子邮件地址">D.1.4. <code>&lt;<a href="mailto:doceng-secretary@FreeBSD.org">doceng-secretary@FreeBSD.org</a>&gt;</code> 是一个占位符，表示文档工程部门秘书的电子邮件地址。<a class="anchor" href="#_doceng_secretaryfreebsd_org_是一个占位符表示文档工程部门秘书的电子邮件地址"></a></h4>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>pub   rsa2048/E1C03580AEB45E58 2019-10-31 [SC] [expires: 2022-10-30]
      Key fingerprint = F24D 7B32 B864 625E 5541  A0E4 E1C0 3580 AEB4 5E58
uid                            FreeBSD Doceng Team Secretary &lt;doceng-secretary@freebsd.org&gt;
sub   rsa2048/9EA8D713509472FC 2019-10-31 [E] [expires: 2022-10-30]</pre>
</div>
</div>
<div class="literalblock literal-block-margin">
<div class="content">
<pre>-----BEGIN PGP PUBLIC KEY BLOCK-----

mQENBF27FFcBCADeoSsIgyQUY8vREwkTikwFFlNg31MVy5s/Nq1cNK1PRfRMnprS
yfB62KqbYuz16bmQKaA9zHN4FGfiTvR6tl66LVHm1s/5HPiLv8sP14GsruLro9zN
v72dO7a9i68bMw+jarPOnu9dGiDFEI0dACOkdCGEYKEUapQeNpmWRrQ46BeXyFwF
JcNx76bJJUkwk6fWC0W63D762e6lCEX6ndoaPjjLBnFvtx13heNGUc8RukBwe2mA
U5pSGHj47J05bdWiRSwZaXa8PcW+20zTWaP755w7zWe4h60GANY7OsT9nuOqsioJ
QonxTrJuZweKRV8fNQ1EfDws3HZr7/7iXvO3ABEBAAG0PEZyZWVCU0QgRG9jZW5n
IFRlYW0gU2VjcmV0YXJ5IDxkb2Nlbmctc2VjcmV0YXJ5QGZyZWVic2Qub3JnPokB
VAQTAQoAPhYhBPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsDBQkFo5qABQsJ
CAcDBRUKCQgLBRYDAgEAAh4BAheAAAoJEOHANYCutF5YB2IIALw+EPYmOz9qlqIn
oTFmk/5MrcdzC5iLEfxubbF6TopDWsWPiOh5mAuvfEmROSGf6ctvdYe9UtQV3VNY
KeeyskeFrIBOFo2KG/dFqKPAWef6IfhbW3HWDWo5uOBg01jHzQ/pB1n6SMKiXfsM
idL9wN+UQKxF3Y7S/bVrZTV0isRUolO9+8kQeSYT/NMojVM0H2fWrTP/TaNEW4fY
JBDAl5hsktzdl8sdbNqdC0GiX3xb4GvgVzGGQELagsxjfuXk6PfOyn6Wx2d+yRcI
FrKojmhihBp5VGFQkntBIXQkaW0xhW+WBGxwXdaAl0drQlZ3W+edgdOl705x73kf
Uw3Fh2a5AQ0EXbsUVwEIANEPAsltM4vFj2pi5xEuHEcZIrIX/ZJhoaBtZkqvkB+H
4pu3/eQHK5hg0Dw12ugffPMz8mi57iGNI9TXd8ZYMJxAdvEZSDHCKZTX9G+FcxWa
/AzKNiG25uSISzz7rMB/lV1gofCdGtpHFRFTiNxFcoacugTdlYDiscgJZMJSg/hC
GXBdEKXR5WRAgAGandcL8llCToOt1lZEOkd5vJM861w6evgDhAZ2HGhRuG8/NDxG
r4UtlnYGUCFof/Q4oPNbDJzmZXF+8OQyTNcEpVD3leEOWG1Uv5XWS2XKVHcHZZ++
ISo/B5Q6Oi3SJFCVV9f+g09YF+PgfP/mVMBgif2fT20AEQEAAYkBPAQYAQoAJhYh
BPJNezK4ZGJeVUGg5OHANYCutF5YBQJduxRXAhsMBQkFo5qAAAoJEOHANYCutF5Y
kecIAMTh2VHQqjXHTszQMsy3NjiTVVITI3z+pzY0u2EYmLytXQ2pZMzLHMcklmub
5po0X4EvL6bZiJcLMI2mSrOs0Gp8P3hyMI40IkqoLMp7VA2LFlPgIJ7K5W4oVwf8
khY6lw7qg2l69APm/MM3xAyiL4p6MU8tpvWg5AncZ6lxyy27rxVflzEtCrKQuG/a
oVaOlMjH3uxvOK6IIxlhvWD0nKs/e2h2HIAZ+ILE6ytS5ZEg2GXuigoQZdEnv71L
xyvE9JANwGZLkDxnS5pgN2ikfkQYlFpJEkrNTQleCOHIIIp8vgJngEaP51xOIbQM
CiG/y3cmKQ/ZfH7BBvlZVtZKQsI=
=MQKT
-----END PGP PUBLIC KEY BLOCK-----</pre>
</div>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="freebsd-glossary">FreeBSD 词汇表<a class="anchor" href="#freebsd-glossary"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>这个词汇表包含了在 FreeBSD 社区和文档中使用的术语和缩写。</p>
</div>
<h3 id="_一个" class="discrete">一个</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">ACL 是 Access Control List 的缩写，意为访问控制列表。它是一种用于控制对计算机系统资源的访问权限的机制。 ACL 可以定义哪些用户或用户组有权访问特定的文件、目录或网络资源，并可以指定不同的权限级别，如读取、写入或执行。通过 ACL ，系统管理员可以更精细地管理和控制用户对系统资源的访问。</dt>
<dd>
<p>参见 <a href="#acl-glossary ">访问控制列表 </a> 。</p>
</dd>
<dt class="hdlist1">高级配置与电源接口（ ACPI ）</dt>
<dd>
<p>参见 <a href="#acpi-glossary ">高级配置与电源接口 </a> 。</p>
</dd>
<dt class="hdlist1">AMD 是 Advanced Micro Devices 的缩写，是一家总部位于美国的半导体公司。该公司主要从事计算机处理器、图形处理器和其他相关技术的研发和制造。 AMD 是英特尔公司的主要竞争对手之一，其产品广泛应用于个人电脑、服务器和游戏主机等领域。</dt>
<dd>
<p>参见《自动挂载守护进程》（ Automatic Mount Daemon ）。</p>
</dd>
<dt class="hdlist1">AML 是反洗钱（ Anti-Money Laundering ）的缩写，是一种旨在防止和打击洗钱活动的法律和监管措施。洗钱是指将非法获得的资金通过一系列交易和操作掩盖其来源的行为。 AML 旨在确保金融机构和其他相关实体遵守法律规定的反洗钱要求，以减少洗钱和恐怖主义融资的风险。</dt>
<dd>
<p>参见 <a href="#aml-glossary ">ACPI 机器语言 </a> 。</p>
</dd>
<dt class="hdlist1">应用程序编程接口（ API ）</dt>
<dd>
<p>参见 <a href="#api-glossary ">应用程序编程接口 </a> 。</p>
</dd>
<dt class="hdlist1">APIC 是 Application Programming Interface Controller 的缩写，意为应用程序编程接口控制器。 APIC 是一种硬件设备，用于管理和调度计算机系统中的中断和中断控制器。它负责处理和分发中断请求，以确保系统的正常运行和响应。 APIC 还可以提供高级功能，如多处理器系统中的进程间通信和同步。</dt>
<dd>
<p>请参阅《高级可编程中断控制器》（ Advanced Programmable Interrupt Controller ）一节。</p>
</dd>
<dt class="hdlist1">APM 是应用性能管理的缩写，它是一种用于监控和管理软件应用程序性能的方法和工具。 APM 可以帮助开发人员和运维团队追踪应用程序的性能指标，识别潜在的性能问题，并提供优化建议。通过使用 APM ，组织可以提高应用程序的可靠性、可用性和性能，从而提供更好的用户体验。</dt>
<dd>
<p>请参阅《高级电源管理》（ Advanced Power Management ） <a href="#apm-glossary">[apm-glossary]</a> 。</p>
</dd>
<dt class="hdlist1">APOP 是一种用于电子邮件认证的协议。它使用了一种称为挑战 - 响应机制的方式来验证邮件服务器和客户端之间的身份。在 APOP 中，服务器会向客户端发送一个随机的挑战字符串，客户端需要使用预共享的密钥对挑战字符串进行加密，并将结果发送回服务器进行验证。通过这种方式， APOP 可以防止未经授权的访问和邮件欺骗。</dt>
<dd>
<p>参见《认证邮局协议（ Authenticated Post Office Protocol ）》。</p>
</dd>
<dt class="hdlist1">ASL 是美国手语（ American Sign Language ）的缩写。它是一种用手势和面部表情进行交流的语言，主要用于聋人之间的沟通。 ASL 是一种独立的语言，与英语并不相同。它在美国和加拿大广泛使用，并且在全球范围内也有一定的使用者。 ASL 的手势和动作具有丰富的语法和词汇，可以表达复杂的意思和概念。</dt>
<dd>
<p>请参阅 <a href="#asl-glossary ">ACPI 源语言 </a> 。</p>
</dd>
<dt class="hdlist1">ATA 是一种计算机接口标准，用于连接硬盘驱动器和计算机系统。 ATA 代表“ Advanced Technology Attachment ”，它定义了硬盘驱动器与计算机之间的通信协议和电气接口。 ATA 接口通常用于连接传统的机械硬盘驱动器，但也可以用于连接其他类型的存储设备，如固态硬盘（ SSD ）。 ATA 接口有多个版本，包括 ATA-1 、 ATA-2 、 ATA-3 等，每个版本都有不同的特性和功能。 ATA 接口已经被更先进的接口标准，如 SATA （ Serial ATA ）所取代，但仍然在一些老旧的计算机系统中使用。</dt>
<dd>
<p>参见《 ATA 词汇表》。</p>
</dd>
<dt class="hdlist1">自动取款机</dt>
<dd>
<p>参见《异步传输模式 (ATM) 术语表》。</p>
</dd>
</dl>
</div>
<div id="aml-glossary" class="dlist">
<dl>
<dt class="hdlist1">ACPI 机器语言</dt>
<dd>
<p>伪代码由一个在符合 ACPI 的操作系统中的虚拟机解释，它在底层硬件和向操作系统呈现的文档化接口之间提供了一层。</p>
</dd>
</dl>
</div>
<div id="asl-glossary" class="dlist">
<dl>
<dt class="hdlist1">ACPI 源语言</dt>
<dd>
<p>AML 是一种编程语言。</p>
</dd>
</dl>
</div>
<div id="acl-glossary" class="dlist">
<dl>
<dt class="hdlist1">访问控制列表</dt>
<dd>
<p>一个附加在对象上的权限列表，通常是文件或网络设备。</p>
</dd>
</dl>
</div>
<div id="acpi-glossary" class="dlist">
<dl>
<dt class="hdlist1">高级配置与电源接口</dt>
<dd>
<p>ACPI 是一种规范，它提供了硬件接口的抽象，使操作系统不需要了解底层硬件即可充分利用它。 ACPI 发展并取代了以前由 APM 、 PNPBIOS 和其他技术提供的功能，并提供了控制功耗、机器暂停、设备启用和禁用等功能。</p>
</dd>
</dl>
</div>
<div id="api-glossary" class="dlist">
<dl>
<dt class="hdlist1">应用程序编程接口</dt>
<dd>
<p>一组程序、协议和工具，用于指定一个或多个程序部分之间的规范交互方式；它们如何、何时以及为什么协同工作，以及它们共享或操作的数据。</p>
</dd>
</dl>
</div>
<div id="apm-glossary" class="dlist">
<dl>
<dt class="hdlist1">高级电源管理</dt>
<dd>
<p>APM （高级电源管理）是一种 API ，使操作系统能够与 BIOS 协同工作，以实现电源管理。对于大多数应用程序来说， APM 已被更通用和强大的 ACPI （高级配置和电源接口）规范所取代。</p>
</dd>
</dl>
</div>
<div id="apic-glossary" class="dlist">
<dl>
<dt class="hdlist1">高级可编程中断控制器</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ata-glossary" class="dlist">
<dl>
<dt class="hdlist1">高级技术附件</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="atm-glossary" class="dlist">
<dl>
<dt class="hdlist1">异步传输模式</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="apop-glossary" class="dlist">
<dl>
<dt class="hdlist1">认证邮局协议</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="amd-glossary" class="dlist">
<dl>
<dt class="hdlist1">自动挂载守护进程</dt>
<dd>
<p>当访问文件系统中的文件或目录时，自动挂载文件系统的守护进程。</p>
</dd>
</dl>
</div>
<h3 id="_b" class="discrete">B</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">BAR</dt>
<dd>
<p>参见 <a href="#bar-glossary ">基地址寄存器 </a> 。</p>
</dd>
<dt class="hdlist1">BIND 是一种开源的域名系统（ DNS ）软件。它用于将域名转换为 IP 地址，并将 IP 地址转换为域名。 BIND 是最常用的 DNS 服务器软件之一，被广泛用于互联网和企业网络中。它提供了高度可靠和可扩展的 DNS 解析服务，支持各种功能和配置选项。 BIND 还具有强大的安全功能，可以防止 DNS 欺骗和其他网络攻击。</dt>
<dd>
<p>参见《 Berkeley Internet Name Domain 》。</p>
</dd>
<dt class="hdlist1">基本输入输出系统（ BIOS ）</dt>
<dd>
<p>参见《基本输入 / 输出系统（ BIOS ）》词汇表。</p>
</dd>
<dt class="hdlist1">BSD 是一种开放源代码的操作系统，它基于 Unix 的设计原则。 BSD 是 Berkeley Software Distribution 的缩写，最早由加州大学伯克利分校开发。 BSD 操作系统具有稳定性、可靠性和安全性的特点，并且被广泛用于服务器和嵌入式系统等领域。 BSD 操作系统有多个不同的分支，包括 FreeBSD 、 OpenBSD 和 NetBSD 等。这些分支在 BSD 的基础上进行了不同程度的修改和改进，以满足不同用户的需求。 BSD 操作系统也被许多大型互联网公司使用，如苹果公司的 macOS 就是基于 FreeBSD 开发的。总体而言， BSD 是一个强大而灵活的操作系统，为用户提供了丰富的功能和可定制性。</dt>
<dd>
<p>参见《伯克利软件发行版 (Berkeley Software Distribution) 》。</p>
</dd>
</dl>
</div>
<div id="bar-glossary" class="dlist">
<dl>
<dt class="hdlist1">基地址寄存器</dt>
<dd>
<p>确定 PCI 设备将响应的地址范围的寄存器。</p>
</dd>
</dl>
</div>
<div id="bios-glossary" class="dlist">
<dl>
<dt class="hdlist1">基本输入 / 输出系统</dt>
<dd>
<p>BIOS 的定义在一定程度上取决于上下文。有些人将其称为带有基本例程的 ROM 芯片，用于提供软件和硬件之间的接口。其他人将其称为包含在芯片中的一组例程，用于帮助引导系统。有些人还可能将其称为用于配置引导过程的屏幕。 BIOS 是特定于个人电脑的，但其他系统也有类似的东西。</p>
</dd>
</dl>
</div>
<div id="bind-glossary" class="dlist">
<dl>
<dt class="hdlist1">伯克利互联网域名系统</dt>
<dd>
<p>DNS 协议的实现。</p>
</dd>
</dl>
</div>
<div id="bsd-glossary" class="dlist">
<dl>
<dt class="hdlist1">伯克利软件发行版</dt>
<dd>
<p>这是加州大学伯克利分校的计算机系统研究组（ CSRG ）为 AT &amp; T 的 32V UNIX® 所做的改进和修改所赋予的名称。 FreeBSD 是 CSRG 工作的后代。</p>
</dd>
</dl>
</div>
<div id="bikeshed-glossary" class="dlist">
<dl>
<dt class="hdlist1">自行车棚建设</dt>
<dd>
<p>一种现象，即许多人对一个简单的话题发表意见，而对一个复杂的话题几乎没有讨论。有关该术语的起源，请参见 <a href="{faq}">FAQ ，涂漆自行车棚</a> 。</p>
</dd>
</dl>
</div>
<h3 id="_c_是一种通用的编程语言广泛用于开发各种应用程序和系统软件它是一种高级语言具有强大的表达能力和灵活性_c_语言具有简洁的语法和丰富的库函数使得开发者可以快速编写高效的代码它还具有良好的可移植性可以在不同的操作系统和硬件平台上运行_c_语言在计算机科学和软件工程领域有着重要的地位是学习和理解计算机底层原理的基础" class="discrete">C 是一种通用的编程语言，广泛用于开发各种应用程序和系统软件。它是一种高级语言，具有强大的表达能力和灵活性。 C 语言具有简洁的语法和丰富的库函数，使得开发者可以快速编写高效的代码。它还具有良好的可移植性，可以在不同的操作系统和硬件平台上运行。 C 语言在计算机科学和软件工程领域有着重要的地位，是学习和理解计算机底层原理的基础。</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">CD 是一种光盘，全称为“ Compact Disc ”，是一种用于存储和播放音频、视频和数据的介质。它具有高容量、长寿命和良好的音质特点，被广泛应用于音乐、电影、软件和游戏等领域。 CD 通常以数字形式存储数据，通过激光技术读取和写入数据。它是数字化时代的重要媒介之一，为人们提供了便捷的娱乐和信息获取方式。</dt>
<dd>
<p>参见 <a href="#cd-glossary ">载波检测 </a> 。</p>
</dd>
<dt class="hdlist1">CHAP （ Challenge-Handshake Authentication Protocol ）</dt>
<dd>
<p>请参阅《挑战握手认证协议》章节。</p>
</dd>
<dt class="hdlist1">CLIP 是一种基于深度学习的图像和文本理解模型。它能够同时理解图像和文本，并将它们映射到一个共享的语义空间中。 CLIP 的目标是使计算机能够理解和推理出图像和文本之间的关系，从而实现更高级的视觉和语言任务。通过训练大规模的图像和文本数据集， CLIP 能够学习到丰富的视觉和语义表示，从而在各种任务中展现出强大的性能。</dt>
<dd>
<p>请参阅《经典 IP over ATM 》的 <a href="#clip-glossary">[clip-glossary]</a> 部分。</p>
</dd>
<dt class="hdlist1">COFF （ Common Object File Format ）是一种通用的目标文件格式，用于存储编译后的程序代码和数据。它被广泛用于计算机软件开发中，特别是在 Windows 操作系统上。 COFF 文件包含了可执行文件、动态链接库和静态库等形式的目标文件。它提供了一种标准化的方式来组织和管理程序的代码和数据，使得不同的编译器和链接器能够互相兼容和交互操作。 COFF 文件格式定义了文件头、节表、符号表和重定位表等部分，以及其他一些附加信息。通过解析 COFF 文件，计算机系统可以加载和执行程序，实现软件的运行和功能。</dt>
<dd>
<p>请参阅 <a href="#coff-glossary ">通用目标文件格式 </a> 。</p>
</dd>
<dt class="hdlist1">中央处理器</dt>
<dd>
<p>参见 <a href="#cpu-glossary ">中央处理器 </a> 。</p>
</dd>
<dt class="hdlist1">CTS 是指 Compatibility Test Suite ，即兼容性测试套件。它是用于测试 Android 设备和应用程序是否符合 Android 兼容性标准的一套测试工具和测试用例。 CTS 包含了一系列的测试，包括功能测试、性能测试、稳定性测试等，以确保 Android 设备和应用程序在不同硬件和软件环境下的兼容性和稳定性。 CTS 是 Android 兼容性计划的重要组成部分，通过使用 CTS 进行测试，可以确保 Android 设备和应用程序的互操作性和一致性。</dt>
<dd>
<p>参见《 cts-glossary ， Clear To Send 》。</p>
</dd>
</dl>
</div>
<div id="cd-glossary" class="dlist">
<dl>
<dt class="hdlist1">载波检测</dt>
<dd>
<p>RS232C 信号表示已检测到载波。</p>
</dd>
</dl>
</div>
<div id="cpu-glossary" class="dlist">
<dl>
<dt class="hdlist1">中央处理器</dt>
<dd>
<p>也被称为处理器。这是计算机的大脑，所有的计算都在这里进行。有许多不同的架构，具有不同的指令集。其中比较知名的有 Intel-x86 及其衍生产品、 Arm 和 PowerPC 。</p>
</dd>
</dl>
</div>
<div id="chap-glossary" class="dlist">
<dl>
<dt class="hdlist1">挑战 - 握手认证协议</dt>
<dd>
<p>基于客户端和服务器之间共享的秘密，对用户进行身份验证的方法。</p>
</dd>
</dl>
</div>
<div id="clip-glossary" class="dlist">
<dl>
<dt class="hdlist1">经典的 ATM 上的 IP</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="cts-glossary" class="dlist">
<dl>
<dt class="hdlist1">清除发送</dt>
<dd>
<p>RS232C 信号表示远程系统被授权发送数据。</p>
<div class="paragraph">
<p>参见 <a href="#rts-glossary ">也称为请求发送（ Also Request To Send ） </a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="coff-glossary" class="dlist">
<dl>
<dt class="hdlist1">通用对象文件格式</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<h3 id="_d" class="discrete">D</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">DAC 是数字到模拟转换器（ Digital-to-Analog Converter ）的缩写，它是一种将数字信号转换为模拟信号的设备或电路。 DAC 在许多应用中都起着重要的作用，例如音频设备、通信系统和控制系统等。它将数字信号的离散值转换为连续的模拟信号，以便在模拟电路中进行处理或输出。 DAC 的性能通常由分辨率、采样率、线性度和动态范围等参数来衡量。</dt>
<dd>
<p>请参阅 <a href="#dac-glossary ">自主访问控制 </a> 。</p>
</dd>
<dt class="hdlist1">DDB</dt>
<dd>
<p>请参阅 <a href="#ddb-glossary ">调试器 </a> 。</p>
</dd>
<dt class="hdlist1">数据加密标准（ DES ）是一种对称密钥加密算法，用于保护数据的机密性。它使用 56 位密钥对 64 位的数据块进行加密和解密。 DES 算法在计算机安全领域得到广泛应用，但由于其较短的密钥长度，已经被认为不够安全。</dt>
<dd>
<p>请参阅《数据加密标准》（ Data Encryption Standard ）。</p>
</dd>
<dt class="hdlist1">动态主机配置协议（ DHCP ）</dt>
<dd>
<p>参见《动态主机配置协议（ Dynamic Host Configuration Protocol ）术语表》。</p>
</dd>
<dt class="hdlist1">DNS （ Domain Name System ）是一种用于将域名转换为 IP 地址的分布式命名系统。它充当了互联网上的电话簿，将人类可读的域名映射到计算机可理解的 IP 地址。 DNS 的主要功能包括域名解析、域名注册和域名管理等。通过 DNS ，用户可以通过输入域名来访问网站、发送电子邮件等。 DNS 的工作原理是通过查询分布在全球各地的 DNS 服务器来获取域名与 IP 地址之间的映射关系。</dt>
<dd>
<p>参见 <a href="#dns-glossary ">域名系统 </a> 。</p>
</dd>
<dt class="hdlist1">DSDT （ Differentiated System Description Table ）是一种 ACPI （ Advanced Configuration and Power Interface ）规范中定义的表格，用于描述计算机硬件的配置和功能。 DSDT 表格包含了操作系统在启动过程中需要的关键信息，如设备的类型、特性和驱动程序的加载方式。操作系统在启动时会读取 DSDT 表格，并根据其中的信息来正确地配置和管理硬件设备。</dt>
<dd>
<p>参见 <a href="#dsdt-glossary ">不同 iated System Description Table</a> 。</p>
</dd>
<dt class="hdlist1">DSR 是指动态频谱分配（ Dynamic Spectrum Allocation ）的缩写。动态频谱分配是一种无线通信技术，通过实时监测和管理无线频谱资源的利用，以提高频谱利用效率和满足不同用户和应用的需求。它可以根据实际需求动态地分配和重新分配频谱资源，以最大程度地提高频谱利用率和网络性能。</dt>
<dd>
<p>参见 <a href="#dsr-glossary ">数据集就绪 </a> 。</p>
</dd>
<dt class="hdlist1">DTR 是指“定义测试关系（ Define The Relationship ）”。</dt>
<dd>
<p>参见 <a href="#dtr-glossary ">数据终端就绪 </a> 。</p>
</dd>
<dt class="hdlist1">DVMRP （ Distance Vector Multicast Routing Protocol ）是一种距离向量组播路由协议。它用于在互联网中传输组播数据包，并通过距离向量算法来确定最佳的组播路径。 DVMRP 使用基于距离的度量来选择最短路径，并使用组播树来转发数据包。它是一种基于 IP 的组播路由协议，适用于小型网络和较简单的拓扑结构。</dt>
<dd>
<p>参见《距离向量组播路由协议词汇表》（ Distance-Vector Multicast Routing Protocol ）。</p>
</dd>
</dl>
</div>
<div id="dac-glossary" class="dlist">
<dl>
<dt class="hdlist1">自主访问控制</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="des-glossary" class="dlist">
<dl>
<dt class="hdlist1">数据加密标准</dt>
<dd>
<p>一种加密信息的方法，传统上用作 UNIX® 密码的加密方法和 <a href="https://man.freebsd.org/cgi/man.cgi?query=crypt&amp;sektion=3&amp;format=html">crypt(3)</a> 函数的加密方法。</p>
</dd>
</dl>
</div>
<div id="dsr-glossary" class="dlist">
<dl>
<dt class="hdlist1">数据集准备完毕</dt>
<dd>
<p>RS232C 信号是从调制解调器发送到计算机或终端的信号，表示准备好发送和接收数据。</p>
<div class="paragraph">
<p>参见 <a href="#dtr-glossary ">也可以参考数据终端就绪 </a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="dtr-glossary" class="dlist">
<dl>
<dt class="hdlist1">数据终端就绪</dt>
<dd>
<p>RS232C 信号是从计算机或终端发送到调制解调器的信号，表示准备好发送和接收数据。</p>
</dd>
</dl>
</div>
<div id="ddb-glossary" class="dlist">
<dl>
<dt class="hdlist1">调试器</dt>
<dd>
<p>一个交互式的内核工具，用于检查系统的状态，通常在系统崩溃后用于确定故障周围的事件。</p>
</dd>
</dl>
</div>
<div id="dsdt-glossary" class="dlist">
<dl>
<dt class="hdlist1">差异化系统描述表</dt>
<dd>
<p>一个 ACPI 表，提供关于基本系统配置信息的基本信息。</p>
</dd>
</dl>
</div>
<div id="dvmrp-glossary" class="dlist">
<dl>
<dt class="hdlist1">距离向量多播路由协议</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="dns-glossary" class="dlist">
<dl>
<dt class="hdlist1">域名系统</dt>
<dd>
<p>将人类可读的主机名（即 mail.example.net ）转换为 Internet 地址，反之亦然的系统。</p>
</dd>
</dl>
</div>
<div id="dhcp-glossary" class="dlist">
<dl>
<dt class="hdlist1">动态主机配置协议</dt>
<dd>
<p>当计算机（主机）向服务器请求 IP 地址时，动态分配 IP 地址的协议。地址分配被称为“租约”。</p>
</dd>
</dl>
</div>
<h3 id="_e" class="discrete">E</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">ECOFF 是一种可执行文件格式，用于表示可执行程序和共享库。它是早期 UNIX 系统中常用的格式之一，用于存储二进制代码和相关的符号信息。 ECOFF 文件包含了程序的指令、数据和符号表等信息，可以在操作系统中加载和执行。</dt>
<dd>
<p>请参阅《扩展 COFF （ Extended COFF ）》。</p>
</dd>
<dt class="hdlist1">ELF （ Executable and Linkable Format ）是一种可执行和可链接格式，用于在计算机系统中存储可执行文件、目标文件和共享库。它是一种通用的二进制文件格式，被广泛用于 UNIX 和类 UNIX 系统中。 ELF 文件包含了程序的机器代码、数据、符号表和其他与程序执行相关的信息。它提供了灵活的内存管理和动态链接的能力，使得程序的加载和执行更加高效和可靠。</dt>
<dd>
<p>参见 <a href="#elf-glossary ">可执行和链接格式 </a> 。</p>
</dd>
<dt class="hdlist1">ESP 是指英语为第二语言（ English as a Second Language ）的缩写。</dt>
<dd>
<p>参见 <a href="#esp-glossary ">封装安全载荷 </a> 。</p>
</dd>
<dt class="hdlist1">封装安全载荷</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="elf-glossary" class="dlist">
<dl>
<dt class="hdlist1">可执行和链接格式</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ecoff-glossary" class="dlist">
<dl>
<dt class="hdlist1">扩展 COFF</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<h3 id="_f" class="discrete">F</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">FADT 是固件可用性和设备性能表（ Firmware ACPI Description Table ）的缩写。它是一种 ACPI （高级配置和电源接口）表格，用于描述计算机系统中的固件和硬件设备的特性和功能。 FADT 包含了系统的基本信息，如固件版本、电源管理特性和硬件配置等。它在操作系统启动时被 BIOS 或 UEFI 固件提供给操作系统，以便操作系统能够正确地管理和与硬件设备进行通信。</dt>
<dd>
<p>参见 <a href="#fadt-glossary ">固定 ACPI 描述表 </a> 。</p>
</dd>
<dt class="hdlist1">FAT 是一种文件系统，全称为 FAT （ File Allocation Table ），是一种用于在计算机存储设备上组织和管理文件的方法。 FAT 最早由微软公司开发，广泛应用于 DOS 和 Windows 操作系统中。 FAT 文件系统使用一种称为文件分配表的数据结构来跟踪文件的存储位置和状态。 FAT 文件系统具有简单、可靠和兼容性好的特点，但在处理大容量存储设备和大文件时性能较差。</dt>
<dd>
<p>请参阅 <a href="#fat-glossary ">文件分配表 </a> 。</p>
</dd>
<dt class="hdlist1">FAT16 是一种文件系统，它是 FAT （文件分配表）系列中的一种。它最初在 1984 年由微软引入，用于 DOS 操作系统和早期的 Windows 版本。 FAT16 使用 16 位的文件分配表项来管理文件和目录的存储和访问。它支持最大容量为 2GB 的分区，并具有较低的存储效率和文件系统限制。尽管 FAT16 已经被更先进的文件系统所取代，但它仍然在某些嵌入式系统和旧版操作系统中使用。</dt>
<dd>
<p>参见 <a href="#fat16-glossary ">文件分配表（ 16 位） </a> 。</p>
</dd>
<dt class="hdlist1">FTP 是一种用于在计算机网络上传输文件的协议。它允许用户通过客户端和服务器之间的连接来上传和下载文件。 FTP 使用基于文本的命令和响应模式进行通信，并支持匿名访问和身份验证。它是互联网上最常用的文件传输协议之一。</dt>
<dd>
<p>参见 <a href="#ftp-glossary ">文件传输协议 </a> 。</p>
</dd>
</dl>
</div>
<div id="fat-glossary" class="dlist">
<dl>
<dt class="hdlist1">文件分配表</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="fat16-glossary" class="dlist">
<dl>
<dt class="hdlist1">文件分配表（ 16 位）</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ftp-glossary" class="dlist">
<dl>
<dt class="hdlist1">文件传输协议</dt>
<dd>
<p>一种基于 TCP 实现的高级协议家族的成员，可用于在 TCP/IP 网络上传输文件。</p>
</dd>
</dl>
</div>
<div id="fadt-glossary" class="dlist">
<dl>
<dt class="hdlist1">固定 ACPI 描述表</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<h3 id="_g" class="discrete">G</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">图形用户界面（ GUI ）</dt>
<dd>
<p>参见 <a href="#gui-glossary ">图形用户界面 </a> 。</p>
</dd>
</dl>
</div>
<div id="giant-glossary" class="dlist">
<dl>
<dt class="hdlist1">巨人</dt>
<dd>
<p>一个互斥机制的名称（一个睡眠“互斥锁”），用于保护大量的内核资源。尽管在过去，一个简单的锁机制足以满足机器可能只有几十个进程、一个网络卡，当然只有一个处理器的需求，但在当前时代，它是一个无法接受的性能瓶颈。 FreeBSD 开发人员正在积极努力将其替换为保护单个资源的锁，这将为单处理器和多处理器机器提供更高程度的并行性。</p>
</dd>
</dl>
</div>
<div id="gui-glossary" class="dlist">
<dl>
<dt class="hdlist1">图形用户界面</dt>
<dd>
<p>用户和计算机通过图形进行交互的系统。</p>
</dd>
</dl>
</div>
<h3 id="_你好我是一个翻译引擎我可以帮助你将英文翻译成中文请告诉我你需要翻译的内容" class="discrete">你好！我是一个翻译引擎，我可以帮助你将英文翻译成中文。请告诉我你需要翻译的内容。</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">HTML （超文本标记语言）是一种用于创建网页的标准标记语言。它使用标签来描述网页的结构和内容，并且可以通过链接和嵌入其他媒体（如图像、视频和音频）来丰富网页的呈现效果。 HTML 是 Web 开发的基础，它提供了一种结构化的方式来组织和呈现信息，使得网页可以在不同的设备和浏览器上进行访问和显示。</dt>
<dd>
<p>参见 <a href="#html-glossary ">超文本标记语言 </a> 。</p>
</dd>
<dt class="hdlist1">HUP</dt>
<dd>
<p>参见 <a href="#hup-glossary ">挂断 </a> 。</p>
</dd>
</dl>
</div>
<div id="hup-glossary" class="dlist">
<dl>
<dt class="hdlist1">挂断电话</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="html-glossary" class="dlist">
<dl>
<dt class="hdlist1">超文本标记语言</dt>
<dd>
<p>用于创建网页的标记语言。</p>
</dd>
</dl>
</div>
<h3 id="_i" class="discrete">I</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">输入 / 输出</dt>
<dd>
<p>请参阅 <a href="#io-glossary ">输入 / 输出 </a> 。</p>
</dd>
<dt class="hdlist1">IASL 是 Intel ACPI Source Language 的缩写，意为 Intel ACPI 源代码语言。</dt>
<dd>
<p>请参阅 <a href="#iasl-glossary ， Intel 的 ASL 编译器 ">[iasl-glossary ， Intel 的 ASL 编译器 ]</a> 。</p>
</dd>
<dt class="hdlist1">IMAP （ Internet Mail Access Protocol ）是一种用于电子邮件客户端与邮件服务器之间进行通信的协议。它允许用户在不下载邮件的情况下直接在邮件服务器上管理和查看邮件。 IMAP 提供了更多的功能和灵活性，例如可以在多个设备上同步邮件、管理文件夹和标签、搜索邮件等。 IMAP 是一种常用的电子邮件协议，被广泛用于个人和企业邮件系统中。</dt>
<dd>
<p>参见 <a href="#imap-glossary ">Internet Message Access Protocol</a> 。</p>
</dd>
<dt class="hdlist1">IP 是 Internet Protocol （互联网协议）的缩写，它是一种用于在网络上传输数据的协议。 IP 地址是一个由数字和点组成的标识符，用于唯一标识网络上的设备。 IP 地址可以分为 IPv4 和 IPv6 两种格式。 IPv4 地址由 32 位二进制数表示，通常以点分十进制的形式呈现。 IPv6 地址由 128 位二进制数表示，通常以冒号分隔的八组十六进制数呈现。 IP 地址的作用是在网络上定位和识别设备，使得数据能够正确地传输和交换。</dt>
<dd>
<p>参见 <a href="#ip-glossary ">Internet Protocol</a> 。</p>
</dd>
<dt class="hdlist1">IPFW 是指 Internet 协议防火墙，是一种用于保护计算机网络安全的软件或硬件设备。它可以监控和控制网络流量，根据预设的规则来允许或阻止特定的网络连接。 IPFW 可以帮助防止未经授权的访问、网络攻击和数据泄露等安全威胁。</dt>
<dd>
<p>参见 <a href="#ipfw-glossary ">IP 防火墙 </a> 。</p>
</dd>
<dt class="hdlist1">IPP 是 Internet Printing Protocol 的缩写，即互联网打印协议。它是一种用于在网络上进行打印操作的协议，允许用户通过互联网连接到远程打印机并发送打印任务。 IPP 提供了一种标准化的方式来管理打印作业，包括打印机的发现、状态查询、打印任务的提交和控制等功能。它是一种跨平台的协议，可以在不同操作系统和设备之间进行通信。</dt>
<dd>
<p>请参阅 <a href="#ipp-glossary ">Internet Printing Protocol</a> 。</p>
</dd>
<dt class="hdlist1">IPv4 是 Internet Protocol version 4 的缩写，即互联网协议第四版。它是一种用于在互联网上进行数据传输的网络协议。 IPv4 使用 32 位地址来标识网络上的设备，这些地址由四个十进制数表示，每个数的取值范围是 0 到 255 。 IPv4 是目前广泛使用的互联网协议，但由于地址空间有限，已经逐渐被 IPv6 取代。</dt>
<dd>
<p>请参阅 <a href="#ipv4-glossary ">IP 版本 4</a> 。</p>
</dd>
<dt class="hdlist1">IPv6 是 Internet 协议第六版的缩写，它是一种用于互联网通信的网络协议。 IPv6 的主要目的是解决 IPv4 所面临的地址耗尽问题，并提供更好的安全性、可靠性和性能。与 IPv4 相比， IPv6 拥有更大的地址空间，能够支持更多的设备连接到互联网。此外， IPv6 还引入了一些新的特性，如流量优先级和安全性增强。随着互联网的发展， IPv6 正逐渐取代 IPv4 成为主流的网络协议。</dt>
<dd>
<p>请参阅《 IPv6 词汇表， IP 版本 6 》。</p>
</dd>
<dt class="hdlist1">ISP 是 Internet Service Provider 的缩写，意为互联网服务提供商。</dt>
<dd>
<p>参见 <a href="#isp-glossary ">互联网服务提供商 </a> 。</p>
</dd>
</dl>
</div>
<div id="ipfw-glossary" class="dlist">
<dl>
<dt class="hdlist1">IP 防火墙</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ipv4-glossary" class="dlist">
<dl>
<dt class="hdlist1">IP 版本 4</dt>
<dd>
<p>IP 协议版本 4 使用 32 位进行寻址。这个版本仍然是最广泛使用的，但正在逐渐被 IPv6 取代。</p>
<div class="paragraph">
<p>请参阅《 IPv6 词汇表，同时也是 IP 版本 6 》。</p>
</div>
</dd>
</dl>
</div>
<div id="ipv6-glossary" class="dlist">
<dl>
<dt class="hdlist1">IP 版本 6</dt>
<dd>
<p>新的 IP 协议。由于 IPv4 中的地址空间即将耗尽而发明。使用 128 位进行寻址。</p>
</dd>
</dl>
</div>
<div id="io-glossary" class="dlist">
<dl>
<dt class="hdlist1">输入 / 输出</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="iasl-glossary" class="dlist">
<dl>
<dt class="hdlist1">英特尔的 ASL 编译器</dt>
<dd>
<p>Intel 的编译器用于将 ASL 转换为 AML 。</p>
</dd>
</dl>
</div>
<div id="imap-glossary" class="dlist">
<dl>
<dt class="hdlist1">Internet Message Access Protocol （ IMAP ）</dt>
<dd>
<p>一种用于访问邮件服务器上的电子邮件消息的协议，其特点是消息通常保存在服务器上，而不是下载到邮件阅读器客户端。</p>
<div class="paragraph">
<p>参见邮局协议版本 3 。</p>
</div>
</dd>
</dl>
</div>
<div id="ipp-glossary" class="dlist">
<dl>
<dt class="hdlist1">Internet 打印协议</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ip-glossary" class="dlist">
<dl>
<dt class="hdlist1">互联网协议</dt>
<dd>
<p>互联网上的基本协议，用于数据包传输。最初由美国国防部开发，是 TCP/IP 协议栈的一个极其重要的组成部分。没有互联网协议，互联网就不会成为今天的样子。更多信息，请参见链接： <a href="ftp://ftp.rfc-editor.org/in-notes/rfc791.txt">RFC 791</a> 。</p>
</dd>
</dl>
</div>
<div id="isp-glossary" class="dlist">
<dl>
<dt class="hdlist1">互联网服务提供商</dt>
<dd>
<p>一家提供互联网接入的公司。</p>
</dd>
</dl>
</div>
<h3 id="_k" class="discrete">K</h3>
<div id="kame-glossary" class="dlist">
<dl>
<dt class="hdlist1">KAME</dt>
<dd>
<p>“ KAME ”是日语中表示“乌龟”的词语，在计算机界中用来指代 <a href="http://www.kame.net/">KAME 项目</a> ，该项目致力于 IPv6 的实现。</p>
</dd>
<dt class="hdlist1">KDC 是密钥分发中心（ Key Distribution Center ）的缩写，它是一种用于计算机网络中的身份验证和密钥管理的中心化服务。 KDC 负责生成、分发和管理网络中的密钥，以确保通信的安全性和保密性。 KDC 通常与 Kerberos 身份验证协议一起使用，用于验证用户的身份并生成用于加密通信的会话密钥。</dt>
<dd>
<p>参见 <a href="#kdc-glossary ">密钥分发中心 </a> 。</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>KLD 是指 Kullback-Leibler 散度，是一种用于衡量两个概率分布之间差异的度量方法。它可以用来比较两个概率分布的相似性或者在机器学习中用于评估模型的性能。 KLD 的计算公式如下：</p>
</div>
<div class="literalblock">
<div class="content">
<pre>KLD(P || Q) = Σ (P(x) * log(P(x) / Q(x)))</pre>
</div>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1">其中， P 和 Q 分别表示两个概率分布， x 表示概率分布中的元素。 KLD 的值越小，表示两个概率分布越相似。</dt>
<dd>
<p>参见 <a href="#kld-glossary ">Kernel ld(1)</a> 。</p>
</dd>
<dt class="hdlist1">KSE</dt>
<dd>
<p>请参阅 <a href="#kse-glossary ">内核调度实体 </a> 。</p>
</dd>
<dt class="hdlist1">千伏安（ KVA ）</dt>
<dd>
<p>参见 <a href="#kva-glossary ，内核虚拟地址 ">[kva-glossary ，内核虚拟地址 ]</a> 。</p>
</dd>
<dt class="hdlist1">千比特每秒</dt>
<dd>
<p>参见 <a href="#kbps-glossary ">每秒千位比特数 </a> 。</p>
</dd>
</dl>
</div>
<div id="kld-glossary" class="dlist">
<dl>
<dt class="hdlist1">内核手册： ld[1]</dt>
<dd>
<p>一种在不重新启动系统的情况下将功能动态加载到 FreeBSD 内核的方法。</p>
</dd>
</dl>
</div>
<div id="kse-glossary" class="dlist">
<dl>
<dt class="hdlist1">内核调度实体</dt>
<dd>
<p>一个由内核支持的线程系统。详细信息请参见链接： <a href="http://www.freebsd.org/kse">项目主页</a> 。</p>
</dd>
</dl>
</div>
<div id="kva-glossary" class="dlist">
<dl>
<dt class="hdlist1">内核虚拟地址</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="kdc-glossary" class="dlist">
<dl>
<dt class="hdlist1">密钥分发中心</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="kbps-glossary" class="dlist">
<dl>
<dt class="hdlist1">千比特每秒</dt>
<dd>
<p>用于测量带宽（在指定的时间内可以通过给定点的数据量）。除了 Kilo 前缀之外，还有 Mega 、 Giga 、 Tera 等替代选项。</p>
</dd>
</dl>
</div>
<h3 id="_l" class="discrete">L</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">局域网</dt>
<dd>
<p>参见 <a href="#lan-glossary ">局域网 </a> 。</p>
</dd>
<dt class="hdlist1">LOR 是英文中的缩写，代表&#34;Letter of Recommendation&#34;，中文意为&#34;推荐信&#34;。</dt>
<dd>
<p>参见 <a href="#lor-glossary ">锁顺序颠倒 </a> 。</p>
</dd>
<dt class="hdlist1">LPD 是 Line Printer Daemon 的缩写，它是一种用于打印机管理的网络协议。 LPD 协议允许计算机通过网络将打印任务发送到打印机，并且可以在打印队列中排队等待打印。 LPD 协议还定义了一些命令和参数，用于控制打印任务的处理和管理。</dt>
<dd>
<p>参见 <a href="#lpd-glossary ">行式打印机守护进程 </a> 。</p>
</dd>
</dl>
</div>
<div id="lpd-glossary" class="dlist">
<dl>
<dt class="hdlist1">行打印机守护程序</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="lan-glossary" class="dlist">
<dl>
<dt class="hdlist1">本地区域网络</dt>
<dd>
<p>局域网是指在局部范围内使用的网络，例如办公室、家庭等。</p>
</dd>
</dl>
</div>
<div id="lor-glossary" class="dlist">
<dl>
<dt class="hdlist1">锁定顺序颠倒</dt>
<dd>
<p>FreeBSD 内核使用多个资源锁来调解对这些资源的争用。在 FreeBSD-CURRENT 内核中发现的一个运行时锁诊断系统（但在发布版本中已被删除），称为 <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> ，可以检测由于锁定错误而导致死锁的潜在可能性。（ <a href="https://man.freebsd.org/cgi/man.cgi?query=witness&amp;sektion=4&amp;format=html">witness(4)</a> 实际上稍微保守，因此可能会出现误报。）真正的阳性报告表示“如果你运气不好，死锁将会在这里发生”。</p>
<div class="paragraph">
<p>真正的正面 LOR （锁定对象关系）往往会很快得到修复，因此在向邮件列表发布之前，请在 <a href="https://lists.FreeBSD.org/subscription/freebsd-current" class="bare">https://lists.FreeBSD.org/subscription/freebsd-current</a> 和链接： <a href="http://sources.zabbadoz.net/freebsd/lor.html">LORs Seen</a> 页面上进行检查。</p>
</div>
</dd>
</dl>
</div>
<h3 id="_m" class="discrete">M</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">MAC 是指&#34;Media Access Control&#34;，中文意为媒体访问控制。在计算机网络中， MAC 地址是用于唯一标识网络设备的物理地址。每个网络设备都有一个唯一的 MAC 地址，它由 48 位二进制数表示。 MAC 地址通常以十六进制的形式表示，由 6 个字节组成，每个字节用冒号或连字符分隔。 MAC 地址在数据链路层起着重要的作用，用于在局域网中识别和定位设备。</dt>
<dd>
<p>参见 <a href="#mac-glossary ">强制访问控制 </a> 。</p>
</dd>
<dt class="hdlist1">MADT</dt>
<dd>
<p>请参阅 <a href="#madt-glossary ">多 APIC 描述表 </a> 。</p>
</dd>
<dt class="hdlist1">MFC （ Microsoft Foundation Class ）是微软基于 C ++语言开发的一套应用程序框架。它提供了一系列的类和函数，用于简化 Windows 应用程序的开发过程。 MFC 包含了许多常用的功能，如窗口管理、消息处理、用户界面设计等，使开发者能够更快速、更方便地创建 Windows 应用程序。 MFC 已经成为 Windows 平台上最常用的应用程序开发框架之一。</dt>
<dd>
<p>请参阅 <a href="#mfc-glossary ">合并当前版本 </a> 。</p>
</dd>
<dt class="hdlist1">MFH 是指&#34;Mainframe Host&#34;，即主机机架。</dt>
<dd>
<p>参见 <a href="#mfh-glossary ">从头合并 </a> 。</p>
</dd>
<dt class="hdlist1">MFS 是指分布式文件系统（ Distributed File System ），它是一种用于存储和管理大规模数据的系统。 MFS 将数据分布在多个服务器上，通过网络进行访问和操作。它提供了高可用性、可扩展性和容错性，能够有效地处理大量数据的存储和访问需求。 MFS 在计算机领域被广泛应用于大数据处理、云计算和分布式存储等领域。</dt>
<dd>
<p>请参阅 <a href="#mfs-glossary ">从稳定分支合并 </a> 。</p>
</dd>
<dt class="hdlist1">MFV 是指最小可行化产品（ Minimum Viable Product ）的缩写。最小可行化产品是指在产品开发过程中，以最小的功能集合来满足用户需求的产品版本。它的目的是通过快速构建和发布最小可行化产品，来验证产品的可行性和市场需求，以便在后续开发中进行迭代和改进。最小可行化产品的特点是具有基本的核心功能，能够提供用户价值，并且能够在短时间内开发和发布。</dt>
<dd>
<p>请参阅 <a href="#mfv-glossary ">从供应商合并 </a> 。</p>
</dd>
<dt class="hdlist1">麻省理工学院</dt>
<dd>
<p>参见《麻省理工学院词汇表》。</p>
</dd>
<dt class="hdlist1">多级安全（ MLS ）</dt>
<dd>
<p>请参阅 <a href="#mls-glossary ">多级安全 </a> 。</p>
</dd>
<dt class="hdlist1">MOTD （ Message of the Day ）是一条每天显示在计算机终端或登录界面上的消息。</dt>
<dd>
<p>参见 <a href="#motd-glossary ">每日消息 </a> 。</p>
</dd>
<dt class="hdlist1">MTA 是邮件传输代理（ Mail Transfer Agent ）的缩写，它是一种计算机程序或软件，用于在计算机网络中传输电子邮件。 MTA 负责接收、路由和传递电子邮件，以确保邮件能够准确、高效地发送到目标地址。常见的 MTA 软件包括 Sendmail 、 Postfix 和 Exim 等。</dt>
<dd>
<p>参见 <a href="#mta-glossary ">邮件传输代理 </a> 。</p>
</dd>
<dt class="hdlist1">MUA</dt>
<dd>
<p>参见 <a href="#mua-glossary ">邮件用户代理 </a> 。</p>
</dd>
</dl>
</div>
<div id="mta-glossary" class="dlist">
<dl>
<dt class="hdlist1">邮件传输代理</dt>
<dd>
<p>MTA （ Mail Transfer Agent ）是用于传输电子邮件的应用程序。传统上， MTA 一直是 BSD 基础系统的一部分。如今， Sendmail 已经包含在基础系统中，但还有许多其他的 MTA ，例如 postfix 、 qmail 和 Exim 。</p>
</dd>
</dl>
</div>
<div id="mua-glossary" class="dlist">
<dl>
<dt class="hdlist1">邮件用户代理</dt>
<dd>
<p>用户使用的应用程序，用于显示和编写电子邮件。</p>
</dd>
</dl>
</div>
<div id="mac-glossary" class="dlist">
<dl>
<dt class="hdlist1">强制访问控制</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="mit-glossary" class="dlist">
<dl>
<dt class="hdlist1">麻省理工学院</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="mfc-glossary" class="dlist">
<dl>
<dt class="hdlist1">合并当前版本</dt>
<dd>
<p>要将功能或补丁从 -CURRENT 分支合并到另一个分支，通常是 -STABLE 分支。</p>
</dd>
</dl>
</div>
<div id="mfh-glossary" class="dlist">
<dl>
<dt class="hdlist1">合并自头部</dt>
<dd>
<p>将功能或补丁从存储库的 HEAD 合并到较早的分支。</p>
</dd>
</dl>
</div>
<div id="mfs-glossary" class="dlist">
<dl>
<dt class="hdlist1">从稳定分支合并</dt>
<dd>
<p>在 FreeBSD 的正常开发过程中，一个变更会先提交到 -CURRENT 分支进行测试，然后再合并到 -STABLE 分支。但在极少数情况下，一个变更会先进入 -STABLE 分支，然后再合并到 -CURRENT 分支。</p>
<div class="paragraph">
<p>当一个补丁从 -STABLE 分支合并到安全分支时，也会使用这个术语。</p>
</div>
<div class="paragraph">
<p>参见 <a href="#mfc-glossary ">同时合并当前内容 </a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="mfv-glossary" class="dlist">
<dl>
<dt class="hdlist1">从供应商合并</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="motd-glossary" class="dlist">
<dl>
<dt class="hdlist1">每日消息</dt>
<dd>
<p>通常在登录时显示的消息，经常用于向系统用户分发信息。</p>
</dd>
</dl>
</div>
<div id="mls-glossary" class="dlist">
<dl>
<dt class="hdlist1">多级安全</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="madt-glossary" class="dlist">
<dl>
<dt class="hdlist1">多个 APIC 描述表</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<h3 id="_n" class="discrete">N</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">网络地址转换（ NAT ）</dt>
<dd>
<p>参见 <a href="#nat-glossary ">网络地址转换 </a> 。</p>
</dd>
<dt class="hdlist1">NDISulator 是一种网络驱动程序隔离技术。它允许在计算机系统中运行多个网络驱动程序实例，每个实例都在独立的隔离环境中运行。这种隔离技术可以提供更高的系统稳定性和安全性，同时还可以提供更好的网络性能和可扩展性。 NDISulator 广泛应用于计算机网络领域，特别是在虚拟化和云计算环境中。</dt>
<dd>
<p>请参阅《 Project Evil 》的 <a href="#projectevil-glossary ">术语表 </a> 。</p>
</dd>
<dt class="hdlist1">NFS （ Network File System ）是一种用于在计算机网络上共享文件的协议。它允许不同的计算机系统通过网络访问和共享文件和目录。 NFS 是一种分布式文件系统，它允许客户端计算机像访问本地文件一样访问远程文件。它提供了高性能和可靠性，并且被广泛用于许多计算机网络环境中。</dt>
<dd>
<p>参见《 NFS 词汇表，网络文件系统》。</p>
</dd>
<dt class="hdlist1">NTFS （新技术文件系统）是一种用于 Windows 操作系统的文件系统。它具有许多优点，包括对大容量硬盘驱动器的支持、文件和文件夹的安全性、高速读写能力以及对文件压缩和加密的支持。 NTFS 还支持许多高级功能，如文件权限和日志记录，以提供更可靠和稳定的文件系统。</dt>
<dd>
<p>请参阅《 NTFS 词汇表》。</p>
</dd>
<dt class="hdlist1">网络时间协议（ NTP ）</dt>
<dd>
<p>参见《网络时间协议（ Network Time Protocol ）》的 <a href="#ntp-glossary ">网络时间协议术语表 </a> 。</p>
</dd>
</dl>
</div>
<div id="nat-glossary" class="dlist">
<dl>
<dt class="hdlist1">网络地址转换</dt>
<dd>
<p>一种技术，通过网关对 IP 数据包进行重写，使得位于网关后面的多台机器能够有效地共享一个 IP 地址。</p>
</dd>
</dl>
</div>
<div id="nfs-glossary" class="dlist">
<dl>
<dt class="hdlist1">网络文件系统</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ntfs-glossary" class="dlist">
<dl>
<dt class="hdlist1">新技术文件系统</dt>
<dd>
<p>一个由微软开发并在其“新技术”操作系统中可用的文件系统，如 Windows® 2000 ， Windows NT® 和 Windows® XP 。</p>
</dd>
</dl>
</div>
<div id="ntp-glossary" class="dlist">
<dl>
<dt class="hdlist1">网络时间协议</dt>
<dd>
<p>一种通过网络同步时钟的方法。</p>
</dd>
</dl>
</div>
<h3 id="_嗨我是一个翻译引擎我可以帮助你将英文翻译成中文请告诉我你需要翻译的内容" class="discrete">嗨！我是一个翻译引擎，我可以帮助你将英文翻译成中文。请告诉我你需要翻译的内容。</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">OBE 是指&#34;Outcome-Based Education&#34;，即以学习成果为导向的教育。</dt>
<dd>
<p>参见 <a href="#obe-glossary ">被事件超越 </a> 。</p>
</dd>
<dt class="hdlist1">ODMR 是一种用于电子邮件的协议，全称为&#34;Off-line Mail Retrieval&#34;。它允许用户在离线状态下检索电子邮件。 ODMR 协议通过与邮件服务器建立连接，并下载用户的新邮件。这种协议通常用于低带宽或不稳定网络连接的环境中，因为它可以减少在线检索邮件所需的时间和带宽。</dt>
<dd>
<p>请参阅《按需邮件中继（ On-Demand Mail Relay ）》。</p>
</dd>
<dt class="hdlist1">操作系统</dt>
<dd>
<p>请参阅 <a href="#os-glossary ">操作系统 </a> 。</p>
</dd>
</dl>
</div>
<div id="odmr-glossary" class="dlist">
<dl>
<dt class="hdlist1">按需邮件中继</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="os-glossary" class="dlist">
<dl>
<dt class="hdlist1">操作系统</dt>
<dd>
<p>一组程序、库和工具，用于访问计算机的硬件资源。操作系统的范围从今天的简单设计，仅支持一次运行一个程序，仅访问一个设备，到完全支持多用户、多任务和多进程的系统，可以同时为数千个用户提供服务，每个用户同时运行数十个不同的应用程序。</p>
</dd>
</dl>
</div>
<div id="obe-glossary" class="dlist">
<dl>
<dt class="hdlist1">被事件超越</dt>
<dd>
<p>指示一个建议的更改（例如问题报告或功能请求），由于 FreeBSD 的后续更改、网络标准的变化、受影响的硬件已经过时等原因，该更改不再相关或适用。</p>
</dd>
</dl>
</div>
<h3 id="_p" class="discrete">P</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">PAE （ Physical Address Extension ）是一种计算机技术，用于扩展 32 位操作系统的内存寻址能力。通过 PAE ，操作系统可以访问超过 4GB 的物理内存。 PAE 技术通过增加物理地址的位数来实现，从而扩展了内存寻址范围。</dt>
<dd>
<p>参见 <a href="#pae-glossary ">物理地址扩展 </a> 。</p>
</dd>
<dt class="hdlist1">PAM （ Pluggable Authentication Modules ）是一种用于实现灵活身份验证的系统框架。它允许系统管理员通过配置文件来选择和配置不同的身份验证方法，如密码、令牌、生物识别等。 PAM 提供了一种标准化的接口，使得开发者可以轻松地添加、修改或替换身份验证模块，而无需修改应用程序的源代码。 PAM 在计算机安全领域被广泛应用，特别是在 Linux 和 UNIX 系统中。</dt>
<dd>
<p>参见 <a href="#pam-glossary ">可插拔认证模块 </a> 。</p>
</dd>
<dt class="hdlist1">PAP 是指人民行动党（ People’s Action Party ）的缩写，是新加坡的主要政党。该党成立于 1954 年，自 1965 年起一直执政至今。人民行动党在新加坡政治中起着重要的角色，致力于推动国家的发展和改革。</dt>
<dd>
<p>参见 <a href="#pap-glossary ">密码认证协议 </a> 。</p>
</dd>
<dt class="hdlist1">个人电脑</dt>
<dd>
<p>参见 <a href="#pc-glossary ">个人电脑 </a> 。</p>
</dd>
<dt class="hdlist1">PCNSFD 是指&#34;Power Control and Network Selection for Device-to-Device Communication in 5G Networks&#34;，即&#34;5G 网络中用于设备对设备通信的功率控制和网络选择&#34;。</dt>
<dd>
<p>请参阅《个人计算机网络文件系统守护进程》（ pcnfsd-glossary ）。</p>
</dd>
<dt class="hdlist1">PDF （ Portable Document Format ）是一种用于显示和打印文档的文件格式。它是由 Adobe Systems 开发的，并且可以在各种操作系统和设备上使用。 PDF 文件可以包含文本、图像、链接和其他元素，并且可以保持文档的格式和布局不变。 PDF 已成为一种广泛使用的文件格式，特别适用于电子书、报告、合同和其他需要保持原始格式的文档。</dt>
<dd>
<p>参见 <a href="#pdf-glossary ">便携式文档格式 </a> 。</p>
</dd>
<dt class="hdlist1">进程标识符（ PID ）</dt>
<dd>
<p>参见 <a href="#pid-glossary ">进程 ID</a> 。</p>
</dd>
<dt class="hdlist1">POLA 是一个缩写，代表着“ Plan , Organize , Lead , and Assess ”（计划、组织、领导和评估）这四个词。这个术语通常用于管理和领导方面，指的是一种管理方法或框架，用于指导和评估组织的活动和目标的实现。</dt>
<dd>
<p>参见《最小惊讶原则》（ Principle Of Least Astonishment ），请参阅 <a href="#pola-glossary">[pola-glossary]</a> 。</p>
</dd>
<dt class="hdlist1">POP 是一种用于接收电子邮件的协议，它代表邮局协议（ Post Office Protocol ）。它允许用户从邮件服务器上下载电子邮件到本地计算机上的邮件客户端。 POP 是一种常见的电子邮件协议，广泛用于个人和企业的电子邮件通信。</dt>
<dd>
<p>参见 <a href="#pop-glossary ">邮局协议 </a> 。</p>
</dd>
<dt class="hdlist1">POP3 （ Post Office Protocol 3 ）是一种用于接收电子邮件的 Internet 标准协议。它允许用户从远程服务器上下载电子邮件到本地计算机上的邮件客户端。 POP3 是一种简单的、无状态的协议，它使用 TCP 连接来传输邮件。它通常与 SMTP （ Simple Mail Transfer Protocol ）一起使用，后者用于发送电子邮件。</dt>
<dd>
<p>请参阅《邮局协议版本 3 》的 <a href="#pop3-glossary ">术语表 </a> 。</p>
</dd>
<dt class="hdlist1">PPD 是指职业性皮肤病（ Occupational Dermatitis ），是一种由工作环境中的化学物质或物理因素引起的皮肤炎症。这种疾病常见于需要与有害物质接触的工作岗位，如工业、农业、建筑和医疗等行业。 PPD 的症状包括皮肤红肿、瘙痒、疼痛和起泡等。及早诊断和采取适当的预防措施对于预防和管理 PPD 非常重要。</dt>
<dd>
<p>请参阅 <a href="#ppd-glossary ">PostScript 打印机描述 </a> 。</p>
</dd>
<dt class="hdlist1">PPP 是指点对点协议（ Point-to-Point Protocol ），它是一种用于在计算机网络中建立和维护数据链路层通信的协议。 PPP 提供了一种可靠的、经过身份验证的连接方式，可以在两个节点之间传输数据。它通常用于建立拨号连接或者在局域网中连接两台计算机。 PPP 是一种通用的协议，可以在各种网络环境中使用。</dt>
<dd>
<p>参见《点对点协议（ PPP ）》。</p>
</dd>
<dt class="hdlist1">PPPoA 是一种广泛用于计算机网络中的协议，它代表点对点协议（ Point-to-Point Protocol over ATM ）。它允许在异步传输模式（ Asynchronous Transfer Mode ）网络上建立点对点连接，并提供了一种可靠的数据传输方式。 PPPoA 通常用于连接用户计算机与互联网服务提供商（ ISP ）之间的宽带连接。</dt>
<dd>
<p>请参阅 <a href="#pppoa-glossary ">PPP over ATM</a> 。</p>
</dd>
<dt class="hdlist1">PPPoE 是一种用于在以太网上建立点对点连接的网络协议。它允许用户通过宽带连接到互联网，并提供了一种认证和授权机制，以确保连接的安全性和可靠性。 PPPoE 通常用于家庭和办公室网络中，以便用户可以通过宽带连接访问互联网。</dt>
<dd>
<p>请参阅 <a href="#pppoe-glossary ">以太网上的 PPP</a> 。</p>
</dd>
</dl>
</div>
<div id="pppoa-glossary" class="dlist">
<dl>
<dt class="hdlist1">PPP over ATM （ Point-to-Point Protocol over Asynchronous Transfer Mode ）</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pppoe-glossary" class="dlist">
<dl>
<dt class="hdlist1">以太网上的 PPP</dt>
<dd>
<p></p>
</dd>
<dt class="hdlist1">PR 是公关的缩写，指的是公共关系。公关是一种管理组织与公众之间关系的活动，旨在建立和维护组织与公众之间的良好沟通和互动。公关的目标是提高组织的声誉和形象，增强公众对组织的认知和信任。公关活动包括媒体关系、社交媒体管理、危机管理、品牌推广等。</dt>
<dd>
<p>请参阅《问题报告》（ <a href="#pr-glossary ">Problem Report</a> ）。</p>
</dd>
<dt class="hdlist1">PXE （ Preboot Execution Environment ）是一种计算机网络协议，用于在局域网中启动和安装操作系统。它允许计算机通过网络从远程服务器下载操作系统镜像，并在启动时执行。 PXE 通常用于大规模部署和管理计算机系统，特别是在无法使用光盘或 USB 驱动器进行安装的情况下。</dt>
<dd>
<p>参见 <a href="#pxe-glossary ">Preboot eXecution Environment</a> 。</p>
</dd>
</dl>
</div>
<div id="pap-glossary" class="dlist">
<dl>
<dt class="hdlist1">密码认证协议</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pc-glossary" class="dlist">
<dl>
<dt class="hdlist1">个人电脑</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pcnfsd-glossary" class="dlist">
<dl>
<dt class="hdlist1">个人计算机网络文件系统守护程序</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pae-glossary" class="dlist">
<dl>
<dt class="hdlist1">物理地址扩展</dt>
<dd>
<p>一种方法是在只有 32 位宽地址空间的系统上实现对最多 64GB RAM 的访问（否则将限制为 4GB ，没有 PAE ）。</p>
</dd>
</dl>
</div>
<div id="pam-glossary" class="dlist">
<dl>
<dt class="hdlist1">可插拔认证模块</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ppp-glossary" class="dlist">
<dl>
<dt class="hdlist1">点对点协议</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pointyhat" class="dlist">
<dl>
<dt class="hdlist1">尖顶帽</dt>
<dd>
<p>一种神秘的头饰，类似于愚人帽，授予任何破坏构建、使修订号逆行或在源代码中造成任何其他混乱的 FreeBSD 贡献者。任何值得一提的贡献者很快就会积累大量这样的头饰。使用方式（几乎总是）幽默。</p>
</dd>
</dl>
</div>
<div id="pdf-glossary" class="dlist">
<dl>
<dt class="hdlist1">便携式文档格式</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pop-glossary" class="dlist">
<dl>
<dt class="hdlist1">邮局协议</dt>
<dd>
<p>参见邮局协议版本 3 。</p>
</dd>
</dl>
</div>
<div id="pop3-glossary" class="dlist">
<dl>
<dt class="hdlist1">邮局协议版本 3</dt>
<dd>
<p>一种用于访问邮件服务器上的电子邮件消息的协议，其特点是通常将消息从服务器下载到客户端，而不是保留在服务器上。</p>
<div class="paragraph">
<p>参见 <a href="#imap-glossary ">互联网消息访问协议 </a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="ppd-glossary" class="dlist">
<dl>
<dt class="hdlist1">PostScript 打印机描述</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pxe-glossary" class="dlist">
<dl>
<dt class="hdlist1">预引导执行环境</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="pola-glossary" class="dlist">
<dl>
<dt class="hdlist1">最小惊讶原则</dt>
<dd>
<p>随着 FreeBSD 的发展，对用户可见的变化应尽量保持不令人惊讶。例如，在 [/etc/defaults/rc.conf] 中任意重新排列系统启动变量违反了 POLA 原则。开发人员在考虑用户可见的系统变化时会考虑 POLA 原则。</p>
</dd>
</dl>
</div>
<div id="pr-glossary" class="dlist">
<dl>
<dt class="hdlist1">问题报告</dt>
<dd>
<p>这是对在 FreeBSD 源代码或文档中发现的某种问题的描述。请参阅 <a href="{problem-reports}">编写 FreeBSD 问题报告</a> 。</p>
</dd>
</dl>
</div>
<div id="pid-glossary" class="dlist">
<dl>
<dt class="hdlist1">进程 ID</dt>
<dd>
<p>一个数字，对于系统上的特定进程是唯一的，它可以标识该进程并允许对其进行操作。</p>
</dd>
</dl>
</div>
<div id="projectevil-glossary" class="dlist">
<dl>
<dt class="hdlist1">邪恶项目</dt>
<dd>
<p>NDISulator 的工作标题是由 Bill Paul 撰写的，他给它取名是因为从哲学的角度来看，需要像这样的东西本身就很糟糕。 NDISulator 是一个特殊的兼容模块，允许在 FreeBSD/i386 上使用 Microsoft Windows™ NDIS miniport 网络驱动程序。这通常是使用驱动程序为闭源的卡片的唯一方法。请参阅 <span class="filename">src/sys/compat/ndis/subr_ndis.c</span> 。</p>
</dd>
</dl>
</div>
<h3 id="_r_是一种用于统计分析和数据可视化的编程语言和环境它提供了丰富的统计和图形功能可以进行数据处理数据分析模型建立和预测等任务_r_语言具有开源的特点拥有庞大的用户社区和丰富的扩展包可以满足不同领域的数据分析需求_r_语言的语法简洁易学适合初学者入门同时也支持高级编程和自定义函数在计算机科学和数据科学领域_r_语言被广泛应用于学术研究商业分析和数据挖掘等领域" class="discrete">R 是一种用于统计分析和数据可视化的编程语言和环境。它提供了丰富的统计和图形功能，可以进行数据处理、数据分析、模型建立和预测等任务。 R 语言具有开源的特点，拥有庞大的用户社区和丰富的扩展包，可以满足不同领域的数据分析需求。 R 语言的语法简洁易学，适合初学者入门，同时也支持高级编程和自定义函数。在计算机科学和数据科学领域， R 语言被广泛应用于学术研究、商业分析和数据挖掘等领域。</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">RA 是指&#34;逆向工程&#34;（ Reverse Engineering ）的缩写。逆向工程是指通过分析已有的产品或系统，以了解其设计、功能和工作原理的过程。逆向工程通常用于研究竞争对手的产品、修复软件漏洞、提取硬件或软件的设计信息等。</dt>
<dd>
<p>请参阅《路由器通告》（ <a href="#ra-glossary ">Router Advertisement</a> ）。</p>
</dd>
<dt class="hdlist1">RAID （冗余磁盘阵列）是一种数据存储技术，通过将多个磁盘驱动器组合在一起，以提供更高的性能、容错能力和数据保护。 RAID 可以在硬件或软件级别实现，并且有不同的级别，如 RAID 0 、 RAID 1 、 RAID 5 等。每个级别都有不同的数据分布和冗余策略，以满足不同的需求。 RAID 技术广泛应用于服务器、存储系统和数据中心等领域，以提供可靠的数据存储和高效的数据访问。</dt>
<dd>
<p>请参阅《冗余磁盘阵列》（ Redundant Array of Inexpensive Disks ）一词的解释。</p>
</dd>
<dt class="hdlist1">RAM （ Random Access Memory ）是一种计算机内存的类型，用于临时存储数据和指令。它是计算机中的主要存储器之一，与硬盘驱动器和固态驱动器等长期存储设备不同。 RAM 具有快速读写速度和易于访问的特点，可以提供计算机运行所需的临时存储空间。当计算机运行程序时，数据和指令被加载到 RAM 中，以便 CPU 可以快速访问和处理。然而， RAM 是一种易失性存储器，意味着在断电或重新启动计算机时，其中的数据将被清除。因此， RAM 通常用于存储临时数据和正在运行的程序，而不是长期存储数据。</dt>
<dd>
<p>请参阅 <a href="#ram-glossary ">随机存取存储器 </a> 。</p>
</dd>
<dt class="hdlist1">研发部门</dt>
<dd>
<p>参见 <a href="#rd-glossary ">接收数据 </a> 。</p>
</dd>
<dt class="hdlist1">RFC （ Request for Comments ）是一系列由互联网工程任务组（ IETF ）发布的文件，用于描述互联网协议、标准、方法和相关主题。 RFC 文件是互联网技术的重要参考资料，其中包含了许多关于网络通信、路由、安全、电子邮件、网页等方面的详细规范和建议。 RFC 文件通常以数字编号进行标识，每个 RFC 都经过了广泛的讨论和审查，以确保其质量和可靠性。</dt>
<dd>
<p>请参阅 <a href="#rfc-glossary ">请求评论 </a> 。</p>
</dd>
<dt class="hdlist1">精简指令集计算机（ RISC ）</dt>
<dd>
<p>参见《精简指令集计算机》（ Reduced Instruction Set Computer ）的 <a href="#risc-glossary ">术语表 </a> 。</p>
</dd>
<dt class="hdlist1">远程过程调用（ RPC ）</dt>
<dd>
<p>参见《远程过程调用》（ Remote Procedure Call ） <a href="#rpc-glossary ">Remote Procedure Call</a> 。</p>
</dd>
<dt class="hdlist1">RS232C 是一种常见的串行通信接口标准，用于在计算机和外部设备之间传输数据。它定义了数据传输的电气特性、信号线的连接方式和通信协议。 RS232C 接口通常用于连接计算机与调制解调器、打印机、串口设备等外部设备。它已经被更先进的接口标准如 USB 所取代，但在某些特定应用中仍然广泛使用。</dt>
<dd>
<p>请参阅 <a href="#rs232c-glossary ">推荐标准 232C</a> 。</p>
</dd>
<dt class="hdlist1">实时战略游戏（ RTS ）</dt>
<dd>
<p>请参阅《请求发送（ Request To Send ）》的内容。</p>
</dd>
</dl>
</div>
<div id="ram-glossary" class="dlist">
<dl>
<dt class="hdlist1">随机存取存储器</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="rcs-glossary" class="dlist">
<dl>
<dt class="hdlist1">版本控制系统</dt>
<dd>
<p>_版本控制系统（ RCS ）_是最早实现“版本控制”功能的软件套件之一，用于普通文件。它允许对每个文件存储、检索、归档、记录、标识和合并多个版本。 RCS 由许多小工具组成，它们共同工作。与更现代的版本控制系统（如 Git ）相比， RCS 缺少一些功能，但对于一小组文件来说，安装、配置和开始使用非常简单。</p>
<div class="paragraph">
<p>参见 <a href="#svn-glossary ">也可以参考 Subversion</a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="rd-glossary" class="dlist">
<dl>
<dt class="hdlist1">接收到的数据</dt>
<dd>
<p>RS232C 引脚或线路，用于接收数据。</p>
<div class="paragraph">
<p>参见 <a href="#td-glossary ">传输的数据 </a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="rs232c-glossary" class="dlist">
<dl>
<dt class="hdlist1">推荐标准 232C</dt>
<dd>
<p>串行设备之间通信的标准。</p>
</dd>
</dl>
</div>
<div id="risc-glossary" class="dlist">
<dl>
<dt class="hdlist1">精简指令集计算机</dt>
<dd>
<p>一种处理器设计方法，其中硬件可以执行的操作被简化，但尽可能通用。这可以导致更低的功耗、更少的晶体管，并且在某些情况下，可以获得更好的性能和增加的代码密度。 RISC 处理器的例子包括 Alpha 、 SPARC® 、 ARM® 和 PowerPC® 。</p>
</dd>
</dl>
</div>
<div id="raid-glossary" class="dlist">
<dl>
<dt class="hdlist1">廉价磁盘冗余阵列</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="rpc-glossary" class="dlist">
<dl>
<dt class="hdlist1">远程过程调用</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="rfc-glossary" class="dlist">
<dl>
<dt class="hdlist1">请求评论</dt>
<dd>
<p>一组定义互联网标准、协议等的文档。请参阅 www.rfc-editor.org 。</p>
<div class="paragraph">
<p>当某人提出改变建议并希望得到反馈时，也可作为一个通用术语使用。</p>
</div>
</dd>
</dl>
</div>
<div id="rts-glossary" class="dlist">
<dl>
<dt class="hdlist1">请求发送</dt>
<dd>
<p>一个 RS232C 信号，请求远程系统开始传输数据。</p>
<div class="paragraph">
<p>参见 <a href="#cts-glossary ">也称为 Clear To Send</a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="ra-glossary" class="dlist">
<dl>
<dt class="hdlist1">路由器通告</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<h3 id="_s" class="discrete">S</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">SCI 是指科学引文索引（ Science Citation Index ），是由美国科学信息研究所（ Institute for Scientific Information ）编制和发布的一种学术文献检索工具。它收录了全球范围内的科学、技术和医学领域的学术期刊文章，并提供了引用关系和引用分析功能，帮助研究人员追踪和评估学术论文的影响力和引用情况。 SCI 是科学研究和学术交流中重要的参考工具之一。</dt>
<dd>
<p>参见 &lt;&lt; 系统控制中断 &gt;&gt; 。</p>
</dd>
<dt class="hdlist1">SCSI （ Small Computer System Interface ）是一种计算机系统中常用的接口标准，用于连接计算机和外部设备，例如硬盘驱动器、光驱和打印机等。它提供了高速数据传输和并行通信的能力，使得计算机可以与多个设备同时进行数据交换。 SCSI 接口广泛应用于服务器、工作站和存储系统等领域。</dt>
<dd>
<p>参见《 SCSI 词汇表》中的《小型计算机系统接口》。</p>
</dd>
<dt class="hdlist1">新加坡</dt>
<dd>
<p>参见 <a href="#sg-glossary ">信号地 </a> 。</p>
</dd>
<dt class="hdlist1">SMB 是指 Server Message Block 的缩写，即服务器消息块。它是一种用于在计算机网络上共享文件、打印机和其他资源的通信协议。 SMB 协议最初由 IBM 开发，后来被微软广泛采用，并成为 Windows 操作系统中文件和打印机共享的主要协议。 SMB 协议使用 TCP/IP 协议进行通信，并提供了安全认证、文件访问控制和数据传输等功能。</dt>
<dd>
<p>请参阅《 SMB 词汇表， Server Message Block 》。</p>
</dd>
<dt class="hdlist1">对称多处理（ SMP ）</dt>
<dd>
<p>参见《对称多处理器（ Symmetric MultiProcessor ）》。</p>
</dd>
<dt class="hdlist1">SMTP （ Simple Mail Transfer Protocol ）是一种用于电子邮件传输的标准协议。它定义了电子邮件客户端和服务器之间的通信规则，以确保可靠地传递电子邮件。 SMTP 使用 TCP/IP 网络来传输邮件，并使用特定的端口号（默认为 25 ）进行通信。通过 SMTP ，用户可以发送电子邮件到目标服务器，并且服务器可以将邮件传递给接收者的电子邮件客户端。 SMTP 还支持身份验证和加密机制，以确保邮件的安全性和私密性。</dt>
<dd>
<p>参见《 SMTP （简单邮件传输协议）术语表》。</p>
</dd>
<dt class="hdlist1">SMTP AUTH （ Simple Mail Transfer Protocol Authentication ）是一种用于电子邮件传输的身份验证机制。它允许邮件服务器在发送或接收邮件时验证用户的身份。通过 SMTP AUTH ，用户可以使用用户名和密码进行身份验证，以便发送或接收邮件。这种身份验证机制可以提高邮件传输的安全性，并防止未经授权的访问和垃圾邮件的发送。</dt>
<dd>
<p>参见 <a href="#smtpauth-glossary ">SMTP 认证 </a> 。</p>
</dd>
<dt class="hdlist1">SSH （ Secure Shell ）是一种网络协议，用于在不安全的网络中安全地进行远程登录和执行命令。它通过加密通信和身份验证来保护数据的安全性。 SSH 广泛用于管理远程服务器和计算机，提供了一种安全的方式来访问和控制远程设备。</dt>
<dd>
<p>请参阅《 SSH 词汇表》中的《 Secure Shell 》。</p>
</dd>
<dt class="hdlist1">STR 是英文单词&#34;strength&#34;的缩写，意为&#34;力量&#34;或&#34;强度&#34;。在计算机领域中， STR 也可以指代&#34;字符串&#34;（ string ）的意思。</dt>
<dd>
<p>参见 <a href="#str-glossary ">挂起到 RAM</a> 。</p>
</dd>
<dt class="hdlist1">SVN 是一个版本控制系统，全称为 Subversion 。它被广泛用于管理和跟踪软件开发项目中的代码变更。 SVN 允许多个开发者同时工作，并提供了版本控制、分支管理、合并等功能，以便更好地协作和管理代码。</dt>
<dd>
<p>参见 <a href="#svn-glossary ">Subversion</a> 。</p>
</dd>
</dl>
</div>
<div id="smtpauth-glossary" class="dlist">
<dl>
<dt class="hdlist1">SMTP 身份验证</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="smb-glossary" class="dlist">
<dl>
<dt class="hdlist1">服务器消息块</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="sg-glossary" class="dlist">
<dl>
<dt class="hdlist1">信号地线</dt>
<dd>
<p>RS232 引脚或线是信号的地线参考。</p>
</dd>
</dl>
</div>
<div id="smtp-glossary" class="dlist">
<dl>
<dt class="hdlist1">简单邮件传输协议</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="ssh-glossary" class="dlist">
<dl>
<dt class="hdlist1">安全外壳协议</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="scsi-glossary" class="dlist">
<dl>
<dt class="hdlist1">小型计算机系统接口</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="svn-glossary" class="dlist">
<dl>
<dt class="hdlist1">Subversion 是一个版本控制系统，用于管理和跟踪文件和目录的变化。它允许多个用户协同工作，并提供了版本控制、分支和合并等功能。 Subversion 使用中央服务器存储文件的历史记录，并允许用户通过检出、提交和更新等操作来与服务器进行交互。它是一个开源软件，广泛用于软件开发和项目管理中。</dt>
<dd>
<p>Subversion 是一个版本控制系统，目前被 FreeBSD 项目使用。</p>
</dd>
</dl>
</div>
<div id="str-glossary" class="dlist">
<dl>
<dt class="hdlist1">挂起到 RAM</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="smp-glossary" class="dlist">
<dl>
<dt class="hdlist1">对称多处理器（ Symmetric MultiProcessor ，简称 SMP ）</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="sci-glossary" class="dlist">
<dl>
<dt class="hdlist1">系统控制中断</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<h3 id="_t" class="discrete">T</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">传输控制协议（ TCP ）</dt>
<dd>
<p>参见《传输控制协议》。</p>
</dd>
<dt class="hdlist1">TCP/IP 是一种网络协议套件，用于在计算机网络中进行通信。它由两个主要协议组成：传输控制协议（ TCP ）和 Internet 协议（ IP ）。 TCP 负责在网络上可靠地传输数据，而 IP 则负责将数据包从一个网络节点传输到另一个网络节点。 TCP/IP 是互联网的基础协议，也被广泛应用于局域网和广域网中。</dt>
<dd>
<p>参见《传输控制协议 / 互联网协议》（ Transmission Control Protocol/Internet Protocol ）的 <a href="#tcpip-glossary ">术语表 </a> 。</p>
</dd>
<dt class="hdlist1">TD</dt>
<dd>
<p>参见 <a href="#td-glossary ">传输数据 </a> 。</p>
</dd>
<dt class="hdlist1">TFTP （ Trivial File Transfer Protocol ）是一种简单的文件传输协议，用于在计算机网络中传输文件。它通常用于在本地网络中快速传输小型文件，如配置文件、固件等。 TFTP 使用 UDP 协议进行通信，并且没有身份验证或加密功能。它的设计目标是简单和高效，因此功能相对较少。 TFTP 常用于网络设备的配置和维护，以及在计算机之间传输引导程序和操作系统映像。</dt>
<dd>
<p>参见 <a href="#tftp-glossary ">Trivial FTP</a> 。</p>
</dd>
<dt class="hdlist1">TGT</dt>
<dd>
<p>请参阅 <a href="#tgt-glossary ">票据授权票 </a> 。</p>
</dd>
<dt class="hdlist1">TSC 是指技术指导委员会（ Technical Steering Committee ），它是一个由技术专家组成的团队，负责指导和监督项目的技术方向和决策。 TSC 的成员通常是项目的核心贡献者和领导者，他们负责评审和批准新功能、技术架构和项目发展计划。 TSC 的目标是确保项目的技术方向与项目的愿景和目标保持一致，并促进项目的技术创新和发展。</dt>
<dd>
<p>参见 <a href="#tsc-glossary ">时间戳计数器 </a> 。</p>
</dd>
</dl>
</div>
<div id="tgt-glossary" class="dlist">
<dl>
<dt class="hdlist1">票据授予票据</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<div id="tsc-glossary" class="dlist">
<dl>
<dt class="hdlist1">时间戳计数器</dt>
<dd>
<p>现代 Pentium® 处理器内部的性能分析计数器，用于计算核心频率时钟周期。</p>
</dd>
</dl>
</div>
<div id="tcp-glossary" class="dlist">
<dl>
<dt class="hdlist1">传输控制协议</dt>
<dd>
<p>一种位于（例如） IP 协议之上的协议，确保数据包以可靠、有序的方式传递。</p>
</dd>
</dl>
</div>
<div id="tcpip-glossary" class="dlist">
<dl>
<dt class="hdlist1">传输控制协议 / 互联网协议</dt>
<dd>
<p>TCP/IP 是指运行在 IP 协议之上的 TCP 协议的组合术语。互联网的大部分运行都是基于 TCP/IP 。</p>
</dd>
</dl>
</div>
<div id="td-glossary" class="dlist">
<dl>
<dt class="hdlist1">传输的数据</dt>
<dd>
<p>RS232C 引脚或线是用于传输数据的。</p>
<div class="paragraph">
<p>请参阅 <a href="#rd-glossary ">也收到的数据 </a> 。</p>
</div>
</dd>
</dl>
</div>
<div id="tftp-glossary" class="dlist">
<dl>
<dt class="hdlist1">Trivial FTP （简称 TFTP ）</dt>
<dd>
<p></p>
</dd>
</dl>
</div>
<h3 id="_u" class="discrete">U</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">用户数据报协议（ UDP ）</dt>
<dd>
<p>参见《用户数据报协议》（ User Datagram Protocol ）的 <a href="#udp-glossary ">词汇表 </a> 。</p>
</dd>
<dt class="hdlist1">UFS1</dt>
<dd>
<p>请参阅《 Unix 文件系统版本 1 》的 <a href="#ufs1-glossary ">Unix 文件系统版本 1</a> 部分。</p>
</dd>
<dt class="hdlist1">UFS2</dt>
<dd>
<p>参见 <a href="#ufs2-glossary ">Unix 文件系统版本 2</a> 。</p>
</dd>
<dt class="hdlist1">用户标识</dt>
<dd>
<p>参见 <a href="#uid-glossary ">用户 ID</a> 。</p>
</dd>
<dt class="hdlist1">URL （ Uniform Resource Locator ）是统一资源定位符的缩写，用于标识和定位互联网上的资源。它是一个字符串，包含了资源的地址和访问方式。 URL 通常由协议、主机名、端口号、路径和查询参数等组成，可以用于访问网页、图片、视频等各种类型的资源。</dt>
<dd>
<p>参见 <a href="#url-glossary ">统一资源定位符 </a> 。</p>
</dd>
<dt class="hdlist1">通用串行总线（ Universal Serial Bus ），简称 USB ，是一种用于连接计算机与外部设备的通信接口标准。它可以用于连接各种设备，如打印机、键盘、鼠标、摄像头、移动存储设备等。 USB 接口具有热插拔、高速传输、简单易用等特点，已经成为计算机领域中最常用的接口之一。</dt>
<dd>
<p>参见《通用串行总线》。</p>
</dd>
</dl>
</div>
<div id="url-glossary" class="dlist">
<dl>
<dt class="hdlist1">统一资源定位符</dt>
<dd>
<p>一种定位资源的方法，例如在互联网上定位文档以及识别该资源的手段。</p>
</dd>
</dl>
</div>
<div id="ufs1-glossary" class="dlist">
<dl>
<dt class="hdlist1">Unix 文件系统版本 1</dt>
<dd>
<p>原始的 UNIX® 文件系统，有时被称为伯克利快速文件系统。</p>
</dd>
</dl>
</div>
<div id="ufs2-glossary" class="dlist">
<dl>
<dt class="hdlist1">Unix 文件系统版本 2</dt>
<dd>
<p>UFS2 是 UFS1 的扩展，引入于 FreeBSD 5-CURRENT 。 UFS2 增加了 64 位块指针（突破了 1T 的限制），支持扩展文件存储和其他功能。</p>
</dd>
</dl>
</div>
<div id="usb-glossary" class="dlist">
<dl>
<dt class="hdlist1">通用串行总线</dt>
<dd>
<p>一种硬件标准，用于将各种计算机外设连接到通用接口。</p>
</dd>
</dl>
</div>
<div id="uid-glossary" class="dlist">
<dl>
<dt class="hdlist1">用户 ID</dt>
<dd>
<p>计算机中为每个用户分配的唯一编号，通过该编号可以识别分配给该用户的资源和权限。</p>
</dd>
</dl>
</div>
<div id="udp-glossary" class="dlist">
<dl>
<dt class="hdlist1">用户数据报协议</dt>
<dd>
<p>UDP 是一种简单而不可靠的数据报协议，用于在 TCP/IP 网络上交换数据。 UDP 不像 TCP 那样提供错误检查和纠正。</p>
</dd>
</dl>
</div>
<h3 id="_v" class="discrete">V</h3>
<div class="dlist">
<dl>
<dt class="hdlist1">虚拟专用网络（ VPN ）</dt>
<dd>
<p>请参阅《虚拟私人网络》的 <a href="#vpn-glossary ">虚拟私人网络 </a> 部分。</p>
</dd>
</dl>
</div>
<div id="vpn-glossary" class="dlist">
<dl>
<dt class="hdlist1">虚拟专用网络</dt>
<dd>
<p>一种使用公共电信网络（如互联网）来提供对本地网络（如企业局域网）的远程访问的方法。</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="sect1">
<h2 id="colophon">后记<a class="anchor" href="#colophon"></a></h2>
<div class="sectionbody">
<div class="paragraph">
<p>这本书是由《FreeBSD 文档项目》的数百名贡献者共同完成的。该文本使用 AsciiDoc 格式编写。</p>
</div>
</div>
</div>
<div id="footnotes">
<hr/>
<div class="footnote" id="_footnotedef_1">
<a href="#_footnoteref_1">1</a>. 有一些任务是无法中断的。例如，如果进程正在尝试从网络上的另一台计算机上读取文件，而该计算机不可用，那么该进程被称为不可中断。最终，该进程将超时，通常在两分钟后。一旦超时发生，该进程将被终止。
</div>
</div>

    </div>
    
    <hr />
    <div class="last-modified">
      <p><strong>Last modified on</strong>: January 9, 2024 by <a href="https://cgit.freebsd.org/doc/commit/?id=57cd73e" target="_blank">fiercex</a></p>
    </div>
    
    <div class="buttons">
      
      <div class="home">
        <i class="fa fa-home" aria-hidden="true" title="Home"></i>
        <div class="container">
          
            <a href="../" class="direction">Home</a>
          
        </div>
      </div>
      
    </div>
    <label class="hidden book-menu-overlay" for="menu-control"></label>
  </div>
  <aside class="toc">
    <div class="toc-content">
      <h3>Table of Contents</h3>
      <nav id="TableOfContents">
  <ul>
    <li><a href="#book-preface">前言</a>
      <ul>
        <li><a href="#preface-audience">预期读者</a></li>
        <li><a href="#preface-changes-from4">第四版</a></li>
        <li><a href="#preface-changes-from3">第三版</a></li>
        <li><a href="#preface-changes-from2">第二版（2004 年）</a></li>
        <li><a href="#preface-changes">第一版（2001 年）</a></li>
        <li><a href="#preface-overview">本书的组织结构</a></li>
        <li><a href="#preface-conv">本书中使用的约定</a></li>
        <li><a href="#preface-acknowledgements">致谢</a></li>
      </ul>
    </li>
    <li><a href="#getting-started">Part I: 入门指南</a>
      <ul>
        <li><a href="#introduction">Chapter 1. 介绍</a></li>
        <li><a href="#bsdinstall">Chapter 2. 安装 FreeBSD</a></li>
        <li><a href="#basics">Chapter 3. FreeBSD 基础知识</a></li>
        <li><a href="#ports">Chapter 4. 安装应用程序：软件包和 Ports</a></li>
        <li><a href="#x11">Chapter 5. X Window System （X  Window系统）</a></li>
        <li><a href="#wayland">Chapter 6. 在 FreeBSD 上的 Wayland</a></li>
        <li><a href="#network">Chapter 7. 网络</a></li>
      </ul>
    </li>
    <li><a href="#common-tasks">Part II: 常见任务</a>
      <ul>
        <li><a href="#desktop">Chapter 8. 桌面环境</a></li>
        <li><a href="#multimedia">Chapter 9. 多媒体</a></li>
        <li><a href="#kernelconfig">Chapter 10. 配置 FreeBSD 内核</a></li>
        <li><a href="#printing">Chapter 11. 打印</a></li>
        <li><a href="#linuxemu">Chapter 12. Linux 二进制兼容性</a></li>
        <li><a href="#wine">Chapter 13. WINE 是一个允许在 Linux 和其他类 Unix 操作系统上运行 Windows 应用程序的兼容层。它通过实现 Windows API 的替代实现来实现这一功能。 WINE 的名称是“ Wine Is Not an Emulator ”的缩写，这意味着它不是一个真正的模拟器，而是通过将 Windows API 调用转换为对底层操作系统的调用来实现兼容性。 WINE 对于那些需要在 Linux 环境中运行 Windows 应用程序的用户来说是非常有用的。</a></li>
      </ul>
    </li>
    <li><a href="#system-administration">Part III: 系统管理</a>
      <ul>
        <li><a href="#config-tuning">Chapter 14. 配置、服务、日志和电源管理</a></li>
        <li><a href="#boot">Chapter 15. FreeBSD 的引导过程</a></li>
        <li><a href="#security">Chapter 16. 安全</a></li>
        <li><a href="#jails">Chapter 17. Jails 和容器</a></li>
        <li><a href="#mac">Chapter 18. 强制访问控制</a></li>
        <li><a href="#audit">Chapter 19. 安全事件审计</a></li>
        <li><a href="#disks">Chapter 20. 存储</a></li>
        <li><a href="#geom">Chapter 21. GEOM ：模块化磁盘转换框架</a></li>
        <li><a href="#zfs">Chapter 22. Z 文件系统（ZFS）</a></li>
        <li><a href="#filesystems">Chapter 23. 其他文件系统</a></li>
        <li><a href="#virtualization">Chapter 24. 虚拟化</a></li>
        <li><a href="#l10n">Chapter 25. 本地化 - i18n/L10n 的使用和设置</a></li>
        <li><a href="#updating-upgrading">Chapter 26. 更新和升级 FreeBSD</a></li>
        <li><a href="#dtrace">Chapter 27. DTrace 是一种动态跟踪工具，用于在操作系统和应用程序中收集和分析性能数据。它最初是由 Sun Microsystems 开发的，现在已经成为许多操作系统的标准特性，包括 Solaris 、 FreeBSD 和 Mac OS X 。 DTrace 可以帮助开发人员和系统管理员识别和解决性能问题，优化代码和系统配置，并提供深入的可视化和分析功能。它使用一种称为 D 语言的特殊语法来编写跟踪脚本，并提供了丰富的系统调用和内核事件的跟踪功能。 DTrace 是一个强大而灵活的工具，被广泛用于调试和优化各种类型的软件和系统。</a></li>
        <li><a href="#usb-device-mode">Chapter 28. USB 设备模式 /USB OTG</a></li>
      </ul>
    </li>
    <li><a href="#network-communication">Part IV: 网络通信</a>
      <ul>
        <li><a href="#serialcomms">Chapter 29. 串行通信</a></li>
        <li><a href="#ppp-and-slip">Chapter 30. PPP</a></li>
        <li><a href="#mail">Chapter 31. 电子邮件</a></li>
        <li><a href="#network-servers">Chapter 32. 网络服务器</a></li>
        <li><a href="#firewalls">Chapter 33. 防火墙</a></li>
        <li><a href="#advanced-networking">Chapter 34. 高级网络</a></li>
      </ul>
    </li>
    <li><a href="#appendices">Part V: 附录</a>
      <ul>
        <li><a href="#_获取_freebsd">附录 A: 获取 FreeBSD</a></li>
        <li><a href="#bibliography">附录 B: 参考文献</a></li>
        <li><a href="#eresources">附录 C: 互联网资源</a></li>
        <li><a href="#pgpkeys">附录 D: OpenPGP 密钥</a></li>
        <li><a href="#freebsd-glossary">FreeBSD 词汇表</a></li>
        <li><a href="#colophon">后记</a></li>
      </ul>
    </li>
  </ul>
</nav>
      <hr />
      
    </div>
  </aside>
  <a class="to-top" href="#top">
    <i class="fa fa-arrow-circle-up" aria-hidden="true"></i>
  </a>
</main>

    <footer>
  <div class="footer-container">
    <section class="logo-column">
          <img src="https://free.bsd-doc.org/images/FreeBSD-colors.svg" width="160" height="50" alt="FreeBSD logo" />
        <div class="options-container">
          
            <div class="language-container">
              <a id="languages" href="https://free.bsd-doc.org/zh-cn-auto/languages">
                
                <img src="https://free.bsd-doc.org/images/language.png" class="language-image" alt="Choose language">
                <span>简体中文-自动翻译</span>
              </a>
            </div>
          
          <div class="theme-container">
            <select id="theme-chooser">
	      <option value="theme-system">System</option>
              <option value="theme-light">Light</option>
              <option value="theme-dark">Dark</option>
              <option value="theme-high-contrast">High contrast</option>
            </select>
          </div>
        </div>
      </section>
      
      <section class="copyright-column">
        <p>&copy; 1994-2024 The FreeBSD Project. All rights reserved</p>
        <span>Made with <span class="heart">♥</span> by the FreeBSD Community</span>
      </section>
  </div>
</footer>

  </body>
</html>
