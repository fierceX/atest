# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2023-12-17 07:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/boot/_index.adoc:1
#, no-wrap
msgid ""
"An introduction to the FreeBSD Booting Process, demonstrates how to "
"customize the FreeBSD boot process, including everything that happens until "
"the FreeBSD kernel has started, probed for devices, and started init"
msgstr ""
"FreeBSD 引导过程简介，介绍了如何自定义 FreeBSD 引导过程，包括从引导开始直到 FreeBSD 内核启动、设备探测和 init "
"启动的所有过程。"

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/boot/_index.adoc:1
#, no-wrap
msgid "Part III. System Administration"
msgstr "第三部分：系统管理"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/boot/_index.adoc:1
#, no-wrap
msgid "Chapter 15. The FreeBSD Booting Process"
msgstr "第 15 章 FreeBSD 的引导过程"

#. type: Title =
#: documentation/content/en/books/handbook/boot/_index.adoc:14
#, no-wrap
msgid "The FreeBSD Booting Process"
msgstr "FreeBSD 的引导过程"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:39
#, 
msgid ""
"include::shared/attributes/attributes-{{% lang %}}.adoc[] "
"include::shared/{{% lang %}}/teams.adoc[] include::shared/{{% lang "
"%}}/mailing-lists.adoc[] include::shared/{{% lang %}}/urls.adoc[]"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/boot/_index.adoc:52
#, no-wrap
msgid "Synopsis"
msgstr "简介"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:56
#, 
msgid ""
"The process of starting a computer and loading the operating system is "
"referred to as \"the bootstrap process\", or \"booting\".  FreeBSD's boot "
"process provides a great deal of flexibility in customizing what happens "
"when the system starts, including the ability to select from different "
"operating systems installed on the same computer, different versions of the "
"same operating system, or a different installed kernel."
msgstr ""
"启动计算机并加载操作系统的过程被称为“引导过程”或“引导”。 FreeBSD "
"的引导过程提供了很大的灵活性，可以自定义系统启动时发生的事情，包括选择在同一台计算机上安装的不同操作系统、同一操作系统的不同版本或不同的内核。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:60
#, 
msgid ""
"This chapter details the configuration options that can be set.  It "
"demonstrates how to customize the FreeBSD boot process, including everything"
" that happens until the FreeBSD kernel has started, probed for devices, and "
"started man:init[8].  This occurs when the text color of the boot messages "
"changes from bright white to grey."
msgstr ""
"本章详细介绍了可以设置的配置选项。它演示了如何自定义 FreeBSD 的启动过程，包括在 FreeBSD 内核启动、设备探测和 man:init[8] "
"启动之前发生的所有事情。这发生在启动消息的文本颜色从亮白色变为灰色时。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:62
#, 
msgid "After reading this chapter, you will recognize:"
msgstr "阅读完本章后，您将会认识到："

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:64
#, 
msgid "The components of the FreeBSD bootstrap system and how they interact."
msgstr "FreeBSD 引导系统的组件及其相互作用方式。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:65
#, 
msgid ""
"The options that can be passed to the components in the FreeBSD bootstrap in"
" order to control the boot process."
msgstr "可以传递给 FreeBSD 引导程序中组件的选项，以控制引导过程。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:66
#, 
msgid "The basics of setting device hints."
msgstr "设置设备提示的基础知识。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:67
#, 
msgid ""
"How to boot into single- and multi-user mode and how to properly shut down a"
" FreeBSD system."
msgstr "如何进入单用户模式和多用户模式，以及如何正确关闭 FreeBSD 系统。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:71
#, 
msgid ""
"This chapter only describes the boot process for FreeBSD running on x86 and "
"amd64 systems."
msgstr "本章仅描述在 x86 和 amd64 系统上运行的 FreeBSD 的引导过程。"

#. type: Title ==
#: documentation/content/en/books/handbook/boot/_index.adoc:74
#, no-wrap
msgid "FreeBSD Boot Process"
msgstr "FreeBSD 引导过程"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:80
#, 
msgid ""
"Turning on a computer and starting the operating system poses an interesting"
" dilemma.  By definition, the computer does not know how to do anything "
"until the operating system is started.  This includes running programs from "
"the disk.  If the computer can not run a program from the disk without the "
"operating system, and the operating system programs are on the disk, how is "
"the operating system started?"
msgstr ""
"打开计算机并启动操作系统会带来一个有趣的困境。根据定义，计算机在启动操作系统之前不知道如何执行任何操作，包括从磁盘运行程序。如果计算机没有操作系统就无法从磁盘运行程序，而操作系统的程序又存储在磁盘上，那么操作系统是如何启动的呢？"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:85
#, 
msgid ""
"This problem parallels one in the book The Adventures of Baron Munchausen.  "
"A character had fallen part way down a manhole, and pulled himself out by "
"grabbing his bootstraps and lifting.  In the early days of computing, the "
"term _bootstrap_ was applied to the mechanism used to load the operating "
"system.  It has since become shortened to \"booting\"."
msgstr ""
"这个问题与《巴伦·门舒森的冒险》一书中的一个问题相似。一个角色在一个井盖上卡住了一半身子，他通过抓住自己的靴带并抬起来自救。在计算机的早期，术语 _引导（"
"bootstrap）_ 被用来指代加载操作系统的机制。后来，这个术语被缩短为“引导（booting）”。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:89
#, 
msgid ""
"On x86 hardware, the Basic Input/Output System (BIOS) is responsible for "
"loading the operating system.  The BIOS looks on the hard disk for the "
"Master Boot Record (MBR), which must be located in a specific place on the "
"disk.  The BIOS has enough knowledge to load and run the MBR, and assumes "
"that the MBR can then carry out the rest of the tasks involved in loading "
"the operating system, possibly with the help of the BIOS."
msgstr ""
"在 x86 硬件上，基本输入/输出系统（BIOS）负责加载操作系统。BIOS 在硬盘上查找主引导记录（MBR"
"），该记录必须位于硬盘的特定位置。BIOS 具有足够的知识来加载和运行 MBR，并假设 MBR 可以完成加载操作系统的其余任务，可能需要 BIOS "
"的帮助。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:96
#, 
msgid ""
"FreeBSD provides for booting from both the older MBR standard, and the newer"
" GUID Partition Table (GPT).  GPT partitioning is often found on computers "
"with the Unified Extensible Firmware Interface (UEFI).  However, FreeBSD can"
" boot from GPT partitions even on machines with only a legacy BIOS with "
"man:gptboot[8].  Work is under way to provide direct UEFI booting."
msgstr ""
"FreeBSD 支持从旧的 MBR 标准和新的 GUID 分区表（GPT）进行引导。GPT 分区通常在具有统一可扩展固件接口（UEFI"
"）的计算机上找到。然而，即使在只有传统 BIOS 的机器上，FreeBSD 也可以从 GPT 分区引导，使用 man:gptboot[8] "
"。目前正在进行直接支持 UEFI 引导的工作。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:101
#, 
msgid ""
"The code within the MBR is typically referred to as a _boot manager_, "
"especially when it interacts with the user.  The boot manager usually has "
"more code in the first track of the disk or within the file system.  "
"Examples of boot managers include the standard FreeBSD boot manager boot0, "
"also called Boot Easy, and GNU GRUB, which is used by many Linux(R) "
"distributions."
msgstr ""
"MBR 中的代码通常被称为“引导管理器”，特别是当它与用户交互时。引导管理器通常在磁盘的第一个磁道或文件系统中有更多的代码。引导管理器的示例包括标准的 "
"FreeBSD 引导管理器 boot0，也称为 Boot Easy，以及 GNU GRUB，它被许多 Linux(R) 发行版使用。"

#.  There is extref:{faq}[a frequently asked question] about GRUB. Beyond the
#. answer there, //
#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:106
#, 
msgid ""
"Users of GRUB should refer to https://www.gnu.org/software/grub/grub-"
"documentation.html[GNU-provided documentation]."
msgstr ""
"GRUB 的用户应参考 https://www.gnu.org/software/grub/grub-"
"documentation.html[GNU 提供的文档]。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:110
#, 
msgid ""
"If only one operating system is installed, the MBR searches for the first "
"bootable (active) slice on the disk, and then runs the code on that slice to"
" load the remainder of the operating system.  When multiple operating "
"systems are present, a different boot manager can be installed to display a "
"list of operating systems so the user can select one to boot."
msgstr ""
"如果只安装了一个操作系统，MBR "
"会搜索磁盘上第一个可引导（活动的）分区，并运行该分区上的代码来加载操作系统的其余部分。当存在多个操作系统时，可以安装不同的引导管理器来显示操作系统列表，以便用户可以选择要引导的操作系统。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:117
#, 
msgid ""
"The remainder of the FreeBSD bootstrap system is divided into three stages."
"  The first stage knows just enough to get the computer into a specific "
"state and run the second stage.  The second stage can do a little bit more, "
"before running the third stage.  The third stage finishes the task of "
"loading the operating system.  The work is split into three stages because "
"the MBR puts limits on the size of the programs that can be run at stages "
"one and two.  Chaining the tasks together allows FreeBSD to provide a more "
"flexible loader."
msgstr ""
"FreeBSD "
"引导系统的剩余部分分为三个阶段。第一阶段只需知道让计算机进入特定状态并运行第二阶段即可。第二阶段可以做更多的事情，然后运行第三阶段。第三阶段完成加载操作系统的任务。将工作分为三个阶段是因为"
" MBR 对可以在第一和第二阶段运行的程序的大小有限制。将任务链接在一起使 FreeBSD 能够提供更灵活的加载程序。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:120
#, 
msgid ""
"The kernel is then started and begins to probe for devices and initialize "
"them for use.  Once the kernel boot process is finished, the kernel passes "
"control to the user process man:init[8], which makes sure the disks are in a"
" usable state, starts the user-level resource configuration which mounts "
"file systems, sets up network cards to communicate on the network, and "
"starts the processes which have been configured to run at startup."
msgstr ""
"然后启动内核，并开始探测设备并初始化它们以供使用。一旦内核引导过程完成，内核将控制权交给用户进程 man:init[8]"
"，该进程确保磁盘处于可用状态，启动用户级资源配置以挂载文件系统，设置网络卡以进行网络通信，并启动已配置为在启动时运行的进程。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:122
#, 
msgid ""
"This section describes these stages in more detail and demonstrates how to "
"interact with the FreeBSD boot process."
msgstr "本节将更详细地描述这些阶段，并演示如何与 FreeBSD 引导过程进行交互。"

#. type: Title ===
#: documentation/content/en/books/handbook/boot/_index.adoc:124
#, no-wrap
msgid "The Boot Manager"
msgstr "引导管理器"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:128
#, 
msgid ""
"The boot manager code in the MBR is sometimes referred to as _stage zero_ of"
" the boot process.  By default, FreeBSD uses the boot0 boot manager."
msgstr "MBR 中的引导管理器代码有时被称为引导过程的 _零阶段_。默认情况下，FreeBSD 使用 boot0 引导管理器。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:132
#, 
msgid ""
"The MBR installed by the FreeBSD installer is based on "
"[.filename]#/boot/boot0#.  The size and capability of boot0 is restricted to"
" 446 bytes due to the slice table and `0x55AA` identifier at the end of the "
"MBR.  If boot0 and multiple operating systems are installed, a message "
"similar to this example will be displayed at boot time:"
msgstr ""
"FreeBSD 安装程序安装的 MBR 基于 [.filename]#/boot/boot0#。由于 slice 表和 MBR 末尾的 0x55AA 标识符， boot0 "
"的大小和功能被限制为 446 字节。如果安装了 boot0 和多个操作系统，则在启动时会显示类似于以下示例的消息："

#. type: Block title
#: documentation/content/en/books/handbook/boot/_index.adoc:134
#, no-wrap
msgid "[.filename]#boot0# Screenshot"
msgstr "[.filename]#boot0# 截图"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:142
#, no-wrap
msgid ""
"F1 Win\n"
"F2 FreeBSD\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:144
#, no-wrap
msgid "Default: F2\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:150
#, 
msgid ""
"Other operating systems will overwrite an existing MBR if they are installed"
" after FreeBSD.  If this happens, or to replace the existing MBR with the "
"FreeBSD MBR, use the following command:"
msgstr ""
"如果在 FreeBSD 之后安装其他操作系统，它们将覆盖现有的 MBR。如果发生这种情况，或者要用 FreeBSD 的 MBR 替换现有的 MBR "
"，请使用以下命令："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:154
#, no-wrap
msgid "# fdisk -B -b /boot/boot0 device\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:158
#, 
msgid ""
"where _device_ is the boot disk, such as [.filename]#ad0# for the first IDE "
"disk, [.filename]#ad2# for the first IDE disk on a second IDE controller, or"
" [.filename]#da0# for the first SCSI disk.  To create a custom configuration"
" of the MBR, refer to man:boot0cfg[8]."
msgstr ""
"其中 _device_ 是引导磁盘，例如 [.filename]#ad0# 表示第一个 IDE 磁盘，[.filename]#ad2# 表示第二个 "
"IDE 控制器上的第一个 IDE 磁盘，或者 [.filename]#da0# 表示第一个 SCSI 磁盘。要创建自定义的 MBR 配置，请参考 "
"man:boot0cfg[8]。"

#. type: Title ===
#: documentation/content/en/books/handbook/boot/_index.adoc:160
#, no-wrap
msgid "Stage One and Stage Two"
msgstr "第一阶段和第二阶段"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:165
#, 
msgid ""
"Conceptually, the first and second stages are part of the same program on "
"the same area of the disk.  Due to space constraints, they have been split "
"into two, but are always installed together.  They are copied from the "
"combined [.filename]#/boot/boot# by the FreeBSD installer or `bsdlabel`."
msgstr ""
"从概念上讲，第一阶段和第二阶段是同一个程序在磁盘的同一个区域的一部分。由于空间限制，它们被分成两部分，但总是一起安装的。它们是由 FreeBSD "
"安装程序或 `bsdlabel` 从组合的 [.filename]#/boot/boot# 复制而来。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:168
#, 
msgid ""
"These two stages are located outside file systems, in the first track of the"
" boot slice, starting with the first sector.  This is where boot0, or any "
"other boot manager, expects to find a program to run which will continue the"
" boot process."
msgstr ""
"这两个阶段位于文件系统之外，在引导 slice 的第一个磁道上，从第一个扇区开始。这是 boot0 或任何其他引导管理器期望找到一个程序来继续引导过程的位置。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:171
#, 
msgid ""
"The first stage, [.filename]#boot1#, is very simple, since it can only be "
"512 bytes in size.  It knows just enough about the FreeBSD _bsdlabel_, which"
" stores information about the slice, to find and execute [.filename]#boot2#."
msgstr ""
"第一阶段，[.filename]#boot1#，非常简单，因为它的大小只能是 512 字节。它对 FreeBSD "
"的 _bsdlabel_ 有一定了解，该标签存储有关分区的信息，以便找到并执行 [.filename]#boot2#。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:176
#, 
msgid ""
"Stage two, [.filename]#boot2#, is slightly more sophisticated, and "
"understands the FreeBSD file system enough to find files.  It can provide a "
"simple interface to choose the kernel or loader to run.  It runs loader, "
"which is much more sophisticated and provides a boot configuration file.  If"
" the boot process is interrupted at stage two, the following interactive "
"screen is displayed:"
msgstr ""
"第二阶段，[.filename]#boot2#，稍微复杂一些，足够理解 FreeBSD "
"文件系统以找到文件。它可以提供一个简单的界面来选择要运行的内核或加载程序。它运行加载程序，加载程序更加复杂，并提供一个引导配置文件。如果在第二阶段中断了引导过程，将显示以下交互式屏幕："

#. type: Block title
#: documentation/content/en/books/handbook/boot/_index.adoc:178
#, no-wrap
msgid "[.filename]#boot2# Screenshot"
msgstr "[.filename]#boot2# 截图"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:187
#, no-wrap
msgid ""
">> FreeBSD/i386 BOOT\n"
"Default: 0:ad(0,a)/boot/loader\n"
"boot:\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:192
#, 
msgid ""
"To replace the installed [.filename]#boot1# and [.filename]#boot2#, use "
"`bsdlabel`, where _diskslice_ is the disk and slice to boot from, such as "
"[.filename]#ad0s1# for the first slice on the first IDE disk:"
msgstr ""
"要替换已安装的 [.filename]#boot1# 和 [.filename]#boot2# ，请使用 `bsdlabel` 命令，其中 "
"_diskslice_ 是要从中引导的磁盘和分区，例如 [.filename]#ad0s1# 表示第一个 IDE 磁盘上的第一个分区。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:196
#, no-wrap
msgid "# bsdlabel -B diskslice\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:202
#, 
msgid ""
"If just the disk name is used, such as [.filename]#ad0#, `bsdlabel` will "
"create the disk in \"dangerously dedicated mode\", without slices.  This is "
"probably not the desired action, so double check the _diskslice_ before "
"pressing kbd:[Return]."
msgstr ""
"如果只使用磁盘名称，例如 [.filename]#ad0#， `bsdlabel` "
"将以“危险专用模式（dangerously dedicated mode）”创建磁盘，而不使用分区。这可能不是期望的操作，所以在按下 kbd:[Return] 之前，请仔细检查 _diskslice_。"

#. type: Title ===
#: documentation/content/en/books/handbook/boot/_index.adoc:205
#, no-wrap
msgid "Stage Three"
msgstr "第三阶段"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:209
#, 
msgid ""
"The loader is the final stage of the three-stage bootstrap process.  It is "
"located on the file system, usually as [.filename]#/boot/loader#."
msgstr "加载器是三阶段引导过程的最后阶段。它位于文件系统上，通常是作为 [.filename]#/boot/loader# 文件。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:211
#, 
msgid ""
"The loader is intended as an interactive method for configuration, using a "
"built-in command set, backed up by a more powerful interpreter which has a "
"more complex command set."
msgstr "加载器旨在作为一种交互式的配置方法，使用内置的命令集，并由更强大的解释器支持，该解释器具有更复杂的命令集。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:214
#, 
msgid ""
"During initialization, loader will probe for a console and for disks, and "
"figure out which disk it is booting from.  It will set variables "
"accordingly, and an interpreter is started where user commands can be passed"
" from a script or interactively."
msgstr "在初始化过程中，加载器将探测控制台和磁盘，并确定正在引导的磁盘。它将相应地设置变量，并启动一个解释器，用户可以通过脚本或交互方式传递命令。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:217
#, 
msgid ""
"The loader will then read [.filename]#/boot/loader.rc#, which by default "
"reads in [.filename]#/boot/defaults/loader.conf# which sets reasonable "
"defaults for variables and reads [.filename]#/boot/loader.conf# for local "
"changes to those variables.  [.filename]#loader.rc# then acts on these "
"variables, loading whichever modules and kernel are selected."
msgstr ""
"然后，加载程序将读取 [.filename]#/boot/loader.rc# 文件，默认情况下会读取 [.filename]#/boot/defaults/loader.conf# "
"文件，该文件为变量设置了合理的默认值，并读取 [.filename]#/boot/loader.conf# 文件以获取对这些变量的本地更改。[.filename]#loader.rc# "
"文件会根据这些变量的设置加载所选的模块和内核。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:222
#, 
msgid ""
"Finally, by default, loader issues a 10 second wait for key presses, and "
"boots the kernel if it is not interrupted.  If interrupted, the user is "
"presented with a prompt which understands the command set, where the user "
"may adjust variables, unload all modules, load modules, and then finally "
"boot or reboot.  <<boot-loader-commands>> lists the most commonly used "
"loader commands.  For a complete discussion of all available commands, refer"
" to man:loader[8]."
msgstr ""
"最后，默认情况下，加载程序会等待 10 "
"秒钟以等待按键操作，如果没有被中断，则启动内核。如果被中断，用户将会看到一个理解命令集的提示符，用户可以在其中调整变量、卸载所有模块、加载模块，最后进行启动或重新启动操作。"
" <<boot-loader-commands>> 列出了最常用的加载程序命令。有关所有可用命令的完整讨论，请参阅 man:loader[8]。"

#. type: Block title
#: documentation/content/en/books/handbook/boot/_index.adoc:224
#, no-wrap
msgid "Loader Built-In Commands"
msgstr "加载器内置命令"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:228
#, no-wrap
msgid "Variable"
msgstr "变量"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:230
#: documentation/content/en/books/handbook/boot/_index.adoc:319
#, no-wrap
msgid "Description"
msgstr "描述"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:231
#, no-wrap
msgid "autoboot _seconds_"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:233
#, no-wrap
msgid ""
"Proceeds to boot the kernel if not interrupted within the time span given, "
"in seconds. It displays a countdown, and the default time span is 10 "
"seconds."
msgstr "如果在给定的时间范围内（以秒为单位）没有被中断，将继续启动内核。它会显示一个倒计时，而默认的时间范围是 10 秒。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:234
#, no-wrap
msgid "boot [`-options`] [`kernelname`]"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:236
#, no-wrap
msgid ""
"Immediately proceeds to boot the kernel, with any specified options or "
"kernel name. Providing a kernel name on the command-line is only applicable "
"after an `unload` has been issued. Otherwise, the previously-loaded kernel "
"will be used. If _kernelname_ is not qualified, it will be searched under "
"_/boot/kernel_ and _/boot/modules_."
msgstr ""
"立即启动内核，使用指定的选项或内核名称。在执行 `unload` "
"命令之后，才能在命令行上提供内核名称。否则，将使用先前加载的内核。如果 _kernelname_ 没有限定，将在 _boot/kernel_ 和 _boot/modules_ 下进行搜索。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:237
#, no-wrap
msgid "boot-conf"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:239
#, no-wrap
msgid ""
"Goes through the same automatic configuration of modules based on specified "
"variables, most commonly `kernel`. This only makes sense if `unload` is used"
" first, before changing some variables."
msgstr "根据指定的变量，自动配置模块，通常是 `kernel`。只有在先使用 `unload` 卸载模块后，再更改一些变量时，这才有意义。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:240
#, no-wrap
msgid "help [`_topic_`]"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:242
#, no-wrap
msgid ""
"Shows help messages read from [.filename]#/boot/loader.help#. If the topic "
"given is `index`, the list of available topics is displayed."
msgstr ""
"显示从 [.filename]#/boot/loader.help# 读取的帮助信息。如果给定的主题是 `index`，则显示可用主题的列表。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:243
#, no-wrap
msgid "include `_filename_` ..."
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:245
#, no-wrap
msgid ""
"Reads the specified file and interprets it line by line. An error "
"immediately stops the `include`."
msgstr "读取指定的文件，并逐行解释。一旦出现错误，`include` 操作立即停止。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:246
#, no-wrap
msgid "load [-t ``_type_``] `_filename_`"
msgstr "`"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:248
#, no-wrap
msgid ""
"Loads the kernel, kernel module, or file of the type given, with the "
"specified filename. Any arguments after _filename_ are passed to the file. "
"If _filename_ is not qualified, it will be searched under _/boot/kernel_ and"
" _/boot/modules_."
msgstr ""
"加载给定类型的内核、内核模块或文件，使用指定的文件名。_filename_ 后的任何参数都将传递给该文件。如果 _filename_ 没有限定，将在 _/boot/kernel_ 和 "
"_/boot/modules_ 下进行搜索。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:249
#, no-wrap
msgid "ls [-l] [``_path_``]"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:251
#, no-wrap
msgid ""
"Displays a listing of files in the given path, or the root directory, if the"
" path is not specified. If `-l` is specified, file sizes will also be shown."
msgstr "显示给定路径中的文件列表，如果未指定路径，则显示根目录。如果指定了 `-l` ，还将显示文件大小。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:252
#, no-wrap
msgid "lsdev [`-v`]"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:254
#, no-wrap
msgid ""
"Lists all of the devices from which it may be possible to load modules. If "
"`-v` is specified, more details are printed."
msgstr "列出所有可能加载模块的设备。如果指定了 `-v`，则会打印更多详细信息。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:255
#, no-wrap
msgid "lsmod [`-v`]"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:257
#, no-wrap
msgid "Displays loaded modules. If `-v` is specified, more details are shown."
msgstr "显示已加载的模块。如果指定了 `-v`，则显示更多详细信息。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:258
#, no-wrap
msgid "more `_filename_`"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:260
#, no-wrap
msgid "Displays the files specified, with a pause at each `LINES` displayed."
msgstr "显示指定的文件，在每个显示的 `LINES` 之间暂停。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:261
#, no-wrap
msgid "reboot"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:263
#, no-wrap
msgid "Immediately reboots the system."
msgstr "立即重新启动系统。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:264
#, no-wrap
msgid "set `_variable_`, set `_variable=value_`"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:266
#, no-wrap
msgid "Sets the specified environment variables."
msgstr "设置指定的环境变量。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:267
#, no-wrap
msgid "unload"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:268
#, no-wrap
msgid "Removes all loaded modules."
msgstr "移除所有已加载的模块。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:272
#, 
msgid ""
"Here are some practical examples of loader usage.  To boot the usual kernel "
"in single-user mode:"
msgstr "以下是一些加载器使用的实际示例。要以单用户模式启动常规内核："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:276
#, no-wrap
msgid " boot -s\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:279
#, 
msgid ""
"To unload the usual kernel and modules and then load the previous or "
"another, specified kernel:"
msgstr "卸载常规的内核和模块，然后加载先前的或另一个指定的内核："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:284
#, no-wrap
msgid ""
" unload\n"
" load /path/to/kernelfile\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:287
#, 
msgid ""
"Use the qualified [.filename]#/boot/GENERIC/kernel# to refer to the default "
"kernel that comes with an installation, or "
"[.filename]#/boot/kernel.old/kernel#, to refer to the previously installed "
"kernel before a system upgrade or before configuring a custom kernel."
msgstr ""
"使用限定的 [.filename]#/boot/GENERIC/kernel# 来引用安装时默认的内核，或者使用 "
"[.filename]#/boot/kernel.old/kernel# 来引用在系统升级或配置自定义内核之前先前安装的内核。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:290
#, 
msgid ""
"Use the following to load the usual modules with another kernel.  Note that "
"in this case it is not necessary the qualified name:"
msgstr "使用以下内容在另一个内核中加载常用模块。请注意，在这种情况下，不需要使用限定名称："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:296
#, no-wrap
msgid ""
"unload\n"
"set kernel=\"mykernel\"\n"
"boot-conf\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:299
#, 
msgid "To load an automated kernel configuration script:"
msgstr "加载自动化内核配置脚本的方法："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:303
#, no-wrap
msgid " load -t userconfig_script /boot/kernel.conf\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/boot/_index.adoc:306
#, no-wrap
msgid "Last Stage"
msgstr "最后阶段"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:311
#, 
msgid ""
"Once the kernel is loaded by either loader or by boot2, which bypasses "
"loader, it examines any boot flags and adjusts its behavior as necessary.  "
"<<boot-kernel>> lists the commonly used boot flags.  Refer to man:boot[8] "
"for more information on the other boot flags."
msgstr ""
"一旦内核被加载，无论是由引导程序还是由绕过引导程序的 boot2 加载，它都会检查任何引导标志并根据需要调整其行为。 <<boot-kernel>> "
"列出了常用的引导标志。有关其他引导标志的更多信息，请参阅 man:boot[8]。"

#. type: Block title
#: documentation/content/en/books/handbook/boot/_index.adoc:313
#, no-wrap
msgid "Kernel Interaction During Boot"
msgstr "引导过程中的内核交互"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:317
#, no-wrap
msgid "Option"
msgstr "选项"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:320
#, no-wrap
msgid "`-a`"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:322
#, no-wrap
msgid ""
"During kernel initialization, ask for the device to mount as the root file "
"system."
msgstr "在内核初始化期间，请求设备作为根文件系统进行挂载。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:323
#, no-wrap
msgid "`-C`"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:325
#, no-wrap
msgid "Boot the root file system from a CDROM."
msgstr "从 CDROM 引导根文件系统。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:326
#, no-wrap
msgid "`-s`"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:328
#, no-wrap
msgid "Boot into single-user mode."
msgstr "进入单用户模式。"

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:329
#, no-wrap
msgid "`-v`"
msgstr ""

#. type: Table
#: documentation/content/en/books/handbook/boot/_index.adoc:330
#, no-wrap
msgid "Be more verbose during kernel startup."
msgstr "在内核启动过程中增加更多的详细信息。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:334
#, 
msgid ""
"Once the kernel has finished booting, it passes control to the user process "
"man:init[8], which is located at [.filename]#/sbin/init#, or the program "
"path specified in the `init_path` variable in `loader`.  This is the last "
"stage of the boot process."
msgstr ""
"一旦内核启动完成，它将控制权交给用户进程 man:init[8]，该进程位于 [.filename]#/sbin/init# 或者在 `loader` 中的 "
"`init_path` 变量指定的程序路径。这是引导过程的最后阶段。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:338
#, 
msgid ""
"The boot sequence makes sure that the file systems available on the system "
"are consistent.  If a UFS file system is not, and `fsck` cannot fix the "
"inconsistencies, init drops the system into single-user mode so that the "
"system administrator can resolve the problem directly.  Otherwise, the "
"system boots into multi-user mode."
msgstr ""
"引导序列确保系统上可用的文件系统是一致的。如果 UFS 文件系统不一致，并且 `fsck` 无法修复不一致性，init "
"会将系统切换到单用户模式，以便系统管理员可以直接解决问题。否则，系统将启动到多用户模式。"

#. type: Title ====
#: documentation/content/en/books/handbook/boot/_index.adoc:340
#, no-wrap
msgid "Single-User Mode"
msgstr "单用户模式"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:345
#, 
msgid ""
"A user can specify this mode by booting with `-s` or by setting the "
"`boot_single` variable in loader.  It can also be reached by running "
"`shutdown now` from multi-user mode.  Single-user mode begins with this "
"message:"
msgstr ""
"用户可以通过使用 `-s` 参数启动或在引导程序中设置 `boot_single` 变量来指定此模式。也可以通过在多用户模式下运行 `shutdown "
"now` 命令来进入此模式。单用户模式从以下消息开始："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:349
#, no-wrap
msgid "Enter full pathname of shell or RETURN for /bin/sh:\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:353
#, 
msgid ""
"If the user presses kbd:[Enter], the system will enter the default Bourne "
"shell.  To specify a different shell, input the full path to the shell."
msgstr ""
"如果用户按下 kbd:[Enter] 键，系统将进入默认的 Bourne shell 。要指定不同的 shell，请输入 shell 的完整路径。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:358
#, 
msgid ""
"Single-user mode is usually used to repair a system that will not boot due "
"to an inconsistent file system or an error in a boot configuration file.  It"
" can also be used to reset the `root` password when it is unknown.  These "
"actions are possible as the single-user mode prompt gives full, local access"
" to the system and its configuration files.  There is no networking in this "
"mode."
msgstr ""
"单用户模式通常用于修复由于不一致的文件系统或引导配置文件错误而无法启动的系统。它还可以用于在未知情况下重置 `root` "
"密码。由于单用户模式提示符提供对系统及其配置文件的完全本地访问权限，因此可以执行这些操作。在此模式下没有网络连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:361
#, 
msgid ""
"While single-user mode is useful for repairing a system, it poses a security"
" risk unless the system is in a physically secure location.  By default, any"
" user who can gain physical access to a system will have full control of "
"that system after booting into single-user mode."
msgstr ""
"单用户模式在修复系统时非常有用，但如果系统不在物理安全的位置，它会带来安全风险。默认情况下，任何能够物理访问系统的用户在进入单用户模式后将完全控制该系统。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:364
#, 
msgid ""
"If the system `console` is changed to `insecure` in [.filename]#/etc/ttys#, "
"the system will first prompt for the `root` password before initiating "
"single-user mode.  This adds a measure of security while removing the "
"ability to reset the `root` password when it is unknown."
msgstr ""
"如果在 [.filename]#/etc/ttys# 文件中将系统的 `console` 设置为 `insecure`，系统将在启动单用户模式之前首先提示输入 `root`"
" 密码。这样做可以增加一定的安全性，但也会移除在未知情况下重置 `root` 密码的能力。"

#. type: Block title
#: documentation/content/en/books/handbook/boot/_index.adoc:366
#, no-wrap
msgid "Configuring an Insecure Console in [.filename]#/etc/ttys#"
msgstr "在 [.filename]#/etc/ttys# 中配置一个不安全的控制台"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:376
#, no-wrap
msgid ""
"# name  getty                           type    status          comments\n"
"#\n"
"# If console is marked \"insecure\", then init will ask for the root password\n"
"# when going to single-user mode.\n"
"console none                            unknown off insecure\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:381
#, 
msgid ""
"An `insecure` console means that physical security to the console is "
"considered to be insecure, so only someone who knows the `root` password may"
" use single-user mode."
msgstr "一个 `不安全（insecure）` 的控制台意味着控制台的物理安全被认为是不安全的，因此只有知道 `root` 密码的人才能使用单用户模式。"

#. type: Title ====
#: documentation/content/en/books/handbook/boot/_index.adoc:383
#, no-wrap
msgid "Multi-User Mode"
msgstr "多用户模式"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:386
#, 
msgid ""
"If init finds the file systems to be in order, or once the user has finished"
" their commands in single-user mode and has typed `exit` to leave single-"
"user mode, the system enters multi-user mode, in which it starts the "
"resource configuration of the system."
msgstr ""
"如果 init 发现文件系统正常，或者用户在单用户模式下完成了他们的命令并输入 `exit` 退出单用户模式，系统将进入多用户模式，开始系统的资源配置。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:390
#, 
msgid ""
"The resource configuration system reads in configuration defaults from "
"[.filename]#/etc/defaults/rc.conf# and system-specific details from "
"[.filename]#/etc/rc.conf#.  It then proceeds to mount the system file "
"systems listed in [.filename]#/etc/fstab#.  It starts up networking "
"services, miscellaneous system daemons, then the startup scripts of locally "
"installed packages."
msgstr ""
"资源配置系统从 [.filename]#/etc/defaults/rc.conf# 读取配置的默认值，并从 [.filename]#/etc/rc.conf# "
"读取系统特定的详细信息。然后，它会挂载 [.filename]#/etc/fstab# "
"中列出的系统文件系统。它启动网络服务、杂项系统守护进程，然后启动本地安装软件包的启动脚本。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:392
#, 
msgid ""
"To learn more about the resource configuration system, refer to man:rc[8] "
"and examine the scripts located in [.filename]#/etc/rc.d#."
msgstr "要了解更多关于资源配置系统的信息，请参考 man:rc[8]，并检查位于 [.filename]#/etc/rc.d# 的脚本。"

#. type: Title ==
#: documentation/content/en/books/handbook/boot/_index.adoc:394
#, no-wrap
msgid "Device Hints"
msgstr "设备提示"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:399
#, 
msgid ""
"During initial system startup, the boot man:loader[8] reads "
"man:device.hints[5].  This file stores kernel boot information known as "
"variables, sometimes referred to as \"device hints\".  These \"device "
"hints\" are used by device drivers for device configuration."
msgstr ""
"在系统初始启动时，引导管理程序 boot man:loader[8] 会读取 man:device.hints[5] "
"文件。该文件存储了内核引导信息，也被称为 “设备提示（device hints）”。这些 “设备提示” 被设备驱动程序用于设备配置。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:404
#, 
msgid ""
"Device hints may also be specified at the Stage 3 boot loader prompt, as "
"demonstrated in <<boot-loader>>.  Variables can be added using `set`, "
"removed with `unset`, and viewed `show`.  Variables set in "
"[.filename]#/boot/device.hints# can also be overridden.  Device hints "
"entered at the boot loader are not permanent and will not be applied on the "
"next reboot."
msgstr ""
"设备提示也可以在第三阶段的引导加载程序提示符中指定，如 <<boot-loader>> 中所示。可以使用 `set` 添加变量，使用 `unset` "
"删除变量，并使用 `show` 查看变量。在 [.filename]#/boot/device.hints# "
"中设置的变量也可以被覆盖。在引导加载程序中输入的设备提示不是永久的，下次重启时不会应用。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:406
#, 
msgid ""
"Once the system is booted, man:kenv[1] can be used to dump all of the "
"variables."
msgstr "一旦系统启动，可以使用 man:kenv[1] 命令来转储所有的变量。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:409
#, 
msgid ""
"The syntax for [.filename]#/boot/device.hints# is one variable per line, "
"using the hash \"#\" as comment markers.  Lines are constructed as follows:"
msgstr "[.filename]#/boot/device.hints# 的语法是每行一个变量，使用井号 “#” 作为注释标记。行的构造如下："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:413
#, no-wrap
msgid " hint.driver.unit.keyword=\"value\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:416
#, 
msgid "The syntax for the Stage 3 boot loader is:"
msgstr "第三阶段引导加载程序的语法是："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/boot/_index.adoc:420
#, no-wrap
msgid " set hint.driver.unit.keyword=value\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:424
#, 
msgid ""
"where `driver` is the device driver name, `unit` is the device driver unit "
"number, and `keyword` is the hint keyword.  The keyword may consist of the "
"following options:"
msgstr ""
"其中 `driver` 是设备驱动程序的名称，`unit` 是设备驱动程序的单元号，`keyword` 是提示关键字。关键字可以包含以下选项："

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:426
#, 
msgid "`at`: specifies the bus which the device is attached to."
msgstr "`at`：指定设备所连接的总线。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:427
#, 
msgid "`port`: specifies the start address of the I/O to be used."
msgstr "`port`：指定要使用的 I/O 的起始地址。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:428
#, 
msgid "`irq`: specifies the interrupt request number to be used."
msgstr "`irq`：指定要使用的中断请求号。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:429
#, 
msgid "`drq`: specifies the DMA channel number."
msgstr "`drq`：指定 DMA 通道号。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:430
#, 
msgid "`maddr`: specifies the physical memory address occupied by the device."
msgstr "`maddr`：指定设备占用的物理内存地址。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:431
#, 
msgid "`flags`: sets various flag bits for the device."
msgstr "`flags`：为设备设置各种标志位。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:432
#, 
msgid "`disabled`: if set to `1` the device is disabled."
msgstr "`disabled`: 如果设置为 `1` ，则设备被禁用。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:435
#, 
msgid ""
"Since device drivers may accept or require more hints not listed here, "
"viewing a driver's manual page is recommended.  For more information, refer "
"to man:device.hints[5], man:kenv[1], man:loader.conf[5], and man:loader[8]."
msgstr ""
"由于设备驱动程序可能接受或需要更多未在此处列出的提示，建议查看驱动程序的手册页。有关更多信息，请参阅 man:device.hints[5] 、 "
"man:kenv[1]、man:loader.conf[5] 和 man:loader[8]。"

#. type: Title ==
#: documentation/content/en/books/handbook/boot/_index.adoc:437
#, no-wrap
msgid "Shutdown Sequence"
msgstr "关机序列"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:440
#, 
msgid ""
"Upon controlled shutdown using man:shutdown[8], man:init[8] will attempt to "
"run the script [.filename]#/etc/rc.shutdown#, and then proceed to send all "
"processes the `TERM` signal, and subsequently the `KILL` signal to any that "
"do not terminate in a timely manner."
msgstr ""
"在使用 man:shutdown[8] 进行控制关闭时， man:init[8] 将尝试运行脚本 "
"[.filename]#/etc/rc.shutdown# ，然后继续向所有进程发送 `TERM` 信号，随后对于未能及时终止的进程发送 `KILL` "
"信号。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:446
#, 
msgid ""
"To power down a FreeBSD machine on architectures and systems that support "
"power management, use `shutdown -p now` to turn the power off immediately.  "
"To reboot a FreeBSD system, use `shutdown -r now`.  One must be `root` or a "
"member of `operator` in order to run man:shutdown[8].  One can also use "
"man:halt[8] and man:reboot[8].  Refer to their manual pages and to "
"man:shutdown[8] for more information."
msgstr ""
"在支持电源管理的架构和系统上，要关闭 FreeBSD 机器，可以使用 `shutdown -p now` 立即关闭电源。要重新启动 FreeBSD "
"系统，可以使用 `shutdown -r now` 。要运行 man:shutdown[8]，必须是 `root` 用户或 `operator` "
"组的成员。还可以使用 man:halt[8] 和 man:reboot[8]。有关更多信息，请参考它们的手册页面和 "
"man:shutdown[8]。"

#. type: Plain text
#: documentation/content/en/books/handbook/boot/_index.adoc:448
#, 
msgid ""
"Modify group membership by referring to crossref:basics[users-"
"synopsis,“Users and Basic Account Management”]."
msgstr "通过引用 crossref:basics[users-synopsis,“用户和基本账户管理”] 来修改组成员身份。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/boot/_index.adoc:452
#, 
msgid ""
"Power management requires man:acpi[4] to be loaded as a module or statically"
" compiled into a custom kernel."
msgstr "电源管理需要将 man:acpi[4] 加载为模块或静态编译到自定义内核中。"
