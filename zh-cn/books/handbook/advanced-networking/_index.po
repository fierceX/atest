# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2023-12-17 07:06+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, fuzzy, no-wrap
msgid ""
"Advanced networking in FreeBSD:  basics of gateways and routes, CARP, how to"
" configure multiple VLANs on FreeBSD, etc"
msgstr "FreeBSD 中的高级网络功能：网关和路由的基础知识， CARP ，如何在 FreeBSD 上配置多个 VLAN 等。"

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, fuzzy, no-wrap
msgid "IV. Network Communication"
msgstr "IV. 网络通信"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, fuzzy, no-wrap
msgid "Chapter 34. Advanced Networking"
msgstr "第 34 章 . 高级网络"

#. type: Title =
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:14
#, fuzzy, no-wrap
msgid "Advanced Networking"
msgstr "高级网络"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:39
#, fuzzy
msgid ""
"include::shared/attributes/attributes-{{% lang %}}.adoc[] "
"include::shared/{{% lang %}}/teams.adoc[] include::shared/{{% lang "
"%}}/mailing-lists.adoc[] include::shared/{{% lang %}}/urls.adoc[]"
msgstr ""
"include::shared/attributes/attributes-{{% lang %}}.adoc[] "
"include::shared/{{% lang %}}/teams.adoc[] include::shared/{{% lang "
"%}}/mailing-lists.adoc[] include::shared/{{% lang %}}/urls.adoc[]"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:52
#, fuzzy, no-wrap
msgid "Synopsis"
msgstr "概要"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:55
#, fuzzy
msgid "This chapter covers a number of advanced networking topics."
msgstr "本章涵盖了一些高级网络主题。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:57
#, fuzzy
msgid "After reading this chapter, you will know:"
msgstr "阅读完本章后，您将了解："

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:59
#, fuzzy
msgid "The basics of gateways and routes."
msgstr "网关和路由的基础知识。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:60
#, fuzzy
msgid "How to set up USB tethering."
msgstr "如何设置 USB 网络共享。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:61
#, fuzzy
msgid "How to set up IEEE(R) 802.11 and Bluetooth(R) devices."
msgstr "如何设置 IEEE(R) 802.11 和 Bluetooth(R) 设备。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:62
#, fuzzy
msgid "How to make FreeBSD act as a bridge."
msgstr "如何将 FreeBSD 配置为桥接模式。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:63
#, fuzzy
msgid "How to set up network PXE booting."
msgstr "如何设置网络 PXE 引导。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:64
#, fuzzy
msgid ""
"How to enable and utilize the features of the Common Address Redundancy "
"Protocol (CARP) in FreeBSD."
msgstr "如何在 FreeBSD 中启用和利用 Common Address Redundancy Protocol (CARP) 的功能。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:65
#, fuzzy
msgid "How to configure multiple VLANs on FreeBSD."
msgstr "如何在 FreeBSD 上配置多个 VLAN 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:66
#, fuzzy
msgid "Configure bluetooth headset."
msgstr "配置蓝牙耳机。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:68
#, fuzzy
msgid "Before reading this chapter, you should:"
msgstr "在阅读本章之前，你应该："

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:70
#, fuzzy
msgid "Understand the basics of the [.filename]#/etc/rc# scripts."
msgstr "了解 [.filename]#/etc/rc# 脚本的基础知识。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:71
#, fuzzy
msgid "Be familiar with basic network terminology."
msgstr "熟悉基本的网络术语。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:72
#, fuzzy
msgid ""
"Understand basic network configuration on FreeBSD "
"(crossref:network[network,FreeBSD network])."
msgstr "了解 FreeBSD 上的基本网络配置（交叉引用： network[network , FreeBSD 网络] ）。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:73
#, fuzzy
msgid ""
"Know how to configure and install a new FreeBSD kernel "
"(crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel])."
msgstr ""
"了解如何配置和安装新的 FreeBSD 内核（参见： kernelconfig[kernelconfig ，配置 FreeBSD 内核] ）。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:74
#, fuzzy
msgid ""
"Know how to install additional third-party software "
"(crossref:ports[ports,Installing Applications: Packages and Ports])."
msgstr "了解如何安装额外的第三方软件（参见：安装应用程序：软件包和端口）。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:76
#, fuzzy, no-wrap
msgid "Gateways and Routes"
msgstr "网关和路由"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:85
#, fuzzy
msgid ""
"_Routing_ is the mechanism that allows a system to find the network path to "
"another system.  A _route_ is a defined pair of addresses which represent "
"the \"destination\" and a \"gateway\".  The route indicates that when trying"
" to get to the specified destination, send the packets through the specified"
" gateway.  There are three types of destinations: individual hosts, subnets,"
" and \"default\".  The \"default route\" is used if no other routes apply.  "
"There are also three types of gateways: individual hosts, interfaces, also "
"called links, and Ethernet hardware (MAC) addresses.  Known routes are "
"stored in a routing table."
msgstr ""
"_路由_ 是一种机制，允许系统找到到另一个系统的网络路径。_路由_ "
"是一对定义好的地址，表示\"目标\"和\"网关\"。路由指示当尝试到达指定的目标时，通过指定的网关发送数据包。目标有三种类型：单个主机、子网和\"默认\"。如果没有其他路由适用，将使用\"默认路由\"。网关也有三种类型：单个主机、接口（也称为链路）和以太网硬件（"
" MAC ）地址。已知的路由存储在路由表中。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:88
#, fuzzy
msgid ""
"This section provides an overview of routing basics.  It then demonstrates "
"how to configure a FreeBSD system as a router and offers some "
"troubleshooting tips."
msgstr "本节提供了路由基础知识的概述。然后演示了如何将 FreeBSD 系统配置为路由器，并提供了一些故障排除技巧。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:90
#, fuzzy, no-wrap
msgid "Routing Basics"
msgstr "路由基础知识"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:93
#, fuzzy
msgid "To view the routing table of a FreeBSD system, use man:netstat[1]:"
msgstr "要查看 FreeBSD 系统的路由表，请使用 man:netstat[1] 命令。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:98
#, no-wrap
msgid ""
"% netstat -r\n"
"Routing tables\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:110
#, no-wrap
msgid ""
"Internet:\n"
"Destination      Gateway            Flags     Refs     Use     Netif Expire\n"
"default          outside-gw         UGS        37      418       em0\n"
"localhost        localhost          UH          0      181       lo0\n"
"test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77\n"
"10.20.30.255     link#1             UHLW        1     2421\n"
"example.com      link#1             UC          0        0\n"
"host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0\n"
"host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>\n"
"host2.example.com link#1            UC          0        0\n"
"224              link#1             UC          0        0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:113
#, fuzzy
msgid "The entries in this example are as follows:"
msgstr "这个示例中的条目如下："

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:114
#, fuzzy, no-wrap
msgid "default"
msgstr "默认"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:118
#, fuzzy
msgid ""
"The first route in this table specifies the `default` route.  When the local"
" system needs to make a connection to a remote host, it checks the routing "
"table to determine if a known path exists.  If the remote host matches an "
"entry in the table, the system checks to see if it can connect using the "
"interface specified in that entry."
msgstr ""
"这个表中的第一条路由指定了“默认”路由。当本地系统需要与远程主机建立连接时，它会检查路由表以确定是否存在已知路径。如果远程主机与表中的条目匹配，系统会检查是否可以使用该条目中指定的接口进行连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:122
#, fuzzy
msgid ""
"If the destination does not match an entry, or if all known paths fail, the "
"system uses the entry for the default route.  For hosts on a local area "
"network, the `Gateway` field in the default route is set to the system which"
" has a direct connection to the Internet.  When reading this entry, verify "
"that the `Flags` column indicates that the gateway is usable (`UG`)."
msgstr ""
"如果目标与任何条目都不匹配，或者所有已知路径都失败，则系统将使用默认路由的条目。对于局域网上的主机， "
"默认路由中的“网关”字段设置为直接连接到互联网的系统。在阅读此条目时，请验证“标志”列是否指示网关可用（ `UG` ）。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:124
#, fuzzy
msgid ""
"The default route for a machine which itself is functioning as the gateway "
"to the outside world will be the gateway machine at the Internet Service "
"Provider (ISP)."
msgstr "如果一台机器本身作为外部世界的网关，那么它的默认路由将是互联网服务提供商（ ISP ）的网关机器。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:125
#, fuzzy, no-wrap
msgid "localhost"
msgstr "本地主机"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:129
#, fuzzy
msgid ""
"The second route is the `localhost` route.  The interface specified in the "
"`Netif` column for `localhost` is [.filename]#lo0#, also known as the "
"loopback device.  This indicates that all traffic for this destination "
"should be internal, rather than sending it out over the network."
msgstr ""
"第二条路由是 `localhost` 路由。在 `Netif` 列中指定的接口为 `.filename`#lo0# "
"，也被称为环回设备。这表示所有发送到该目的地的流量都应该是内部流量，而不是通过网络发送出去。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:130
#, fuzzy, no-wrap
msgid "MAC address"
msgstr "MAC 地址"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:136
#, fuzzy
msgid ""
"The addresses beginning with `0:e0:` are MAC addresses.  FreeBSD will "
"automatically identify any hosts, `test0` in the example, on the local "
"Ethernet and add a route for that host over the Ethernet interface, "
"[.filename]#re0#.  This type of route has a timeout, seen in the `Expire` "
"column, which is used if the host does not respond in a specific amount of "
"time.  When this happens, the route to this host will be automatically "
"deleted.  These hosts are identified using the Routing Information Protocol "
"(RIP), which calculates routes to local hosts based upon a shortest path "
"determination."
msgstr ""
"以 `0:e0:` 开头的地址是 MAC 地址。在 FreeBSD 中，它会自动识别本地以太网上的任何主机（例如 `test0` ），并在以太网接口（ "
"`re0` ）上添加一个用于该主机的路由。这种类型的路由有一个超时时间，在 `Expire` "
"列中显示，如果主机在特定时间内没有响应，路由将被自动删除。这些主机是使用路由信息协议（ RIP "
"）进行识别的，该协议根据最短路径确定计算到本地主机的路由。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:137
#, fuzzy, no-wrap
msgid "subnet"
msgstr "子网"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:141
#, fuzzy
msgid ""
"FreeBSD will automatically add subnet routes for the local subnet.  In this "
"example, `10.20.30.255` is the broadcast address for the subnet `10.20.30` "
"and `example.com` is the domain name associated with that subnet.  The "
"designation `link#1` refers to the first Ethernet card in the machine."
msgstr ""
"FreeBSD 会自动为本地子网添加子网路由。在这个例子中， `10.20.30.255` 是子网 `10.20.30` 的广播地址， "
"`example.com` 是与该子网关联的域名。 `link#1` 表示机器上的第一个以太网卡。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:144
#, fuzzy
msgid ""
"Local network hosts and local subnets have their routes automatically "
"configured by a daemon called man:routed[8].  If it is not running, only "
"routes which are statically defined by the administrator will exist."
msgstr ""
"本地网络主机和本地子网的路由由一个名为 man:routed[8] 的守护进程自动配置。如果该进程未运行，则只会存在由管理员静态定义的路由。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:145
#, fuzzy, no-wrap
msgid "host"
msgstr "主机"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:148
#, fuzzy
msgid ""
"The `host1` line refers to the host by its Ethernet address.  Since it is "
"the sending host, FreeBSD knows to use the loopback interface "
"([.filename]#lo0#) rather than the Ethernet interface."
msgstr ""
"`host1` 行是通过其以太网地址引用主机。由于它是发送主机， FreeBSD 知道要使用回环接口（ [.filename]#lo0# "
"），而不是以太网接口。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:152
#, fuzzy
msgid ""
"The two `host2` lines represent aliases which were created using "
"man:ifconfig[8].  The `=>` symbol after the [.filename]#lo0# interface says "
"that an alias has been set in addition to the loopback address.  Such routes"
" only show up on the host that supports the alias and all other hosts on the"
" local network will have a `link#1` line for such routes."
msgstr ""
"两个 `host2` 行表示使用 man:ifconfig[8] 创建的别名。在 [.filename]#lo0# 接口之后的 ` = >` "
"符号表示除了环回地址之外，还设置了一个别名。这样的路由只会出现在支持别名的主机上，而本地网络上的所有其他主机将会有一个 `link#1` "
"行用于这样的路由。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:153
#, fuzzy, no-wrap
msgid "224"
msgstr "224"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:155
#, fuzzy
msgid "The final line (destination subnet `224`) deals with multicasting."
msgstr "最后一行（目标子网 `224` ）处理多播。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:158
#, fuzzy
msgid ""
"Various attributes of each route can be seen in the `Flags` column.  "
"<<routeflags>> summarizes some of these flags and their meanings:"
msgstr "每个路由的各种属性可以在“ Flags ”列中看到。 <<routeflags>> 总结了一些这些标志及其含义："

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:160
#, fuzzy, no-wrap
msgid "Commonly Seen Routing Table Flags"
msgstr "常见的路由表标志"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:164
#, fuzzy, no-wrap
msgid "Flag"
msgstr "标志"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:166
#, fuzzy, no-wrap
msgid "Purpose"
msgstr "目的"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:167
#, fuzzy, no-wrap
msgid "U"
msgstr "U"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:169
#, fuzzy, no-wrap
msgid "The route is active (up)."
msgstr "路由已激活（上行）。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:170
#, fuzzy, no-wrap
msgid "H"
msgstr "你好！如何帮助您？"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:172
#, fuzzy, no-wrap
msgid "The route destination is a single host."
msgstr "路由目的地是一个单独的主机。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:173
#, fuzzy, no-wrap
msgid "G"
msgstr "G"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:175
#, fuzzy, no-wrap
msgid ""
"Send anything for this destination on to this gateway, which will figure out"
" from there where to send it."
msgstr "将任何东西发送到这个目的地，然后由这个网关决定从哪里发送。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:176
#, fuzzy, no-wrap
msgid "S"
msgstr "S"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:178
#, fuzzy, no-wrap
msgid "This route was statically configured."
msgstr "此路由是静态配置的。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:179
#, fuzzy, no-wrap
msgid "C"
msgstr ""
"C 是一种通用的编程语言，广泛用于开发各种应用程序和系统软件。它是一种高级语言，具有强大的表达能力和灵活性。 C "
"语言具有简洁的语法和丰富的库函数，使得开发者可以快速编写高效的代码。它还具有良好的可移植性，可以在不同的操作系统和硬件平台上运行。 C "
"语言在计算机科学和软件工程领域有着重要的地位，是学习和掌握计算机编程的基础。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:181
#, fuzzy, no-wrap
msgid ""
"Clones a new route based upon this route for machines to connect to. This "
"type of route is normally used for local networks."
msgstr "为机器连接克隆一个基于此路由的新路由。这种类型的路由通常用于本地网络。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:182
#, fuzzy, no-wrap
msgid "W"
msgstr "W"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:184
#, fuzzy, no-wrap
msgid ""
"The route was auto-configured based upon a local area network (clone) route."
msgstr "该路由是基于本地区域网络（克隆）路由进行自动配置的。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:185
#, fuzzy, no-wrap
msgid "L"
msgstr "L"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:186
#, fuzzy, no-wrap
msgid "Route involves references to Ethernet (link) hardware."
msgstr "路由涉及对以太网（链路）硬件的引用。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:189
#, fuzzy
msgid ""
"On a FreeBSD system, the default route can defined in "
"[.filename]#/etc/rc.conf# by specifying the IP address of the default "
"gateway:"
msgstr "在 FreeBSD 系统上，可以通过在 `/etc/rc.conf` 文件中指定默认网关的 IP 地址来定义默认路由："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:193
#, no-wrap
msgid "defaultrouter=\"10.20.30.1\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:196
#, fuzzy
msgid "It is also possible to manually add the route using `route`:"
msgstr "还可以使用 `route` 命令手动添加路由："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:200
#, no-wrap
msgid "# route add default 10.20.30.1\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:204
#, fuzzy
msgid ""
"Note that manually added routes will not survive a reboot.  For more "
"information on manual manipulation of network routing tables, refer to "
"man:route[8]."
msgstr "请注意，手动添加的路由在重新启动后将不会保留。有关手动操作网络路由表的更多信息，请参阅 man:route[8] 。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:206
#, fuzzy, no-wrap
msgid "Configuring a Router with Static Routes"
msgstr "使用静态路由配置路由器"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:211
#, fuzzy
msgid ""
"A FreeBSD system can be configured as the default gateway, or router, for a "
"network if it is a dual-homed system.  A dual-homed system is a host which "
"resides on at least two different networks.  Typically, each network is "
"connected to a separate network interface, though IP aliasing can be used to"
" bind multiple addresses, each on a different subnet, to one physical "
"interface."
msgstr ""
"如果一个 FreeBSD "
"系统是一个双主机系统，它可以被配置为网络的默认网关或路由器。双主机系统是指至少连接在两个不同网络上的主机。通常，每个网络都连接到一个独立的网络接口，尽管可以使用"
" IP 别名来将多个地址绑定到一个物理接口上，每个地址位于不同的子网上。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:214
#, fuzzy
msgid ""
"In order for the system to forward packets between interfaces, FreeBSD must "
"be configured as a router.  Internet standards and good engineering practice"
" prevent the FreeBSD Project from enabling this feature by default, but it "
"can be configured to start at boot by adding this line to "
"[.filename]#/etc/rc.conf#:"
msgstr ""
"为了使系统在接口之间转发数据包， FreeBSD 必须配置为路由器。互联网标准和良好的工程实践阻止了 FreeBSD "
"项目默认启用此功能，但可以通过将以下行添加到 [/etc/rc.conf] 来配置在启动时启动："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:218
#, no-wrap
msgid ""
"gateway_enable=\"YES\"          # Set to YES if this host will be a "
"gateway\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:222
#, fuzzy
msgid ""
"To enable routing now, set the man:sysctl[8] variable "
"`net.inet.ip.forwarding` to `1`.  To stop routing, reset this variable to "
"`0`."
msgstr ""
"要立即启用路由功能，请将 man:sysctl[8] 变量 `net.inet.ip.forwarding` 设置为 `1` "
"。要停止路由功能，请将此变量重置为 `0` 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:226
#, fuzzy
msgid ""
"The routing table of a router needs additional routes so it knows how to "
"reach other networks.  Routes can be either added manually using static "
"routes or routes can be automatically learned using a routing protocol.  "
"Static routes are appropriate for small networks and this section describes "
"how to add a static routing entry for a small network."
msgstr ""
"路由器的路由表需要额外的路由，以便知道如何到达其他网络。路由可以通过手动添加静态路由或使用路由协议自动学习来添加。静态路由适用于小型网络，本节描述了如何为小型网络添加静态路由条目。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:232
#, fuzzy
msgid ""
"For large networks, static routes quickly become unscalable.  FreeBSD comes "
"with the standard BSD routing daemon man:routed[8], which provides the "
"routing protocols RIP, versions 1 and 2, and IRDP.  Support for the BGP and "
"OSPF routing protocols can be installed using the package:net/quagga[] "
"package or port."
msgstr ""
"对于大型网络来说，静态路由很快就变得不可扩展。 FreeBSD 附带了标准的 BSD 路由守护程序 man:routed[8] ，它提供了 RIP "
"协议的版本 1 和 2 以及 IRDP 协议。可以使用 package:net/quagga[] 包或端口安装 BGP 和 OSPF 路由协议的支持。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:235
#, fuzzy
msgid "Consider the following network:"
msgstr "考虑以下网络："

#. type: Target for macro image
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:236
#, fuzzy, no-wrap
msgid "static-routes.png"
msgstr "static-routes.png"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:241
#, fuzzy
msgid ""
"In this scenario, `RouterA` is a FreeBSD machine that is acting as a router "
"to the rest of the Internet.  It has a default route set to `10.0.0.1` which"
" allows it to connect with the outside world.  `RouterB` is already "
"configured to use `192.168.1.1` as its default gateway."
msgstr ""
"在这种情况下， `RouterA` 是一台充当互联网路由器的 FreeBSD 机器。它设置了一个默认路由到 `10.0.0.1` "
"，使其能够与外部世界连接。 `RouterB` 已经配置为使用 `192.168.1.1` 作为其默认网关。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:243
#, fuzzy
msgid ""
"Before adding any static routes, the routing table on `RouterA` looks like "
"this:"
msgstr "在添加任何静态路由之前， `RouterA` 上的路由表如下所示："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:248
#, no-wrap
msgid ""
"% netstat -nr\n"
"Routing tables\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:255
#, no-wrap
msgid ""
"Internet:\n"
"Destination        Gateway            Flags    Refs      Use  Netif  Expire\n"
"default            10.0.0.1           UGS         0    49378    xl0\n"
"127.0.0.1          127.0.0.1          UH          0        6    lo0\n"
"10.0.0.0/24        link#1             UC          0        0    xl0\n"
"192.168.1.0/24     link#2             UC          0        0    xl1\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:259
#, fuzzy
msgid ""
"With the current routing table, `RouterA` does not have a route to the "
"`192.168.2.0/24` network.  The following command adds the `Internal Net 2` "
"network to ``RouterA``'s routing table using `192.168.1.2` as the next hop:"
msgstr ""
"根据当前的路由表， `RouterA` 没有到达 `192.168.2.0/24` 网络的路由。以下命令将使用 `192.168.1.2` "
"作为下一跳，将 `Internal Net 2` 网络添加到 `RouterA` 的路由表中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:263
#, no-wrap
msgid "# route add -net 192.168.2.0/24 192.168.1.2\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:268
#, fuzzy
msgid ""
"Now, `RouterA` can reach any host on the `192.168.2.0/24` network.  However,"
" the routing information will not persist if the FreeBSD system reboots.  If"
" a static route needs to be persistent, add it to [.filename]#/etc/rc.conf#:"
msgstr ""
"现在， `RouterA` 可以访问 `192.168.2.0/24` 网络上的任何主机。然而，如果 FreeBSD "
"系统重新启动，路由信息将不会持久化。如果需要静态路由持久化，将其添加到 `/etc/rc.conf` 文件中。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:274
#, no-wrap
msgid ""
"# Add Internal Net 2 as a persistent static route\n"
"static_routes=\"internalnet2\"\n"
"route_internalnet2=\"-net 192.168.2.0/24 192.168.1.2\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:278
#, fuzzy
msgid ""
"The `static_routes` configuration variable is a list of strings separated by"
" a space, where each string references a route name.  The variable "
"`route_internalnet2` contains the static route for that route name."
msgstr ""
"`static_routes` 配置变量是一个由空格分隔的字符串列表，其中每个字符串引用一个路由名称。变量 `route_internalnet2` "
"包含了该路由名称的静态路由。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:281
#, fuzzy
msgid ""
"Using more than one string in `static_routes` creates multiple static "
"routes.  The following shows an example of adding static routes for the "
"`192.168.0.0/24` and `192.168.1.0/24` networks:"
msgstr ""
"在 `static_routes` 中使用多个字符串可以创建多个静态路由。以下是添加 `192.168.0.0/24` 和 "
"`192.168.1.0/24` 网络的静态路由的示例："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:287
#, no-wrap
msgid ""
"static_routes=\"net1 net2\"\n"
"route_net1=\"-net 192.168.0.0/24 192.168.0.1\"\n"
"route_net2=\"-net 192.168.1.0/24 192.168.1.1\"\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:290
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1321
#, fuzzy, no-wrap
msgid "Troubleshooting"
msgstr "故障排除"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:294
#, fuzzy
msgid ""
"When an address space is assigned to a network, the service provider "
"configures their routing tables so that all traffic for the network will be "
"sent to the link for the site.  But how do external sites know to send their"
" packets to the network's ISP?"
msgstr ""
"当一个地址空间被分配给一个网络时，服务提供商会配置他们的路由表，以便将所有网络流量发送到该站点的链路上。但是外部站点如何知道将其数据包发送到网络的 "
"ISP 呢？"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:297
#, fuzzy
msgid ""
"There is a system that keeps track of all assigned address spaces and "
"defines their point of connection to the Internet backbone, or the main "
"trunk lines that carry Internet traffic across the country and around the "
"world.  Each backbone machine has a copy of a master set of tables, which "
"direct traffic for a particular network to a specific backbone carrier, and "
"from there down the chain of service providers until it reaches a particular"
" network."
msgstr ""
"有一个系统负责跟踪所有分配的地址空间，并定义它们与互联网骨干网的连接点，即负责在国内外承载互联网流量的主干线路。每个骨干机器都有一个主表的副本，该表将特定网络的流量引导到特定的骨干运营商，然后通过服务提供商链路一直传递，直到到达特定的网络。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:300
#, fuzzy
msgid ""
"It is the task of the service provider to advertise to the backbone sites "
"that they are the point of connection, and thus the path inward, for a site."
"  This is known as route propagation."
msgstr "服务提供商的任务是向骨干站点宣传他们是连接点，从而为站点提供内部路径。这被称为路由传播。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:304
#, fuzzy
msgid ""
"Sometimes, there is a problem with route propagation and some sites are "
"unable to connect.  Perhaps the most useful command for trying to figure out"
" where routing is breaking down is `traceroute`.  It is useful when `ping` "
"fails."
msgstr ""
"有时候，路由传播存在问题，导致一些站点无法连接。也许最有用的用于尝试找出路由中断位置的命令是 `traceroute` 。当 `ping` "
"失败时，它非常有用。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:308
#, fuzzy
msgid ""
"When using `traceroute`, include the address of the remote host to connect "
"to.  The output will show the gateway hosts along the path of the attempt, "
"eventually either reaching the target host, or terminating because of a lack"
" of connection.  For more information, refer to man:traceroute[8]."
msgstr ""
"使用 `traceroute` "
"命令时，需要指定要连接的远程主机的地址。输出结果将显示沿着尝试路径的网关主机，最终要么到达目标主机，要么因为连接不上而终止。更多信息，请参考 "
"man:traceroute[8] 。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:310
#, fuzzy, no-wrap
msgid "Multicast Considerations"
msgstr "多播考虑因素"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:315
#, fuzzy
msgid ""
"FreeBSD natively supports both multicast applications and multicast routing."
"  Multicast applications do not require any special configuration in order "
"to run on FreeBSD.  Support for multicast routing requires that the "
"following option be compiled into a custom kernel:"
msgstr ""
"FreeBSD 原生支持多播应用程序和多播路由。在 FreeBSD 上运行多播应用程序不需要任何特殊配置。支持多播路由需要将以下选项编译到自定义内核中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:319
#, no-wrap
msgid "options MROUTING\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:325
#, fuzzy
msgid ""
"The multicast routing daemon, mrouted can be installed using the "
"package:net/mrouted[] package or port.  This daemon implements the DVMRP "
"multicast routing protocol and is configured by editing "
"[.filename]#/usr/local/etc/mrouted.conf# in order to set up the tunnels and "
"DVMRP.  The installation of mrouted also installs map-mbone and mrinfo, as "
"well as their associated man pages.  Refer to these for configuration "
"examples."
msgstr ""
"可以使用 package:net/mrouted[] 包或端口安装多播路由守护程序 mrouted 。该守护程序实现了 DVMRP "
"多播路由协议，并通过编辑 [/usr/local/etc/mrouted.conf] 来配置以设置隧道和 DVMRP 。安装 mrouted 还会安装 "
"map-mbone 和 mrinfo ，以及它们的相关手册页。请参考这些手册页获取配置示例。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:330
#, fuzzy
msgid ""
"DVMRP has largely been replaced by the PIM protocol in many multicast "
"installations.  Refer to man:pim[4] for more information."
msgstr "在许多多播安装中， DVMRP 协议大多被 PIM 协议取代。有关更多信息，请参阅 man:pim[4] 。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:333
#, fuzzy, no-wrap
msgid "Virtual Hosts"
msgstr "虚拟主机"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:337
#, fuzzy
msgid ""
"A common use of FreeBSD is virtual site hosting, where one server appears to"
" the network as many servers.  This is achieved by assigning multiple "
"network addresses to a single interface."
msgstr "FreeBSD 的常见用途之一是虚拟站点托管，其中一个服务器在网络上表现为多个服务器。这是通过将多个网络地址分配给单个接口来实现的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:340
#, fuzzy
msgid ""
"A given network interface has one \"real\" address, and may have any number "
"of \"alias\" addresses.  These aliases are normally added by placing alias "
"entries in [.filename]#/etc/rc.conf#, as seen in this example:"
msgstr ""
"一个给定的网络接口有一个“真实”的地址，可以有任意数量的“别名”地址。这些别名通常是通过在 [/etc/rc.conf] "
"中添加别名条目来添加的，如下面的示例所示："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:344
#, no-wrap
msgid ""
"# sysrc ifconfig_fxp0_alias0=\"inet xxx.xxx.xxx.xxx netmask "
"xxx.xxx.xxx.xxx\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:348
#, fuzzy
msgid ""
"Alias entries must start with `alias__0__` using a sequential number such as"
" `alias0`, `alias1`, and so on.  The configuration process will stop at the "
"first missing number."
msgstr ""
"别名条目必须以 `alias__0__` 开头，使用连续的数字，例如 `alias0` ， `alias1` 等等。配置过程将在第一个缺失的数字处停止。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:352
#, fuzzy
msgid ""
"The calculation of alias netmasks is important.  For a given interface, "
"there must be one address which correctly represents the network's netmask."
"  Any other addresses which fall within this network must have a netmask of "
"all ``1``s, expressed as either `255.255.255.255` or `0xffffffff`."
msgstr ""
"别名网络掩码的计算非常重要。对于给定的接口，必须有一个地址能正确表示网络的网络掩码。任何其他落在该网络内的地址都必须具有全为“ 1 "
"”的网络掩码，可以表示为 `255.255.255.255` 或 `0xffffffff` 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:357
#, fuzzy
msgid ""
"For example, consider the case where the `fxp0` interface is connected to "
"two networks: `10.1.1.0` with a netmask of `255.255.255.0` and `202.0.75.16`"
" with a netmask of `255.255.255.240`.  The system is to be configured to "
"appear in the ranges `10.1.1.1` through `10.1.1.5` and `202.0.75.17` through"
" `202.0.75.20`.  Only the first address in a given network range should have"
" a real netmask.  All the rest (`10.1.1.2` through `10.1.1.5` and "
"`202.0.75.18` through `202.0.75.20`) must be configured with a netmask of "
"`255.255.255.255`."
msgstr ""
"例如，考虑 `fxp0` 接口连接到两个网络的情况： `10.1.1.0` 的子网掩码为 `255.255.255.0` ， `202.0.75.16`"
" 的子网掩码为 `255.255.255.240` 。系统需要配置为出现在范围 `10.1.1.1` 到 `10.1.1.5` 和 "
"`202.0.75.17` 到 `202.0.75.20` 中。给定网络范围中只有第一个地址应具有真实的子网掩码。其余的地址（ `10.1.1.2` 到"
" `10.1.1.5` 和 `202.0.75.18` 到 `202.0.75.20` ）必须配置为子网掩码 `255.255.255.255` 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:359
#, fuzzy
msgid ""
"The following [.filename]#/etc/rc.conf# entries configure the adapter "
"correctly for this scenario:"
msgstr "以下是配置适配器以适应此场景的 [/etc/rc.conf](文件名) 条目："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:371
#, no-wrap
msgid ""
"# sysrc ifconfig_fxp0=\"inet 10.1.1.1 netmask 255.255.255.0\"\n"
"# sysrc ifconfig_fxp0_alias0=\"inet 10.1.1.2 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias1=\"inet 10.1.1.3 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias2=\"inet 10.1.1.4 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias3=\"inet 10.1.1.5 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias4=\"inet 202.0.75.17 netmask 255.255.255.240\"\n"
"# sysrc ifconfig_fxp0_alias5=\"inet 202.0.75.18 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias6=\"inet 202.0.75.19 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias7=\"inet 202.0.75.20 netmask 255.255.255.255\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:375
#, fuzzy
msgid ""
"A simpler way to express this is with a space-separated list of IP address "
"ranges.  The first address will be given the indicated subnet mask and the "
"additional addresses will have a subnet mask of `255.255.255.255`."
msgstr ""
"用空格分隔的 IP 地址范围列表更简单地表达这个概念。第一个地址将使用指定的子网掩码，而其他地址将使用子网掩码 `255.255.255.255` 。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:379
#, no-wrap
msgid ""
"# sysrc ifconfig_fxp0_aliases=\"inet 10.1.1.1-5/24 inet "
"202.0.75.17-20/28\"\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:382
#, fuzzy, no-wrap
msgid "Wireless Advanced Authentication"
msgstr "无线高级认证"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:386
#, fuzzy
msgid ""
"FreeBSD supports different ways of connecting to a wireless network.  This "
"section describes how to perform advanced authentication to a Wireless "
"Network."
msgstr "FreeBSD 支持多种连接无线网络的方式。本节介绍如何进行高级身份验证以连接无线网络。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:388
#, fuzzy
msgid ""
"To make a connection and basic authentication to a wireless network the "
"section crossref:network[wireless-authentication,Connection and "
"Authentication to a Wireless Network] in the Network Chapter describes how "
"to do it."
msgstr ""
"要建立连接并进行基本身份验证以连接到无线网络，可以参考网络章节中的 crossref:network[wireless-authentication ,"
" Connection and Authentication to a Wireless Network] 部分来了解如何操作。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:390
#, fuzzy, no-wrap
msgid "WPA with EAP-TLS"
msgstr "WPA 与 EAP-TLS"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:395
#, fuzzy
msgid ""
"The second way to use WPA is with an 802.1X backend authentication server.  "
"In this case, WPA is called WPA Enterprise to differentiate it from the less"
" secure WPA Personal.  Authentication in WPA Enterprise is based on the "
"Extensible Authentication Protocol (EAP)."
msgstr ""
"使用 WPA 的第二种方式是通过 802.1X 后端认证服务器。在这种情况下， WPA 被称为 WPA 企业版，以区别于较不安全的 WPA 个人版。 "
"WPA 企业版中的认证是基于可扩展认证协议（ EAP ）的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:399
#, fuzzy
msgid ""
"EAP does not come with an encryption method.  Instead, EAP is embedded "
"inside an encrypted tunnel.  There are many EAP authentication methods, but "
"EAP-TLS, EAP-TTLS, and EAP-PEAP are the most common."
msgstr ""
"EAP 不带有加密方法。相反， EAP 被嵌入在一个加密隧道中。有许多 EAP 认证方法，但 EAP-TLS 、 EAP-TTLS 和 EAP-PEAP"
" 是最常见的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:403
#, fuzzy
msgid ""
"EAP with Transport Layer Security (EAP-TLS) is a well-supported wireless "
"authentication protocol since it was the first EAP method to be certified by"
" the http://www.wi-fi.org/[Wi-Fi Alliance].  EAP-TLS requires three "
"certificates to run: the certificate of the Certificate Authority (CA) "
"installed on all machines, the server certificate for the authentication "
"server, and one client certificate for each wireless client.  In this EAP "
"method, both the authentication server and wireless client authenticate each"
" other by presenting their respective certificates, and then verify that "
"these certificates were signed by the organization's CA."
msgstr ""
"EAP 与传输层安全性（ EAP-TLS ）是一种得到广泛支持的无线认证协议，因为它是第一个被 http://www.wi-fi.org/[Wi-Fi "
"联盟] 认证的 EAP 方法。 EAP-TLS 需要三个证书来运行：安装在所有设备上的证书颁发机构（ CA "
"）的证书，用于认证服务器的服务器证书，以及每个无线客户端的一个客户端证书。在这种 EAP "
"方法中，认证服务器和无线客户端通过展示各自的证书来相互认证，然后验证这些证书是由组织的 CA 签名的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:405
#, fuzzy
msgid ""
"As previously, the configuration is done via "
"[.filename]#/etc/wpa_supplicant.conf#:"
msgstr "与以前一样，配置是通过 [/etc/wpa_supplicant.conf] 进行的："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:419
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\" <.>\n"
"  proto=RSN  <.>\n"
"  key_mgmt=WPA-EAP <.>\n"
"  eap=TLS <.>\n"
"  identity=\"loader\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  client_cert=\"/etc/certs/clientcert.pem\" <.>\n"
"  private_key=\"/etc/certs/clientkey.pem\" <.>\n"
"  private_key_passwd=\"freebsdmallclient\" <.>\n"
"}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:430
#, fuzzy
msgid ""
"<.> This field indicates the network name (SSID).  <.> This example uses the"
" RSN IEEE(R) 802.11i protocol, also known as WPA2.  <.> The `key_mgmt` line "
"refers to the key management protocol to use. In this example, it is WPA "
"using EAP authentication.  <.> This field indicates the EAP method for the "
"connection.  <.> The `identity` field contains the identity string for EAP."
"  <.> The `ca_cert` field indicates the pathname of the CA certificate file."
" This file is needed to verify the server certificate.  <.> The "
"`client_cert` line gives the pathname to the client certificate file. This "
"certificate is unique to each wireless client of the network.  <.> The "
"`private_key` field is the pathname to the client certificate private key "
"file.  <.> The `private_key_passwd` field contains the passphrase for the "
"private key."
msgstr ""
"<.> 这个字段表示网络名称（ SSID ）。\n"
" <.> 这个示例使用了 RSN IEEE(R) 802.11i 协议，也被称为 WPA2 。\n"
" <.> `key_mgmt` 行指定了要使用的密钥管理协议。在这个示例中，使用的是使用 EAP 认证的 WPA 。\n"
" <.> 这个字段表示连接的 EAP 方法。\n"
" <.> `identity` 字段包含了 EAP 的身份字符串。\n"
" <.> `ca_cert` 字段指定了 CA 证书文件的路径名。这个文件用于验证服务器证书。\n"
" <.> `client_cert` 行给出了客户端证书文件的路径名。这个证书是每个无线客户端的独特证书。\n"
" <.> `private_key` 字段是客户端证书私钥文件的路径名。\n"
" <.> `private_key_passwd` 字段包含了私钥的密码短语。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:432
#, fuzzy
msgid "Then, add the following lines to [.filename]#/etc/rc.conf#:"
msgstr "然后，将以下行添加到 [/etc/rc.conf] 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:437
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:499
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:570
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA DHCP\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:440
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:502
#, fuzzy
msgid "The next step is to bring up the interface:"
msgstr "下一步是启动界面："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:459
#, no-wrap
msgid ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:462
#, fuzzy
msgid ""
"It is also possible to bring up the interface manually using "
"man:wpa_supplicant[8] and man:ifconfig[8]."
msgstr "还可以使用 man:wpa_supplicant[8] 和 man:ifconfig[8] 手动启动接口。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:464
#, fuzzy, no-wrap
msgid "WPA with EAP-TTLS"
msgstr "WPA 与 EAP-TTLS"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:470
#, fuzzy
msgid ""
"With EAP-TLS, both the authentication server and the client need a "
"certificate.  With EAP-TTLS, a client certificate is optional.  This method "
"is similar to a web server which creates a secure SSL tunnel even if "
"visitors do not have client-side certificates.  EAP-TTLS uses an encrypted "
"TLS tunnel for safe transport of the authentication data."
msgstr ""
"使用 EAP-TLS ，认证服务器和客户端都需要证书。使用 EAP-TTLS ，客户端证书是可选的。这种方法类似于一个 Web "
"服务器，即使访问者没有客户端证书，也会创建一个安全的 SSL 隧道。 EAP-TTLS 使用加密的 TLS 隧道来安全传输认证数据。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:472
#, fuzzy
msgid ""
"The required configuration can be added to "
"[.filename]#/etc/wpa_supplicant.conf#:"
msgstr "所需的配置可以添加到 [/etc/wpa_supplicant.conf] 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:485
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=TTLS <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase2=\"auth=MD5\" <.>\n"
"}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:492
#, fuzzy
msgid ""
"<.> This field specifies the EAP method for the connection.  <.> The "
"`identity` field contains the identity string for EAP authentication inside "
"the encrypted TLS tunnel.  <.> The `password` field contains the passphrase "
"for the EAP authentication.  <.> The `ca_cert` field indicates the pathname "
"of the CA certificate file. This file is needed to verify the server "
"certificate.  <.> This field specifies the authentication method used in the"
" encrypted TLS tunnel. In this example, EAP with MD5-Challenge is used. The "
"\"inner authentication\" phase is often called \"phase2\"."
msgstr ""
"<.> 这个字段指定了连接的 EAP 方法。 <.> `identity` 字段包含了在加密的 TLS 隧道内进行 EAP 身份验证的身份字符串。 "
"<.> `password` 字段包含了 EAP 身份验证的密码。 <.> `ca_cert` 字段指示 CA "
"证书文件的路径名。这个文件用于验证服务器证书。 <.> 这个字段指定了在加密的 TLS 隧道中使用的身份验证方法。在这个例子中，使用了 EAP 和 "
"MD5-Challenge 。\"内部身份验证\"阶段通常被称为\"第二阶段\"。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:494
#, fuzzy
msgid "Next, add the following lines to [.filename]#/etc/rc.conf#:"
msgstr "接下来，将以下行添加到 [.filename]#/etc/rc.conf# 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:522
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:593
#, no-wrap
msgid ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:525
#, fuzzy, no-wrap
msgid "WPA with EAP-PEAP"
msgstr "WPA 与 EAP-PEAP"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:531
#, fuzzy
msgid ""
"PEAPv0/EAP-MSCHAPv2 is the most common PEAP method.  In this chapter, the "
"term PEAP is used to refer to that method."
msgstr "PEAPv0/EAP-MSCHAPv2 是最常见的 PEAP 方法。在本章中，术语 PEAP 用于指代该方法。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:535
#, fuzzy
msgid ""
"Protected EAP (PEAP) is designed as an alternative to EAP-TTLS and is the "
"most used EAP standard after EAP-TLS.  In a network with mixed operating "
"systems, PEAP should be the most supported standard after EAP-TLS."
msgstr ""
"Protected EAP （ PEAP ）是作为 EAP-TTLS 的替代方案而设计的，在 EAP-TLS 之后是最常用的 EAP "
"标准。在一个混合操作系统的网络中， PEAP 应该是仅次于 EAP-TLS 的最受支持的标准。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:539
#, fuzzy
msgid ""
"PEAP is similar to EAP-TTLS as it uses a server-side certificate to "
"authenticate clients by creating an encrypted TLS tunnel between the client "
"and the authentication server, which protects the ensuing exchange of "
"authentication information.  PEAP authentication differs from EAP-TTLS as it"
" broadcasts the username in the clear and only the password is sent in the "
"encrypted TLS tunnel.  EAP-TTLS will use the TLS tunnel for both the "
"username and password."
msgstr ""
"PEAP 与 EAP-TTLS 类似，它使用服务器端证书来通过在客户端和认证服务器之间创建加密的 TLS 隧道来验证客户端，从而保护后续的认证信息交换。"
" PEAP 认证与 EAP-TTLS 不同之处在于，它以明文方式广播用户名，只有密码在加密的 TLS 隧道中发送。而 EAP-TTLS 将同时使用 "
"TLS 隧道传输用户名和密码。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:541
#, fuzzy
msgid ""
"Add the following lines to [.filename]#/etc/wpa_supplicant.conf# to "
"configure the EAP-PEAP related settings:"
msgstr "将以下行添加到 [.filename]#/etc/wpa_supplicant.conf# 以配置 EAP-PEAP 相关设置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:555
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=PEAP <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase1=\"peaplabel=0\" <.>\n"
"  phase2=\"auth=MSCHAPV2\" <.>\n"
"}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:563
#, fuzzy
msgid ""
"<.> This field specifies the EAP method for the connection.  <.> The "
"`identity` field contains the identity string for EAP authentication inside "
"the encrypted TLS tunnel.  <.> The `password` field contains the passphrase "
"for the EAP authentication.  <.> The `ca_cert` field indicates the pathname "
"of the CA certificate file. This file is needed to verify the server "
"certificate.  <.> This field contains the parameters for the first phase of "
"authentication, the TLS tunnel. According to the authentication server used,"
" specify a specific label for authentication. Most of the time, the label "
"will be \"client EAP encryption\" which is set by using `peaplabel=0`. More "
"information can be found in man:wpa_supplicant.conf[5].  <.> This field "
"specifies the authentication protocol used in the encrypted TLS tunnel. In "
"the case of PEAP, it is `auth=MSCHAPV2`."
msgstr ""
"<.> 这个字段指定了连接的 EAP 方法。 <.> `identity` 字段包含了在加密的 TLS 隧道内进行 EAP 认证的身份字符串。 <.> "
"`password` 字段包含了 EAP 认证的密码。 <.> `ca_cert` 字段指示了 CA 证书文件的路径名。这个文件用于验证服务器证书。 "
"<.> 这个字段包含了第一阶段认证的参数，即 TLS 隧道。根据使用的认证服务器，指定一个特定的标签进行认证。大多数情况下，标签将是\"client "
"EAP encryption\"，可以通过使用 `peaplabel = 0` 来设置。更多信息可以在 "
"man:wpa_supplicant.conf[5] 中找到。 <.> 这个字段指定了在加密的 TLS 隧道中使用的认证协议。在 PEAP "
"的情况下，它是 `auth = MSCHAPV2` 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:565
#, fuzzy
msgid "Add the following to [.filename]#/etc/rc.conf#:"
msgstr "将以下内容添加到 [/etc/rc.conf] 文件中："

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:573
#, fuzzy
msgid "Then, bring up the interface:"
msgstr "然后，启动界面："

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:596
#, fuzzy, no-wrap
msgid "Wireless Ad-hoc Mode"
msgstr "无线自组网模式"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:600
#, fuzzy
msgid ""
"IBSS mode, also called ad-hoc mode, is designed for point to point "
"connections.  For example, to establish an ad-hoc network between the "
"machines `A` and `B`, choose two IP addresses and a SSID."
msgstr ""
"IBSS 模式，也称为自组网模式，旨在用于点对点连接。例如，要在机器 A 和 B 之间建立一个自组网，选择两个 IP 地址和一个 SSID 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:602
#, fuzzy
msgid "On `A`:"
msgstr "在 `A` 上："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:616
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:619
#, fuzzy
msgid ""
"The `adhoc` parameter indicates that the interface is running in IBSS mode."
msgstr "`adhoc` 参数表示接口正在以 IBSS 模式运行。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:621
#, fuzzy
msgid "`B` should now be able to detect `A`:"
msgstr "`B` 现在应该能够检测到 `A` ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:628
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 up scan\n"
"  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:632
#, fuzzy
msgid ""
"The `I` in the output confirms that `A` is in ad-hoc mode.  Now, configure "
"`B` with a different IP address:"
msgstr "输出中的 `I` 确认了 `A` 处于即席模式。现在，将 `B` 配置为不同的 IP 地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:645
#, no-wrap
msgid ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:648
#, fuzzy
msgid "Both `A` and `B` are now ready to exchange information."
msgstr "现在， `A` 和 `B` 都准备好交换信息了。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:650
#, fuzzy, no-wrap
msgid "FreeBSD Host Access Points"
msgstr "FreeBSD 主机访问点"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:654
#, fuzzy
msgid ""
"FreeBSD can act as an Access Point (AP) which eliminates the need to buy a "
"hardware AP or run an ad-hoc network.  This can be particularly useful when "
"a FreeBSD machine is acting as a gateway to another network such as the "
"Internet."
msgstr ""
"FreeBSD 可以充当访问点（ AP ），从而无需购买硬件 AP 或运行自组网。当 FreeBSD "
"机器充当网关连接到另一个网络（如互联网）时，这一点尤其有用。"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:656
#, fuzzy, no-wrap
msgid "Basic Settings"
msgstr "基本设置"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:660
#, fuzzy
msgid ""
"Before configuring a FreeBSD machine as an AP, the kernel must be configured"
" with the appropriate networking support for the wireless card as well as "
"the security protocols being used.  For more details, see <<network-"
"wireless-basic>>."
msgstr ""
"在将 FreeBSD 机器配置为 AP 之前，必须为无线网卡配置适当的网络支持和所使用的安全协议。有关更多详细信息，请参阅 <<network-"
"wireless-basic>> 。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:665
#, fuzzy
msgid ""
"The NDIS driver wrapper for Windows(R) drivers does not currently support AP"
" operation.  Only native FreeBSD wireless drivers support AP mode."
msgstr ""
"目前，用于 Windows(R) 驱动程序的 NDIS 驱动程序包装器不支持 AP 操作。只有原生的 FreeBSD 无线驱动程序支持 AP 模式。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:668
#, fuzzy
msgid ""
"Once wireless networking support is loaded, check if the wireless device "
"supports the host-based access point mode, also known as hostap mode:"
msgstr "一旦加载了无线网络支持，检查无线设备是否支持主机模式接入点模式，也称为 hostap 模式："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:675
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 list caps\n"
"drivercaps=6f85edc1<STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG>\n"
"cryptocaps=1f<WEP,TKIP,AES,AES_CCM,TKIPMIC>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:681
#, fuzzy
msgid ""
"This output displays the card's capabilities.  The `HOSTAP` word confirms "
"that this wireless card can act as an AP.  Various supported ciphers are "
"also listed: WEP, TKIP, and AES.  This information indicates which security "
"protocols can be used on the AP."
msgstr ""
"此输出显示了该卡的功能。 `HOSTAP` 一词确认了该无线网卡可以充当 AP 。还列出了各种支持的加密算法： WEP 、 TKIP 和 AES "
"。这些信息表明可以在 AP 上使用哪些安全协议。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:683
#, fuzzy
msgid ""
"The wireless device can only be put into hostap mode during the creation of "
"the network pseudo-device, so a previously created device must be destroyed "
"first:"
msgstr "在创建网络伪设备时，无线设备只能被设置为 hostap 模式，因此必须先销毁先前创建的设备："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:687
#, no-wrap
msgid "# ifconfig wlan0 destroy\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:690
#, fuzzy
msgid ""
"then regenerated with the correct option before setting the other "
"parameters:"
msgstr "在设置其他参数之前，使用正确的选项重新生成。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:695
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode hostap\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:698
#, fuzzy
msgid ""
"Use man:ifconfig[8] again to see the status of the [.filename]#wlan0# "
"interface:"
msgstr "再次使用 man:ifconfig[8] 命令查看 wlan0 接口的状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:710
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst dtimperiod 1 -dfs\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:713
#, fuzzy
msgid ""
"The `hostap` parameter indicates the interface is running in the host-based "
"access point mode."
msgstr "`hostap` 参数表示接口正在以基于主机的访问点模式运行。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:715
#, fuzzy
msgid ""
"The interface configuration can be done automatically at boot time by adding"
" the following lines to [.filename]#/etc/rc.conf#:"
msgstr "可以通过在 [.filename]#/etc/rc.conf# 文件中添加以下行来在启动时自动进行接口配置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:721
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"create_args_wlan0=\"wlanmode hostap\"\n"
"ifconfig_wlan0=\"inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1\"\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:723
#, fuzzy, no-wrap
msgid "Host-based Access Point Without Authentication or Encryption"
msgstr "无身份验证或加密的基于主机的接入点"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:727
#, fuzzy
msgid ""
"Although it is not recommended to run an AP without any authentication or "
"encryption, this is a simple way to check if the AP is working.  This "
"configuration is also important for debugging client issues."
msgstr "虽然不建议在没有任何身份验证或加密的情况下运行 AP ，但这是检查 AP 是否工作的简单方法。这种配置对于调试客户端问题也很重要。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:729
#, fuzzy
msgid ""
"Once the AP is configured, initiate a scan from another wireless machine to "
"find the AP:"
msgstr "一旦配置了 AP ，从另一台无线机器上发起扫描以找到 AP ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:736
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up scan\n"
"SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:739
#, fuzzy
msgid "The client machine found the AP and can be associated with it:"
msgstr "客户端机器找到了 AP 并且可以与其关联："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:753
#, no-wrap
msgid ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g\n"
"\t  status: associated\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7\n"
"\t  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7\n"
"\t  roam:rate 5 protmode CTS wme burst\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:756
#, fuzzy, no-wrap
msgid "WPA2 Host-based Access Point"
msgstr "WPA2 基于主机的接入点"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:760
#, fuzzy
msgid ""
"This section focuses on setting up a FreeBSD access point using the WPA2 "
"security protocol.  More details regarding WPA and the configuration of WPA-"
"based wireless clients can be found in <<network-wireless-wpa>>."
msgstr ""
"本节重点介绍使用 WPA2 安全协议设置 FreeBSD 访问点。有关 WPA 和基于 WPA 的无线客户端配置的更多详细信息，请参阅 "
"<<network-wireless-wpa>> 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:762
#, fuzzy
msgid ""
"The man:hostapd[8] daemon is used to deal with client authentication and key"
" management on the WPA2-enabled AP."
msgstr "hostapd[8] 守护进程用于处理 WPA2 启用的访问点上的客户端身份验证和密钥管理。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:765
#, fuzzy
msgid ""
"The following configuration operations are performed on the FreeBSD machine "
"acting as the AP.  Once the AP is correctly working, man:hostapd[8] can be "
"automatically started at boot with this line in [.filename]#/etc/rc.conf#:"
msgstr ""
"在充当 AP 的 FreeBSD 机器上执行以下配置操作。一旦 AP 正确工作，可以在启动时通过在 `/etc/rc.conf` "
"文件中添加以下行来自动启动 `man:hostapd[8]` ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:769
#, no-wrap
msgid "hostapd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:772
#, fuzzy
msgid ""
"Before trying to configure man:hostapd[8], first configure the basic "
"settings introduced in <<network-wireless-ap-basic>>."
msgstr "在尝试配置 man:hostapd[8] 之前，请先配置 <<network-wireless-ap-basic>> 中介绍的基本设置。"

#. type: Title =====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:773
#, fuzzy, no-wrap
msgid "WPA2-PSK"
msgstr "WPA2-PSK 是一种 Wi-Fi 网络安全协议，它使用预共享密钥（ PSK ）来进行身份验证和加密。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:776
#, fuzzy
msgid ""
"WPA2-PSK is intended for small networks where the use of a backend "
"authentication server is not possible or desired."
msgstr "WPA2-PSK 适用于无法或不希望使用后端认证服务器的小型网络。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:778
#, fuzzy
msgid "The configuration is done in [.filename]#/etc/hostapd.conf#:"
msgstr "配置是在 [/etc/hostapd.conf] 中完成的："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:790
#, no-wrap
msgid ""
"interface=wlan0                  <.>\n"
"debug=1                          <.>\n"
"ctrl_interface=/var/run/hostapd  <.>\n"
"ctrl_interface_group=wheel       <.>\n"
"ssid=freebsdap                   <.>\n"
"wpa=2                            <.>\n"
"wpa_passphrase=freebsdmall       <.>\n"
"wpa_key_mgmt=WPA-PSK             <.>\n"
"wpa_pairwise=CCMP                <.>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:801
#, fuzzy
msgid ""
"<.> Wireless interface used for the access point.  <.> Level of verbosity "
"used during the execution of man:hostapd[8]. A value of `1` represents the "
"minimal level.  <.> Pathname of the directory used by man:hostapd[8] to "
"store domain socket files for communication with external programs such as "
"man:hostapd_cli[8]. The default value is used in this example.  <.> The "
"group allowed to access the control interface files.  <.> The wireless "
"network name, or SSID, that will appear in wireless scans.  <.> Enable WPA "
"and specify which WPA authentication protocol will be required. A value of "
"`2` configures the AP for WPA2 and is recommended. Set to `1` only if the "
"obsolete WPA is required.  <.> ASCII passphrase for WPA authentication.  <.>"
" The key management protocol to use. This example sets WPA-PSK.  <.> "
"Encryption algorithms accepted by the access point. In this example, only "
"the CCMP (AES) cipher is accepted. CCMP is an alternative to TKIP and is "
"strongly preferred when possible. TKIP should be allowed only when there are"
" stations incapable of using CCMP."
msgstr ""
"<.> 用于访问点的无线接口。\n"
" <.> 在执行 man:hostapd[8] 期间使用的详细程度。值为 `1` 表示最低级别。\n"
" <.> man:hostapd[8] 用于存储与外部程序（如 man:hostapd_cli[8] ）通信的域套接字文件的路径名。在此示例中使用默认值。\n"
" <.> 允许访问控制接口文件的组。\n"
" <.> 将出现在无线扫描中的无线网络名称或 SSID 。\n"
" <.> 启用 WPA 并指定所需的 WPA 身份验证协议。值为 `2` 配置 AP 为 WPA2 ，推荐使用。仅在需要过时的 WPA 时设置为 `1` 。\n"
" <.> 用于 WPA 身份验证的 ASCII 密码。\n"
" <.> 要使用的密钥管理协议。此示例设置为 WPA-PSK 。\n"
" <.> 访问点接受的加密算法。在此示例中，仅接受 CCMP （ AES ）密码。 CCMP 是 TKIP 的替代方案，在可能的情况下强烈推荐使用。仅当有无法使用 CCMP 的设备时才应允许使用 TKIP 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:803
#, fuzzy
msgid "The next step is to start man:hostapd[8]:"
msgstr "下一步是启动 man:hostapd[8] ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:807
#, no-wrap
msgid "# service hostapd forcestart\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:824
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"wlan0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\tether 04:f0:21:16:8e:10\n"
"\tinet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9\n"
"\tnd6 options=21<PERFORMNUD,AUTO_LINKLOCAL>\n"
"\tmedia: IEEE 802.11 Wireless Ethernet autoselect mode 11na <hostap>\n"
"\tstatus: running\n"
"\tssid No5ignal channel 36 (5180 MHz 11a ht/40+) bssid 04:f0:21:16:8e:10\n"
"\tcountry US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2\n"
"\tAES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6\n"
"\tscanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst\n"
"\tdtimperiod 1 -dfs\n"
"\tgroups: wlan\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:829
#, fuzzy
msgid ""
"Once the AP is running, the clients can associate with it.  See <<network-"
"wireless-wpa>> for more details.  It is possible to see the stations "
"associated with the AP using `ifconfig _wlan0_ list sta`."
msgstr ""
"一旦 AP 运行起来，客户端就可以与其关联。更多详细信息请参见 <<network-wireless-wpa>> 。可以使用 `ifconfig "
"_wlan0_ list sta` 命令查看与 AP 关联的设备。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:831
#, fuzzy, no-wrap
msgid "USB Tethering"
msgstr "USB 网络共享"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:835
#, fuzzy
msgid ""
"Many cellphones provide the option to share their data connection over USB "
"(often called \"tethering\").  This feature uses one of RNDIS, CDC, or a "
"custom Apple(R) iPhone(R)/iPad(R) protocol."
msgstr ""
"许多手机提供通过 USB 共享数据连接的选项（通常称为“网络共享”）。此功能使用 RNDIS 、 CDC 或自定义的 Apple(R) "
"iPhone(R)/iPad(R) 协议之一。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:837
#, fuzzy
msgid "Android(TM) devices generally use the man:urndis[4] driver."
msgstr "Android(TM) 设备通常使用 man:urndis[4] 驱动程序。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:838
#, fuzzy
msgid "Apple(R) devices use the man:ipheth[4] driver."
msgstr "Apple(R) 设备使用 man:ipheth[4] 驱动程序。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:839
#, fuzzy
msgid "Older devices will often use the man:cdce[4] driver."
msgstr "较旧的设备通常使用 man:cdce[4] 驱动程序。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:841
#, fuzzy
msgid ""
"Before attaching a device, load the appropriate driver into the kernel:"
msgstr "在连接设备之前，将适当的驱动程序加载到内核中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:847
#, no-wrap
msgid ""
"# kldload if_urndis\n"
"# kldload if_cdce\n"
"# kldload if_ipheth\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:851
#, fuzzy
msgid ""
"Once the device is attached ``ue``_0_ will be available for use like a "
"normal network device.  Be sure that the \"USB tethering\" option is enabled"
" on the device."
msgstr "一旦设备连接上， ``ue``_0_ 将可用于像普通网络设备一样使用。请确保设备上已启用“ USB 网络共享”选项。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:853
#, fuzzy
msgid ""
"To make this change permanent and load the driver as a module at boot time, "
"place the appropriate line of the following in "
"[.filename]#/boot/loader.conf#:"
msgstr ""
"要使此更改永久生效并在启动时将驱动程序作为模块加载，将以下适当的行放置在 [.filename]#/boot/loader.conf# 中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:859
#, no-wrap
msgid ""
"if_urndis_load=\"YES\"\n"
"if_cdce_load=\"YES\"\n"
"if_ipheth_load=\"YES\"\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:862
#, fuzzy, no-wrap
msgid "Bluetooth"
msgstr "蓝牙"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:867
#, fuzzy
msgid ""
"Bluetooth is a wireless technology for creating personal networks operating "
"in the 2.4 GHz unlicensed band, with a range of 10 meters.  Networks are "
"usually formed ad-hoc from portable devices such as cellular phones, "
"handhelds, and laptops.  Unlike Wi-Fi wireless technology, Bluetooth offers "
"higher level service profiles, such as FTP-like file servers, file pushing, "
"voice transport, serial line emulation, and more."
msgstr ""
"蓝牙是一种无线技术，用于在 2.4 GHz 无线频段中创建个人网络，其范围为 10 "
"米。网络通常是由便携设备（如手机、手持设备和笔记本电脑）自动形成的。与 Wi-Fi 无线技术不同，蓝牙提供更高级的服务配置文件，例如类似 FTP "
"的文件服务器、文件推送、语音传输、串行线仿真等。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:870
#, fuzzy
msgid ""
"This section describes the use of a USB Bluetooth dongle on a FreeBSD "
"system.  It then describes the various Bluetooth protocols and utilities."
msgstr "本节描述了在 FreeBSD 系统上使用 USB 蓝牙适配器的方法。然后，它介绍了各种蓝牙协议和实用工具。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:871
#, fuzzy, no-wrap
msgid "Loading Bluetooth Support"
msgstr "加载蓝牙支持"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:878
#, fuzzy
msgid ""
"The Bluetooth stack in FreeBSD is implemented using the man:netgraph[4] "
"framework.  A broad variety of Bluetooth USB dongles is supported by "
"man:ng_ubt[4].  Broadcom BCM2033 based Bluetooth devices are supported by "
"the man:ubtbcmfw[4] and man:ng_ubt[4] drivers.  The 3Com Bluetooth PC Card "
"3CRWB60-A is supported by the man:ng_bt3c[4] driver.  Serial and UART based "
"Bluetooth devices are supported by man:sio[4], man:ng_h4[4], and "
"man:hcseriald[8]."
msgstr ""
"在 FreeBSD 中，蓝牙堆栈是使用 man:netgraph[4] 框架实现的。 man:ng_ubt[4] 支持各种各样的蓝牙 USB "
"适配器。基于 Broadcom BCM2033 的蓝牙设备由 man:ubtbcmfw[4] 和 man:ng_ubt[4] 驱动程序支持。 3Com "
"蓝牙 PC 卡 3CRWB60-A 由 man:ng_bt3c[4] 驱动程序支持。基于串口和 UART 的蓝牙设备由 man:sio[4] 、 "
"man:ng_h4[4] 和 man:hcseriald[8] 驱动程序支持。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:881
#, fuzzy
msgid ""
"Before attaching a device, determine which of the above drivers it uses, "
"then load the driver.  For example, if the device uses the man:ng_ubt[4] "
"driver:"
msgstr "在连接设备之前，确定设备使用的是上述驱动程序中的哪一个，然后加载该驱动程序。例如，如果设备使用的是 man:ng_ubt[4] 驱动程序："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:885
#, no-wrap
msgid "# kldload ng_ubt\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:888
#, fuzzy
msgid ""
"If the Bluetooth device will be attached to the system during system "
"startup, the system can be configured to load the module at boot time by "
"adding the driver to [.filename]#/boot/loader.conf#:"
msgstr "如果在系统启动期间将蓝牙设备连接到系统上，可以通过将驱动程序添加到 [/boot/loader.conf] 来配置系统在引导时加载模块。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:892
#, no-wrap
msgid "ng_ubt_load=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:896
#, fuzzy
msgid ""
"Once the driver is loaded, plug in the USB dongle.  If the driver load was "
"successful, output similar to the following should appear on the console and"
" in [.filename]#/var/log/messages#:"
msgstr ""
"一旦驱动程序加载完成，插入 USB dongle 。如果驱动程序加载成功，类似以下内容的输出将出现在控制台和 [/var/log/messages] "
"文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:903
#, no-wrap
msgid ""
"ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2\n"
"ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2\n"
"ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,\n"
"      wMaxPacketSize=49, nframes=6, buffer size=294\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:908
#, fuzzy
msgid ""
"To start and stop the Bluetooth stack, use its startup script. It is a good "
"idea to stop the stack before unplugging the device.  Starting the bluetooth"
" stack might require man:hcsecd[8] to be started.  When starting the stack, "
"the output should be similar to the following:"
msgstr ""
"要启动和停止蓝牙堆栈，请使用其启动脚本。在拔下设备之前停止堆栈是一个好主意。启动蓝牙堆栈可能需要启动 man:hcsecd[8] "
"。启动堆栈时，输出应类似于以下内容："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:923
#, no-wrap
msgid ""
"# service bluetooth start ubt0\n"
"BD_ADDR: 00:02:72:00:d4:1a\n"
"Features: 0xff 0xff 0xf 00 00 00 00 00\n"
"<3-Slot> <5-Slot> <Encryption> <Slot offset>\n"
"<Timing accuracy> <Switch> <Hold mode> <Sniff mode>\n"
"<Park mode> <RSSI> <Channel quality> <SCO link>\n"
"<HV2 packets> <HV3 packets> <u-law log> <A-law log> <CVSD>\n"
"<Paging scheme> <Power control> <Transparent SCO data>\n"
"Max. ACL packet size: 192 bytes\n"
"Number of ACL packets: 8\n"
"Max. SCO packet size: 64 bytes\n"
"Number of SCO packets: 8\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:925
#, fuzzy, no-wrap
msgid "Finding Other Bluetooth Devices"
msgstr "查找其他蓝牙设备"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:930
#, fuzzy
msgid ""
"The Host Controller Interface (HCI) provides a uniform method for accessing "
"Bluetooth baseband capabilities.  In FreeBSD, a netgraph HCI node is created"
" for each Bluetooth device.  For more details, refer to man:ng_hci[4]."
msgstr ""
"主机控制器接口（ HCI ）提供了一种统一的方法来访问蓝牙基带功能。在 FreeBSD 中，为每个蓝牙设备创建一个 netgraph HCI "
"节点。有关更多详细信息，请参阅 man:ng_hci[4] 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:937
#, fuzzy
msgid ""
"One of the most common tasks is discovery of Bluetooth devices within RF "
"proximity.  This operation is called _inquiry_.  Inquiry and other HCI "
"related operations are done using man:hccontrol[8].  The example below shows"
" how to find out which Bluetooth devices are in range.  The list of devices "
"should be displayed in a few seconds.  Note that a remote device will only "
"answer the inquiry if it is set to _discoverable_ mode."
msgstr ""
"发现 RF 附近的蓝牙设备是最常见的任务之一。这个操作被称为“查询”。查询和其他 HCI 相关的操作是使用 man:hccontrol[8] "
"完成的。下面的示例显示了如何查找在范围内的蓝牙设备。设备列表应该在几秒钟内显示出来。请注意，只有在远程设备设置为“可发现”模式时，它才会回答查询。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:950
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci inquiry\n"
"Inquiry result, num_responses=1\n"
"Inquiry result #0\n"
"       BD_ADDR: 00:80:37:29:19:a4\n"
"       Page Scan Rep. Mode: 0x1\n"
"       Page Scan Period Mode: 00\n"
"       Page Scan Mode: 00\n"
"       Class: 52:02:04\n"
"       Clock offset: 0x78ef\n"
"Inquiry complete. Status: No error [00]\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:956
#, fuzzy
msgid ""
"The `BD_ADDR` is the unique address of a Bluetooth device, similar to the "
"MAC address of a network card.  This address is needed for further "
"communication with a device and it is possible to assign a human readable "
"name to a `BD_ADDR`.  Information regarding the known Bluetooth hosts is "
"contained in [.filename]#/etc/bluetooth/hosts#.  The following example shows"
" how to obtain the human readable name that was assigned to the remote "
"device:"
msgstr ""
"`BD_ADDR` 是蓝牙设备的唯一地址，类似于网络卡的 MAC 地址。这个地址在与设备进行进一步通信时是必需的，并且可以为 `BD_ADDR` "
"分配一个可读的名称。已知的蓝牙主机的信息包含在 [/etc/bluetooth/hosts] 文件中。以下示例显示了如何获取分配给远程设备的可读名称："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:962
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4\n"
"BD_ADDR: 00:80:37:29:19:a4\n"
"Name: Pav's T39\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:966
#, fuzzy
msgid ""
"If an inquiry is performed on a remote Bluetooth device, it will find the "
"computer as \"your.host.name (ubt0)\".  The name assigned to the local "
"device can be changed at any time."
msgstr "如果对远程蓝牙设备进行查询，将会以\"your.host.name (ubt0)\"的形式找到计算机。本地设备的名称可以随时更改。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:969
#, fuzzy
msgid ""
"Remote devices can be assigned aliases in [.filename]#/etc/bluetooth/hosts#."
"  More information about [.filename]#/etc/bluetooth/hosts# file might be "
"found in man:bluetooth.hosts[5]."
msgstr ""
"远程设备可以在 [/etc/bluetooth/hosts](/etc/bluetooth/hosts) 中分配别名。有关 "
"[/etc/bluetooth/hosts](/etc/bluetooth/hosts) 文件的更多信息可以在 "
"man:bluetooth.hosts[5] 中找到。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:972
#, fuzzy
msgid ""
"The Bluetooth system provides a point-to-point connection between two "
"Bluetooth units, or a point-to-multipoint connection which is shared among "
"several Bluetooth devices.  The following example shows how to create a "
"connection to a remote device:"
msgstr "蓝牙系统提供了两个蓝牙设备之间的点对点连接，或者在多个蓝牙设备之间共享的点对多点连接。以下示例展示了如何创建与远程设备的连接："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:976
#, no-wrap
msgid "% hccontrol -n ubt0hci create_connection BT_ADDR\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:979
#, fuzzy
msgid ""
"`create_connection` accepts `BT_ADDR` as well as host aliases in "
"[.filename]#/etc/bluetooth/hosts#."
msgstr ""
"`create_connection` 函数接受 `BT_ADDR` 和主机别名作为参数，在 `/etc/bluetooth/hosts` 文件中定义。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:981
#, fuzzy
msgid ""
"The following example shows how to obtain the list of active baseband "
"connections for the local device:"
msgstr "以下示例显示了如何获取本地设备的活动基带连接列表："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:987
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci read_connection_list\n"
"Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State\n"
"00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:991
#, fuzzy
msgid ""
"A _connection handle_ is useful when termination of the baseband connection "
"is required, though it is normally not required to do this by hand.  The "
"stack will automatically terminate inactive baseband connections."
msgstr "当需要终止基带连接时，_连接句柄_非常有用，尽管通常不需要手动执行此操作。堆栈会自动终止不活动的基带连接。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:997
#, no-wrap
msgid ""
"# hccontrol -n ubt0hci disconnect 41\n"
"Connection handle: 41\n"
"Reason: Connection terminated by local host [0x16]\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1001
#, fuzzy
msgid ""
"Type `hccontrol help` for a complete listing of available HCI commands.  "
"Most of the HCI commands do not require superuser privileges."
msgstr "输入 `hccontrol help` 以获取可用 HCI 命令的完整列表。大多数 HCI 命令不需要超级用户权限。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1002
#, fuzzy, no-wrap
msgid "Device Pairing"
msgstr "设备配对"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1013
#, fuzzy
msgid ""
"By default, Bluetooth communication is not authenticated, and any device can"
" talk to any other device.  A Bluetooth device, such as a cellular phone, "
"may choose to require authentication to provide a particular service.  "
"Bluetooth authentication is normally done with a _PIN code_, an ASCII string"
" up to 16 characters in length.  The user is required to enter the same PIN "
"code on both devices.  Once the user has entered the PIN code, both devices "
"will generate a _link key_.  After that, the link key can be stored either "
"in the devices or in a persistent storage.  Next time, both devices will use"
" the previously generated link key.  This procedure is called _pairing_.  "
"Note that if the link key is lost by either device, the pairing must be "
"repeated."
msgstr ""
"默认情况下，蓝牙通信不需要进行身份验证，任何设备都可以与其他设备进行通信。蓝牙设备（如手机）可以选择要求进行身份验证以提供特定服务。蓝牙身份验证通常使用一个最长为"
" 16 个字符的 ASCII 字符串作为_PIN 码_。用户需要在两台设备上输入相同的 PIN 码。用户输入 PIN "
"码后，两台设备将生成一个_链接密钥_。之后，链接密钥可以存储在设备或持久存储中。下次，两台设备将使用先前生成的链接密钥。这个过程称为_配对_。请注意，如果链接密钥被任一设备丢失，配对必须重新进行。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1017
#, fuzzy
msgid ""
"The man:hcsecd[8] daemon is responsible for handling Bluetooth "
"authentication requests.  The default configuration file is "
"[.filename]#/etc/bluetooth/hcsecd.conf#.  An example section for a cellular "
"phone with the PIN code set to `1234` is shown below:"
msgstr ""
"man:hcsecd[8] 守护进程负责处理蓝牙认证请求。默认的配置文件是 /etc/bluetooth/hcsecd.conf "
"。下面是一个示例部分，其中手机的 PIN 码设置为 `1234` ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1026
#, no-wrap
msgid ""
"device {\n"
"        bdaddr  00:80:37:29:19:a4;\n"
"        name    \"Pav's T39\";\n"
"        key     nokey;\n"
"        pin     \"1234\";\n"
"      }\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1036
#, fuzzy
msgid ""
"The only limitation on PIN codes is length.  Some devices, such as Bluetooth"
" headsets, may have a fixed PIN code built in.  The `-d` switch forces "
"man:hcsecd[8] to stay in the foreground, so it is easy to see what is "
"happening.  Set the remote device to receive pairing and initiate the "
"Bluetooth connection to the remote device.  The remote device should "
"indicate that pairing was accepted and request the PIN code.  Enter the same"
" PIN code listed in [.filename]#hcsecd.conf#.  Now the computer and the "
"remote device are paired.  Alternatively, pairing can be initiated on the "
"remote device."
msgstr ""
"对于 PIN 码，唯一的限制是长度。一些设备，如蓝牙耳机，可能有一个固定的内置 PIN 码。 `-d` 开关强制 man:hcsecd[8] "
"保持在前台，以便可以清楚地看到发生了什么。将远程设备设置为接收配对并启动与远程设备的蓝牙连接。远程设备应指示接受配对并请求 PIN 码。输入与 "
"[.filename]#hcsecd.conf# 中列出的相同的 PIN 码。现在计算机和远程设备已配对。或者，可以在远程设备上启动配对。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1038
#, fuzzy
msgid ""
"The following line can be added to [.filename]#/etc/rc.conf# to configure "
"man:hcsecd[8] to start automatically on system start:"
msgstr "可以将以下行添加到 [.filename]#/etc/rc.conf# 中，以配置 man:hcsecd[8] 在系统启动时自动启动："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1042
#, no-wrap
msgid "hcsecd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1045
#, fuzzy
msgid "The following is a sample of the man:hcsecd[8] daemon output:"
msgstr "以下是 man:hcsecd[8] 守护进程输出的示例："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1054
#, no-wrap
msgid ""
"hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist\n"
"hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists\n"
"hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1056
#, fuzzy, no-wrap
msgid "Network Access with PPP Profiles"
msgstr "使用 PPP 配置文件的网络访问"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1060
#, fuzzy
msgid ""
"A Dial-Up Networking (DUN) profile can be used to configure a cellular phone"
" as a wireless modem for connecting to a dial-up Internet access server.  It"
" can also be used to configure a computer to receive data calls from a "
"cellular phone."
msgstr "可以使用拨号网络（ DUN ）配置文件将手机配置为无线调制解调器，以连接到拨号上网服务器。它还可以用于配置计算机接收来自手机的数据呼叫。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1063
#, fuzzy
msgid ""
"Network access with a PPP profile can be used to provide LAN access for a "
"single Bluetooth device or multiple Bluetooth devices.  It can also provide "
"PC to PC connection using PPP networking over serial cable emulation."
msgstr ""
"使用 PPP 配置文件进行网络访问可以为单个蓝牙设备或多个蓝牙设备提供局域网访问。它还可以使用 PPP 网络通过串行电缆仿真实现 PC 与 PC "
"之间的连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1067
#, fuzzy
msgid ""
"In FreeBSD, these profiles are implemented with man:ppp[8] and the "
"man:rfcomm_pppd[8] wrapper which converts a Bluetooth connection into "
"something PPP can use.  Before a profile can be used, a new PPP label must "
"be created in [.filename]#/etc/ppp/ppp.conf#.  Consult man:rfcomm_pppd[8] "
"for examples."
msgstr ""
"在 FreeBSD 中，这些配置文件是通过 man:ppp[8] 和 man:rfcomm_pppd[8] 包装器实现的，该包装器将蓝牙连接转换为 "
"PPP 可以使用的内容。在使用配置文件之前，必须在 [.filename]#/etc/ppp/ppp.conf# 中创建一个新的 PPP 标签。请参考 "
"man:rfcomm_pppd[8] 中的示例。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1069
#, fuzzy
msgid ""
"In this example, man:rfcomm_pppd[8] is used to open a connection to a remote"
" device with a `BD_ADDR` of `00:80:37:29:19:a4` on a DUNRFCOMM channel:"
msgstr ""
"在这个例子中，使用 man:rfcomm_pppd[8] 来打开与远程设备的连接，其 `BD_ADDR` 为 `00:80:37:29:19:a4` "
"，在一个 DUNRFCOMM 通道上。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1073
#, no-wrap
msgid "# rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1078
#, fuzzy
msgid ""
"The actual channel number will be obtained from the remote device using the "
"SDP protocol.  It is possible to specify the RFCOMM channel by hand, and in "
"this case man:rfcomm_pppd[8] will not perform the SDP query.  Use "
"man:sdpcontrol[8] to find out the RFCOMM channel on the remote device."
msgstr ""
"实际的通道号将通过使用 SDP 协议从远程设备获取。可以手动指定 RFCOMM 通道，在这种情况下， man:rfcomm_pppd[8] 将不执行 "
"SDP 查询。使用 man:sdpcontrol[8] 来查找远程设备上的 RFCOMM 通道。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1084
#, fuzzy
msgid ""
"In order to provide network access with the PPPLAN service, man:sdpd[8] must"
" be running and a new entry for LAN clients must be created in "
"[.filename]#/etc/ppp/ppp.conf#.  Consult man:rfcomm_pppd[8] for examples.  "
"Finally, start the RFCOMMPPP server on a valid RFCOMM channel number.  The "
"RFCOMMPPP server will automatically register the Bluetooth LAN service with "
"the local SDP daemon.  The example below shows how to start the RFCOMMPPP "
"server."
msgstr ""
"为了使用 PPPLAN 服务提供网络访问，必须运行 man:sdpd[8] 并在 [.filename]#/etc/ppp/ppp.conf# "
"中创建一个新的 LAN 客户端条目。请参考 man:rfcomm_pppd[8] 中的示例。最后，在有效的 RFCOMM 通道号上启动 "
"RFCOMMPPP 服务器。 RFCOMMPPP 服务器将自动在本地 SDP 守护进程中注册蓝牙 LAN 服务。下面的示例显示了如何启动 "
"RFCOMMPPP 服务器。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1088
#, no-wrap
msgid "# rfcomm_pppd -s -C 7 -l rfcomm-server\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1090
#, fuzzy, no-wrap
msgid "Bluetooth Protocols"
msgstr "蓝牙协议"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1093
#, fuzzy
msgid ""
"This section provides an overview of the various Bluetooth protocols, their "
"function, and associated utilities."
msgstr "本节提供了各种蓝牙协议的概述，包括它们的功能和相关工具。"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1094
#, fuzzy, no-wrap
msgid "Logical Link Control and Adaptation Protocol (L2CAP)"
msgstr "逻辑链路控制和适配协议（ L2CAP ）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1098
#, fuzzy
msgid ""
"The Logical Link Control and Adaptation Protocol (L2CAP) provides "
"connection-oriented and connectionless data services to upper layer "
"protocols.  L2CAP permits higher level protocols and applications to "
"transmit and receive L2CAP data packets up to 64 kilobytes in length."
msgstr ""
"逻辑链路控制和适配协议（ L2CAP ）为上层协议提供面向连接和无连接的数据服务。 L2CAP 允许更高级的协议和应用程序传输和接收最长为 64 "
"千字节的 L2CAP 数据包。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1104
#, fuzzy
msgid ""
"L2CAP is based around the concept of _channels_.  A channel is a logical "
"connection on top of a baseband connection, where each channel is bound to a"
" single protocol in a many-to-one fashion.  Multiple channels can be bound "
"to the same protocol, but a channel cannot be bound to multiple protocols.  "
"Each L2CAP packet received on a channel is directed to the appropriate "
"higher level protocol.  Multiple channels can share the same baseband "
"connection."
msgstr ""
"L2CAP "
"基于“通道”概念。通道是在基带连接之上的逻辑连接，每个通道以多对一的方式绑定到单个协议上。多个通道可以绑定到同一个协议，但一个通道不能绑定到多个协议。在通道上接收到的每个"
" L2CAP 数据包都会被传递给相应的高层协议。多个通道可以共享同一个基带连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1109
#, fuzzy
msgid ""
"In FreeBSD, a netgraph L2CAP node is created for each Bluetooth device.  "
"This node is normally connected to the downstream Bluetooth HCI node and "
"upstream Bluetooth socket nodes.  The default name for the L2CAP node is "
"\"devicel2cap\".  For more details refer to man:ng_l2cap[4]."
msgstr ""
"在 FreeBSD 中，为每个蓝牙设备创建一个 netgraph L2CAP 节点。该节点通常连接到下游的蓝牙 HCI 节点和上游的蓝牙套接字节点。 "
"L2CAP 节点的默认名称为\"devicel2cap\"。有关更多详细信息，请参阅 man:ng_l2cap[4] 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1112
#, fuzzy
msgid ""
"A useful command is man:l2ping[8], which can be used to ping other devices."
"  Some Bluetooth implementations might not return all of the data sent to "
"them, so `0 bytes` in the following example is normal."
msgstr ""
"一个有用的命令是 man:l2ping[8] ，它可以用来 ping 其他设备。一些蓝牙实现可能不会返回所有发送给它们的数据，所以在下面的示例中 `0 "
"bytes` 是正常的。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1120
#, no-wrap
msgid ""
"# l2ping -a 00:80:37:29:19:a4\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1124
#, fuzzy
msgid ""
"The man:l2control[8] utility is used to perform various operations on L2CAP "
"nodes.  This example shows how to obtain the list of logical connections "
"(channels) and the list of baseband connections for the local device:"
msgstr ""
"man:l2control[8] 实用程序用于对 L2CAP 节点执行各种操作。此示例演示了如何获取本地设备的逻辑连接（通道）列表和基带连接列表。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1135
#, no-wrap
msgid ""
"% l2control -a 00:02:72:00:d4:1a read_channel_list\n"
"L2CAP channels:\n"
"Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State\n"
"00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN\n"
"% l2control -a 00:02:72:00:d4:1a read_connection_list\n"
"L2CAP connections:\n"
"Remote BD_ADDR    Handle Flags Pending State\n"
"00:07:e0:00:0b:ca     41 O           0 OPEN\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1140
#, fuzzy
msgid ""
"Another diagnostic tool is man:btsockstat[1].  It is similar to "
"man:netstat[1], but for Bluetooth network-related data structures.  The "
"example below shows the same logical connection as man:l2control[8] above."
msgstr ""
"另一个诊断工具是 man:btsockstat[1] 。它类似于 man:netstat[1] ，但用于蓝牙网络相关的数据结构。下面的示例显示了与上面的"
" man:l2control[8] 相同的逻辑连接。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1153
#, no-wrap
msgid ""
"% btsockstat\n"
"Active L2CAP sockets\n"
"PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State\n"
"c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN\n"
"Active RFCOMM sessions\n"
"L2PCB    PCB      Flag MTU   Out-Q DLCs State\n"
"c2afe900 c2b53380 1    127   0     Yes  OPEN\n"
"Active RFCOMM sockets\n"
"PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State\n"
"c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1155
#, fuzzy, no-wrap
msgid "Radio Frequency Communication (RFCOMM)"
msgstr "无线电频率通信（ RFCOMM ）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1160
#, fuzzy
msgid ""
"The RFCOMM protocol provides emulation of serial ports over the L2CAP "
"protocol.  RFCOMM is a simple transport protocol, with additional provisions"
" for emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports.  It "
"supports up to 60 simultaneous connections (RFCOMM channels) between two "
"Bluetooth devices."
msgstr ""
"RFCOMM 协议通过 L2CAP 协议提供串口的仿真。 RFCOMM 是一个简单的传输协议，还提供了模拟 RS-232 （ EIATIA-232-E "
"）串口的 9 个电路的附加功能。它支持两个蓝牙设备之间的最多 60 个同时连接（ RFCOMM 通道）。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1164
#, fuzzy
msgid ""
"For the purposes of RFCOMM, a complete communication path involves two "
"applications running on the communication endpoints with a communication "
"segment between them.  RFCOMM is intended to cover applications that make "
"use of the serial ports of the devices in which they reside.  The "
"communication segment is a direct connect Bluetooth link from one device to "
"another."
msgstr ""
"对于 RFCOMM 而言，一个完整的通信路径涉及到两个在通信端点上运行的应用程序，它们之间有一个通信段。 RFCOMM "
"旨在覆盖利用设备串口的应用程序。通信段是从一个设备直接连接到另一个设备的蓝牙链路。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1167
#, fuzzy
msgid ""
"RFCOMM is only concerned with the connection between the devices in the "
"direct connect case, or between the device and a modem in the network case."
"  RFCOMM can support other configurations, such as modules that communicate "
"via Bluetooth wireless technology on one side and provide a wired interface "
"on the other side."
msgstr ""
"RFCOMM 只关注直接连接情况下设备之间的连接，或者设备与网络情况下的调制解调器之间的连接。 RFCOMM "
"可以支持其他配置，例如通过蓝牙无线技术在一侧进行通信并在另一侧提供有线接口的模块。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1169
#, fuzzy
msgid "In FreeBSD, RFCOMM is implemented at the Bluetooth sockets layer."
msgstr "在 FreeBSD 中， RFCOMM 是在蓝牙套接字层实现的。"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1170
#, fuzzy, no-wrap
msgid "Service Discovery Protocol (SDP)"
msgstr "服务发现协议（ SDP ）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1174
#, fuzzy
msgid ""
"The Service Discovery Protocol (SDP) provides the means for client "
"applications to discover the existence of services provided by server "
"applications as well as the attributes of those services.  The attributes of"
" a service include the type or class of service offered and the mechanism or"
" protocol information needed to utilize the service."
msgstr ""
"服务发现协议（ SDP "
"）提供了客户端应用程序发现由服务器应用程序提供的服务的存在以及这些服务的属性的方法。服务的属性包括提供的服务类型或类别以及利用该服务所需的机制或协议信息。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1181
#, fuzzy
msgid ""
"SDP involves communication between a SDP server and a SDP client.  The "
"server maintains a list of service records that describe the characteristics"
" of services associated with the server.  Each service record contains "
"information about a single service.  A client may retrieve information from "
"a service record maintained by the SDP server by issuing a SDP request.  If "
"the client, or an application associated with the client, decides to use a "
"service, it must open a separate connection to the service provider in order"
" to utilize the service.  SDP provides a mechanism for discovering services "
"and their attributes, but it does not provide a mechanism for utilizing "
"those services."
msgstr ""
"SDP 涉及 SDP 服务器和 SDP "
"客户端之间的通信。服务器维护一个描述与服务器相关的服务特性的服务记录列表。每个服务记录包含有关单个服务的信息。客户端可以通过发出 SDP 请求从 SDP"
" 服务器维护的服务记录中检索信息。如果客户端或与客户端相关的应用程序决定使用某个服务，则必须打开与服务提供者的单独连接以利用该服务。 SDP "
"提供了一种发现服务及其属性的机制，但不提供利用这些服务的机制。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1185
#, fuzzy
msgid ""
"Normally, a SDP client searches for services based on some desired "
"characteristics of the services.  However, there are times when it is "
"desirable to discover which types of services are described by an SDP "
"server's service records without any prior information about the services.  "
"This process of looking for any offered services is called _browsing_."
msgstr ""
"通常， SDP 客户端根据服务的某些期望特征来搜索服务。然而，有时候希望在没有关于服务的任何先前信息的情况下，发现 SDP "
"服务器的服务记录描述了哪些类型的服务。这个寻找任何提供的服务的过程被称为“浏览”。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1188
#, fuzzy
msgid ""
"The Bluetooth SDP server, man:sdpd[8], and command line client, "
"man:sdpcontrol[8], are included in the standard FreeBSD installation.  The "
"following example shows how to perform a SDP browse query."
msgstr ""
"蓝牙 SDP 服务器（ man:sdpd[8] ）和命令行客户端（ man:sdpcontrol[8] ）已包含在标准的 FreeBSD "
"安装中。以下示例展示了如何执行 SDP 浏览查询。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1199
#, no-wrap
msgid ""
"% sdpcontrol -a 00:01:03:fc:6e:ec browse\n"
"Record Handle: 00000000\n"
"Service Class ID List:\n"
"        Service Discovery Server (0x1000)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"                Protocol specific parameter #1: u/int/uuid16 1\n"
"                Protocol specific parameter #2: u/int/uuid16 1\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1203
#, no-wrap
msgid ""
"Record Handle: 0x00000001\n"
"Service Class ID List:\n"
"        Browse Group Descriptor (0x1001)\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1213
#, no-wrap
msgid ""
"Record Handle: 0x00000002\n"
"Service Class ID List:\n"
"        LAN Access Using PPP (0x1102)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"        RFCOMM (0x0003)\n"
"                Protocol specific parameter #1: u/int8/bool 1\n"
"Bluetooth Profile Descriptor List:\n"
"        LAN Access Using PPP (0x1102) ver. 1.0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1220
#, fuzzy
msgid ""
"Note that each service has a list of attributes, such as the RFCOMM channel."
"  Depending on the service, the user might need to make note of some of the "
"attributes.  Some Bluetooth implementations do not support service browsing "
"and may return an empty list.  In this case, it is possible to search for "
"the specific service.  The example below shows how to search for the OBEX "
"Object Push (OPUSH) service:"
msgstr ""
"请注意，每个服务都有一系列属性，例如 RFCOMM "
"通道。根据服务的不同，用户可能需要注意其中一些属性。某些蓝牙实现不支持服务浏览，并可能返回一个空列表。在这种情况下，可以搜索特定的服务。下面的示例演示了如何搜索"
" OBEX 对象推送（ OPUSH ）服务："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1224
#, no-wrap
msgid "% sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1228
#, fuzzy
msgid ""
"Offering services on FreeBSD to Bluetooth clients is done with the "
"man:sdpd[8] server.  The following line can be added to "
"[.filename]#/etc/rc.conf#:"
msgstr ""
"在 FreeBSD 上为蓝牙客户端提供服务是通过 man:sdpd[8] 服务器完成的。可以将以下行添加到 "
"[.filename]#/etc/rc.conf# 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1232
#, no-wrap
msgid "sdpd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1235
#, fuzzy
msgid "Then the man:sdpd[8] daemon can be started with:"
msgstr "然后可以使用以下命令启动 man:sdpd[8] 守护进程："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1239
#, no-wrap
msgid "# service sdpd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1244
#, fuzzy
msgid ""
"The local server application that wants to provide a Bluetooth service to "
"remote clients will register the service with the local SDP daemon.  An "
"example of such an application is man:rfcomm_pppd[8].  Once started, it will"
" register the Bluetooth LAN service with the local SDP daemon."
msgstr ""
"希望为远程客户端提供蓝牙服务的本地服务器应用程序将在本地 SDP 守护进程中注册该服务。这样的应用程序示例是 man:rfcomm_pppd[8] "
"。一旦启动，它将在本地 SDP 守护进程中注册蓝牙局域网服务。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1246
#, fuzzy
msgid ""
"The list of services registered with the local SDP server can be obtained by"
" issuing a SDP browse query via the local control channel:"
msgstr "可以通过在本地控制通道上发出 SDP 浏览查询来获取注册到本地 SDP 服务器的服务列表。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1250
#, no-wrap
msgid "# sdpcontrol -l browse\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1252
#, fuzzy, no-wrap
msgid "OBEX Object Push (OPUSH)"
msgstr "OBEX 对象推送（ OPUSH ）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1256
#, fuzzy
msgid ""
"Object Exchange (OBEX) is a widely used protocol for simple file transfers "
"between mobile devices.  Its main use is in infrared communication, where it"
" is used for generic file transfers between notebooks or PDAs, and for "
"sending business cards or calendar entries between cellular phones and other"
" devices with Personal Information Manager (PIM) applications."
msgstr ""
"Object Exchange （ OBEX ）是一种广泛使用的协议，用于移动设备之间的简单文件传输。它主要用于红外通信，用于笔记本电脑或个人数字助理（"
" PDA ）之间的通用文件传输，以及在手机和其他具有个人信息管理（ PIM ）应用程序的设备之间发送名片或日历条目。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1258
#, fuzzy
msgid ""
"The OBEX server and client are implemented by obexapp, which can be "
"installed using the package:comms/obexapp[] package or port."
msgstr "OBEX 服务器和客户端是由 obexapp 实现的，可以使用 comms/obexapp[] 软件包或端口进行安装。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1266
#, fuzzy
msgid ""
"The OBEX client is used to push and/or pull objects from the OBEX server.  "
"An example object is a business card or an appointment.  The OBEX client can"
" obtain the RFCOMM channel number from the remote device via SDP.  This can "
"be done by specifying the service name instead of the RFCOMM channel number."
"  Supported service names are: `IrMC`, `FTRN`, and `OPUSH`.  It is also "
"possible to specify the RFCOMM channel as a number.  Below is an example of "
"an OBEX session where the device information object is pulled from the "
"cellular phone, and a new object, the business card, is pushed into the "
"phone's directory."
msgstr ""
"OBEX 客户端用于从 OBEX 服务器推送和 / 或拉取对象。一个示例对象可以是名片或约会。 OBEX 客户端可以通过 SDP 从远程设备获取 "
"RFCOMM 通道号。这可以通过指定服务名称而不是 RFCOMM 通道号来完成。支持的服务名称有： `IrMC` ， `FTRN` 和 `OPUSH` "
"。还可以将 RFCOMM 通道指定为数字。下面是一个 OBEX 会话的示例，其中从手机中提取设备信息对象，并将一个新对象，名片，推送到手机的目录中。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1276
#, no-wrap
msgid ""
"% obexapp -a 00:80:37:29:19:a4 -C IrMC\n"
"obex> get telecom/devinfo.txt devinfo-t39.txt\n"
"Success, response: OK, Success (0x20)\n"
"obex> put new.vcf\n"
"Success, response: OK, Success (0x20)\n"
"obex> di\n"
"Success, response: OK, Success (0x20)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1283
#, fuzzy
msgid ""
"In order to provide the OPUSH service, man:sdpd[8] must be running and a "
"root folder, where all incoming objects will be stored, must be created.  "
"The default path to the root folder is [.filename]#/var/spool/obex#.  "
"Finally, start the OBEX server on a valid RFCOMM channel number.  The OBEX "
"server will automatically register the OPUSH service with the local SDP "
"daemon.  The example below shows how to start the OBEX server."
msgstr ""
"为了提供 OPUSH 服务，必须运行 man:sdpd[8] 并创建一个根文件夹，用于存储所有传入的对象。根文件夹的默认路径是 "
"[/var/spool/obex] 。最后，在有效的 RFCOMM 通道号上启动 OBEX 服务器。 OBEX 服务器将自动在本地 SDP "
"守护进程中注册 OPUSH 服务。下面的示例显示了如何启动 OBEX 服务器。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1287
#, no-wrap
msgid "# obexapp -s -C 10\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1289
#, fuzzy, no-wrap
msgid "Serial Port Profile (SPP)"
msgstr "串口配置文件（ SPP ）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1293
#, fuzzy
msgid ""
"The Serial Port Profile (SPP) allows Bluetooth devices to perform serial "
"cable emulation.  This profile allows legacy applications to use Bluetooth "
"as a cable replacement, through a virtual serial port abstraction."
msgstr "串口配置文件（ SPP ）允许蓝牙设备执行串行电缆仿真。该配置文件允许传统应用程序通过虚拟串口抽象将蓝牙用作电缆替代品。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1298
#, fuzzy
msgid ""
"In FreeBSD, man:rfcomm_sppd[1] implements SPP and a pseudo tty is used as a "
"virtual serial port abstraction.  The example below shows how to connect to "
"a remote device's serial port service.  A RFCOMM channel does not have to be"
" specified as man:rfcomm_sppd[1] can obtain it from the remote device via "
"SDP.  To override this, specify a RFCOMM channel on the command line."
msgstr ""
"在 FreeBSD 中， man:rfcomm_sppd[1] 实现了 SPP "
"，并且使用伪终端作为虚拟串口抽象。下面的示例展示了如何连接到远程设备的串口服务。 man:rfcomm_sppd[1] 不需要指定 RFCOMM "
"通道，它可以通过 SDP 从远程设备获取。如果要覆盖这个行为，可以在命令行上指定一个 RFCOMM 通道。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1304
#, no-wrap
msgid ""
"# rfcomm_sppd -a 00:07:E0:00:0B:CA -t\n"
"rfcomm_sppd[94692]: Starting on /dev/pts/6...\n"
"/dev/pts/6\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1307
#, fuzzy
msgid "Once connected, the pseudo tty can be used as serial port:"
msgstr "一旦连接成功，伪终端可以被用作串口。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1311
#, no-wrap
msgid "# cu -l /dev/pts/6\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1314
#, fuzzy
msgid ""
"The pseudo tty is printed on stdout and can be read by wrapper scripts:"
msgstr "伪终端（ pseudo tty ）会被打印到标准输出，并可以被包装脚本读取。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1319
#, no-wrap
msgid ""
"PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`\n"
"cu -l $PTS\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1327
#, fuzzy
msgid ""
"By default, when FreeBSD is accepting a new connection, it tries to perform "
"a role switch and become master.  Some older Bluetooth devices which do not "
"support role switching will not be able to connect.  Since role switching is"
" performed when a new connection is being established, it is not possible to"
" ask the remote device if it supports role switching.  However, there is a "
"HCI option to disable role switching on the local side:"
msgstr ""
"默认情况下，当 FreeBSD "
"接受新连接时，它会尝试执行角色切换并成为主设备。一些不支持角色切换的较旧的蓝牙设备将无法连接。由于角色切换是在建立新连接时执行的，因此无法询问远程设备是否支持角色切换。然而，有一个"
" HCI 选项可以在本地禁用角色切换："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1331
#, no-wrap
msgid "# hccontrol -n ubt0hci write_node_role_switch 0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1335
#, fuzzy
msgid ""
"To display Bluetooth packets, use the third-party package hcidump, which can"
" be installed using the package:comms/hcidump[] package or port.  This "
"utility is similar to man:tcpdump[1] and can be used to display the contents"
" of Bluetooth packets on the terminal and to dump the Bluetooth packets to a"
" file."
msgstr ""
"要显示蓝牙数据包，请使用第三方软件包 hcidump ，可以使用 package:comms/hcidump[] 软件包或端口进行安装。该实用程序类似于"
" man:tcpdump[1] ，可用于在终端上显示蓝牙数据包的内容，并将蓝牙数据包转储到文件中。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1337
#, fuzzy, no-wrap
msgid "Bridging"
msgstr "桥接"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1341
#, fuzzy
msgid ""
"It is sometimes useful to divide a network, such as an Ethernet segment, "
"into network segments without having to create IP subnets and use a router "
"to connect the segments together.  A device that connects two networks "
"together in this fashion is called a \"bridge\"."
msgstr ""
"有时候，将一个网络（比如以太网段）划分为网络段，而无需创建 IP "
"子网并使用路由器将这些网络段连接起来，是非常有用的。以这种方式连接两个网络的设备被称为“桥接器”。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1346
#, fuzzy
msgid ""
"A bridge works by learning the MAC addresses of the devices on each of its "
"network interfaces.  It forwards traffic between networks only when the "
"source and destination MAC addresses are on different networks.  In many "
"respects, a bridge is like an Ethernet switch with very few ports.  A "
"FreeBSD system with multiple network interfaces can be configured to act as "
"a bridge."
msgstr ""
"桥接器通过学习每个网络接口上设备的 MAC 地址来工作。只有当源 MAC 地址和目标 MAC "
"地址位于不同的网络上时，它才会在网络之间转发流量。在许多方面，桥接器类似于只有很少端口的以太网交换机。可以配置具有多个网络接口的 FreeBSD "
"系统来充当桥接器。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1348
#, fuzzy
msgid "Bridging can be useful in the following situations:"
msgstr "桥接在以下情况下非常有用："

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1349
#, fuzzy, no-wrap
msgid "Connecting Networks"
msgstr "连接网络"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1353
#, fuzzy
msgid ""
"The basic operation of a bridge is to join two or more network segments.  "
"There are many reasons to use a host-based bridge instead of networking "
"equipment, such as cabling constraints or firewalling.  A bridge can also "
"connect a wireless interface running in hostap mode to a wired network and "
"act as an access point."
msgstr ""
"桥接的基本操作是连接两个或多个网络段。使用主机级桥接而不是网络设备有许多原因，例如布线限制或防火墙。桥接还可以将以 hostap "
"模式运行的无线接口连接到有线网络，并充当访问点。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1354
#, fuzzy, no-wrap
msgid "Filtering/Traffic Shaping Firewall"
msgstr "过滤 / 流量整形防火墙"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1356
#, fuzzy
msgid ""
"A bridge can be used when firewall functionality is needed without routing "
"or Network Address Translation (NAT)."
msgstr "当需要防火墙功能而不需要路由或网络地址转换（ NAT ）时，可以使用桥接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1361
#, fuzzy
msgid ""
"An example is a small company that is connected via DSL or ISDN to an ISP.  "
"There are thirteen public IP addresses from the ISP and ten computers on the"
" network.  In this situation, using a router-based firewall is difficult "
"because of subnetting issues.  A bridge-based firewall can be configured "
"without any IP addressing issues."
msgstr ""
"一个例子是一个通过 DSL 或 ISDN 连接到 ISP 的小公司。 ISP 提供了 13 个公共 IP 地址，网络上有 10 "
"台计算机。在这种情况下，由于子网划分问题，使用基于路由器的防火墙是困难的。而基于桥接的防火墙可以在没有任何 IP 地址问题的情况下进行配置。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1362
#, fuzzy, no-wrap
msgid "Network Tap"
msgstr "网络分流器"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1364
#, fuzzy
msgid ""
"A bridge can join two network segments in order to inspect all Ethernet "
"frames that pass between them using man:bpf[4] and man:tcpdump[1] on the "
"bridge interface, or by sending a copy of all frames out on an additional "
"interface known as a span port."
msgstr ""
"桥接器可以连接两个网络段，以便使用桥接接口上的 man:bpf[4] 和 man:tcpdump[1] "
"来检查它们之间传递的所有以太网帧，或者通过将所有帧的副本发送到一个额外的接口，即监控端口。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1365
#, fuzzy, no-wrap
msgid "Layer 2 VPN"
msgstr "第二层虚拟专用网络（ Layer 2 VPN ）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1367
#, fuzzy
msgid ""
"Two Ethernet networks can be joined across an IP link by bridging the "
"networks to an EtherIP tunnel or a man:tap[4] based solution such as "
"OpenVPN."
msgstr ""
"通过将网络桥接到 EtherIP 隧道或基于 man:tap[4] 的解决方案（如 OpenVPN ），可以通过 IP 链接将两个以太网网络连接起来。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1368
#, fuzzy, no-wrap
msgid "Layer 2 Redundancy"
msgstr "第二层冗余"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1370
#, fuzzy
msgid ""
"A network can be connected together with multiple links and use the Spanning"
" Tree Protocol (STP) to block redundant paths."
msgstr "一个网络可以通过多个链路连接在一起，并使用生成树协议（ STP ）来阻塞冗余路径。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1373
#, fuzzy
msgid ""
"This section describes how to configure a FreeBSD system as a bridge using "
"man:if_bridge[4].  A netgraph bridging driver is also available, and is "
"described in man:ng_bridge[4]."
msgstr ""
"本节介绍了如何使用 man:if_bridge[4] 将 FreeBSD 系统配置为桥接模式。还提供了 netgraph 桥接驱动程序的配置方法，详见 "
"man:ng_bridge[4] 。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1378
#, fuzzy
msgid ""
"Packet filtering can be used with any firewall package that hooks into the "
"man:pfil[9] framework.  The bridge can be used as a traffic shaper with "
"man:altq[4] or man:dummynet[4]."
msgstr ""
"数据包过滤可以与任何钩入 man:pfil[9] 框架的防火墙软件包一起使用。桥接可以与 man:altq[4] 或 man:dummynet[4] "
"一起用作流量整形器。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1380
#, fuzzy, no-wrap
msgid "Enabling the Bridge"
msgstr "启用桥接功能"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1384
#, fuzzy
msgid ""
"In FreeBSD, man:if_bridge[4] is a kernel module which is automatically "
"loaded by man:ifconfig[8] when creating a bridge interface.  It is also "
"possible to compile bridge support into a custom kernel by adding `device "
"if_bridge` to the custom kernel configuration file."
msgstr ""
"在 FreeBSD 中， man:if_bridge[4] 是一个内核模块，当创建一个桥接接口时， man:ifconfig[8] "
"会自动加载它。也可以通过在自定义内核配置文件中添加 `device if_bridge` 来编译桥接支持到自定义内核中。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1387
#, fuzzy
msgid ""
"The bridge is created using interface cloning.  To create the bridge "
"interface:"
msgstr "使用接口克隆来创建桥接。要创建桥接接口："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1398
#, no-wrap
msgid ""
"# ifconfig bridge create\n"
"bridge0\n"
"# ifconfig bridge0\n"
"bridge0: flags=8802<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1403
#, fuzzy
msgid ""
"When a bridge interface is created, it is automatically assigned a randomly "
"generated Ethernet address.  The `maxaddr` and `timeout` parameters control "
"how many MAC addresses the bridge will keep in its forwarding table and how "
"many seconds before each entry is removed after it is last seen.  The other "
"parameters control how STP operates."
msgstr ""
"当创建一个桥接接口时，它会自动分配一个随机生成的以太网地址。 `maxaddr` 和 `timeout` 参数控制桥接将保留多少个 MAC "
"地址在其转发表中，以及每个条目在最后一次被检测到后多少秒后被删除。其他参数控制 STP 的操作方式。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1406
#, fuzzy
msgid ""
"Next, specify which network interfaces to add as members of the bridge.  For"
" the bridge to forward packets, all member interfaces and the bridge need to"
" be up:"
msgstr "接下来，指定要添加为桥接成员的网络接口。为了使桥接转发数据包，所有成员接口和桥接都需要处于启动状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1412
#, no-wrap
msgid ""
"# ifconfig bridge0 addm fxp0 addm fxp1 up\n"
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1416
#, fuzzy
msgid ""
"The bridge can now forward Ethernet frames between [.filename]#fxp0# and "
"[.filename]#fxp1#.  Add the following lines to [.filename]#/etc/rc.conf# so "
"the bridge is created at startup:"
msgstr "桥接器现在可以在 fxp0 和 fxp1 之间转发以太网帧。在 /etc/rc.conf 中添加以下行，以便在启动时创建桥接器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1423
#, no-wrap
msgid ""
"cloned_interfaces=\"bridge0\"\n"
"ifconfig_bridge0=\"addm fxp0 addm fxp1 up\"\n"
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1428
#, fuzzy
msgid ""
"If the bridge host needs an IP address, set it on the bridge interface, not "
"on the member interfaces.  The address can be set statically or via DHCP.  "
"This example sets a static IP address:"
msgstr ""
"如果桥接主机需要一个 IP 地址，请在桥接接口上设置，而不是在成员接口上设置。该地址可以静态设置或通过 DHCP 设置。以下示例设置了一个静态 IP "
"地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1432
#, no-wrap
msgid "# ifconfig bridge0 inet 192.168.0.1/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1436
#, fuzzy
msgid ""
"It is also possible to assign an IPv6 address to a bridge interface.  To "
"make the changes permanent, add the addressing information to "
"[.filename]#/etc/rc.conf#."
msgstr "还可以将 IPv6 地址分配给桥接口。要使更改永久生效，请将寻址信息添加到 /etc/rc.conf 文件中。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1442
#, fuzzy
msgid ""
"When packet filtering is enabled, bridged packets will pass through the "
"filter inbound on the originating interface on the bridge interface, and "
"outbound on the appropriate interfaces.  Either stage can be disabled.  When"
" direction of the packet flow is important, it is best to firewall on the "
"member interfaces rather than the bridge itself."
msgstr ""
"当启用数据包过滤时，桥接的数据包将通过过滤器从桥接接口的原始接口进入，并通过适当的接口出去。任何一个阶段都可以被禁用。当数据包流向很重要时，最好在成员接口上设置防火墙，而不是在桥接本身上设置。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1445
#, fuzzy
msgid ""
"The bridge has several configurable settings for passing non-IP and IP "
"packets, and layer2 firewalling with man:ipfw[8].  See man:if_bridge[4] for "
"more information."
msgstr ""
"该桥接器具有多个可配置的设置，用于传递非 IP 和 IP 数据包，并使用 man:ipfw[8] 进行第二层防火墙设置。有关更多信息，请参阅 "
"man:if_bridge[4] 。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1447
#, fuzzy, no-wrap
msgid "Enabling Spanning Tree"
msgstr "启用生成树"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1452
#, fuzzy
msgid ""
"For an Ethernet network to function properly, only one active path can exist"
" between two devices.  The STP protocol detects loops and puts redundant "
"links into a blocked state.  Should one of the active links fail, STP "
"calculates a different tree and enables one of the blocked paths to restore "
"connectivity to all points in the network."
msgstr ""
"为了使以太网网络正常运行，两个设备之间只能存在一条活动路径。 STP 协议可以检测到环路，并将冗余链路置于阻塞状态。如果其中一条活动链路失败， STP "
"会计算出一棵不同的树，并启用一条被阻塞的路径，以恢复网络中所有节点的连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1456
#, fuzzy
msgid ""
"The Rapid Spanning Tree Protocol (RSTP or 802.1w) provides backwards "
"compatibility with legacy STP.  RSTP provides faster convergence and "
"exchanges information with neighboring switches to quickly transition to "
"forwarding mode without creating loops.  FreeBSD supports RSTP and STP as "
"operating modes, with RSTP being the default mode."
msgstr ""
"快速生成树协议（ RSTP 或 802.1w ）与传统的生成树协议（ STP ）向后兼容。 RSTP "
"提供更快的收敛速度，并与相邻交换机交换信息，以便快速转换到转发模式，而不会创建环路。 FreeBSD 支持 RSTP 和 STP 作为操作模式，其中 "
"RSTP 是默认模式。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1459
#, fuzzy
msgid ""
"STP can be enabled on member interfaces using man:ifconfig[8].  For a bridge"
" with [.filename]#fxp0# and [.filename]#fxp1# as the current interfaces, "
"enable STP with:"
msgstr ""
"可以使用 man:ifconfig[8] 在成员接口上启用 STP 。对于具有 .fxpo 和 .fxpl 作为当前接口的桥接，可以使用以下命令启用 "
"STP ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1474
#, no-wrap
msgid ""
"# ifconfig bridge0 stp fxp0 stp fxp1\n"
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether d6:cf:d5:a0:94:6d\n"
"        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 3 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1478
#, fuzzy
msgid ""
"This bridge has a spanning tree ID of `00:01:02:4b:d4:50` and a priority of "
"`32768`.  As the `root id` is the same, it indicates that this is the root "
"bridge for the tree."
msgstr ""
"这个桥的生成树 ID 是 `00:01:02:4b:d4:50` ，优先级是 `32768` 。由于根 ID 相同，这表明这是生成树的根桥。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1480
#, fuzzy
msgid "Another bridge on the network also has STP enabled:"
msgstr "网络上的另一座桥梁也启用了 STP ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1494
#, no-wrap
msgid ""
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role root state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 5 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1498
#, fuzzy
msgid ""
"The line `root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` "
"shows that the root bridge is `00:01:02:4b:d4:50` and has a path cost of "
"`400000` from this bridge.  The path to the root bridge is via `port 4` "
"which is [.filename]#fxp0#."
msgstr ""
"该行 `root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` 显示根桥为 "
"`00:01:02:4b:d4:50` ，从该桥到根桥的路径成本为 `400000` 。到达根桥的路径通过 `port 4` ，即 "
"[.filename]#fxp0# 。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1499
#, fuzzy, no-wrap
msgid "Bridge Interface Parameters"
msgstr "桥接接口参数"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1504
#, fuzzy
msgid ""
"Several `ifconfig` parameters are unique to bridge interfaces.  This section"
" summarizes some common uses for these parameters.  The complete list of "
"available parameters is described in man:ifconfig[8]."
msgstr ""
"几个 `ifconfig` 参数是专门用于桥接接口的。本节概述了这些参数的一些常见用法。完整的可用参数列表在 man:ifconfig[8] 中有描述。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1505
#, fuzzy, no-wrap
msgid "private"
msgstr "私有的"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1509
#, fuzzy
msgid ""
"A private interface does not forward any traffic to any other port that is "
"also designated as a private interface.  The traffic is blocked "
"unconditionally so no Ethernet frames will be forwarded, including ARP "
"packets.  If traffic needs to be selectively blocked, a firewall should be "
"used instead."
msgstr ""
"私有接口不会将任何流量转发到其他被指定为私有接口的端口。流量会被无条件地阻塞，因此不会转发任何以太网帧，包括 ARP "
"数据包。如果需要选择性地阻止流量，应该使用防火墙。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1510
#, fuzzy, no-wrap
msgid "span"
msgstr "跨度"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1515
#, fuzzy
msgid ""
"A span port transmits a copy of every Ethernet frame received by the bridge."
"  The number of span ports configured on a bridge is unlimited, but if an "
"interface is designated as a span port, it cannot also be used as a regular "
"bridge port.  This is most useful for snooping a bridged network passively "
"on another host connected to one of the span ports of the bridge.  For "
"example, to send a copy of all frames out the interface named "
"[.filename]#fxp4#:"
msgstr ""
"一个 SPAN 端口会传输桥接器接收到的每个以太网帧的副本。一个桥接器上配置的 SPAN 端口数量是无限的，但是如果一个接口被指定为 SPAN "
"端口，它就不能再被用作常规的桥接端口。这对于在连接到桥接器的 SPAN "
"端口之一的另一台主机上被动地监听桥接网络非常有用。例如，要将所有帧的副本发送到名为 [.filename]#fxp4# 的接口上。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1519
#, no-wrap
msgid "# ifconfig bridge0 span fxp4\n"
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1521
#, fuzzy, no-wrap
msgid "sticky"
msgstr "粘性"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1526
#, fuzzy
msgid ""
"If a bridge member interface is marked as sticky, dynamically learned "
"address entries are treated as static entries in the forwarding cache.  "
"Sticky entries are never aged out of the cache or replaced, even if the "
"address is seen on a different interface.  This gives the benefit of static "
"address entries without the need to pre-populate the forwarding table.  "
"Clients learned on a particular segment of the bridge cannot roam to another"
" segment."
msgstr ""
"如果桥接成员接口被标记为粘性（ sticky "
"），动态学习的地址条目将被视为转发缓存中的静态条目。粘性条目不会因为地址在不同接口上出现而被清除或替换。这提供了静态地址条目的好处，而无需预先填充转发表。在桥接的特定段上学习的客户端不能漫游到另一个段。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1529
#, fuzzy
msgid ""
"An example of using sticky addresses is to combine the bridge with VLANs in "
"order to isolate customer networks without wasting IP address space.  "
"Consider that `CustomerA` is on `vlan100`, `CustomerB` is on `vlan101`, and "
"the bridge has the address `192.168.0.1`:"
msgstr ""
"使用粘性地址的一个例子是将桥接器与 VLAN 结合使用，以便在不浪费 IP 地址空间的情况下隔离客户网络。假设 `CustomerA` 位于 "
"`vlan100` ， `CustomerB` 位于 `vlan101` ，桥接器的地址为 `192.168.0.1` ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1534
#, no-wrap
msgid ""
"# ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101\n"
"# ifconfig bridge0 inet 192.168.0.1/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1538
#, fuzzy
msgid ""
"In this example, both clients see `192.168.0.1` as their default gateway.  "
"Since the bridge cache is sticky, one host cannot spoof the MAC address of "
"the other customer in order to intercept their traffic."
msgstr ""
"在这个例子中，两个客户端都将 `192.168.0.1` 视为它们的默认网关。由于桥接缓存是粘性的，一个主机无法伪造另一个客户的 MAC "
"地址以拦截其流量。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1540
#, fuzzy
msgid ""
"Any communication between the VLANs can be blocked using a firewall or, as "
"seen in this example, private interfaces:"
msgstr "可以使用防火墙或私有接口来阻止 VLAN 之间的任何通信，就像在这个例子中所看到的那样："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1544
#, no-wrap
msgid "# ifconfig bridge0 private vlan100 private vlan101\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1547
#, fuzzy
msgid ""
"The customers are completely isolated from each other and the full `/24` "
"address range can be allocated without subnetting."
msgstr "客户之间完全隔离，可以分配整个 `/24` 地址范围而无需进行子网划分。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1550
#, fuzzy
msgid ""
"The number of unique source MAC addresses behind an interface can be "
"limited.  Once the limit is reached, packets with unknown source addresses "
"are dropped until an existing host cache entry expires or is removed."
msgstr "接口后面的唯一源 MAC 地址数量可以被限制。一旦达到限制，具有未知源地址的数据包将被丢弃，直到现有的主机缓存条目过期或被删除。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1552
#, fuzzy
msgid ""
"The following example sets the maximum number of Ethernet devices for "
"`CustomerA` on `vlan100` to 10:"
msgstr "以下示例将 `vlan100` 上 `CustomerA` 的以太网设备的最大数量设置为 10 ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1556
#, no-wrap
msgid "# ifconfig bridge0 ifmaxaddr vlan100 10\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1562
#, fuzzy
msgid ""
"Bridge interfaces also support monitor mode, where the packets are discarded"
" after man:bpf[4] processing and are not processed or forwarded further.  "
"This can be used to multiplex the input of two or more interfaces into a "
"single man:bpf[4] stream.  This is useful for reconstructing the traffic for"
" network taps that transmit the RX/TX signals out through two separate "
"interfaces.  For example, to read the input from four network interfaces as "
"one stream:"
msgstr ""
"桥接接口还支持监控模式，在 man:bpf[4] 处理后丢弃数据包，不再进行进一步处理或转发。这可以用于将两个或多个接口的输入多路复用到单个 "
"man:bpf[4] 流中。这对于重构通过两个独立接口传输 RX/TX 信号的网络监听器的流量非常有用。例如，要将四个网络接口的输入作为一个流进行读取："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1567
#, no-wrap
msgid ""
"# ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up\n"
"# tcpdump -i bridge0\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1569
#, fuzzy, no-wrap
msgid "SNMP Monitoring"
msgstr "SNMP 监控"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1573
#, fuzzy
msgid ""
"The bridge interface and STP parameters can be monitored via man:bsnmpd[1] "
"which is included in the FreeBSD base system.  The exported bridge MIBs "
"conform to IETF standards so any SNMP client or monitoring package can be "
"used to retrieve the data."
msgstr ""
"桥接接口和 STP 参数可以通过 man:bsnmpd[1] 进行监控，该工具包含在 FreeBSD 基本系统中。导出的桥接 MIB 符合 IETF "
"标准，因此可以使用任何 SNMP 客户端或监控软件来检索数据。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1575
#, fuzzy
msgid ""
"To enable monitoring on the bridge, uncomment this line in "
"[.filename]#/etc/snmpd.config# by removing the beginning `+#+` symbol:"
msgstr ""
"要在桥接器上启用监控，请取消注释 [.filename]#/etc/snmpd.config# 中的此行，即删除开头的 `+#+` 符号："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1579
#, no-wrap
msgid "begemotSnmpdModulePath.\"bridge\" = \"/usr/lib/snmp_bridge.so\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1584
#, fuzzy
msgid ""
"Other configuration settings, such as community names and access lists, may "
"need to be modified in this file.  See man:bsnmpd[1] and man:snmp_bridge[3] "
"for more information.  Once these edits are saved, add this line to "
"[.filename]#/etc/rc.conf#:"
msgstr ""
"其他配置设置，如社区名称和访问列表，可能需要在此文件中进行修改。有关更多信息，请参阅 man:bsnmpd[1] 和 "
"man:snmp_bridge[3] 。保存这些编辑后，将此行添加到 [.filename]#/etc/rc.conf# ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1588
#, no-wrap
msgid "bsnmpd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1591
#, fuzzy
msgid "Then, start man:bsnmpd[1]:"
msgstr "然后，启动 man:bsnmpd[1] ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1595
#, no-wrap
msgid "# service bsnmpd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1600
#, fuzzy
msgid ""
"The following examples use the Net-SNMP software (package:net-mgmt/net-"
"snmp[]) to query a bridge from a client system.  The package:net-"
"mgmt/bsnmptools[] port can also be used.  From the SNMP client which is "
"running Net-SNMP, add the following lines to "
"[.filename]#$HOME/.snmp/snmp.conf# in order to import the bridge MIB "
"definitions:"
msgstr ""
"以下示例使用 Net-SNMP 软件（软件包： net-mgmt/net-snmp[] ）从客户端系统查询桥接。也可以使用软件包： net-"
"mgmt/bsnmptools[] 端口。从运行 Net-SNMP 的 SNMP 客户端，在 [.filename]# $ "
"HOME/.snmp/snmp.conf# 中添加以下行以导入桥接 MIB 定义："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1605
#, no-wrap
msgid ""
"mibdirs +/usr/share/snmp/mibs\n"
"mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1608
#, fuzzy
msgid "To monitor a single bridge using the IETF BRIDGE-MIB (RFC4188):"
msgstr "使用 IETF BRIDGE-MIB （ RFC4188 ）监控单个桥接设备："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1627
#, no-wrap
msgid ""
"% snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge\n"
"BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44\n"
"BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports\n"
"BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds\n"
"BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2\n"
"BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"...\n"
"BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)\n"
"BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)\n"
"BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000\n"
"BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0\n"
"BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80\n"
"BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1\n"
"RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1632
#, fuzzy
msgid ""
"The `dot1dStpTopChanges.0` value is two, indicating that the STP bridge "
"topology has changed twice.  A topology change means that one or more links "
"in the network have changed or failed and a new tree has been calculated.  "
"The `dot1dStpTimeSinceTopologyChange.0` value will show when this happened."
msgstr ""
"`dot1dStpTopChanges.0` 的值为 2 ，表示 STP "
"桥接拓扑已经发生了两次变化。拓扑变化意味着网络中的一个或多个链路发生了变化或故障，并重新计算了新的树形结构。 "
"`dot1dStpTimeSinceTopologyChange.0` 的值将显示这一事件发生的时间。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1634
#, fuzzy
msgid ""
"To monitor multiple bridge interfaces, the private BEGEMOT-BRIDGE-MIB can be"
" used:"
msgstr "要监控多个桥接口，可以使用私有的 BEGEMOT-BRIDGE-MIB 。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1652
#, no-wrap
msgid ""
"% snmpwalk -v 2c -c public bridge1.example.com\n"
"enterprises.fokus.begemot.begemotBridge\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge0\" = STRING: bridge0\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge2\" = STRING: bridge2\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge0\" = STRING: e:ce:3b:5a:9e:13\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge2\" = STRING: 12:5e:4d:74:d:fc\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge0\" = INTEGER: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge2\" = INTEGER: 1\n"
"...\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge0\" = Timeticks: (116927) 0:19:29.27 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge2\" = Timeticks: (82773) 0:13:47.73 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge0\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge2\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge0\" = Hex-STRING: 80 00 00 40 95 30 5E 31\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge2\" = Hex-STRING: 80 00 00 50 8B B8 C6 A9\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1655
#, fuzzy
msgid ""
"To change the bridge interface being monitored via the `mib-2.dot1dBridge` "
"subtree:"
msgstr "要通过 `mib-2.dot1dBridge` 子树更改被监视的桥接口："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1660
#, no-wrap
msgid ""
"% snmpset -v 2c -c private bridge1.example.com\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1663
#, fuzzy, no-wrap
msgid "Link Aggregation and Failover"
msgstr "链路聚合和故障转移"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1668
#, fuzzy
msgid ""
"FreeBSD provides the man:lagg[4] interface which can be used to aggregate "
"multiple network interfaces into one virtual interface in order to provide "
"failover and link aggregation.  Failover allows traffic to continue to flow "
"as long as at least one aggregated network interface has an established "
"link.  Link aggregation works best on switches which support LACP, as this "
"protocol distributes traffic bi-directionally while responding to the "
"failure of individual links."
msgstr ""
"FreeBSD 提供了 man:lagg[4] "
"接口，可以将多个网络接口聚合成一个虚拟接口，以实现故障转移和链路聚合。故障转移允许流量在至少一个聚合网络接口建立连接时继续传输。链路聚合在支持 LACP"
" 的交换机上效果最佳，因为该协议可以在双向传输流量的同时响应单个链路的故障。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1671
#, fuzzy
msgid ""
"The aggregation protocols supported by the lagg interface determine which "
"ports are used for outgoing traffic and whether or not a specific port "
"accepts incoming traffic.  The following protocols are supported by "
"man:lagg[4]:"
msgstr "lagg 接口支持的聚合协议决定了哪些端口用于出站流量，以及特定端口是否接受入站流量。 man:lagg[4] 支持以下协议："

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1672
#, fuzzy, no-wrap
msgid "failover"
msgstr "故障转移"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1677
#, fuzzy
msgid ""
"This mode sends and receives traffic only through the master port.  If the "
"master port becomes unavailable, the next active port is used.  The first "
"interface added to the virtual interface is the master port and all "
"subsequently added interfaces are used as failover devices.  If failover to "
"a non-master port occurs, the original port becomes master once it becomes "
"available again."
msgstr ""
"这种模式只通过主端口发送和接收流量。如果主端口不可用，将使用下一个活动端口。添加到虚拟接口的第一个接口是主端口，随后添加的接口将用作故障转移设备。如果故障转移到非主端口，原始端口在再次可用时将恢复为主端口。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1678
#, fuzzy, no-wrap
msgid "loadbalance"
msgstr "负载均衡"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1681
#, fuzzy
msgid ""
"This provides a static setup and does not negotiate aggregation with the "
"peer or exchange frames to monitor the link.  If the switch supports LACP, "
"that should be used instead."
msgstr "这提供了一个静态设置，并且不与对等方协商聚合或交换帧以监视链路。如果交换机支持 LACP ，则应使用该协议。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1682
#, fuzzy, no-wrap
msgid "lacp"
msgstr ""
"LACP （ Link Aggregation Control Protocol "
"）是一种用于组合多个物理链路形成逻辑链路的网络协议。它允许将多个物理链路捆绑在一起，形成一个高带宽、高可靠性的逻辑链路，提供更好的网络性能和冗余备份。 "
"LACP 通过协商和管理链路聚合组（ LAG ）来实现链路的动态添加和删除，以及链路的负载均衡和故障恢复。 LACP "
"常用于数据中心、企业网络和运营商网络等场景，以提供更高的带宽和可靠性。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1687
#, fuzzy
msgid ""
"The IEEE(R) 802.3ad Link Aggregation Control Protocol (LACP) negotiates a "
"set of aggregable links with the peer into one or more Link Aggregated "
"Groups (LAGs).  Each LAG is composed of ports of the same speed, set to "
"full-duplex operation, and traffic is balanced across the ports in the LAG "
"with the greatest total speed.  Typically, there is only one LAG which "
"contains all the ports.  In the event of changes in physical connectivity, "
"LACP will quickly converge to a new configuration."
msgstr ""
"IEEE(R) 802.3ad 链路聚合控制协议（ LACP ）与对等方协商一组可聚合的链路，形成一个或多个链路聚合组（ LAG ）。每个 LAG "
"由相同速度的端口组成，设置为全双工操作，并且流量在 LAG 中的端口之间进行平衡，以获得最大总速度。通常，只有一个包含所有端口的 LAG "
"。在物理连接发生变化时， LACP 将迅速收敛到新的配置。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1690
#, fuzzy
msgid ""
"LACP balances outgoing traffic across the active ports based on hashed "
"protocol header information and accepts incoming traffic from any active "
"port.  The hash includes the Ethernet source and destination address and, if"
" available, the VLAN tag, and the IPv4 or IPv6 source and destination "
"address."
msgstr ""
"LACP 根据哈希协议头信息平衡传出流量，并从任何活动端口接受传入流量。哈希包括以太网源地址和目的地址，如果可用，还包括 VLAN 标签以及 IPv4 "
"或 IPv6 源地址和目的地址。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1691
#, fuzzy, no-wrap
msgid "roundrobin"
msgstr "轮询"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1694
#, fuzzy
msgid ""
"This mode distributes outgoing traffic using a round-robin scheduler through"
" all active ports and accepts incoming traffic from any active port.  Since "
"this mode violates Ethernet frame ordering, it should be used with caution."
msgstr "这种模式通过循环调度器将出站流量分发到所有活动端口，并接受来自任何活动端口的入站流量。由于这种模式违反了以太网帧的顺序，因此应谨慎使用。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1695
#, fuzzy, no-wrap
msgid "broadcast"
msgstr "广播"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1697
#, fuzzy
msgid ""
"This mode sends outgoing traffic to all ports configured on the lagg "
"interface, and receives frames on any port."
msgstr "该模式将出站流量发送到 lagg 接口上配置的所有端口，并在任何端口上接收帧。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1698
#, fuzzy, no-wrap
msgid "Configuration Examples"
msgstr "配置示例"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1702
#, fuzzy
msgid ""
"This section demonstrates how to configure a Cisco(R) switch and a FreeBSD "
"system for LACP load balancing.  It then shows how to configure two Ethernet"
" interfaces in failover mode as well as how to configure failover mode "
"between an Ethernet and a wireless interface."
msgstr ""
"本节演示了如何配置 Cisco(R) 交换机和 FreeBSD 系统以实现 LACP "
"负载均衡。然后，它展示了如何配置两个以故障转移模式工作的以太网接口，以及如何在以太网接口和无线接口之间配置故障转移模式。"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1704
#, fuzzy, no-wrap
msgid "LACP Aggregation with a Cisco(R) Switch"
msgstr "使用 Cisco(R) 交换机进行 LACP 聚合"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1710
#, fuzzy
msgid ""
"This example connects two man:fxp[4] Ethernet interfaces on a FreeBSD "
"machine to the first two Ethernet ports on a Cisco(R) switch as a single "
"load balanced and fault tolerant link.  More interfaces can be added to "
"increase throughput and fault tolerance.  Replace the names of the Cisco(R) "
"ports, Ethernet devices, channel group number, and IP address shown in the "
"example to match the local configuration."
msgstr ""
"这个例子将一个 FreeBSD 机器上的两个 man:fxp[4] 以太网接口连接到 Cisco(R) "
"交换机的前两个以太网端口，作为一个负载均衡和容错链接。可以添加更多接口以增加吞吐量和容错性。请根据本地配置替换示例中显示的 Cisco(R) "
"端口名称、以太网设备、通道组号和 IP 地址的名称。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1713
#, fuzzy
msgid ""
"Frame ordering is mandatory on Ethernet links and any traffic between two "
"stations always flows over the same physical link, limiting the maximum "
"speed to that of one interface.  The transmit algorithm attempts to use as "
"much information as it can to distinguish different traffic flows and "
"balance the flows across the available interfaces."
msgstr ""
"以太网链路上的帧排序是强制性的，任何两个站点之间的流量总是通过同一物理链路传输，这限制了最大速度为一个接口的速度。传输算法尝试使用尽可能多的信息来区分不同的流量，并在可用接口之间平衡流量。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1715
#, fuzzy
msgid ""
"On the Cisco(R) switch, add the _FastEthernet0/1_ and _FastEthernet0/2_ "
"interfaces to channel group _1_:"
msgstr "在 Cisco(R) 交换机上，将_FastEthernet0/1_和_FastEthernet0/2_接口添加到通道组_1_中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1725
#, no-wrap
msgid ""
"interface FastEthernet0/1\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"
"!\n"
"interface FastEthernet0/2\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1728
#, fuzzy
msgid ""
"On the FreeBSD system, create the man:lagg[4] interface using the physical "
"interfaces _fxp0_ and _fxp1_ and bring the interfaces up with an IP address "
"of _10.0.0.3/24_:"
msgstr ""
"在 FreeBSD 系统上，使用物理接口_fxp0_和_fxp1_创建 man:lagg[4] 接口，并使用 IP "
"地址_10.0.0.3/24_将接口启动："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1735
#, no-wrap
msgid ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1738
#, fuzzy
msgid "Next, verify the status of the virtual interface:"
msgstr "接下来，验证虚拟接口的状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1751
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto lacp\n"
"        laggport: fxp1 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"
"        laggport: fxp0 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1756
#, fuzzy
msgid ""
"Ports marked as `ACTIVE` are part of the LAG that has been negotiated with "
"the remote switch.  Traffic will be transmitted and received through these "
"active ports.  Add `-v` to the above command to view the LAG identifiers."
msgstr ""
"标记为“ ACTIVE ”的端口是与远程交换机协商的链路聚合组（ LAG ）的一部分。通过这些活动端口传输和接收流量。在上述命令中添加“ -v ”以查看"
" LAG 标识符。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1758
#, fuzzy
msgid "To see the port status on the Cisco(R) switch:"
msgstr "查看 Cisco(R) 交换机上的端口状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1765
#, no-wrap
msgid ""
"switch# show lacp neighbor\n"
"Flags:  S - Device is requesting Slow LACPDUs\n"
"        F - Device is requesting Fast LACPDUs\n"
"        A - Device is in Active mode       P - Device is in Passive mode\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1767
#, no-wrap
msgid "Channel group 1 neighbors\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1769
#, no-wrap
msgid "Partner's information:\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1774
#, no-wrap
msgid ""
"                  LACP port                        Oper    Port     Port\n"
"Port      Flags   Priority  Dev ID         Age     Key     Number   State\n"
"Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D\n"
"Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1777
#, fuzzy
msgid "For more detail, type `show lacp neighbor detail`."
msgstr "要获取更详细的信息，请输入 `show lacp neighbor detail` 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1779
#, fuzzy
msgid ""
"To retain this configuration across reboots, add the following entries to "
"[.filename]#/etc/rc.conf# on the FreeBSD system:"
msgstr "要在重新启动后保留此配置，请将以下条目添加到 FreeBSD 系统上的 `/etc/rc.conf` 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1786
#, no-wrap
msgid ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\"\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1791
#, fuzzy, no-wrap
msgid "Failover Mode"
msgstr "故障转移模式"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1798
#, fuzzy
msgid ""
"Failover mode can be used to switch over to a secondary interface if the "
"link is lost on the master interface.  To configure failover, make sure that"
" the underlying physical interfaces are up, then create the man:lagg[4] "
"interface.  In this example, _fxp0_ is the master interface, _fxp1_ is the "
"secondary interface, and the virtual interface is assigned an IP address of "
"_10.0.0.15/24_:"
msgstr ""
"如果主接口丢失连接，可以使用故障转移模式切换到备用接口。要配置故障转移，请确保底层物理接口正常工作，然后创建 man:lagg[4] "
"接口。在这个例子中，_fxp0_是主接口，_fxp1_是备用接口，虚拟接口被分配了一个 IP 地址为_10.0.0.15/24_。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1805
#, no-wrap
msgid ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1808
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1909
#, fuzzy
msgid "The virtual interface should look something like this:"
msgstr "虚拟接口应该类似于这样："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1821
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto failover\n"
"        laggport: fxp1 flags=0<>\n"
"        laggport: fxp0 flags=5<MASTER,ACTIVE>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1826
#, fuzzy
msgid ""
"Traffic will be transmitted and received on _fxp0_.  If the link is lost on "
"_fxp0_, _fxp1_ will become the active link.  If the link is restored on the "
"master interface, it will once again become the active link."
msgstr ""
"流量将在 _fxp0_ 上进行传输和接收。如果 _fxp0_ 上的连接丢失，_fxp1_ 将成为活动连接。如果主接口上的连接恢复，它将再次成为活动连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1828
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1932
#, fuzzy
msgid ""
"To retain this configuration across reboots, add the following entries to "
"[.filename]#/etc/rc.conf#:"
msgstr "要在重新启动后保留此配置，请将以下条目添加到 [.filename]#/etc/rc.conf# 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1835
#, no-wrap
msgid ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24\"\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1840
#, fuzzy, no-wrap
msgid "Failover Mode Between Ethernet and Wireless Interfaces"
msgstr "以太网和无线接口之间的故障转移模式"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1846
#, fuzzy
msgid ""
"For laptop users, it is usually desirable to configure the wireless device "
"as a secondary which is only used when the Ethernet connection is not "
"available.  With man:lagg[4], it is possible to configure a failover which "
"prefers the Ethernet connection for both performance and security reasons, "
"while maintaining the ability to transfer data over the wireless connection."
msgstr ""
"对于笔记本电脑用户来说，通常希望将无线设备配置为次要设备，仅在以太网连接不可用时使用。通过使用 man:lagg[4] "
"，可以配置故障转移，优先选择以太网连接，以提高性能和安全性，同时保持通过无线连接传输数据的能力。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1848
#, fuzzy
msgid ""
"This is achieved by overriding the Ethernet interface's MAC address with "
"that of the wireless interface."
msgstr "这是通过使用无线接口的 MAC 地址覆盖以太网接口的 MAC 地址来实现的。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1854
#, fuzzy
msgid ""
"In theory, either the Ethernet or wireless MAC address can be changed to "
"match the other.  However, some popular wireless interfaces lack support for"
" overriding the MAC address.  We therefore recommend overriding the Ethernet"
" MAC address for this purpose."
msgstr ""
"理论上，以太网或无线网络的 MAC 地址都可以更改以匹配另一个。然而，一些常用的无线接口不支持覆盖 MAC 地址。因此，我们建议为此目的覆盖以太网的 "
"MAC 地址。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1861
#, fuzzy
msgid ""
"If the driver for the wireless interface is not loaded in the `GENERIC` or "
"custom kernel, and the computer is running FreeBSD {rel121-current}, load "
"the corresponding [.filename]#.ko# in [.filename]#/boot/loader.conf# by "
"adding `*driver_load=\"YES\"*` to that file and rebooting.  Another, better "
"way is to load the driver in [.filename]#/etc/rc.conf# by adding it to "
"`kld_list` (see man:rc.conf[5] for details) in that file and rebooting.  "
"This is needed because otherwise the driver is not loaded yet at the time "
"the man:lagg[4] interface is set up."
msgstr ""
"如果在 `GENERIC` 或自定义内核中没有加载无线接口的驱动程序，并且计算机正在运行 FreeBSD {rel121-current} "
"，则可以通过在 `/boot/loader.conf` 文件中添加 `*driver_load =\"YES\"*` 来加载相应的 `.ko` "
"文件，并重新启动计算机。另一种更好的方法是通过将驱动程序添加到 `/etc/rc.conf` 文件中的 `kld_list` （详见 "
"man:rc.conf[5] ）并重新启动来加载驱动程序。这是必需的，因为否则在设置 man:lagg[4] 接口时驱动程序尚未加载。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1867
#, fuzzy
msgid ""
"In this example, the Ethernet interface, _re0_, is the master and the "
"wireless interface, _wlan0_, is the failover.  The _wlan0_ interface was "
"created from the _ath0_ physical wireless interface, and the Ethernet "
"interface will be configured with the MAC address of the wireless interface."
"  First, bring the wireless interface up (replacing _FR_ with your own "
"2-letter country code), but do not set an IP address.  Replace _wlan0_ to "
"match the system's wireless interface name:"
msgstr ""
"在这个例子中，以太网接口_re0_是主接口，无线接口_wlan0_是备份接口。_wlan0_接口是从_ath0_物理无线接口创建的，并且以太网接口将配置无线接口的"
" MAC 地址。首先，将无线接口启动（将_FR_替换为您自己的两个字母的国家代码），但不设置 IP "
"地址。将_wlan0_替换为与系统的无线接口名称匹配的名称："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1871
#, no-wrap
msgid "# ifconfig wlan0 create wlandev ath0 country FR ssid my_router up\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1874
#, fuzzy
msgid "Now you can determine the MAC address of the wireless interface:"
msgstr "现在您可以确定无线接口的 MAC 地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1889
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\tether b8:ee:65:5b:32:59\n"
"\tgroups: wlan\n"
"\tssid Bbox-A3BD2403 channel 6 (2437 MHz 11g ht/20) bssid 00:37:b7:56:4b:60\n"
"\tregdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON\n"
"\tdeftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60\n"
"\tprotmode CTS ampdulimit 64k ampdudensity 8 shortgi -stbctx stbcrx\n"
"\t-ldpc wme burst roaming MANUAL\n"
"\tmedia: IEEE 802.11 Wireless Ethernet MCS mode 11ng\n"
"\tstatus: associated\n"
"\tnd6 options=29<PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1893
#, fuzzy
msgid ""
"The `ether` line will contain the MAC address of the specified interface.  "
"Now, change the MAC address of the Ethernet interface to match:"
msgstr "`ether` 行将包含指定接口的 MAC 地址。现在，将以太网接口的 MAC 地址更改为匹配的地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1897
#, no-wrap
msgid "# ifconfig re0 ether b8:ee:65:5b:32:59\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1900
#, fuzzy
msgid ""
"Make sure the _re0_ interface is up, then create the man:lagg[4] interface "
"with _re0_ as master with failover to _wlan0_:"
msgstr "确保_re0_接口处于启动状态，然后使用_re0_作为主接口创建 man:lagg[4] 接口，并设置故障转移至_wlan0_。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1906
#, no-wrap
msgid ""
"# ifconfig re0 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1922
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether b8:ee:65:5b:32:59\n"
"        laggproto failover lagghash l2,l3,l4\n"
"        laggport: re0 flags=5<MASTER,ACTIVE>\n"
"        laggport: wlan0 flags=0<>\n"
"        groups: lagg\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1925
#, fuzzy
msgid "Then, start the DHCP client to obtain an IP address:"
msgstr "然后，启动 DHCP 客户端以获取 IP 地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1929
#, no-wrap
msgid "# dhclient lagg0\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1941
#, no-wrap
msgid ""
"ifconfig_re0=\"ether b8:ee:65:5b:32:59\"\n"
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA\"\n"
"create_args_wlan0=\"country FR\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"up laggproto failover laggport re0 laggport wlan0 DHCP\"\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1946
#, fuzzy, no-wrap
msgid "Diskless Operation with PXE"
msgstr "使用 PXE 进行无盘操作"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1952
#, fuzzy
msgid ""
"The Intel(R) Preboot eXecution Environment (PXE) allows an operating system "
"to boot over the network.  For example, a FreeBSD system can boot over the "
"network and operate without a local disk, using file systems mounted from an"
" NFS server.  PXE support is usually available in the BIOS.  To use PXE when"
" the machine starts, select the `Boot from network` option in the BIOS setup"
" or type a function key during system initialization."
msgstr ""
"Intel(R) Preboot eXecution Environment (PXE) 允许操作系统通过网络引导。例如， FreeBSD "
"系统可以通过网络引导并在没有本地磁盘的情况下运行，使用从 NFS 服务器挂载的文件系统。 PXE 支持通常在 BIOS 中可用。要在机器启动时使用 "
"PXE ，在 BIOS 设置中选择“从网络引导”选项或在系统初始化期间键入功能键。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1954
#, fuzzy
msgid ""
"In order to provide the files needed for an operating system to boot over "
"the network, a PXE setup also requires properly configured DHCP, TFTP, and "
"NFS servers, where:"
msgstr "为了提供操作系统在网络上启动所需的文件， PXE 设置还需要正确配置的 DHCP 、 TFTP 和 NFS 服务器，其中："

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1956
#, fuzzy
msgid ""
"Initial parameters, such as an IP address, executable boot filename and "
"location, server name, and root path are obtained from the DHCP server."
msgstr "初始参数，如 IP 地址、可执行的引导文件名和位置、服务器名称和根路径，是从 DHCP 服务器获取的。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1957
#, fuzzy
msgid "The operating system loader file is booted using TFTP."
msgstr "操作系统加载程序文件使用 TFTP 进行引导。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1958
#, fuzzy
msgid "The file systems are loaded using NFS."
msgstr "文件系统使用 NFS 加载。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1963
#, fuzzy
msgid ""
"When a computer PXE boots, it receives information over DHCP about where to "
"obtain the initial boot loader file.  After the host computer receives this "
"information, it downloads the boot loader via TFTP and then executes the "
"boot loader.  In FreeBSD, the boot loader file is "
"[.filename]#/boot/pxeboot#.  After [.filename]#/boot/pxeboot# executes, the "
"FreeBSD kernel is loaded and the rest of the FreeBSD bootup sequence "
"proceeds, as described in crossref:boot[boot,The FreeBSD Booting Process]."
msgstr ""
"当计算机进行 PXE 引导时，它通过 DHCP 接收关于获取初始引导加载程序文件的信息。主机计算机接收到这些信息后，通过 TFTP "
"下载引导加载程序，然后执行引导加载程序。在 FreeBSD 中，引导加载程序文件是 [/boot/pxeboot] 。在 [/boot/pxeboot]"
" 执行后， FreeBSD 内核被加载，随后进行 FreeBSD 的引导过程，如 crossref:boot[boot , The FreeBSD "
"Booting Process] 中所述。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1968
#, fuzzy
msgid ""
"For UEFI PXE based boot, the actual boot loader file to use is "
"[.filename]#/boot/loader.efi#.  See the below section crossref:advanced-"
"networking[_debugging_pxe_problems,Debugging PXE Problems] on how to use "
"[.filename]#/boot/loader.efi#."
msgstr ""
"对于基于 UEFI PXE 的引导，要使用的实际引导加载程序文件是 [.filename]#/boot/loader.efi# 。请参阅下面的章节 "
"crossref:advanced-networking[_debugging_pxe_problems ,调试 PXE 问题] ，了解如何使用 "
"[.filename]#/boot/loader.efi# 。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1972
#, fuzzy
msgid ""
"This section describes how to configure these services on a FreeBSD system "
"so that other systems can PXE boot into FreeBSD.  Refer to man:diskless[8] "
"for more information."
msgstr ""
"本节介绍了如何在 FreeBSD 系统上配置这些服务，以便其他系统可以通过 PXE 引导进入 FreeBSD 。有关更多信息，请参阅 "
"man:diskless[8] 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1977
#, fuzzy
msgid ""
"As described, the system providing these services is insecure.  It should "
"live in a protected area of a network and be untrusted by other hosts."
msgstr "如上所述，提供这些服务的系统是不安全的。它应该存在于网络的受保护区域，并且其他主机不应信任它。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1980
#, fuzzy, no-wrap
msgid "Setting Up the PXE Environment"
msgstr "设置 PXE 环境"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1986
#, fuzzy
msgid ""
"The steps shown in this section configure the built-in NFS and TFTP servers."
"  The next section demonstrates how to install and configure the DHCP "
"server.  In this example, the directory which will contain the files used by"
" PXE users is [.filename]#/b/tftpboot/FreeBSD/install#.  It is important "
"that this directory exists and that the same directory name is set in both "
"[.filename]#/etc/inetd.conf# and [.filename]#/usr/local/etc/dhcpd.conf#."
msgstr ""
"本节中显示的步骤配置了内置的 NFS 和 TFTP 服务器。下一节演示了如何安装和配置 DHCP 服务器。在本示例中，用于 PXE 用户的文件的目录是 "
"[.filename]#/b/tftpboot/FreeBSD/install# 。重要的是，该目录存在，并且在 "
"[.filename]#/etc/inetd.conf# 和 [.filename]#/usr/local/etc/dhcpd.conf# "
"中设置了相同的目录名。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1991
#, fuzzy
msgid ""
"The command examples below assume use of the man:sh[1] shell.  man:csh[1] "
"and man:tcsh[1] users will need to start a man:sh[1] shell or adapt the "
"commands to man:csh[1] syntax."
msgstr ""
"下面的命令示例假设使用 man:sh[1] shell 。 man:csh[1] 和 man:tcsh[1] 用户需要启动一个 man:sh[1] "
"shell 或者根据 man:csh[1] 语法调整命令。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1995
#, fuzzy
msgid ""
"Create the root directory which will contain a FreeBSD installation to be "
"NFS mounted:"
msgstr "创建根目录，该目录将包含一个要进行 NFS 挂载的 FreeBSD 安装。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2000
#, no-wrap
msgid ""
"# export NFSROOTDIR=/b/tftpboot/FreeBSD/install\n"
"# mkdir -p ${NFSROOTDIR}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2003
#, fuzzy
msgid ""
"Enable the NFS server by adding this line to [.filename]#/etc/rc.conf#:"
msgstr "通过将以下行添加到 [.filename]#/etc/rc.conf# 来启用 NFS 服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2007
#, no-wrap
msgid "nfs_server_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2010
#, fuzzy
msgid ""
"Export the diskless root directory via NFS by adding the following to "
"[.filename]#/etc/exports#:"
msgstr "通过将以下内容添加到 [/etc/exports] ，将无磁盘根目录通过 NFS 导出："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2014
#, no-wrap
msgid "/b -ro -alldirs -maproot=root\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2017
#, fuzzy
msgid "Start the NFS server:"
msgstr "启动 NFS 服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2021
#, no-wrap
msgid "# service nfsd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2024
#, fuzzy
msgid ""
"Enable man:inetd[8] by adding the following line to "
"[.filename]#/etc/rc.conf#:"
msgstr "通过将以下行添加到 [.filename]#/etc/rc.conf# 来启用 man:inetd[8] ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2028
#, no-wrap
msgid "inetd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2031
#, fuzzy
msgid ""
"Uncomment the following line in [.filename]#/etc/inetd.conf# by making sure "
"it does not start with a `+#+` symbol:"
msgstr "请取消注释 [.filename]#/etc/inetd.conf# 中的以下行，确保它不以 `+#+` 符号开头："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2035
#, no-wrap
msgid ""
"tftp dgram udp wait root /usr/libexec/tftpd tftpd blocksize 1468 -l -s "
"/b/tftpboot\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2042
#, fuzzy
msgid ""
"The specified tftp blocksize, e.g. 1468 bytes, replaces the default size 512"
" bytes.  Some PXE versions require the TCP version of TFTP.  In this case, "
"uncomment the second `tftp` line which contains `stream tcp`."
msgstr ""
"指定的 tftp 块大小，例如 1468 字节，替换了默认大小 512 字节。某些 PXE 版本要求使用 TCP 版本的 TFTP "
"。在这种情况下，取消注释包含 `stream tcp` 的第二个 `tftp` 行。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2045
#, fuzzy
msgid "Start man:inetd[8]:"
msgstr "启动 man:inetd[8] ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2049
#, no-wrap
msgid "# service inetd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2052
#, fuzzy
msgid ""
"Install the base system into [.filename]#${NFSROOTDIR}#, either by "
"decompressing the official archives or by rebuilding the FreeBSD kernel and "
"userland (refer to crossref:cutting-edge[makeworld,“Updating FreeBSD from "
"Source”] for more detailed instructions, but do not forget to add "
"`DESTDIR=_${NFSROOTDIR}_` when running the `make installkernel` and `make "
"installworld` commands."
msgstr ""
"将基本系统安装到 [$ {NFSROOTDIR}]# $ {NFSROOTDIR}# 中，可以通过解压官方存档或重新构建 FreeBSD "
"内核和用户空间来完成（有关更详细的说明，请参阅 crossref:cutting-edge[makeworld ，“从源代码更新 FreeBSD ”] "
"，但在运行 `make installkernel` 和 `make installworld` 命令时不要忘记添加 `DESTDIR =_$ "
"{NFSROOTDIR}_` 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2053
#, fuzzy
msgid ""
"Test that the TFTP server works and can download the boot loader which will "
"be obtained via PXE:"
msgstr "测试 TFTP 服务器是否正常工作，并且能够通过 PXE 下载引导加载程序："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2059
#, no-wrap
msgid ""
"# tftp localhost\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2062
#, fuzzy
msgid ""
"Edit [.filename]#${NFSROOTDIR}/etc/fstab# and create an entry to mount the "
"root file system over NFS:"
msgstr "编辑 [.filename]# $ {NFSROOTDIR}/etc/fstab# 并创建一个条目以通过 NFS 挂载根文件系统："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2067
#, no-wrap
msgid ""
"# Device                                         Mountpoint    FSType   Options  Dump Pass\n"
"myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2071
#, fuzzy
msgid ""
"Replace _myhost.example.com_ with the hostname or IP address of the NFS "
"server.  In this example, the root file system is mounted read-only in order"
" to prevent NFS clients from potentially deleting the contents of the root "
"file system."
msgstr ""
"将 _myhost.example.com_ 替换为 NFS 服务器的主机名或 IP 地址。在这个例子中，根文件系统以只读方式挂载，以防止 NFS "
"客户端可能删除根文件系统的内容。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2072
#, fuzzy
msgid ""
"Set the root password in the PXE environment for client machines which are "
"PXE booting :"
msgstr "为通过 PXE 引导的客户机在 PXE 环境中设置根密码："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2077
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# passwd\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2080
#, fuzzy
msgid ""
"If needed, enable man:ssh[1] root logins for client machines which are PXE "
"booting by editing [.filename]#${NFSROOTDIR}/etc/ssh/sshd_config# and "
"enabling `PermitRootLogin`. This option is documented in man:sshd_config[5]."
msgstr ""
"如有需要，通过编辑 ` $ {NFSROOTDIR}/etc/ssh/sshd_config` 文件并启用 `PermitRootLogin` "
"选项，可以为使用 PXE 引导的客户机启用 `man:ssh[1]` 根登录。该选项在 `man:sshd_config[5]` 中有详细说明。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2081
#, fuzzy
msgid ""
"Perform any other needed customizations of the PXE environment in "
"[.filename]#${NFSROOTDIR}#. These customizations could include things like "
"installing packages or editing the password file with man:vipw[8]."
msgstr ""
"在 [.filename]# $ {NFSROOTDIR}# 中进行任何其他所需的 PXE 环境自定义。这些自定义可能包括安装软件包或使用 "
"man:vipw[8] 编辑密码文件。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2084
#, fuzzy
msgid ""
"When booting from an NFS root volume, [.filename]#/etc/rc# detects the NFS "
"boot and runs [.filename]#/etc/rc.initdiskless#.  In this case, "
"[.filename]#/etc# and [.filename]#/var# need to be memory backed file "
"systems so that these directories are writable but the NFS root directory is"
" read-only:"
msgstr ""
"当从 NFS 根卷引导时， [/etc/rc] 检测到 NFS 引导并运行 [/etc/rc.initdiskless] 。在这种情况下， [/etc]"
" 和 [/var] 需要是内存支持的文件系统，以便这些目录可写，但 NFS 根目录是只读的。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2091
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# mkdir -p conf/base\n"
"# tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc\n"
"# tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2096
#, fuzzy
msgid ""
"When the system boots, memory file systems for [.filename]#/etc# and "
"[.filename]#/var# will be created and mounted and the contents of the "
"[.filename]#cpio.gz# files will be copied into them.  By default, these file"
" systems have a maximum capacity of 5 megabytes.  If your archives do not "
"fit, which is usually the case for [.filename]#/var# when binary packages "
"have been installed, request a larger size by putting the number of 512 byte"
" sectors needed (e.g., 5 megabytes is 10240 sectors) in "
"[.filename]#${NFSROOTDIR}/conf/base/etc/md_size# and "
"[.filename]#${NFSROOTDIR}/conf/base/var/md_size# files for [.filename]#/etc#"
" and [.filename]#/var# file systems respectively."
msgstr ""
"当系统启动时，将创建并挂载 [.filename]#/etc# 和 [.filename]#/var# 的内存文件系统，并将 "
"[.filename]#cpio.gz# 文件的内容复制到其中。默认情况下，这些文件系统的最大容量为 5 兆字节。如果您的存档不适合，通常是 "
"[.filename]#/var# 安装了二进制包的情况下，可以通过在 [.filename]# $ "
"{NFSROOTDIR}/conf/base/etc/md_size# 和 [.filename]# $ "
"{NFSROOTDIR}/conf/base/var/md_size# 文件中放入所需的 512 字节扇区数（例如， 5 兆字节为 10240 "
"扇区）来请求更大的大小，分别用于 [.filename]#/etc# 和 [.filename]#/var# 文件系统。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2098
#, fuzzy, no-wrap
msgid "Configuring the DHCP Server"
msgstr "配置 DHCP 服务器"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2101
#, fuzzy
msgid ""
"The DHCP server does not need to be the same machine as the TFTP and NFS "
"server, but it needs to be accessible in the network."
msgstr "DHCP 服务器不需要与 TFTP 和 NFS 服务器位于同一台机器上，但它需要在网络中可访问。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2103
#, fuzzy
msgid ""
"DHCP is not part of the FreeBSD base system but can be installed using the "
"package:net/isc-dhcp44-server[] port or package."
msgstr ""
"DHCP 不是 FreeBSD 基本系统的一部分，但可以使用 package:net/isc-dhcp44-server[] 端口或包进行安装。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2106
#, fuzzy
msgid ""
"Once installed, edit the configuration file, "
"[.filename]#/usr/local/etc/dhcpd.conf#.  Configure the `next-server`, "
"`filename`, and `root-path` settings as seen in this example:"
msgstr ""
"安装完成后，编辑配置文件 [.filename]#/usr/local/etc/dhcpd.conf# 。根据以下示例配置 `next-server` "
"、 `filename` 和 `root-path` 设置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2116
#, no-wrap
msgid ""
"subnet 192.168.0.0 netmask 255.255.255.0 {\n"
"   range 192.168.0.2 192.168.0.3 ;\n"
"   option subnet-mask 255.255.255.0 ;\n"
"   option routers 192.168.0.1 ;\n"
"   option broadcast-address 192.168.0.255 ;\n"
"   option domain-name-servers 192.168.35.35, 192.168.35.36 ;\n"
"   option domain-name \"example.com\";\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2119
#, no-wrap
msgid ""
"   # IP address of TFTP server\n"
"   next-server 192.168.0.1 ;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2122
#, no-wrap
msgid ""
"   # path of boot loader obtained via tftp\n"
"   filename \"FreeBSD/install/boot/pxeboot\" ;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2125
#, no-wrap
msgid ""
"   # pxeboot boot loader will try to NFS mount this directory for root FS\n"
"   option root-path \"192.168.0.1:/b/tftpboot/FreeBSD/install/\" ;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2127
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2130
#, fuzzy
msgid ""
"The `next-server` directive is used to specify the IP address of the TFTP "
"server."
msgstr "`next-server` 指令用于指定 TFTP 服务器的 IP 地址。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2133
#, fuzzy
msgid ""
"The `filename` directive defines the path to [.filename]#/boot/pxeboot#.  A "
"relative filename is used, meaning that [.filename]#/b/tftpboot# is not "
"included in the path."
msgstr ""
"`filename` 指令定义了路径为 [.filename]#/boot/pxeboot# 的文件名。使用的是相对路径，这意味着路径中不包括 "
"[.filename]#/b/tftpboot# 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2135
#, fuzzy
msgid "The `root-path` option defines the path to the NFS root file system."
msgstr "`root-path` 选项定义了 NFS 根文件系统的路径。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2137
#, fuzzy
msgid ""
"Once the edits are saved, enable DHCP at boot time by adding the following "
"line to [.filename]#/etc/rc.conf#:"
msgstr "在保存编辑后，通过将以下行添加到 [.filename]#/etc/rc.conf# 来在启动时启用 DHCP ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2141
#, no-wrap
msgid "dhcpd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2144
#, fuzzy
msgid "Then start the DHCP service:"
msgstr "然后启动 DHCP 服务："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2148
#, no-wrap
msgid "# service isc-dhcpd start\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2150
#, fuzzy, no-wrap
msgid "Debugging PXE Problems"
msgstr "调试 PXE 问题"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2154
#, fuzzy
msgid ""
"Once all of the services are configured and started, PXE clients should be "
"able to automatically load FreeBSD over the network.  If a particular client"
" is unable to connect, when that client machine boots up, enter the BIOS "
"configuration menu and confirm that it is set to boot from the network."
msgstr ""
"一旦所有服务都配置并启动完成， PXE 客户端应该能够通过网络自动加载 FreeBSD 。如果某个特定的客户端无法连接，当该客户端机器启动时，进入 "
"BIOS 配置菜单并确认其设置为从网络启动。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2156
#, fuzzy
msgid ""
"This section describes some troubleshooting tips for isolating the source of"
" the configuration problem should no clients be able to PXE boot."
msgstr "本节介绍了一些故障排除技巧，用于确定配置问题的根源，以防止任何客户端无法进行 PXE 引导。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2160
#, fuzzy
msgid ""
"Use the package:net/wireshark[] package or port to debug the network traffic"
" involved during the PXE booting process, which is illustrated in the "
"diagram below."
msgstr "使用 package:net/wireshark[] 包或端口来调试 PXE 引导过程中涉及的网络流量，如下图所示。"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2161
#, fuzzy, no-wrap
msgid "PXE Booting Process with NFS Root Mount"
msgstr "PXE 引导过程与 NFS 根目录挂载"

#. type: Target for macro image
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2162
#, fuzzy, no-wrap
msgid "pxe-nfs.png"
msgstr "pxe-nfs.png 是一个文件名，无法直接翻译。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2165
#, fuzzy
msgid "Client broadcasts a DHCPDISCOVER message."
msgstr "客户端广播一个 DHCPDISCOVER 消息。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2167
#, fuzzy
msgid ""
"The DHCP server responds with the IP address, next-server, filename, and "
"root-path values."
msgstr "DHCP 服务器响应 IP 地址、 next-server 、 filename 和 root-path 的值。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2169
#, fuzzy
msgid ""
"The client sends a TFTP request to next-server, asking to retrieve filename."
msgstr "客户端向 next-server 发送一个 TFTP 请求，请求检索文件名。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2171
#, fuzzy
msgid "The TFTP server responds and sends filename to client."
msgstr "TFTP 服务器响应并向客户端发送文件名。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2173
#, fuzzy
msgid ""
"The client executes filename, which is pxeboot(8), which then loads the "
"kernel. When the kernel executes, the root file system specified by root-"
"path is mounted over NFS."
msgstr "客户端执行文件名为 pxeboot(8) ，然后加载内核。当内核执行时，通过 root-path 指定的根文件系统将通过 NFS 挂载。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2175
#, fuzzy
msgid ""
"On the TFTP server, read [.filename]#/var/log/xferlog# to ensure that "
"[.filename]#pxeboot# is being retrieved from the correct location. To test "
"this example configuration:"
msgstr "在 TFTP 服务器上，读取 [/var/log/xferlog] 以确保从正确的位置检索到 [pxeboot] 。要测试此示例配置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2181
#, no-wrap
msgid ""
"# tftp 192.168.0.1\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2184
#, fuzzy
msgid ""
"The `BUGS` sections in man:tftpd[8] and man:tftp[1] document some "
"limitations with TFTP."
msgstr "在 man:tftpd[8] 和 man:tftp[1] 中的 `BUGS` 部分记录了 TFTP 的一些限制。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2185
#, fuzzy
msgid ""
"Make sure that the root file system can be mounted via NFS. To test this "
"example configuration:"
msgstr "确保可以通过 NFS 挂载根文件系统。要测试此示例配置，请执行以下操作："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2189
#, no-wrap
msgid "# mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2192
#, fuzzy
msgid ""
"For UEFI PXE based booting, replace the [.filename]#boot/pxeboot# file with "
"the [.filename]#boot/loader.efi# file:"
msgstr ""
"对于基于 UEFI PXE 的引导，请将 [.filename]#boot/pxeboot# 文件替换为 "
"[.filename]#boot/loader.efi# 文件："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2197
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# mv boot/pxeboot boot/pxeboot.original\n"
"# cp boot/loader.efi boot/pxeboot\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2201
#, fuzzy, no-wrap
msgid "Common Address Redundancy Protocol (CARP)"
msgstr "常见地址冗余协议（ CARP ）"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2205
#, fuzzy
msgid ""
"The Common Address Redundancy Protocol (CARP) allows multiple hosts to share"
" the same IP address and Virtual Host ID (VHID) in order to provide _high "
"availability_ for one or more services.  This means that one or more hosts "
"can fail, and the other hosts will transparently take over so that users do "
"not see a service failure."
msgstr ""
"通用地址冗余协议（ CARP ）允许多个主机共享相同的 IP 地址和虚拟主机 ID （ VHID "
"），以提供一个或多个服务的高可用性。这意味着一个或多个主机可能会失败，而其他主机将自动接管，使用户无法看到服务中断。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2209
#, fuzzy
msgid ""
"In addition to the shared IP address, each host has its own IP address for "
"management and configuration.  All of the machines that share an IP address "
"have the same VHID.  The VHID for each virtual IP address must be unique "
"across the broadcast domain of the network interface."
msgstr ""
"除了共享的 IP 地址外，每个主机还有自己的 IP 地址用于管理和配置。共享同一个 IP 地址的所有机器具有相同的 VHID 。每个虚拟 IP 地址的 "
"VHID 必须在网络接口的广播域中是唯一的。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2212
#, fuzzy
msgid ""
"High availability using CARP is built into FreeBSD, though the steps to "
"configure it vary slightly depending upon the FreeBSD version.  This section"
" provides the same example configuration for versions before and equal to or"
" after FreeBSD 10."
msgstr ""
"在 FreeBSD 中，使用 CARP 实现高可用性是内置的，尽管根据 FreeBSD 的版本不同，配置步骤可能略有不同。本节提供了适用于 "
"FreeBSD 10 版本之前、以及等于或之后版本的相同示例配置。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2215
#, fuzzy
msgid ""
"This example configures failover support with three hosts, all with unique "
"IP addresses, but providing the same web content.  It has two different "
"masters named `hosta.example.org` and `hostb.example.org`, with a shared "
"backup named `hostc.example.org`."
msgstr ""
"这个示例配置了三个主机的故障转移支持，每个主机都有唯一的 IP 地址，但提供相同的网页内容。它有两个不同的主服务器，分别命名为 "
"`hosta.example.org` 和 `hostb.example.org` ，还有一个共享备份命名为 `hostc.example.org` 。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2222
#, fuzzy
msgid ""
"These machines are load balanced with a Round Robin DNS configuration.  The "
"master and backup machines are configured identically except for their "
"hostnames and management IP addresses.  These servers must have the same "
"configuration and run the same services.  When the failover occurs, requests"
" to the service on the shared IP address can only be answered correctly if "
"the backup server has access to the same content.  The backup machine has "
"two additional CARP interfaces, one for each of the master content server's "
"IP addresses.  When a failure occurs, the backup server will pick up the "
"failed master machine's IP address."
msgstr ""
"这些机器使用循环轮询 DNS 配置进行负载均衡。主备机器的配置完全相同，只是主机名和管理 IP "
"地址不同。这些服务器必须具有相同的配置并运行相同的服务。当发生故障切换时，只有当备份服务器可以访问相同的内容时，才能正确地回答共享 IP "
"地址上的服务请求。备份机器还有两个额外的 CARP 接口，分别用于主内容服务器的每个 IP 地址。当发生故障时，备份服务器将接管失败的主机器的 IP "
"地址。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2224
#, fuzzy, no-wrap
msgid "Using CARP on FreeBSD 10 and Later"
msgstr "在 FreeBSD 10 及更高版本上使用 CARP"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2227
#, fuzzy
msgid ""
"Enable boot-time support for CARP by adding an entry for the "
"[.filename]#carp.ko# kernel module in [.filename]#/boot/loader.conf#:"
msgstr "通过在 `/boot/loader.conf` 中为 `carp.ko` 内核模块添加条目，启用 CARP 的启动时支持。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2231
#, no-wrap
msgid "carp_load=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2234
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2315
#, fuzzy
msgid "To load the module now without rebooting:"
msgstr "立即加载模块而无需重新启动："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2238
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2319
#, no-wrap
msgid "# kldload carp\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2241
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2322
#, fuzzy
msgid ""
"For users who prefer to use a custom kernel, include the following line in "
"the custom kernel configuration file and compile the kernel as described in "
"crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]:"
msgstr ""
"对于喜欢使用自定义内核的用户，请在自定义内核配置文件中包含以下行，并按照 crossref:kernelconfig[kernelconfig , "
"Configuring the FreeBSD Kernel] 中描述的方式编译内核。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2245
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2326
#, no-wrap
msgid "device\tcarp\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2248
#, fuzzy
msgid ""
"The hostname, management IP address and subnet mask, shared IP address, and "
"VHID are all set by adding entries to [.filename]#/etc/rc.conf#. This "
"example is for `hosta.example.org`:"
msgstr ""
"主机名、管理 IP 地址和子网掩码、共享 IP 地址以及 VHID 都是通过向 [.filename]#/etc/rc.conf# "
"添加条目来设置的。以下示例适用于 `hosta.example.org` ："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2254
#, no-wrap
msgid ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 pass testpass alias 192.168.1.50/32\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2259
#, fuzzy
msgid ""
"The next set of entries are for `hostb.example.org`.  Since it represents a "
"second master, it uses a different shared IP address and VHID.  However, the"
" passwords specified with `pass` must be identical as CARP will only listen "
"to and accept advertisements from machines with the correct password."
msgstr ""
"下一组条目是针对 `hostb.example.org` 的。由于它代表了第二个主机，所以它使用了不同的共享 IP 地址和 VHID 。然而，使用 "
"`pass` 指定的密码必须相同，因为 CARP 只会监听和接受来自具有正确密码的机器的广告。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2265
#, no-wrap
msgid ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 2 pass testpass alias 192.168.1.51/32\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2270
#, fuzzy
msgid ""
"The third machine, `hostc.example.org`, is configured to handle failover "
"from either master.  This machine is configured with two CARPVHIDs, one to "
"handle the virtual IP address for each of the master hosts.  The CARP "
"advertising skew, `advskew`, is set to ensure that the backup host "
"advertises later than the master, since `advskew` controls the order of "
"precedence when there are multiple backup servers."
msgstr ""
"第三台机器 `hostc.example.org` 配置为处理来自任一主机的故障转移。该机器配置了两个 CARPVHID ，一个用于处理每个主机的虚拟 "
"IP 地址。 CARP 广告偏差 `advskew` 被设置为确保备份主机比主机广告晚，因为 `advskew` 控制多个备份服务器时的优先顺序。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2277
#, no-wrap
msgid ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32\"\n"
"ifconfig_em0_alias1=\"inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2281
#, fuzzy
msgid ""
"Having two CARPVHIDs configured means that `hostc.example.org` will notice "
"if either of the master servers becomes unavailable.  If a master fails to "
"advertise before the backup server, the backup server will pick up the "
"shared IP address until the master becomes available again."
msgstr ""
"配置了两个 CARPVHID 意味着 `hostc.example.org` "
"将会注意到主服务器中的任何一个不可用。如果主服务器在备份服务器之前无法进行广告宣传，备份服务器将会接管共享 IP 地址，直到主服务器再次可用。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2288
#, fuzzy
msgid ""
"If the original master server becomes available again, `hostc.example.org` "
"will not release the virtual IP address back to it automatically.  For this "
"to happen, preemption has to be enabled.  The feature is disabled by "
"default, it is controlled via the man:sysctl[8] variable "
"`net.inet.carp.preempt`.  The administrator can force the backup server to "
"return the IP address to the master:"
msgstr ""
"如果原始主服务器再次可用， `hostc.example.org` 不会自动将虚拟 IP "
"地址释放给它。要实现这一点，必须启用抢占功能。该功能默认情况下是禁用的，可以通过 `net.inet.carp.preempt` "
"变量来控制。管理员可以强制备份服务器将 IP 地址返回给主服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2292
#, no-wrap
msgid "# ifconfig em0 vhid 1 state backup\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2298
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2384
#, fuzzy
msgid ""
"Once the configuration is complete, either restart networking or reboot each"
" system.  High availability is now enabled."
msgstr "配置完成后，要么重新启动网络，要么重新启动每个系统。高可用性现在已启用。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2301
#, fuzzy
msgid ""
"CARP functionality can be controlled via several man:sysctl[8] variables "
"documented in the man:carp[4] manual pages.  Other actions can be triggered "
"from CARP events by using man:devd[8]."
msgstr ""
"CARP 功能可以通过 man:sysctl[8] 变量来控制，这些变量在 man:carp[4] 手册页中有详细说明。还可以使用 "
"man:devd[8] 来触发 CARP 事件的其他操作。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2303
#, fuzzy, no-wrap
msgid "Using CARP on FreeBSD 9 and Earlier"
msgstr "在 FreeBSD 9 及更早版本上使用 CARP"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2306
#, fuzzy
msgid ""
"The configuration for these versions of FreeBSD is similar to the one "
"described in the previous section, except that a CARP device must first be "
"created and referred to in the configuration."
msgstr "这些版本的 FreeBSD 的配置与前一节中描述的类似，只是首先必须创建一个 CARP 设备并在配置中引用它。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2308
#, fuzzy
msgid ""
"Enable boot-time support for CARP by loading the [.filename]#if_carp.ko# "
"kernel module in [.filename]#/boot/loader.conf#:"
msgstr ""
"通过在 [/boot/loader.conf] 中加载 [.filename]#if_carp.ko# 内核模块，启用 CARP 的启动时支持。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2312
#, no-wrap
msgid "if_carp_load=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2329
#, fuzzy
msgid "Next, on each host, create a CARP device:"
msgstr "接下来，在每台主机上创建一个 CARP 设备："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2333
#, no-wrap
msgid "# ifconfig carp0 create\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2338
#, fuzzy
msgid ""
"Set the hostname, management IP address, the shared IP address, and VHID by "
"adding the required lines to [.filename]#/etc/rc.conf#.  Since a virtual "
"CARP device is used instead of an alias, the actual subnet mask of `/24` is "
"used instead of `/32`.  Here are the entries for `hosta.example.org`:"
msgstr ""
"通过在 [.filename]#/etc/rc.conf# 中添加所需的行，设置主机名、管理 IP 地址、共享 IP 地址和 VHID 。由于使用虚拟 "
"CARP 设备而不是别名，所以使用实际的子网掩码 `/24` 而不是 `/32` 。以下是 `hosta.example.org` 的条目："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2345
#, no-wrap
msgid ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 1 pass testpass 192.168.1.50/24\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2348
#, fuzzy
msgid "On `hostb.example.org`:"
msgstr "在 `hostb.example.org` 上："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2355
#, no-wrap
msgid ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 2 pass testpass 192.168.1.51/24\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2358
#, fuzzy
msgid ""
"The third machine, `hostc.example.org`, is configured to handle failover "
"from either of the master hosts:"
msgstr "第三台机器 `hostc.example.org` 配置为处理来自任一主机的故障转移："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2366
#, no-wrap
msgid ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0 carp1\"\n"
"ifconfig_carp0=\"vhid 1 advskew 100 pass testpass 192.168.1.50/24\"\n"
"ifconfig_carp1=\"vhid 2 advskew 100 pass testpass 192.168.1.51/24\"\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2373
#, fuzzy
msgid ""
"Preemption is disabled in the [.filename]#GENERIC# FreeBSD kernel.  If "
"preemption has been enabled with a custom kernel, `hostc.example.org` may "
"not release the IP address back to the original content server.  The "
"administrator can force the backup server to return the IP address to the "
"master with the command:"
msgstr ""
"在 [.filename]#GENERIC# FreeBSD 内核中禁用了抢占。如果使用自定义内核启用了抢占， `hostc.example.org` "
"可能无法将 IP 地址释放回原始内容服务器。管理员可以使用以下命令强制备份服务器将 IP 地址返回给主服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2377
#, no-wrap
msgid "# ifconfig carp0 down && ifconfig carp0 up\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2380
#, fuzzy
msgid ""
"This should be done on the [.filename]#carp# interface which corresponds to "
"the correct host."
msgstr "这应该在与正确主机对应的 [.filename]#carp# 接口上完成。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2386
#, fuzzy, no-wrap
msgid "VLANs"
msgstr "虚拟局域网（ VLANs ）"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2390
#, fuzzy
msgid ""
"VLANs are a way of virtually dividing up a network into many different "
"subnetworks, also referred to as segmenting.  Each segment will have its own"
" broadcast domain and be isolated from other VLANs."
msgstr "VLAN （虚拟局域网）是一种将网络虚拟分割成许多不同子网络的方法，也被称为分段。每个分段都有自己的广播域，并与其他 VLAN 隔离开来。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2393
#, fuzzy
msgid ""
"On FreeBSD, VLANs must be supported by the network card driver.  To see "
"which drivers support vlans, refer to the man:vlan[4] manual page."
msgstr ""
"在 FreeBSD 上， VLAN 必须由网络适配器驱动程序支持。要查看哪些驱动程序支持 VLAN ，请参考 man:vlan[4] 手册页。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2396
#, fuzzy
msgid ""
"When configuring a VLAN, a couple pieces of information must be known.  "
"First, which network interface? Second, what is the VLAN tag?"
msgstr "配置 VLAN 时，需要了解一些信息。首先，是哪个网络接口？其次， VLAN 标签是什么？"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2398
#, fuzzy
msgid ""
"To configure VLANs at run time, with a NIC of `em0` and a VLAN tag of `5` "
"the command would look like this:"
msgstr "要在运行时配置 VLAN ，使用网卡 `em0` 和 VLAN 标签 `5` ，命令如下："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2402
#, no-wrap
msgid "# ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2407
#, fuzzy
msgid ""
"See how the interface name includes the NIC driver name and the VLAN tag, "
"separated by a period? This is a best practice to make maintaining the VLAN "
"configuration easy when many VLANs are present on a machine."
msgstr ""
"看到接口名称包括了网卡驱动名称和 VLAN 标签，用句点分隔吗？这是一种最佳实践，可以在一个机器上存在多个 VLAN 时，方便维护 VLAN 配置。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2411
#, fuzzy
msgid ""
"To configure VLANs at boot time, [.filename]#/etc/rc.conf# must be updated."
"  To duplicate the configuration above, the following will need to be added:"
msgstr "要在启动时配置 VLAN ，必须更新 `/etc/rc.conf` 文件。要复制上述配置，需要添加以下内容："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2416
#, no-wrap
msgid ""
"vlans_em0=\"5\"\n"
"ifconfig_em0_5=\"inet 192.168.20.20/24\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2419
#, fuzzy
msgid ""
"Additional VLANs may be added, by simply adding the tag to the `vlans_em0` "
"field and adding an additional line configuring the network on that VLAN "
"tag's interface."
msgstr "可以通过简单地将标签添加到 `vlans_em0` 字段，并添加一行额外的配置网络的代码来添加其他 VLAN 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2423
#, fuzzy
msgid ""
"It is useful to assign a symbolic name to an interface so that when the "
"associated hardware is changed, only a few configuration variables need to "
"be updated.  For example, security cameras need to be run over VLAN 1 on "
"`em0`.  Later, if the `em0` card is replaced with a card that uses the "
"man:ixgb[4] driver, all references to `em0.1` will not have to change to "
"`ixgb0.1`."
msgstr ""
"为了在关联的硬件发生更改时只需要更新少量配置变量，给接口分配一个符号名称是很有用的。例如，安全摄像头需要在 `em0` 上运行 VLAN 1 "
"。如果以后将 `em0` 卡替换为使用 man:ixgb[4] 驱动程序的卡，所有对 `em0.1` 的引用都不需要更改为 `ixgb0.1` 。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2425
#, fuzzy
msgid ""
"To configure VLAN `5`, on the NIC `em0`, assign the interface name "
"`cameras`, and assign the interface an IP address of `_192.168.20.20_` with "
"a `24`-bit prefix, use this command:"
msgstr ""
"要配置 VLAN `5` ，在网卡 `em0` 上分配接口名称 `cameras` ，并为接口分配 IP 地址 `_192.168.20.20_` "
"，使用 `24` 位前缀，使用以下命令："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2429
#, no-wrap
msgid ""
"# ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet "
"192.168.20.20/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2432
#, fuzzy
msgid "For an interface named `video`, use the following:"
msgstr "对于名为 `video` 的接口，请使用以下内容："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2436
#, no-wrap
msgid ""
"# ifconfig video.5 create vlan 5 vlandev video name cameras inet "
"192.168.20.20/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2439
#, fuzzy
msgid ""
"To apply the changes at boot time, add the following lines to "
"[.filename]#/etc/rc.conf#:"
msgstr "要在启动时应用更改，请将以下行添加到 [/etc/rc.conf] 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2445
#, no-wrap
msgid ""
"vlans_video=\"cameras\"\n"
"create_args_cameras=\"vlan 5\"\n"
"ifconfig_cameras=\"inet 192.168.20.20/24\"\n"
msgstr ""
