# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR The FreeBSD Project
# This file is distributed under the same license as the FreeBSD Documentation package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: FreeBSD Documentation VERSION\n"
"POT-Creation-Date: 2023-12-17 04:24+0000\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: YAML Front Matter: description
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, fuzzy, no-wrap
msgid ""
"Advanced networking in FreeBSD:  basics of gateways and routes, CARP, how to"
" configure multiple VLANs on FreeBSD, etc"
msgstr "在FreeBSD中的高级网络配置：网关和路由的基础知识，CARP（冗余地址协议）以及在FreeBSD中配置多个VLAN的方法等。"

#. type: YAML Front Matter: part
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, fuzzy, no-wrap
msgid "IV. Network Communication"
msgstr "IV. 网络通信"

#. type: YAML Front Matter: title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1
#, fuzzy, no-wrap
msgid "Chapter 34. Advanced Networking"
msgstr "第34章. 高级网络"

#. type: Title =
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:14
#, fuzzy, no-wrap
msgid "Advanced Networking"
msgstr "高级网络技术"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:39
#, fuzzy
msgid ""
"include::shared/attributes/attributes-{{% lang %}}.adoc[] "
"include::shared/{{% lang %}}/teams.adoc[] include::shared/{{% lang "
"%}}/mailing-lists.adoc[] include::shared/{{% lang %}}/urls.adoc[]"
msgstr ""
"include::shared/attributes/attributes-zh_CN.adoc[] "
"include::shared/zh_CN/teams.adoc[] include::shared/zh_CN/mailing-"
"lists.adoc[] include::shared/zh_CN/urls.adoc[]"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:52
#, fuzzy, no-wrap
msgid "Synopsis"
msgstr "概要"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:55
#, fuzzy
msgid "This chapter covers a number of advanced networking topics."
msgstr "本章涵盖了一系列高级网络主题。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:57
#, fuzzy
msgid "After reading this chapter, you will know:"
msgstr "阅读完本章后，您将了解以下内容："

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:59
#, fuzzy
msgid "The basics of gateways and routes."
msgstr "网关和路由的基础知识。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:60
#, fuzzy
msgid "How to set up USB tethering."
msgstr ""
"如何设置USB网络共享。\n"
"\n"
"USB网络共享（USB tethering）是一种通过USB连接将移动设备连接到计算机并共享其互联网连接的方法。以下是设置USB网络共享的步骤：\n"
"1. 确保您的移动设备和计算机都支持USB网络共享功能。\n"
"2. 使用USB数据线将移动设备连接到计算机的USB接口。\n"
"3. 在移动设备的设置菜单中找到“网络共享”或“USB网络共享”选项。\n"
"4. 启用USB网络共享选项。\n"
"5. 在计算机上，打开网络设置。\n"
"6. 在网络设置中，找到可用的网络连接选项。\n"
"7. 找到以移动设备的名称命名的网络连接选项。\n"
"8. 连接到该网络连接选项。\n"
"9. 现在您的计算机应该能够通过移动设备的互联网连接进行上网。\n"
"请注意，不同的移动设备和操作系统可能会有略微不同的设置过程，因此请根据您自己的设备和操作系统进行相应的调整。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:61
#, fuzzy
msgid "How to set up IEEE(R) 802.11 and Bluetooth(R) devices."
msgstr "如何设置IEEE(R) 802.11和Bluetooth(R)设备。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:62
#, fuzzy
msgid "How to make FreeBSD act as a bridge."
msgstr ""
"如何使FreeBSD作为一个桥接器。\n"
"\n"
"要将FreeBSD配置为桥接器，需要进行以下步骤：\n"
"\n"
"1. 确保系统已安装FreeBSD操作系统，并以管理员身份登录。\n"
"\n"
"2. 编辑网络配置文件，请运行以下命令以打开文件编辑器：\n"
"```\n"
"sudo vi /etc/rc.conf\n"
"```\n"
"\n"
"3. 在文件中，添加以下配置以使FreeBSD作为桥接器：\n"
"```\n"
"cloned_interfaces=\"bridge0\"\n"
"ifconfig_bridge0=\"addm em0 addm em1 up\"\n"
"```\n"
"其中，`em0`和`em1`是桥接器的接口名称，你可以将其替换为实际的接口名称。\n"
"\n"
"4. 执行以下命令以启动桥接器：\n"
"```\n"
"sudo service netif restart\n"
"```\n"
"\n"
"这样，FreeBSD就被配置为桥接器，可以转发网络流量了。请记住，在配置桥接器时，确保正确设置网络接口和连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:63
#, fuzzy
msgid "How to set up network PXE booting."
msgstr ""
"如何设置网络PXE引导。\n"
"\n"
"PXE（Preboot Execution Environment，预启动执行环境）是一种计算机网络协议，用于在局域网中设置和管理网络引导。以下是设置网络PXE引导的步骤：\n"
"\n"
"1. 确保计算机上的网络接口卡（NIC）支持PXE引导，并且已经启用了PXE功能。\n"
"2. 配置DHCP服务器，以便在网络引导时分配IP地址、网关和DNS服务器。同时，在DHCP服务器上设置引导文件的位置。\n"
"3. 设置TFTP服务器，以便在网络引导时从客户端下载引导文件。\n"
"4. 准备引导文件，通常是操作系统的映像文件（如ISO文件）或引导加载器（如GRUB）。\n"
"5. 将引导文件放置在TFTP服务器的指定目录中，并确保客户端能够访问该位置。\n"
"6. 配置客户端以启用PXE引导。这可以在计算机的BIOS或UEFI设置中完成，具体方法取决于计算机的制造商和型号。\n"
"7. 启动客户端计算机，并选择使用PXE引导。计算机将向DHCP服务器请求IP地址，并从TFTP服务器下载引导文件。\n"
"8. 完成上述步骤后，客户端计算机将能够通过网络引导，并根据引导文件的指示继续安装或加载操作系统。\n"
"\n"
"请注意，网络PXE引导的设置可能因操作系统、硬件和网络环境而有所不同。建议参考特定操作系统和硬件的文档或厂商提供的指南以获取详细的设置步骤和配置参数。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:64
#, fuzzy
msgid ""
"How to enable and utilize the features of the Common Address Redundancy "
"Protocol (CARP) in FreeBSD."
msgstr "如何在FreeBSD中启用和利用Common Address Redundancy Protocol（CARP）的功能。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:65
#, fuzzy
msgid "How to configure multiple VLANs on FreeBSD."
msgstr ""
"如何在FreeBSD上配置多个VLAN。\n"
"\n"
"配置FreeBSD上的多个VLAN的步骤如下：\n"
"\n"
"1. 确保网络适配器支持VLAN，并已正确连接到交换机。\n"
"2. 修改 `/etc/rc.conf` 文件，在其中添加适当的网络适配器配置。\n"
"   例如，如果您的网络适配器是 `em0`，您可以添加以下行：\n"
"   ```\n"
"   ifconfig_em0=\"up\"\n"
"   ```\n"
"   如果您需要配置多个VLAN，您可以添加以下行：\n"
"   ```\n"
"   ifconfig_em0_alias0=\"vlan 10 vlandev em0\"\n"
"   ifconfig_em0_alias1=\"vlan 20 vlandev em0\"\n"
"   ```\n"
"   这样就会创建两个名为 `vlan10` 和 `vlan20` 的虚拟网络适配器。\n"
"3. 重新启动网络服务以使更改生效：\n"
"   ```\n"
"   /etc/rc.d/netif restart\n"
"   ```\n"
"4. 检查 VLAN 配置是否成功：\n"
"   使用 `ifconfig` 命令检查适配器列表，应该会看到新创建的虚拟适配器。\n"
"   ```\n"
"   ifconfig\n"
"   ```\n"
"   使用 `ifconfig vlanX` 命令检查特定的 VLAN 配置，X 代表 VLAN 号码。\n"
"   ```\n"
"   ifconfig vlan10\n"
"   ifconfig vlan20\n"
"   ```\n"
"\n"
"通过执行上述步骤，您可以在FreeBSD上成功配置多个VLAN。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:66
#, fuzzy
msgid "Configure bluetooth headset."
msgstr "配置蓝牙耳机。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:68
#, fuzzy
msgid "Before reading this chapter, you should:"
msgstr "在阅读本章之前，您应该："

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:70
#, fuzzy
msgid "Understand the basics of the [.filename]#/etc/rc# scripts."
msgstr "了解 [.filename]#/etc/rc# 脚本的基础知识。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:71
#, fuzzy
msgid "Be familiar with basic network terminology."
msgstr "熟悉基本的网络术语。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:72
#, fuzzy
msgid ""
"Understand basic network configuration on FreeBSD "
"(crossref:network[network,FreeBSD network])."
msgstr ""
"在FreeBSD上了解基本的网络配置（参考crossref:network[network, FreeBSD network]）。\n"
"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:73
#, fuzzy
msgid ""
"Know how to configure and install a new FreeBSD kernel "
"(crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel])."
msgstr "了解如何配置和安装新的 FreeBSD 内核（参考:kernelconfig[kernelconfig,配置 FreeBSD 内核]）。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:74
#, fuzzy
msgid ""
"Know how to install additional third-party software "
"(crossref:ports[ports,Installing Applications: Packages and Ports])."
msgstr "知道如何安装额外的第三方软件（crossref：ports [ports，安装应用程序：软件包和端口]）。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:76
#, fuzzy, no-wrap
msgid "Gateways and Routes"
msgstr "网关和路由"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:85
#, fuzzy
msgid ""
"_Routing_ is the mechanism that allows a system to find the network path to "
"another system.  A _route_ is a defined pair of addresses which represent "
"the \"destination\" and a \"gateway\".  The route indicates that when trying"
" to get to the specified destination, send the packets through the specified"
" gateway.  There are three types of destinations: individual hosts, subnets,"
" and \"default\".  The \"default route\" is used if no other routes apply.  "
"There are also three types of gateways: individual hosts, interfaces, also "
"called links, and Ethernet hardware (MAC) addresses.  Known routes are "
"stored in a routing table."
msgstr ""
"_路由_ 是一种机制，允许系统找到到另一个系统的网络路径。一个 _路由_ "
"是一对定义好的地址，表示\"目的地\"和\"网关\"。路由表明在尝试到达指定目的地时，将数据包通过指定的网关发送。有三种类型的目的地：个别主机、子网和 "
"\"默认\" 。如果没有其他路由适用，将使用 "
"\"默认路由\"。网关也有三种类型：个别主机、接口（也称为连接点）和以太网硬件（MAC）地址。已知的路由存储在路由表中。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:88
#, fuzzy
msgid ""
"This section provides an overview of routing basics.  It then demonstrates "
"how to configure a FreeBSD system as a router and offers some "
"troubleshooting tips."
msgstr "本节提供了路由基础知识的概述。然后演示了如何将FreeBSD系统配置为路由器，并提供了一些故障排除技巧。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:90
#, fuzzy, no-wrap
msgid "Routing Basics"
msgstr ""
"路由基础\n"
"\n"
"路由是计算机网络中的关键概念之一。它指的是决定将数据包从源地址发送到目的地址的过程。在互联网中，路由器是负责执行这一任务的网络设备。\n"
"\n"
"路由在网络通信中起着重要作用。它通过查看数据包的目的地址，使用路由表中的信息确定下一跳，并将数据包转发到正确的目的地。通过这种方式，路由器可以将数据包从一个网络转发到另一个网络，使得不同局域网或广域网之间能够相互通信。\n"
"\n"
"路由还可以根据特定的路由策略，如最短路径、最快路径或负载均衡来选择最佳路径。这样可以提高网络的性能和可靠性。\n"
"\n"
"理解和掌握路由基础对于网络管理员和网络工程师来说是至关重要的，因为它是网络通信的基础，并直接影响网络的性能和可用性。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:93
#, fuzzy
msgid "To view the routing table of a FreeBSD system, use man:netstat[1]:"
msgstr "要查看FreeBSD系统的路由表，请使用man:netstat[1]命令。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:98
#, no-wrap
msgid ""
"% netstat -r\n"
"Routing tables\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:110
#, no-wrap
msgid ""
"Internet:\n"
"Destination      Gateway            Flags     Refs     Use     Netif Expire\n"
"default          outside-gw         UGS        37      418       em0\n"
"localhost        localhost          UH          0      181       lo0\n"
"test0            0:e0:b5:36:cf:4f   UHLW        5    63288       re0     77\n"
"10.20.30.255     link#1             UHLW        1     2421\n"
"example.com      link#1             UC          0        0\n"
"host1            0:e0:a8:37:8:1e    UHLW        3     4601       lo0\n"
"host2            0:e0:a8:37:8:1e    UHLW        0        5       lo0 =>\n"
"host2.example.com link#1            UC          0        0\n"
"224              link#1             UC          0        0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:113
#, fuzzy
msgid "The entries in this example are as follows:"
msgstr "这个例子中的条目如下："

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:114
#, fuzzy, no-wrap
msgid "default"
msgstr "默认"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:118
#, fuzzy
msgid ""
"The first route in this table specifies the `default` route.  When the local"
" system needs to make a connection to a remote host, it checks the routing "
"table to determine if a known path exists.  If the remote host matches an "
"entry in the table, the system checks to see if it can connect using the "
"interface specified in that entry."
msgstr ""
"这个表中的第一条路由指定了 "
"`default`（默认）路由。当本地系统需要与远程主机建立连接时，它会检查路由表以确定是否存在已知路径。如果远程主机在表中有匹配的条目，系统会检查是否可以使用该条目中指定的接口进行连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:122
#, fuzzy
msgid ""
"If the destination does not match an entry, or if all known paths fail, the "
"system uses the entry for the default route.  For hosts on a local area "
"network, the `Gateway` field in the default route is set to the system which"
" has a direct connection to the Internet.  When reading this entry, verify "
"that the `Flags` column indicates that the gateway is usable (`UG`)."
msgstr ""
"如果目的地与条目不匹配，或者所有已知路径都失败，系统将使用默认路由的条目。对于局域网上的主机，\"Gateway\"字段在默认路由中被设置为直接连接互联网的系统。在阅读这个条目时，请确保\"Flags\"列指示网关是可用的（`UG`）。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:124
#, fuzzy
msgid ""
"The default route for a machine which itself is functioning as the gateway "
"to the outside world will be the gateway machine at the Internet Service "
"Provider (ISP)."
msgstr "一个作为外界的网关的机器的默认路由将是互联网服务提供商（ISP）的网关机器。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:125
#, fuzzy, no-wrap
msgid "localhost"
msgstr "本地主机"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:129
#, fuzzy
msgid ""
"The second route is the `localhost` route.  The interface specified in the "
"`Netif` column for `localhost` is [.filename]#lo0#, also known as the "
"loopback device.  This indicates that all traffic for this destination "
"should be internal, rather than sending it out over the network."
msgstr ""
"第二条路由是`localhost`路由。在`Netif`列中指定了`localhost`的接口为`.filename`#lo0#，也被称为回环设备。这表明所有针对此目的地的流量都应该是内部流量，而不是通过网络发送出去。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:130
#, fuzzy, no-wrap
msgid "MAC address"
msgstr "MAC地址（Media Access Control Address）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:136
#, fuzzy
msgid ""
"The addresses beginning with `0:e0:` are MAC addresses.  FreeBSD will "
"automatically identify any hosts, `test0` in the example, on the local "
"Ethernet and add a route for that host over the Ethernet interface, "
"[.filename]#re0#.  This type of route has a timeout, seen in the `Expire` "
"column, which is used if the host does not respond in a specific amount of "
"time.  When this happens, the route to this host will be automatically "
"deleted.  These hosts are identified using the Routing Information Protocol "
"(RIP), which calculates routes to local hosts based upon a shortest path "
"determination."
msgstr ""
"以`0:e0:`开头的地址是MAC地址。在FreeBSD中，系统会自动识别在本地以太网上的主机（如例子中的`test0`），并在以太网接口（即`re0`）上添加一个路由。这种类型的路由具有超时时间（在`Expire`列中可见），如果主机在特定时间内没有响应，则该路由将被自动删除。这些主机是通过路由信息协议（RIP）来识别的，该协议根据最短路径确定来计算到本地主机的路由。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:137
#, fuzzy, no-wrap
msgid "subnet"
msgstr "子网"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:141
#, fuzzy
msgid ""
"FreeBSD will automatically add subnet routes for the local subnet.  In this "
"example, `10.20.30.255` is the broadcast address for the subnet `10.20.30` "
"and `example.com` is the domain name associated with that subnet.  The "
"designation `link#1` refers to the first Ethernet card in the machine."
msgstr ""
"FreeBSD会自动添加本地子网的子网路由。在这个例子中，`10.20.30.255`是子网`10.20.30`的广播地址，`example.com`是与该子网关联的域名。`link#1`的指定是指机器上的第一个以太网卡。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:144
#, fuzzy
msgid ""
"Local network hosts and local subnets have their routes automatically "
"configured by a daemon called man:routed[8].  If it is not running, only "
"routes which are statically defined by the administrator will exist."
msgstr ""
"局域网主机和本地子网的路由会由一个叫做 man:routed[8] 的守护进程自动配置。如果该进程未运行，则只会存在由管理员静态定义的路由。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:145
#, fuzzy, no-wrap
msgid "host"
msgstr "主机"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:148
#, fuzzy
msgid ""
"The `host1` line refers to the host by its Ethernet address.  Since it is "
"the sending host, FreeBSD knows to use the loopback interface "
"([.filename]#lo0#) rather than the Ethernet interface."
msgstr ""
"`host1` 行是根据其以太网地址指定的主机。由于它是发送主机，FreeBSD "
"知道要使用环回接口（[.filename]#lo0#），而不是以太网接口。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:152
#, fuzzy
msgid ""
"The two `host2` lines represent aliases which were created using "
"man:ifconfig[8].  The `=>` symbol after the [.filename]#lo0# interface says "
"that an alias has been set in addition to the loopback address.  Such routes"
" only show up on the host that supports the alias and all other hosts on the"
" local network will have a `link#1` line for such routes."
msgstr ""
"两行 `host2` 代表使用 man:ifconfig[8] 创建的别名。在 [.filename]#lo0# 接口后的 `=>` "
"符号表示除回环地址外，已设置了一个别名。这样的路由只在支持别名的主机上显示，而本地网络中的其他主机将具有针对此类路由的 `link#1` 行。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:153
#, fuzzy, no-wrap
msgid "224"
msgstr "内容无法翻译，因为它不符合 asciidoc 格式的规范。请提供符合规范的文本，以便我进行翻译。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:155
#, fuzzy
msgid "The final line (destination subnet `224`) deals with multicasting."
msgstr "最后一行（目标子网`224`）处理多播。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:158
#, fuzzy
msgid ""
"Various attributes of each route can be seen in the `Flags` column.  "
"<<routeflags>> summarizes some of these flags and their meanings:"
msgstr "每个路由的各种属性可以在“Flags”列中看到。<<routeflags>>总结了一些标志及其含义："

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:160
#, fuzzy, no-wrap
msgid "Commonly Seen Routing Table Flags"
msgstr ""
"常见的路由表标记\n"
"\n"
"Routing table中经常出现的标记有："

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:164
#, fuzzy, no-wrap
msgid "Flag"
msgstr "标记"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:166
#, fuzzy, no-wrap
msgid "Purpose"
msgstr "目的"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:167
#, fuzzy, no-wrap
msgid "U"
msgstr "U"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:169
#, fuzzy, no-wrap
msgid "The route is active (up)."
msgstr "该路由已激活（上线）。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:170
#, fuzzy, no-wrap
msgid "H"
msgstr "H"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:172
#, fuzzy, no-wrap
msgid "The route destination is a single host."
msgstr "路由目的地是单个主机。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:173
#, fuzzy, no-wrap
msgid "G"
msgstr "抱歉，您的消息不完整，请提供更多的信息。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:175
#, fuzzy, no-wrap
msgid ""
"Send anything for this destination on to this gateway, which will figure out"
" from there where to send it."
msgstr "将任何东西发送到这个目的地上，发送到这个网关上，网关会从那里找出应该将它发送到哪里。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:176
#, fuzzy, no-wrap
msgid "S"
msgstr "S"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:178
#, fuzzy, no-wrap
msgid "This route was statically configured."
msgstr "这个路由是静态配置的。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:179
#, fuzzy, no-wrap
msgid "C"
msgstr ""
"C是一种通用的编程语言，广泛用于计算机科学和软件开发领域。它是一种结构化的、高效的语言，被用于开发操作系统、嵌入式系统和各种应用程序。C语言具有强大的控制流程和内存管理能力，并且支持低级别编程。它是一种面向过程的语言，有丰富的库函数和工具可供使用。C语言的语法简洁而灵活，使得开发者可以更加精确和高效地编写代码。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:181
#, fuzzy, no-wrap
msgid ""
"Clones a new route based upon this route for machines to connect to. This "
"type of route is normally used for local networks."
msgstr "为了让设备连接到网络，基于这个路由克隆一个新的路由。这种类型的路由通常用于本地网络。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:182
#, fuzzy, no-wrap
msgid "W"
msgstr "W"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:184
#, fuzzy, no-wrap
msgid ""
"The route was auto-configured based upon a local area network (clone) route."
msgstr "该路由是基于本地网络（副本）路由的自动配置。"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:185
#, fuzzy, no-wrap
msgid "L"
msgstr "L"

#. type: Table
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:186
#, fuzzy, no-wrap
msgid "Route involves references to Ethernet (link) hardware."
msgstr "路由器涉及对以太网（链路）硬件的引用。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:189
#, fuzzy
msgid ""
"On a FreeBSD system, the default route can defined in "
"[.filename]#/etc/rc.conf# by specifying the IP address of the default "
"gateway:"
msgstr "在FreeBSD系统上，默认路由可以在`/etc/rc.conf`中定义，通过指定默认网关的IP地址来实现："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:193
#, no-wrap
msgid "defaultrouter=\"10.20.30.1\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:196
#, fuzzy
msgid "It is also possible to manually add the route using `route`:"
msgstr "还可以通过使用 `route` 命令手动添加路由："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:200
#, no-wrap
msgid "# route add default 10.20.30.1\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:204
#, fuzzy
msgid ""
"Note that manually added routes will not survive a reboot.  For more "
"information on manual manipulation of network routing tables, refer to "
"man:route[8]."
msgstr "请注意，手动添加的路由表在重新启动后将失效。有关手动操作网络路由表的更多信息，请参阅 man:route[8]。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:206
#, fuzzy, no-wrap
msgid "Configuring a Router with Static Routes"
msgstr ""
"使用静态路由配置路由器\n"
"\n"
"=== Introduction\n"
"\n"
"Static routes are a way to manually configure the routing table on a router. With static routes, network administrators can specify the path that network traffic should take by defining specific routes.\n"
"\n"
"In this document, we will explain how to configure a router with static routes.\n"
"\n"
"=== Prerequisites\n"
"\n"
"Before configuring static routes, make sure you have the following information:\n"
"\n"
"1. The IP addresses of the networks you want to reach.\n"
"2. The IP addresses of the next-hop routers that will forward traffic to those networks.\n"
"3. The administrative distance and metric values for the routes.\n"
"\n"
"=== Steps to Configure Static Routes\n"
"\n"
"To configure static routes on a router, follow these steps:\n"
"\n"
"1. Access the router's command line interface (CLI) using a telnet or SSH client.\n"
"2. Enter privileged EXEC mode by entering the enable command.\n"
"3. Enter global configuration mode by entering the configure terminal command.\n"
"4. Specify the static route using the following command:\n"
"```asciidoc\n"
"ip route <destination_network> <netmask> <next_hop_ip>\n"
"```\n"
"Replace `<destination_network>` with the IP address of the network you want to reach, `<netmask>` with the network mask, and `<next_hop_ip>` with the IP address of the next-hop router.\n"
"5. (Optional) Set the administrative distance and metric values for the route using the following command:\n"
"```asciidoc\n"
"ip route <destination_network> <netmask> <next_hop_ip> <administrative_distance> <metric>\n"
"```\n"
"Replace `<administrative_distance>` with the desired administrative distance value and `<metric>` with the desired metric value.\n"
"6. Repeat steps 4-5 for each static route you want to configure.\n"
"7. Save the configuration using the following command:\n"
"```asciidoc\n"
"write memory\n"
"```\n"
"\n"
"=== Conclusion\n"
"\n"
"Configuring a router with static routes allows network administrators to have more control over the path that network traffic takes. By manually defining specific routes, administrators can optimize the network's performance and ensure efficient data transfer."

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:211
#, fuzzy
msgid ""
"A FreeBSD system can be configured as the default gateway, or router, for a "
"network if it is a dual-homed system.  A dual-homed system is a host which "
"resides on at least two different networks.  Typically, each network is "
"connected to a separate network interface, though IP aliasing can be used to"
" bind multiple addresses, each on a different subnet, to one physical "
"interface."
msgstr ""
"如果FreeBSD系统是一个双主机系统，则可以将其配置为网络的默认网关或路由器。双主机系统是位于至少两个不同网络上的主机。通常，每个网络连接到一个单独的网络接口，尽管IP别名可以用于将多个地址绑定到一个物理接口上，每个地址都位于不同的子网上。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:214
#, fuzzy
msgid ""
"In order for the system to forward packets between interfaces, FreeBSD must "
"be configured as a router.  Internet standards and good engineering practice"
" prevent the FreeBSD Project from enabling this feature by default, but it "
"can be configured to start at boot by adding this line to "
"[.filename]#/etc/rc.conf#:"
msgstr ""
"为了让系统在接口之间转发数据包，需要将FreeBSD配置为路由器。互联网标准和良好的工程实践要求FreeBSD项目不将此功能默认启用，但可以通过在[.filename]#/etc/rc.conf#中添加以下行来在启动时配置：\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:218
#, no-wrap
msgid ""
"gateway_enable=\"YES\"          # Set to YES if this host will be a "
"gateway\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:222
#, fuzzy
msgid ""
"To enable routing now, set the man:sysctl[8] variable "
"`net.inet.ip.forwarding` to `1`.  To stop routing, reset this variable to "
"`0`."
msgstr ""
"要立即启用路由功能，请将 man:sysctl[8] 变量 `net.inet.ip.forwarding` 设置为 "
"`1`。要停止路由功能，请将此变量重置为 `0`。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:226
#, fuzzy
msgid ""
"The routing table of a router needs additional routes so it knows how to "
"reach other networks.  Routes can be either added manually using static "
"routes or routes can be automatically learned using a routing protocol.  "
"Static routes are appropriate for small networks and this section describes "
"how to add a static routing entry for a small network."
msgstr ""
"路由器的路由表需要添加额外的路由，以便知道如何到达其他网络。可以通过手动添加静态路由或使用路由协议自动学习路由来添加路由。静态路由适用于小型网络，本节将介绍如何为小型网络添加静态路由条目。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:232
#, fuzzy
msgid ""
"For large networks, static routes quickly become unscalable.  FreeBSD comes "
"with the standard BSD routing daemon man:routed[8], which provides the "
"routing protocols RIP, versions 1 and 2, and IRDP.  Support for the BGP and "
"OSPF routing protocols can be installed using the package:net/quagga[] "
"package or port."
msgstr ""
"对于大型网络来说，静态路由很快变得不可扩展。FreeBSD配备了标准的BSD路由守护进程man:routed[8]，它提供了RIP版本1和2以及IRDP的路由协议支持。可以使用包:net/quagga[]包或端口安装BGP和OSPF路由协议的支持。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:235
#, fuzzy
msgid "Consider the following network:"
msgstr "考虑以下网络："

#. type: Target for macro image
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:236
#, fuzzy, no-wrap
msgid "static-routes.png"
msgstr "static-routes.png 是一个静态路由的示意图。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:241
#, fuzzy
msgid ""
"In this scenario, `RouterA` is a FreeBSD machine that is acting as a router "
"to the rest of the Internet.  It has a default route set to `10.0.0.1` which"
" allows it to connect with the outside world.  `RouterB` is already "
"configured to use `192.168.1.1` as its default gateway."
msgstr ""
"在这个场景中，`RouterA` 是一台运行 FreeBDS 的机器，作为连接到互联网的路由器。它设置了一个默认路由 "
"`10.0.0.1`，使其能够与外部世界建立连接。`RouterB` 已配置使用 `192.168.1.1` 作为默认网关。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:243
#, fuzzy
msgid ""
"Before adding any static routes, the routing table on `RouterA` looks like "
"this:"
msgstr "在添加任何静态路由之前，`RouterA` 上的路由表如下所示："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:248
#, no-wrap
msgid ""
"% netstat -nr\n"
"Routing tables\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:255
#, no-wrap
msgid ""
"Internet:\n"
"Destination        Gateway            Flags    Refs      Use  Netif  Expire\n"
"default            10.0.0.1           UGS         0    49378    xl0\n"
"127.0.0.1          127.0.0.1          UH          0        6    lo0\n"
"10.0.0.0/24        link#1             UC          0        0    xl0\n"
"192.168.1.0/24     link#2             UC          0        0    xl1\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:259
#, fuzzy
msgid ""
"With the current routing table, `RouterA` does not have a route to the "
"`192.168.2.0/24` network.  The following command adds the `Internal Net 2` "
"network to ``RouterA``'s routing table using `192.168.1.2` as the next hop:"
msgstr ""
"根据当前的路由表，`RouterA`没有到达`192.168.2.0/24`网络的路由。下面的命令使用`192.168.1.2`作为下一跳，将`Internal"
" Net 2`网络添加到`RouterA`的路由表中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:263
#, no-wrap
msgid "# route add -net 192.168.2.0/24 192.168.1.2\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:268
#, fuzzy
msgid ""
"Now, `RouterA` can reach any host on the `192.168.2.0/24` network.  However,"
" the routing information will not persist if the FreeBSD system reboots.  If"
" a static route needs to be persistent, add it to [.filename]#/etc/rc.conf#:"
msgstr ""
"现在，`RouterA`可以到达`192.168.2.0/24`网络上的任何主机。然而，如果FreeBSD系统重新启动，路由信息将不会持久化。如果需要静态路由保持持久化，将其添加到[.filename]#/etc/rc.conf#文件中。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:274
#, no-wrap
msgid ""
"# Add Internal Net 2 as a persistent static route\n"
"static_routes=\"internalnet2\"\n"
"route_internalnet2=\"-net 192.168.2.0/24 192.168.1.2\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:278
#, fuzzy
msgid ""
"The `static_routes` configuration variable is a list of strings separated by"
" a space, where each string references a route name.  The variable "
"`route_internalnet2` contains the static route for that route name."
msgstr ""
"`static_routes` 配置变量是一个由空格分隔的字符串列表，其中每个字符串引用一个路由名称。变量 `route_internalnet2` "
"包含了该路由名称的静态路由。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:281
#, fuzzy
msgid ""
"Using more than one string in `static_routes` creates multiple static "
"routes.  The following shows an example of adding static routes for the "
"`192.168.0.0/24` and `192.168.1.0/24` networks:"
msgstr ""
"在`static_routes`中使用多个字符串可以创建多个静态路由。以下是为`192.168.0.0/24`和`192.168.1.0/24`网络添加静态路由的示例："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:287
#, no-wrap
msgid ""
"static_routes=\"net1 net2\"\n"
"route_net1=\"-net 192.168.0.0/24 192.168.0.1\"\n"
"route_net2=\"-net 192.168.1.0/24 192.168.1.1\"\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:290
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1321
#, fuzzy, no-wrap
msgid "Troubleshooting"
msgstr "故障排除"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:294
#, fuzzy
msgid ""
"When an address space is assigned to a network, the service provider "
"configures their routing tables so that all traffic for the network will be "
"sent to the link for the site.  But how do external sites know to send their"
" packets to the network's ISP?"
msgstr ""
"当一个地址空间被分配给一个网络时，服务提供商会配置他们的路由表，以便将所有针对该网络的流量发送到该站点的链路上。但是外部站点如何知道将其数据包发送到网络的"
" ISP？"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:297
#, fuzzy
msgid ""
"There is a system that keeps track of all assigned address spaces and "
"defines their point of connection to the Internet backbone, or the main "
"trunk lines that carry Internet traffic across the country and around the "
"world.  Each backbone machine has a copy of a master set of tables, which "
"direct traffic for a particular network to a specific backbone carrier, and "
"from there down the chain of service providers until it reaches a particular"
" network."
msgstr ""
"有一个系统来跟踪所有分配的地址空间，并定义它们与互联网骨干网的连接点，即承载互联网流量跨越国家和全球的主干线路。每个骨干机都有一个主要的表集副本，它将特定网络的流量指向特定的骨干运营商，然后通过服务提供商链路传递，直到到达特定网络。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:300
#, fuzzy
msgid ""
"It is the task of the service provider to advertise to the backbone sites "
"that they are the point of connection, and thus the path inward, for a site."
"  This is known as route propagation."
msgstr "将作为服务提供商的任务是向骨干网站宣传他们是连接点，从而成为某个站点的内部路径。这被称为路由传播。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:304
#, fuzzy
msgid ""
"Sometimes, there is a problem with route propagation and some sites are "
"unable to connect.  Perhaps the most useful command for trying to figure out"
" where routing is breaking down is `traceroute`.  It is useful when `ping` "
"fails."
msgstr ""
"有时，路由传播存在问题，一些站点无法连接。尝试弄清楚路由故障位置最有用的命令可能是`traceroute`。当`ping`失败时，它非常有用。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:308
#, fuzzy
msgid ""
"When using `traceroute`, include the address of the remote host to connect "
"to.  The output will show the gateway hosts along the path of the attempt, "
"eventually either reaching the target host, or terminating because of a lack"
" of connection.  For more information, refer to man:traceroute[8]."
msgstr ""
"在使用 `traceroute` "
"命令时，需要包含要连接的远程主机的地址。输出结果将显示连接尝试路径上的网关主机，最终要么达到目标主机，要么因缺乏连接而终止。如需了解更多信息，请参阅 "
"man:traceroute[8]。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:310
#, fuzzy, no-wrap
msgid "Multicast Considerations"
msgstr "多播考虑因素"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:315
#, fuzzy
msgid ""
"FreeBSD natively supports both multicast applications and multicast routing."
"  Multicast applications do not require any special configuration in order "
"to run on FreeBSD.  Support for multicast routing requires that the "
"following option be compiled into a custom kernel:"
msgstr "FreeBSD原生支持多播应用和多播路由。在FreeBSD上运行多播应用不需要任何特殊配置。支持多播路由需要将以下选项编译进定制内核中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:319
#, no-wrap
msgid "options MROUTING\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:325
#, fuzzy
msgid ""
"The multicast routing daemon, mrouted can be installed using the "
"package:net/mrouted[] package or port.  This daemon implements the DVMRP "
"multicast routing protocol and is configured by editing "
"[.filename]#/usr/local/etc/mrouted.conf# in order to set up the tunnels and "
"DVMRP.  The installation of mrouted also installs map-mbone and mrinfo, as "
"well as their associated man pages.  Refer to these for configuration "
"examples."
msgstr ""
"使用软件包:net/mrouted[]或端口安装多播路由守护程序，mrouted。该守护程序实现了DVMRP多播路由协议，并通过编辑文件[# "
"/usr/local/etc/mrouted.conf#]来进行配置，从而设置隧道和DVMRP。安装mrouted还会安装map-"
"mbone和mrinfo，以及它们对应的手册页。请参考这些手册页以获取配置示例。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:330
#, fuzzy
msgid ""
"DVMRP has largely been replaced by the PIM protocol in many multicast "
"installations.  Refer to man:pim[4] for more information."
msgstr "在许多组播网络中，DVMRP已经在很大程度上被PIM协议所取代。有关更多信息，请参阅man:pim[4]。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:333
#, fuzzy, no-wrap
msgid "Virtual Hosts"
msgstr "虚拟主机"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:337
#, fuzzy
msgid ""
"A common use of FreeBSD is virtual site hosting, where one server appears to"
" the network as many servers.  This is achieved by assigning multiple "
"network addresses to a single interface."
msgstr "FreeBSD常见的用途之一是虚拟站点托管，其中一个服务器以多个服务器的形式呈现给网络。这是通过给单个接口分配多个网络地址来实现的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:340
#, fuzzy
msgid ""
"A given network interface has one \"real\" address, and may have any number "
"of \"alias\" addresses.  These aliases are normally added by placing alias "
"entries in [.filename]#/etc/rc.conf#, as seen in this example:"
msgstr ""
"一个给定的网络接口有一个“真实”的地址，以及任意数量的“别名”地址。这些别名通常是通过在/etc/rc.conf文件中添加别名条目来添加的，如下面的示例所示："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:344
#, no-wrap
msgid ""
"# sysrc ifconfig_fxp0_alias0=\"inet xxx.xxx.xxx.xxx netmask "
"xxx.xxx.xxx.xxx\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:348
#, fuzzy
msgid ""
"Alias entries must start with `alias__0__` using a sequential number such as"
" `alias0`, `alias1`, and so on.  The configuration process will stop at the "
"first missing number."
msgstr ""
"别名条目必须以`alias__0__`开头，使用顺序编号，例如`alias0`，`alias1`等等。配置过程将在遇到第一个缺失的编号时停止。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:352
#, fuzzy
msgid ""
"The calculation of alias netmasks is important.  For a given interface, "
"there must be one address which correctly represents the network's netmask."
"  Any other addresses which fall within this network must have a netmask of "
"all ``1``s, expressed as either `255.255.255.255` or `0xffffffff`."
msgstr ""
"别名子网掩码的计算非常重要。对于给定的接口，必须有一个地址能正确表示网络的子网掩码。任何其他落在该网络范围内的地址都必须具有全“1”的子网掩码，可以表示为`255.255.255.255`或`0xffffffff`。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:357
#, fuzzy
msgid ""
"For example, consider the case where the `fxp0` interface is connected to "
"two networks: `10.1.1.0` with a netmask of `255.255.255.0` and `202.0.75.16`"
" with a netmask of `255.255.255.240`.  The system is to be configured to "
"appear in the ranges `10.1.1.1` through `10.1.1.5` and `202.0.75.17` through"
" `202.0.75.20`.  Only the first address in a given network range should have"
" a real netmask.  All the rest (`10.1.1.2` through `10.1.1.5` and "
"`202.0.75.18` through `202.0.75.20`) must be configured with a netmask of "
"`255.255.255.255`."
msgstr ""
"例如，考虑以下情况，`fxp0`接口连接到两个网络：一个是网络`10.1.1.0`，子网掩码为`255.255.255.0`，另一个是网络`202.0.75.16`，子网掩码为`255.255.255.240`。系统需要配置为显示在范围`10.1.1.1`到`10.1.1.5`和`202.0.75.17`到`202.0.75.20`内。在给定的网络范围内，只有第一个地址需要有真正的子网掩码。其余地址（`10.1.1.2`到`10.1.1.5`和`202.0.75.18`到`202.0.75.20`）必须配置子网掩码为`255.255.255.255`。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:359
#, fuzzy
msgid ""
"The following [.filename]#/etc/rc.conf# entries configure the adapter "
"correctly for this scenario:"
msgstr "以下是用于此场景正确配置适配器的[.filename]#/etc/rc.conf#条目："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:371
#, no-wrap
msgid ""
"# sysrc ifconfig_fxp0=\"inet 10.1.1.1 netmask 255.255.255.0\"\n"
"# sysrc ifconfig_fxp0_alias0=\"inet 10.1.1.2 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias1=\"inet 10.1.1.3 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias2=\"inet 10.1.1.4 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias3=\"inet 10.1.1.5 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias4=\"inet 202.0.75.17 netmask 255.255.255.240\"\n"
"# sysrc ifconfig_fxp0_alias5=\"inet 202.0.75.18 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias6=\"inet 202.0.75.19 netmask 255.255.255.255\"\n"
"# sysrc ifconfig_fxp0_alias7=\"inet 202.0.75.20 netmask 255.255.255.255\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:375
#, fuzzy
msgid ""
"A simpler way to express this is with a space-separated list of IP address "
"ranges.  The first address will be given the indicated subnet mask and the "
"additional addresses will have a subnet mask of `255.255.255.255`."
msgstr ""
"一个更简单的表达方式是使用以空格分隔的IP地址范围列表。第一个地址将使用指定的子网掩码，而其他的地址将使用`255.255.255.255`作为子网掩码。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:379
#, no-wrap
msgid ""
"# sysrc ifconfig_fxp0_aliases=\"inet 10.1.1.1-5/24 inet "
"202.0.75.17-20/28\"\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:382
#, fuzzy, no-wrap
msgid "Wireless Advanced Authentication"
msgstr "无线高级认证"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:386
#, fuzzy
msgid ""
"FreeBSD supports different ways of connecting to a wireless network.  This "
"section describes how to perform advanced authentication to a Wireless "
"Network."
msgstr "FreeBSD 支持不同的连接无线网络的方式。本节介绍如何对无线网络进行高级认证。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:388
#, fuzzy
msgid ""
"To make a connection and basic authentication to a wireless network the "
"section crossref:network[wireless-authentication,Connection and "
"Authentication to a Wireless Network] in the Network Chapter describes how "
"to do it."
msgstr ""
"要连接和进行基本身份验证到无线网络，可以参考网络章节中的crossref:network[wireless-"
"authentication,连接和身份验证到无线网络]一节中的说明。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:390
#, fuzzy, no-wrap
msgid "WPA with EAP-TLS"
msgstr "WPA与EAP-TLS"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:395
#, fuzzy
msgid ""
"The second way to use WPA is with an 802.1X backend authentication server.  "
"In this case, WPA is called WPA Enterprise to differentiate it from the less"
" secure WPA Personal.  Authentication in WPA Enterprise is based on the "
"Extensible Authentication Protocol (EAP)."
msgstr ""
"使用WPA的第二种方式是使用802.1X后端认证服务器。在这种情况下，WPA被称为WPA企业版，以区别于更不安全的WPA个人版。WPA企业版中的认证是基于可扩展认证协议（EAP）进行的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:399
#, fuzzy
msgid ""
"EAP does not come with an encryption method.  Instead, EAP is embedded "
"inside an encrypted tunnel.  There are many EAP authentication methods, but "
"EAP-TLS, EAP-TTLS, and EAP-PEAP are the most common."
msgstr ""
"EAP（扩展认证协议）不附带加密方法。相反，EAP被嵌入在一个加密的隧道中。有许多EAP认证方法，但EAP-TLS、EAP-TTLS和EAP-"
"PEAP是最常见的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:403
#, fuzzy
msgid ""
"EAP with Transport Layer Security (EAP-TLS) is a well-supported wireless "
"authentication protocol since it was the first EAP method to be certified by"
" the http://www.wi-fi.org/[Wi-Fi Alliance].  EAP-TLS requires three "
"certificates to run: the certificate of the Certificate Authority (CA) "
"installed on all machines, the server certificate for the authentication "
"server, and one client certificate for each wireless client.  In this EAP "
"method, both the authentication server and wireless client authenticate each"
" other by presenting their respective certificates, and then verify that "
"these certificates were signed by the organization's CA."
msgstr ""
"基于传输层安全性（EAP-TLS）的EAP是一种得到广泛支持的无线身份验证协议，因为它是首个由[Wi-Fi联盟](http://www.wi-"
"fi.org/)认证的EAP方法。EAP-"
"TLS需要三个证书才能运行：安装在所有设备上的证书颁发机构（CA）的证书，用于身份验证服务器的服务器证书，以及每个无线客户端的客户端证书。在这种EAP方法中，身份验证服务器和无线客户端通过呈现各自的证书进行互相认证，然后验证这些证书是由组织的CA签名的。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:405
#, fuzzy
msgid ""
"As previously, the configuration is done via "
"[.filename]#/etc/wpa_supplicant.conf#:"
msgstr "和之前一样，配置是通过 [.filename]#/etc/wpa_supplicant.conf# 文件进行的："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:419
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\" <.>\n"
"  proto=RSN  <.>\n"
"  key_mgmt=WPA-EAP <.>\n"
"  eap=TLS <.>\n"
"  identity=\"loader\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  client_cert=\"/etc/certs/clientcert.pem\" <.>\n"
"  private_key=\"/etc/certs/clientkey.pem\" <.>\n"
"  private_key_passwd=\"freebsdmallclient\" <.>\n"
"}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:430
#, fuzzy
msgid ""
"<.> This field indicates the network name (SSID).  <.> This example uses the"
" RSN IEEE(R) 802.11i protocol, also known as WPA2.  <.> The `key_mgmt` line "
"refers to the key management protocol to use. In this example, it is WPA "
"using EAP authentication.  <.> This field indicates the EAP method for the "
"connection.  <.> The `identity` field contains the identity string for EAP."
"  <.> The `ca_cert` field indicates the pathname of the CA certificate file."
" This file is needed to verify the server certificate.  <.> The "
"`client_cert` line gives the pathname to the client certificate file. This "
"certificate is unique to each wireless client of the network.  <.> The "
"`private_key` field is the pathname to the client certificate private key "
"file.  <.> The `private_key_passwd` field contains the passphrase for the "
"private key."
msgstr ""
"<.> 这个字段表示网络名称（SSID）。<.> 这个例子使用了 RSN IEEE(R) 802.11i 协议，也被称为 WPA2。 <.> "
"`key_mgmt` 行是指要使用的密钥管理协议。在这个例子中，使用的是使用 EAP 验证的 WPA。 <.> 这个字段表示连接的 EAP 方法。 "
"<.> `identity` 字段包含用于 EAP 的标识字符串。 <.> `ca_cert` 字段指示 CA "
"证书文件的路径名。这个文件用于验证服务器证书。 <.> `client_cert` "
"行给出了客户端证书文件的路径名。这个证书对于网络的每个无线客户端都是唯一的。 <.> `private_key` 字段是客户端证书私钥文件的路径名。 "
"<.> `private_key_passwd` 字段包含私钥的密码短语。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:432
#, fuzzy
msgid "Then, add the following lines to [.filename]#/etc/rc.conf#:"
msgstr "然后，在文件[/etc/rc.conf]中添加以下行："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:437
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:499
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:570
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA DHCP\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:440
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:502
#, fuzzy
msgid "The next step is to bring up the interface:"
msgstr "下一步是启动界面："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:459
#, no-wrap
msgid ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:462
#, fuzzy
msgid ""
"It is also possible to bring up the interface manually using "
"man:wpa_supplicant[8] and man:ifconfig[8]."
msgstr "还可以使用 man:wpa_supplicant[8] 和 man:ifconfig[8] 手动启动接口。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:464
#, fuzzy, no-wrap
msgid "WPA with EAP-TTLS"
msgstr "使用EAP-TTLS的WPA"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:470
#, fuzzy
msgid ""
"With EAP-TLS, both the authentication server and the client need a "
"certificate.  With EAP-TTLS, a client certificate is optional.  This method "
"is similar to a web server which creates a secure SSL tunnel even if "
"visitors do not have client-side certificates.  EAP-TTLS uses an encrypted "
"TLS tunnel for safe transport of the authentication data."
msgstr ""
"采用EAP-TLS协议，认证服务器和客户端均需要证书。采用EAP-"
"TTLS协议时，客户端证书是可选项。这种方法类似于Web服务器创建一个安全的SSL隧道，即使访问者没有客户端证书。EAP-"
"TTLS使用加密的TLS隧道来安全地传输认证数据。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:472
#, fuzzy
msgid ""
"The required configuration can be added to "
"[.filename]#/etc/wpa_supplicant.conf#:"
msgstr "所需的配置可以添加到```/etc/wpa_supplicant.conf```文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:485
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=TTLS <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase2=\"auth=MD5\" <.>\n"
"}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:492
#, fuzzy
msgid ""
"<.> This field specifies the EAP method for the connection.  <.> The "
"`identity` field contains the identity string for EAP authentication inside "
"the encrypted TLS tunnel.  <.> The `password` field contains the passphrase "
"for the EAP authentication.  <.> The `ca_cert` field indicates the pathname "
"of the CA certificate file. This file is needed to verify the server "
"certificate.  <.> This field specifies the authentication method used in the"
" encrypted TLS tunnel. In this example, EAP with MD5-Challenge is used. The "
"\"inner authentication\" phase is often called \"phase2\"."
msgstr ""
"此字段指定连接的EAP方法。 `identity`字段包含在加密的TLS隧道内进行EAP身份验证的标识字符串。 "
"`password`字段包含EAP身份验证的密码。 "
"`ca_cert`字段指示CA证书文件的路径名。需要该文件来验证服务器证书。此字段指定在加密的TLS隧道中使用的身份验证方法。在此示例中，使用了MD5-Challenge的EAP。\"内部认证\"阶段通常称为\"第二阶段\"。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:494
#, fuzzy
msgid "Next, add the following lines to [.filename]#/etc/rc.conf#:"
msgstr "接下来，将以下行添加到 [.filename]#/etc/rc.conf# 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:522
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:593
#, no-wrap
msgid ""
"# service netif start\n"
"Starting wpa_supplicant.\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 7\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 15\n"
"DHCPREQUEST on wlan0 to 255.255.255.255 port 67 interval 21\n"
"DHCPACK from 192.168.0.20\n"
"bound to 192.168.0.254 -- renewal in 300 seconds.\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> mtu 1500\n"
"      ether 00:11:95:d5:43:62\n"
"      inet 192.168.0.254 netmask 0xffffff00 broadcast 192.168.0.255\n"
"      media: IEEE 802.11 Wireless Ethernet DS/11Mbps mode 11g\n"
"      status: associated\n"
"      ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"      country US ecm authmode WPA2/802.11i privacy ON deftxkey UNDEF\n"
"      AES-CCM 3:128-bit txpower 21.5 bmiss 7 scanvalid 450 bgscan\n"
"      bgscanintvl 300 bgscanidle 250 roam:rssi 7 roam:rate 5 protmode CTS\n"
"      wme burst roaming MANUAL\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:525
#, fuzzy, no-wrap
msgid "WPA with EAP-PEAP"
msgstr "WPA与EAP-PEAP"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:531
#, fuzzy
msgid ""
"PEAPv0/EAP-MSCHAPv2 is the most common PEAP method.  In this chapter, the "
"term PEAP is used to refer to that method."
msgstr "PEAPv0/EAP-MSCHAPv2 是最常见的 PEAP 方法。在本章中，术语 PEAP 用于指代该方法。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:535
#, fuzzy
msgid ""
"Protected EAP (PEAP) is designed as an alternative to EAP-TTLS and is the "
"most used EAP standard after EAP-TLS.  In a network with mixed operating "
"systems, PEAP should be the most supported standard after EAP-TLS."
msgstr ""
"Protected EAP (PEAP) 是作为 EAP-TTLS 的替代方案设计的，在 EAP-TLS 之后是最常用的 EAP "
"标准。在一个有多种操作系统的网络中，PEAP 应该是仅次于 EAP-TLS 的最受支持的标准。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:539
#, fuzzy
msgid ""
"PEAP is similar to EAP-TTLS as it uses a server-side certificate to "
"authenticate clients by creating an encrypted TLS tunnel between the client "
"and the authentication server, which protects the ensuing exchange of "
"authentication information.  PEAP authentication differs from EAP-TTLS as it"
" broadcasts the username in the clear and only the password is sent in the "
"encrypted TLS tunnel.  EAP-TTLS will use the TLS tunnel for both the "
"username and password."
msgstr ""
"PEAP（受保护的可扩展身份验证协议）与EAP-"
"TTLS（受保护的可扩展身份验证隧道化协议）类似，它们都使用服务器端证书验证客户端，通过在客户端和身份验证服务器之间创建加密的TLS隧道来保护后续的身份验证信息交换。但是，PEAP身份验证与EAP-"
"TTLS有所不同，它会明文广播用户名，而只有密码会被发送到加密的TLS隧道中。而EAP-TTLS将同时使用TLS隧道来传输用户名和密码。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:541
#, fuzzy
msgid ""
"Add the following lines to [.filename]#/etc/wpa_supplicant.conf# to "
"configure the EAP-PEAP related settings:"
msgstr "将以下行添加到 [filename]#/etc/wpa_supplicant.conf# 以配置与 EAP-PEAP 相关的设置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:555
#, no-wrap
msgid ""
"network={\n"
"  ssid=\"freebsdap\"\n"
"  proto=RSN\n"
"  key_mgmt=WPA-EAP\n"
"  eap=PEAP <.>\n"
"  identity=\"test\" <.>\n"
"  password=\"test\" <.>\n"
"  ca_cert=\"/etc/certs/cacert.pem\" <.>\n"
"  phase1=\"peaplabel=0\" <.>\n"
"  phase2=\"auth=MSCHAPV2\" <.>\n"
"}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:563
#, fuzzy
msgid ""
"<.> This field specifies the EAP method for the connection.  <.> The "
"`identity` field contains the identity string for EAP authentication inside "
"the encrypted TLS tunnel.  <.> The `password` field contains the passphrase "
"for the EAP authentication.  <.> The `ca_cert` field indicates the pathname "
"of the CA certificate file. This file is needed to verify the server "
"certificate.  <.> This field contains the parameters for the first phase of "
"authentication, the TLS tunnel. According to the authentication server used,"
" specify a specific label for authentication. Most of the time, the label "
"will be \"client EAP encryption\" which is set by using `peaplabel=0`. More "
"information can be found in man:wpa_supplicant.conf[5].  <.> This field "
"specifies the authentication protocol used in the encrypted TLS tunnel. In "
"the case of PEAP, it is `auth=MSCHAPV2`."
msgstr ""
"<.> 这个字段指定了连接的 EAP 方法。\n"
"<.> `identity` 字段包含在加密的 TLS 隧道内进行 EAP 身份验证所需的标识字符串。\n"
"<.> `password` 字段包含 EAP 身份验证的密码。\n"
"<.> `ca_cert` 字段指定 CA 证书文件的路径名。该文件用于验证服务器证书。\n"
"<.> 这个字段包含认证的第一阶段，也就是 TLS 隧道的参数。根据使用的认证服务器，指定一个特定的认证标签。大多数情况下，标签将是使用 `peaplabel=0` 设置的 \"client EAP encryption\"。更多信息可以在 man:wpa_supplicant.conf[5] 中找到。\n"
"<.> 这个字段指定了在加密的 TLS 隧道中使用的认证协议。对于 PEAP，是 `auth=MSCHAPV2`。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:565
#, fuzzy
msgid "Add the following to [.filename]#/etc/rc.conf#:"
msgstr "将以下内容添加到 [.filename]#/etc/rc.conf# 文件中："

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:573
#, fuzzy
msgid "Then, bring up the interface:"
msgstr "然后，打开界面："

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:596
#, fuzzy, no-wrap
msgid "Wireless Ad-hoc Mode"
msgstr "无线自组织模式"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:600
#, fuzzy
msgid ""
"IBSS mode, also called ad-hoc mode, is designed for point to point "
"connections.  For example, to establish an ad-hoc network between the "
"machines `A` and `B`, choose two IP addresses and a SSID."
msgstr ""
"IBSS 模式，也称为 ad-hoc 模式，专为点对点连接而设计。例如，要在计算机 `A` 和 `B` 之间建立一个 ad-hoc 网络，选择两个 IP"
" 地址和一个 SSID。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:602
#, fuzzy
msgid "On `A`:"
msgstr "在 `A` 上："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:616
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:619
#, fuzzy
msgid ""
"The `adhoc` parameter indicates that the interface is running in IBSS mode."
msgstr "`adhoc`参数表示接口正在以IBSS模式运行。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:621
#, fuzzy
msgid "`B` should now be able to detect `A`:"
msgstr "现在，`B` 应该能够检测到 `A`。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:628
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode adhoc\n"
"# ifconfig wlan0 up scan\n"
"  SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"  freebsdap       02:11:95:c3:0d:ac    2   54M -64:-96  100 IS   WME\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:632
#, fuzzy
msgid ""
"The `I` in the output confirms that `A` is in ad-hoc mode.  Now, configure "
"`B` with a different IP address:"
msgstr "输出中的`I`确认了`A`处于自适应模式。现在，配置`B`使用不同的IP地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:645
#, no-wrap
msgid ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <adhoc>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 2 (2417 Mhz 11g) bssid 02:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:648
#, fuzzy
msgid "Both `A` and `B` are now ready to exchange information."
msgstr "现在，`A`和`B`都准备好交换信息了。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:650
#, fuzzy, no-wrap
msgid "FreeBSD Host Access Points"
msgstr "FreeBSD 主机访问点"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:654
#, fuzzy
msgid ""
"FreeBSD can act as an Access Point (AP) which eliminates the need to buy a "
"hardware AP or run an ad-hoc network.  This can be particularly useful when "
"a FreeBSD machine is acting as a gateway to another network such as the "
"Internet."
msgstr ""
"FreeBSD可以用作接入点（AP），这样就不需要购买硬件AP或运行自组网。当FreeBSD机器作为另一个网络（如互联网）的网关时，这特别有用。"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:656
#, fuzzy, no-wrap
msgid "Basic Settings"
msgstr "基本设置"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:660
#, fuzzy
msgid ""
"Before configuring a FreeBSD machine as an AP, the kernel must be configured"
" with the appropriate networking support for the wireless card as well as "
"the security protocols being used.  For more details, see <<network-"
"wireless-basic>>."
msgstr ""
"在将FreeBSD机器配置为接入点之前，必须为无线网卡配置适当的网络支持和所使用的安全协议。有关更多详细信息，请参阅《network-wireless-"
"basic》。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:665
#, fuzzy
msgid ""
"The NDIS driver wrapper for Windows(R) drivers does not currently support AP"
" operation.  Only native FreeBSD wireless drivers support AP mode."
msgstr ""
"当前，用于 Windows(R) 驱动程序的 NDIS 驱动程序包装器不支持 AP 操作。只有原生的 FreeBSD 无线驱动程序支持 AP 模式。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:668
#, fuzzy
msgid ""
"Once wireless networking support is loaded, check if the wireless device "
"supports the host-based access point mode, also known as hostap mode:"
msgstr "加载无线网络支持后，检查无线设备是否支持基于主机的访问点模式，也称为主机接入点模式（Hostap模式）："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:675
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 list caps\n"
"drivercaps=6f85edc1<STA,FF,TURBOP,IBSS,HOSTAP,AHDEMO,TXPMGT,SHSLOT,SHPREAMBLE,MONITOR,MBSS,WPA1,WPA2,BURST,WME,WDS,BGSCAN,TXFRAG>\n"
"cryptocaps=1f<WEP,TKIP,AES,AES_CCM,TKIPMIC>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:681
#, fuzzy
msgid ""
"This output displays the card's capabilities.  The `HOSTAP` word confirms "
"that this wireless card can act as an AP.  Various supported ciphers are "
"also listed: WEP, TKIP, and AES.  This information indicates which security "
"protocols can be used on the AP."
msgstr ""
"这个输出显示了该卡的功能。`HOSTAP`一词确认了这个无线网卡可以充当AP。还列出了各种支持的加密方式：WEP、TKIP和AES。这些信息指示了在AP上可以使用哪些安全协议。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:683
#, fuzzy
msgid ""
"The wireless device can only be put into hostap mode during the creation of "
"the network pseudo-device, so a previously created device must be destroyed "
"first:"
msgstr "在创建网络伪设备时，无线设备只能被设置为 hostap 模式，因此先前创建的设备必须首先被销毁："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:687
#, no-wrap
msgid "# ifconfig wlan0 destroy\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:690
#, fuzzy
msgid ""
"then regenerated with the correct option before setting the other "
"parameters:"
msgstr "在设置其他参数之前，使用正确的选项重新生成。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:695
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0 wlanmode hostap\n"
"# ifconfig wlan0 inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:698
#, fuzzy
msgid ""
"Use man:ifconfig[8] again to see the status of the [.filename]#wlan0# "
"interface:"
msgstr "再次使用 man:ifconfig[8] 命令查看 wlan0 接口的状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:710
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:c3:0d:ac\n"
"\t  inet 192.168.0.1 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet autoselect mode 11g <hostap>\n"
"\t  status: running\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 scanvalid 60\n"
"\t  protmode CTS wme burst dtimperiod 1 -dfs\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:713
#, fuzzy
msgid ""
"The `hostap` parameter indicates the interface is running in the host-based "
"access point mode."
msgstr "`hostap` 参数表示接口正在运行在基于主机的访问点模式下。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:715
#, fuzzy
msgid ""
"The interface configuration can be done automatically at boot time by adding"
" the following lines to [.filename]#/etc/rc.conf#:"
msgstr "可以通过在[.filename]#/etc/rc.conf#文件中添加以下行来在启动时自动进行接口配置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:721
#, no-wrap
msgid ""
"wlans_ath0=\"wlan0\"\n"
"create_args_wlan0=\"wlanmode hostap\"\n"
"ifconfig_wlan0=\"inet 192.168.0.1 netmask 255.255.255.0 ssid freebsdap mode 11g channel 1\"\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:723
#, fuzzy, no-wrap
msgid "Host-based Access Point Without Authentication or Encryption"
msgstr "无身份验证或加密的基于主机的接入点（Access Point）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:727
#, fuzzy
msgid ""
"Although it is not recommended to run an AP without any authentication or "
"encryption, this is a simple way to check if the AP is working.  This "
"configuration is also important for debugging client issues."
msgstr "尽管不推荐在AP上不使用任何身份验证或加密来运行，但这是检查AP是否正常工作的简单方法。这种配置对于调试客户端问题也很重要。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:729
#, fuzzy
msgid ""
"Once the AP is configured, initiate a scan from another wireless machine to "
"find the AP:"
msgstr "一旦配置好AP，从另一台无线机器启动扫描以查找AP："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:736
#, no-wrap
msgid ""
"# ifconfig wlan0 create wlandev ath0\n"
"# ifconfig wlan0 up scan\n"
"SSID/MESH ID    BSSID              CHAN RATE   S:N     INT CAPS\n"
"freebsdap       00:11:95:c3:0d:ac    1   54M -66:-96  100 ES   WME\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:739
#, fuzzy
msgid "The client machine found the AP and can be associated with it:"
msgstr "客户端机器发现了接入点(AP)，可以与其关联："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:753
#, no-wrap
msgid ""
"# ifconfig wlan0 inet 192.168.0.2 netmask 255.255.255.0 ssid freebsdap\n"
"# ifconfig wlan0\n"
"  wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\t  ether 00:11:95:d5:43:62\n"
"\t  inet 192.168.0.2 netmask 0xffffff00 broadcast 192.168.0.255\n"
"\t  media: IEEE 802.11 Wireless Ethernet OFDM/54Mbps mode 11g\n"
"\t  status: associated\n"
"\t  ssid freebsdap channel 1 (2412 Mhz 11g) bssid 00:11:95:c3:0d:ac\n"
"\t  country US ecm authmode OPEN privacy OFF txpower 21.5 bmiss 7\n"
"\t  scanvalid 60 bgscan bgscanintvl 300 bgscanidle 250 roam:rssi 7\n"
"\t  roam:rate 5 protmode CTS wme burst\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:756
#, fuzzy, no-wrap
msgid "WPA2 Host-based Access Point"
msgstr "WPA2 基于主机的接入点"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:760
#, fuzzy
msgid ""
"This section focuses on setting up a FreeBSD access point using the WPA2 "
"security protocol.  More details regarding WPA and the configuration of WPA-"
"based wireless clients can be found in <<network-wireless-wpa>>."
msgstr ""
"本节主要讲述使用WPA2安全协议设置FreeBSD访问点的过程。关于WPA以及基于WPA的无线客户端配置的更多细节可以在 <<network-"
"wireless-wpa>> 中找到。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:762
#, fuzzy
msgid ""
"The man:hostapd[8] daemon is used to deal with client authentication and key"
" management on the WPA2-enabled AP."
msgstr "man:hostapd[8]守护进程用于处理WPA2启用的AP上的客户端认证和密钥管理。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:765
#, fuzzy
msgid ""
"The following configuration operations are performed on the FreeBSD machine "
"acting as the AP.  Once the AP is correctly working, man:hostapd[8] can be "
"automatically started at boot with this line in [.filename]#/etc/rc.conf#:"
msgstr ""
"以下配置操作在充当AP的FreeBSD机器上执行。一旦AP正确工作，可以在 [.filename]#/etc/rc.conf# 文件中添加以下行来自动启动 man:hostapd[8]。\n"
"\n"
"```sh\n"
"hostapd_enable=\"YES\"\n"
"```"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:769
#, no-wrap
msgid "hostapd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:772
#, fuzzy
msgid ""
"Before trying to configure man:hostapd[8], first configure the basic "
"settings introduced in <<network-wireless-ap-basic>>."
msgstr "在尝试配置 man:hostapd[8] 之前，首先配置介绍在 <<network-wireless-ap-basic>> 中的基本设置。"

#. type: Title =====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:773
#, fuzzy, no-wrap
msgid "WPA2-PSK"
msgstr ""
"WPA2-PSK（Wi-Fi Protected Access 2 - Pre-Shared Key）是一种用于保护无线局域网（Wi-"
"Fi）安全的协议。它使用预共享密钥（PSK）来验证用户身份并加密数据传输。WPA2-PSK 是目前最安全的 Wi-Fi "
"加密协议之一，它提供了强大的数据保护和身份验证功能。该协议使用 AES（高级加密标准）加密算法，确保数据的机密性和完整性。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:776
#, fuzzy
msgid ""
"WPA2-PSK is intended for small networks where the use of a backend "
"authentication server is not possible or desired."
msgstr "WPA2-PSK用于小型网络，不需要或不希望使用后端认证服务器。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:778
#, fuzzy
msgid "The configuration is done in [.filename]#/etc/hostapd.conf#:"
msgstr "配置是在 [.filename]#/etc/hostapd.conf# 中完成的："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:790
#, no-wrap
msgid ""
"interface=wlan0                  <.>\n"
"debug=1                          <.>\n"
"ctrl_interface=/var/run/hostapd  <.>\n"
"ctrl_interface_group=wheel       <.>\n"
"ssid=freebsdap                   <.>\n"
"wpa=2                            <.>\n"
"wpa_passphrase=freebsdmall       <.>\n"
"wpa_key_mgmt=WPA-PSK             <.>\n"
"wpa_pairwise=CCMP                <.>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:801
#, fuzzy
msgid ""
"<.> Wireless interface used for the access point.  <.> Level of verbosity "
"used during the execution of man:hostapd[8]. A value of `1` represents the "
"minimal level.  <.> Pathname of the directory used by man:hostapd[8] to "
"store domain socket files for communication with external programs such as "
"man:hostapd_cli[8]. The default value is used in this example.  <.> The "
"group allowed to access the control interface files.  <.> The wireless "
"network name, or SSID, that will appear in wireless scans.  <.> Enable WPA "
"and specify which WPA authentication protocol will be required. A value of "
"`2` configures the AP for WPA2 and is recommended. Set to `1` only if the "
"obsolete WPA is required.  <.> ASCII passphrase for WPA authentication.  <.>"
" The key management protocol to use. This example sets WPA-PSK.  <.> "
"Encryption algorithms accepted by the access point. In this example, only "
"the CCMP (AES) cipher is accepted. CCMP is an alternative to TKIP and is "
"strongly preferred when possible. TKIP should be allowed only when there are"
" stations incapable of using CCMP."
msgstr ""
"无线接口用于访问点。 在执行man:hostapd[8]时使用的详细级别。 值为`1`表示最小级别。 "
"由man:hostapd[8]用于存储与外部程序（如man:hostapd_cli[8]）通信的域套接字文件的路径名。 在此示例中使用默认值。 "
"允许访问控制接口文件的组。 将出现在无线扫描中的无线网络名称或SSID。 启用WPA并指定所需的WPA身份验证协议。 "
"`2`配置AP为WPA2，推荐使用。 仅在需要过时的WPA时设置为`1`。 用于WPA身份验证的ASCII密码短语。 要使用的密钥管理协议。 "
"此示例设置为WPA-PSK。 访问点接受的加密算法。 在此示例中，仅接受CCMP（AES）密码。 "
"CCMP是对TKIP的替代选择，在可能的情况下强烈推荐使用。 仅当有无法使用CCMP的设备时才应允许TKIP。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:803
#, fuzzy
msgid "The next step is to start man:hostapd[8]:"
msgstr "下一步是启动 `man:hostapd[8]`。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:807
#, no-wrap
msgid "# service hostapd forcestart\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:824
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"wlan0: flags=8943<UP,BROADCAST,RUNNING,PROMISC,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\tether 04:f0:21:16:8e:10\n"
"\tinet6 fe80::6f0:21ff:fe16:8e10%wlan0 prefixlen 64 scopeid 0x9\n"
"\tnd6 options=21<PERFORMNUD,AUTO_LINKLOCAL>\n"
"\tmedia: IEEE 802.11 Wireless Ethernet autoselect mode 11na <hostap>\n"
"\tstatus: running\n"
"\tssid No5ignal channel 36 (5180 MHz 11a ht/40+) bssid 04:f0:21:16:8e:10\n"
"\tcountry US ecm authmode WPA2/802.11i privacy MIXED deftxkey 2\n"
"\tAES-CCM 2:128-bit AES-CCM 3:128-bit txpower 17 mcastrate 6 mgmtrate 6\n"
"\tscanvalid 60 ampdulimit 64k ampdudensity 8 shortgi wme burst\n"
"\tdtimperiod 1 -dfs\n"
"\tgroups: wlan\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:829
#, fuzzy
msgid ""
"Once the AP is running, the clients can associate with it.  See <<network-"
"wireless-wpa>> for more details.  It is possible to see the stations "
"associated with the AP using `ifconfig _wlan0_ list sta`."
msgstr ""
"一旦 AP 运行起来，客户端就可以与其关联了。详细信息请参见《网络-无线-WPA》。可以使用 `ifconfig _wlan0_ list sta` "
"命令查看与 AP 关联的站点。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:831
#, fuzzy, no-wrap
msgid "USB Tethering"
msgstr "USB连接共享上网"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:835
#, fuzzy
msgid ""
"Many cellphones provide the option to share their data connection over USB "
"(often called \"tethering\").  This feature uses one of RNDIS, CDC, or a "
"custom Apple(R) iPhone(R)/iPad(R) protocol."
msgstr ""
"许多手机提供通过USB共享数据连接的选项（通常称为“数据共享”）。该功能使用RNDIS、CDC或自定义的Apple(R) "
"iPhone(R)/iPad(R)协议之一。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:837
#, fuzzy
msgid "Android(TM) devices generally use the man:urndis[4] driver."
msgstr "Android(TM) 设备通常使用 man:urndis[4] 驱动程序。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:838
#, fuzzy
msgid "Apple(R) devices use the man:ipheth[4] driver."
msgstr "Apple(R)设备使用man:ipheth[4] 驱动程序。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:839
#, fuzzy
msgid "Older devices will often use the man:cdce[4] driver."
msgstr "较旧的设备通常会使用 man:cdce[4] 驱动程序。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:841
#, fuzzy
msgid ""
"Before attaching a device, load the appropriate driver into the kernel:"
msgstr "在连接设备之前，将适当的驱动程序加载到内核中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:847
#, no-wrap
msgid ""
"# kldload if_urndis\n"
"# kldload if_cdce\n"
"# kldload if_ipheth\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:851
#, fuzzy
msgid ""
"Once the device is attached ``ue``_0_ will be available for use like a "
"normal network device.  Be sure that the \"USB tethering\" option is enabled"
" on the device."
msgstr "一旦设备连接上，*ue*0* 将会像一个正常的网络设备一样可用。请确保设备上的“USB网络共享”选项已启用。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:853
#, fuzzy
msgid ""
"To make this change permanent and load the driver as a module at boot time, "
"place the appropriate line of the following in "
"[.filename]#/boot/loader.conf#:"
msgstr "要将此更改永久保存并在启动时将驱动程序加载为模块，请在 [.filename]#/boot/loader.conf# 中添加以下适当的行："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:859
#, no-wrap
msgid ""
"if_urndis_load=\"YES\"\n"
"if_cdce_load=\"YES\"\n"
"if_ipheth_load=\"YES\"\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:862
#, fuzzy, no-wrap
msgid "Bluetooth"
msgstr "蓝牙"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:867
#, fuzzy
msgid ""
"Bluetooth is a wireless technology for creating personal networks operating "
"in the 2.4 GHz unlicensed band, with a range of 10 meters.  Networks are "
"usually formed ad-hoc from portable devices such as cellular phones, "
"handhelds, and laptops.  Unlike Wi-Fi wireless technology, Bluetooth offers "
"higher level service profiles, such as FTP-like file servers, file pushing, "
"voice transport, serial line emulation, and more."
msgstr ""
"蓝牙是一种无线技术，用于在2.4 "
"GHz无许可频段上创建个人网络，范围为10米。网络通常是根据可携式设备（如手机、手持设备和笔记本电脑）的需求临时形成的。与Wi-"
"Fi无线技术不同，蓝牙提供更高级别的服务配置文件，例如类似FTP的文件服务器、文件推送、语音传输、串行线仿真等。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:870
#, fuzzy
msgid ""
"This section describes the use of a USB Bluetooth dongle on a FreeBSD "
"system.  It then describes the various Bluetooth protocols and utilities."
msgstr "本节介绍了在FreeBSD系统上使用USB蓝牙适配器，然后描述了各种蓝牙协议和工具。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:871
#, fuzzy, no-wrap
msgid "Loading Bluetooth Support"
msgstr "加载蓝牙支持"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:878
#, fuzzy
msgid ""
"The Bluetooth stack in FreeBSD is implemented using the man:netgraph[4] "
"framework.  A broad variety of Bluetooth USB dongles is supported by "
"man:ng_ubt[4].  Broadcom BCM2033 based Bluetooth devices are supported by "
"the man:ubtbcmfw[4] and man:ng_ubt[4] drivers.  The 3Com Bluetooth PC Card "
"3CRWB60-A is supported by the man:ng_bt3c[4] driver.  Serial and UART based "
"Bluetooth devices are supported by man:sio[4], man:ng_h4[4], and "
"man:hcseriald[8]."
msgstr ""
"在FreeBSD中，蓝牙协议栈使用man:netgraph[4]框架实现。man:ng_ubt[4]能够支持多种蓝牙USB适配器。基于Broadcom "
"BCM2033芯片的蓝牙设备可以通过man:ubtbcmfw[4]和man:ng_ubt[4]驱动程序进行支持。3Com蓝牙PC卡3CRWB60-A可以通过man:ng_bt3c[4]驱动程序进行支持。基于串口和UART的蓝牙设备可以通过man:sio[4]、man:ng_h4[4]和man:hcseriald[8]驱动程序进行支持。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:881
#, fuzzy
msgid ""
"Before attaching a device, determine which of the above drivers it uses, "
"then load the driver.  For example, if the device uses the man:ng_ubt[4] "
"driver:"
msgstr "在连接设备之前，确定它使用上述驱动程序中的哪一个，然后加载该驱动程序。例如，如果设备使用 man:ng_ubt[4] 驱动程序："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:885
#, no-wrap
msgid "# kldload ng_ubt\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:888
#, fuzzy
msgid ""
"If the Bluetooth device will be attached to the system during system "
"startup, the system can be configured to load the module at boot time by "
"adding the driver to [.filename]#/boot/loader.conf#:"
msgstr ""
"如果蓝牙设备将在系统启动期间连接到系统，可以通过将驱动程序添加到`.filename`文件[#`/boot/loader.conf`]`来配置系统在启动时加载模块。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:892
#, no-wrap
msgid "ng_ubt_load=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:896
#, fuzzy
msgid ""
"Once the driver is loaded, plug in the USB dongle.  If the driver load was "
"successful, output similar to the following should appear on the console and"
" in [.filename]#/var/log/messages#:"
msgstr ""
"一旦驱动程序加载完成，请插入USB dongle。如果驱动程序加载成功，在控制台和[/var/log/messages]文件中将会显示类似以下的输出："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:903
#, no-wrap
msgid ""
"ubt0: vendor 0x0a12 product 0x0001, rev 1.10/5.25, addr 2\n"
"ubt0: Interface 0 endpoints: interrupt=0x81, bulk-in=0x82, bulk-out=0x2\n"
"ubt0: Interface 1 (alt.config 5) endpoints: isoc-in=0x83, isoc-out=0x3,\n"
"      wMaxPacketSize=49, nframes=6, buffer size=294\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:908
#, fuzzy
msgid ""
"To start and stop the Bluetooth stack, use its startup script. It is a good "
"idea to stop the stack before unplugging the device.  Starting the bluetooth"
" stack might require man:hcsecd[8] to be started.  When starting the stack, "
"the output should be similar to the following:"
msgstr ""
"要启动和停止蓝牙堆栈，请使用其启动脚本。在拔下设备之前停止堆栈是一个好主意。启动蓝牙堆栈可能需要启动man:hcsecd[8]。启动堆栈时，输出应该类似于以下内容："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:923
#, no-wrap
msgid ""
"# service bluetooth start ubt0\n"
"BD_ADDR: 00:02:72:00:d4:1a\n"
"Features: 0xff 0xff 0xf 00 00 00 00 00\n"
"<3-Slot> <5-Slot> <Encryption> <Slot offset>\n"
"<Timing accuracy> <Switch> <Hold mode> <Sniff mode>\n"
"<Park mode> <RSSI> <Channel quality> <SCO link>\n"
"<HV2 packets> <HV3 packets> <u-law log> <A-law log> <CVSD>\n"
"<Paging scheme> <Power control> <Transparent SCO data>\n"
"Max. ACL packet size: 192 bytes\n"
"Number of ACL packets: 8\n"
"Max. SCO packet size: 64 bytes\n"
"Number of SCO packets: 8\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:925
#, fuzzy, no-wrap
msgid "Finding Other Bluetooth Devices"
msgstr "查找其他蓝牙设备"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:930
#, fuzzy
msgid ""
"The Host Controller Interface (HCI) provides a uniform method for accessing "
"Bluetooth baseband capabilities.  In FreeBSD, a netgraph HCI node is created"
" for each Bluetooth device.  For more details, refer to man:ng_hci[4]."
msgstr ""
"主机控制器接口（HCI）提供了访问蓝牙基带能力的统一方法。在FreeBSD中，为每个蓝牙设备创建一个网络图（netgraph）HCI节点。有关详细信息，请参阅"
" man:ng_hci[4]。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:937
#, fuzzy
msgid ""
"One of the most common tasks is discovery of Bluetooth devices within RF "
"proximity.  This operation is called _inquiry_.  Inquiry and other HCI "
"related operations are done using man:hccontrol[8].  The example below shows"
" how to find out which Bluetooth devices are in range.  The list of devices "
"should be displayed in a few seconds.  Note that a remote device will only "
"answer the inquiry if it is set to _discoverable_ mode."
msgstr ""
"最常见的任务之一是发现 RF 接近范围内的蓝牙设备。这个操作被称为 \"inquiry\"（查询）。查询和其他 HCI 相关操作使用 "
"man:hccontrol[8] 进行。下面的示例显示了如何查找范围内的蓝牙设备。设备列表应该在几秒钟内显示出来。请注意，只有在远程设备设置为 "
"\"discoverable\"（可发现）模式时，它才会回应查询。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:950
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci inquiry\n"
"Inquiry result, num_responses=1\n"
"Inquiry result #0\n"
"       BD_ADDR: 00:80:37:29:19:a4\n"
"       Page Scan Rep. Mode: 0x1\n"
"       Page Scan Period Mode: 00\n"
"       Page Scan Mode: 00\n"
"       Class: 52:02:04\n"
"       Clock offset: 0x78ef\n"
"Inquiry complete. Status: No error [00]\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:956
#, fuzzy
msgid ""
"The `BD_ADDR` is the unique address of a Bluetooth device, similar to the "
"MAC address of a network card.  This address is needed for further "
"communication with a device and it is possible to assign a human readable "
"name to a `BD_ADDR`.  Information regarding the known Bluetooth hosts is "
"contained in [.filename]#/etc/bluetooth/hosts#.  The following example shows"
" how to obtain the human readable name that was assigned to the remote "
"device:"
msgstr ""
"`BD_ADDR`是蓝牙设备的唯一地址，类似于网络卡的MAC地址。这个地址用于与设备进行进一步通信，可以为`BD_ADDR`分配一个可读的名称。有关已知的蓝牙主机的信息包含在文件`/etc/bluetooth/hosts`中。以下示例显示如何获取分配给远程设备的可读名称："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:962
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci remote_name_request 00:80:37:29:19:a4\n"
"BD_ADDR: 00:80:37:29:19:a4\n"
"Name: Pav's T39\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:966
#, fuzzy
msgid ""
"If an inquiry is performed on a remote Bluetooth device, it will find the "
"computer as \"your.host.name (ubt0)\".  The name assigned to the local "
"device can be changed at any time."
msgstr "如果对远程蓝牙设备进行查询，将会找到计算机作为\"your.host.name (ubt0)\"。本地设备分配的名称可以随时更改。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:969
#, fuzzy
msgid ""
"Remote devices can be assigned aliases in [.filename]#/etc/bluetooth/hosts#."
"  More information about [.filename]#/etc/bluetooth/hosts# file might be "
"found in man:bluetooth.hosts[5]."
msgstr ""
"远程设备可以在 [/etc/bluetooth/hosts] 文件中分配别名。有关 [/etc/bluetooth/hosts] 文件的更多信息，请参考"
" man:bluetooth.hosts[5]。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:972
#, fuzzy
msgid ""
"The Bluetooth system provides a point-to-point connection between two "
"Bluetooth units, or a point-to-multipoint connection which is shared among "
"several Bluetooth devices.  The following example shows how to create a "
"connection to a remote device:"
msgstr "蓝牙系统提供了两个蓝牙设备之间的点对点连接，或者在多个蓝牙设备之间共享的点对多点连接。以下示例演示了如何创建到远程设备的连接："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:976
#, no-wrap
msgid "% hccontrol -n ubt0hci create_connection BT_ADDR\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:979
#, fuzzy
msgid ""
"`create_connection` accepts `BT_ADDR` as well as host aliases in "
"[.filename]#/etc/bluetooth/hosts#."
msgstr ""
"`create_connection`函数接受在`/etc/bluetooth/hosts`文件中定义的`BT_ADDR`和主机别名作为参数。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:981
#, fuzzy
msgid ""
"The following example shows how to obtain the list of active baseband "
"connections for the local device:"
msgstr "下面的示例显示了如何获取本地设备的活动基带连接列表："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:987
#, no-wrap
msgid ""
"% hccontrol -n ubt0hci read_connection_list\n"
"Remote BD_ADDR    Handle Type Mode Role Encrypt Pending Queue State\n"
"00:80:37:29:19:a4     41  ACL    0 MAST    NONE       0     0 OPEN\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:991
#, fuzzy
msgid ""
"A _connection handle_ is useful when termination of the baseband connection "
"is required, though it is normally not required to do this by hand.  The "
"stack will automatically terminate inactive baseband connections."
msgstr "_连接句柄_ 在需要终止基带连接时非常有用，尽管通常不需要手动进行此操作。堆栈会自动终止非活动的基带连接。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:997
#, no-wrap
msgid ""
"# hccontrol -n ubt0hci disconnect 41\n"
"Connection handle: 41\n"
"Reason: Connection terminated by local host [0x16]\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1001
#, fuzzy
msgid ""
"Type `hccontrol help` for a complete listing of available HCI commands.  "
"Most of the HCI commands do not require superuser privileges."
msgstr "输入 `hccontrol help` 以获取可用 HCI 命令的完整列表。大多数 HCI 命令不需要超级用户权限。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1002
#, fuzzy, no-wrap
msgid "Device Pairing"
msgstr "设备配对"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1013
#, fuzzy
msgid ""
"By default, Bluetooth communication is not authenticated, and any device can"
" talk to any other device.  A Bluetooth device, such as a cellular phone, "
"may choose to require authentication to provide a particular service.  "
"Bluetooth authentication is normally done with a _PIN code_, an ASCII string"
" up to 16 characters in length.  The user is required to enter the same PIN "
"code on both devices.  Once the user has entered the PIN code, both devices "
"will generate a _link key_.  After that, the link key can be stored either "
"in the devices or in a persistent storage.  Next time, both devices will use"
" the previously generated link key.  This procedure is called _pairing_.  "
"Note that if the link key is lost by either device, the pairing must be "
"repeated."
msgstr ""
"默认情况下，蓝牙通信不进行身份验证，任何设备都可以与其他设备进行通信。蓝牙设备（如手机）可以选择需要身份验证来提供特定服务。蓝牙身份验证通常使用一个长度不超过16个字符的_ASCII"
" "
"PIN码_（个人识别码），这是一个ASCII字符串。用户需要在两个设备上输入相同的PIN码。用户输入PIN码后，两个设备将生成一个_链接密钥_。然后，链接密钥可以存储在设备中或持久存储中。下次，两个设备将使用先前生成的链接密钥。这个过程称为_配对_。注意，如果链接密钥在任一设备上丢失，需要重新进行配对。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1017
#, fuzzy
msgid ""
"The man:hcsecd[8] daemon is responsible for handling Bluetooth "
"authentication requests.  The default configuration file is "
"[.filename]#/etc/bluetooth/hcsecd.conf#.  An example section for a cellular "
"phone with the PIN code set to `1234` is shown below:"
msgstr ""
"man:hcsecd[8] 守护进程负责处理蓝牙认证请求。默认的配置文件是 "
"[/etc/bluetooth/hcsecd.conf]。下面是一个示例部分，针对将 PIN 码设置为 `1234` 的手机："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1026
#, no-wrap
msgid ""
"device {\n"
"        bdaddr  00:80:37:29:19:a4;\n"
"        name    \"Pav's T39\";\n"
"        key     nokey;\n"
"        pin     \"1234\";\n"
"      }\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1036
#, fuzzy
msgid ""
"The only limitation on PIN codes is length.  Some devices, such as Bluetooth"
" headsets, may have a fixed PIN code built in.  The `-d` switch forces "
"man:hcsecd[8] to stay in the foreground, so it is easy to see what is "
"happening.  Set the remote device to receive pairing and initiate the "
"Bluetooth connection to the remote device.  The remote device should "
"indicate that pairing was accepted and request the PIN code.  Enter the same"
" PIN code listed in [.filename]#hcsecd.conf#.  Now the computer and the "
"remote device are paired.  Alternatively, pairing can be initiated on the "
"remote device."
msgstr ""
"对于个人识别码（PIN "
"codes），唯一的限制是长度。一些设备，比如蓝牙耳机，可能有一个固定的内置PIN码。`-d`开关强制`man:hcsecd[8]`在前台运行，这样可以轻松查看正在发生的事情。将远程设备设置为接收配对并启动与远程设备的蓝牙连接。远程设备应指示接受配对并要求输入PIN码。输入与【.filename】#hcsecd.conf#中列出的相同的PIN码。现在，计算机和远程设备已配对。另外，也可以在远程设备上启动配对过程。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1038
#, fuzzy
msgid ""
"The following line can be added to [.filename]#/etc/rc.conf# to configure "
"man:hcsecd[8] to start automatically on system start:"
msgstr "可以将以下行添加到[/etc/rc.conf]#文件中，以配置man:hcsecd[8]在系统启动时自动启动:"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1042
#, no-wrap
msgid "hcsecd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1045
#, fuzzy
msgid "The following is a sample of the man:hcsecd[8] daemon output:"
msgstr "以下是 man:hcsecd[8] 守护进程输出的示例："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1054
#, no-wrap
msgid ""
"hcsecd[16484]: Got Link_Key_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', link key doesn't exist\n"
"hcsecd[16484]: Sending Link_Key_Negative_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Got PIN_Code_Request event from 'ubt0hci', remote bdaddr 0:80:37:29:19:a4\n"
"hcsecd[16484]: Found matching entry, remote bdaddr 0:80:37:29:19:a4, name 'Pav's T39', PIN code exists\n"
"hcsecd[16484]: Sending PIN_Code_Reply to 'ubt0hci' for remote bdaddr 0:80:37:29:19:a4\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1056
#, fuzzy, no-wrap
msgid "Network Access with PPP Profiles"
msgstr "使用PPP配置文件的网络访问"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1060
#, fuzzy
msgid ""
"A Dial-Up Networking (DUN) profile can be used to configure a cellular phone"
" as a wireless modem for connecting to a dial-up Internet access server.  It"
" can also be used to configure a computer to receive data calls from a "
"cellular phone."
msgstr ""
"一个拨号网络（Dial-Up "
"Networking，DUN）配置文件用于将手机配置为无线调制解调器，以连接到拨号上网服务器。它也可以用于将计算机配置为接收来自手机的数据呼叫。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1063
#, fuzzy
msgid ""
"Network access with a PPP profile can be used to provide LAN access for a "
"single Bluetooth device or multiple Bluetooth devices.  It can also provide "
"PC to PC connection using PPP networking over serial cable emulation."
msgstr ""
"使用 PPP 配置文件进行网络访问可以为单个蓝牙设备或多个蓝牙设备提供局域网访问。还可以使用串行电缆仿真进行 PPP 网络对 PC 和 PC "
"之间的连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1067
#, fuzzy
msgid ""
"In FreeBSD, these profiles are implemented with man:ppp[8] and the "
"man:rfcomm_pppd[8] wrapper which converts a Bluetooth connection into "
"something PPP can use.  Before a profile can be used, a new PPP label must "
"be created in [.filename]#/etc/ppp/ppp.conf#.  Consult man:rfcomm_pppd[8] "
"for examples."
msgstr ""
"在FreeBSD中，这些配置文件通过man:ppp[8]和man:rfcomm_pppd[8]包装器实现，该包装器将蓝牙连接转换为PPP可以使用的内容。在使用配置文件之前，必须在[.filename]#/etc/ppp/ppp.conf#中创建一个新的PPP标签。请参考man:rfcomm_pppd[8]的示例。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1069
#, fuzzy
msgid ""
"In this example, man:rfcomm_pppd[8] is used to open a connection to a remote"
" device with a `BD_ADDR` of `00:80:37:29:19:a4` on a DUNRFCOMM channel:"
msgstr ""
"在此示例中，使用 man:rfcomm_pppd[8] 打开与远程设备的连接，该设备的 `BD_ADDR` 为 "
"`00:80:37:29:19:a4`，通信频道为 DUNRFCOMM。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1073
#, no-wrap
msgid "# rfcomm_pppd -a 00:80:37:29:19:a4 -c -C dun -l rfcomm-dialup\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1078
#, fuzzy
msgid ""
"The actual channel number will be obtained from the remote device using the "
"SDP protocol.  It is possible to specify the RFCOMM channel by hand, and in "
"this case man:rfcomm_pppd[8] will not perform the SDP query.  Use "
"man:sdpcontrol[8] to find out the RFCOMM channel on the remote device."
msgstr ""
"实际的通道号将通过使用SDP协议从远程设备获取。您可以手动指定RFCOMM通道，在这种情况下，man:rfcomm_pppd[8]不会执行SDP查询。使用man:sdpcontrol[8]来查找远程设备上的RFCOMM通道。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1084
#, fuzzy
msgid ""
"In order to provide network access with the PPPLAN service, man:sdpd[8] must"
" be running and a new entry for LAN clients must be created in "
"[.filename]#/etc/ppp/ppp.conf#.  Consult man:rfcomm_pppd[8] for examples.  "
"Finally, start the RFCOMMPPP server on a valid RFCOMM channel number.  The "
"RFCOMMPPP server will automatically register the Bluetooth LAN service with "
"the local SDP daemon.  The example below shows how to start the RFCOMMPPP "
"server."
msgstr ""
"为了使用PPPLAN服务提供网络访问，必须运行man:sdpd[8]并在[.filename]#/etc/ppp/ppp.conf#中创建一个新的LAN客户端条目。请参考man:rfcomm_pppd[8]中的示例。最后，在有效的RFCOMM通道号上启动RFCOMMPPP服务器。RFCOMMPPP服务器将自动向本地SDP守护进程注册蓝牙LAN服务。以下示例显示了如何启动RFCOMMPPP服务器。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1088
#, no-wrap
msgid "# rfcomm_pppd -s -C 7 -l rfcomm-server\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1090
#, fuzzy, no-wrap
msgid "Bluetooth Protocols"
msgstr "蓝牙协议"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1093
#, fuzzy
msgid ""
"This section provides an overview of the various Bluetooth protocols, their "
"function, and associated utilities."
msgstr "这部分提供了关于不同蓝牙协议、它们的功能以及相关实用工具的概述。"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1094
#, fuzzy, no-wrap
msgid "Logical Link Control and Adaptation Protocol (L2CAP)"
msgstr "逻辑链路控制和适配协议（L2CAP）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1098
#, fuzzy
msgid ""
"The Logical Link Control and Adaptation Protocol (L2CAP) provides "
"connection-oriented and connectionless data services to upper layer "
"protocols.  L2CAP permits higher level protocols and applications to "
"transmit and receive L2CAP data packets up to 64 kilobytes in length."
msgstr ""
"逻辑链路控制和适配协议（L2CAP）为上层协议提供面向连接和无连接的数据服务。L2CAP允许更高级别的协议和应用传输和接收最长64千字节的L2CAP数据包。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1104
#, fuzzy
msgid ""
"L2CAP is based around the concept of _channels_.  A channel is a logical "
"connection on top of a baseband connection, where each channel is bound to a"
" single protocol in a many-to-one fashion.  Multiple channels can be bound "
"to the same protocol, but a channel cannot be bound to multiple protocols.  "
"Each L2CAP packet received on a channel is directed to the appropriate "
"higher level protocol.  Multiple channels can share the same baseband "
"connection."
msgstr ""
"L2CAP基于\"通道\"的概念。通道是在基带连接之上的逻辑连接，每个通道以多对一的方式绑定到一个单一的协议。多个通道可以绑定到同一个协议，但一个通道不能绑定到多个协议。在一个通道上接收的每个L2CAP数据包都会被定向到相应的更高层协议。多个通道可以共享同一个基带连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1109
#, fuzzy
msgid ""
"In FreeBSD, a netgraph L2CAP node is created for each Bluetooth device.  "
"This node is normally connected to the downstream Bluetooth HCI node and "
"upstream Bluetooth socket nodes.  The default name for the L2CAP node is "
"\"devicel2cap\".  For more details refer to man:ng_l2cap[4]."
msgstr ""
"在FreeBSD中，为每个蓝牙设备创建了一个netgraph "
"L2CAP节点。该节点通常连接到下游的蓝牙HCI节点和上游的蓝牙套接字节点。L2CAP节点的默认名称为\"devicel2cap\"。有关更多详细信息，请参考man:ng_l2cap[4]。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1112
#, fuzzy
msgid ""
"A useful command is man:l2ping[8], which can be used to ping other devices."
"  Some Bluetooth implementations might not return all of the data sent to "
"them, so `0 bytes` in the following example is normal."
msgstr ""
"一个有用的命令是`man:l2ping[8]`，可以用来ping其他设备。一些蓝牙实现可能无法返回所有发送给它们的数据，所以下面的例子中出现`0字节`是正常的。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1120
#, no-wrap
msgid ""
"# l2ping -a 00:80:37:29:19:a4\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=0 time=48.633 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=1 time=37.551 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=2 time=28.324 ms result=0\n"
"0 bytes from 0:80:37:29:19:a4 seq_no=3 time=46.150 ms result=0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1124
#, fuzzy
msgid ""
"The man:l2control[8] utility is used to perform various operations on L2CAP "
"nodes.  This example shows how to obtain the list of logical connections "
"(channels) and the list of baseband connections for the local device:"
msgstr ""
"man:l2control[8] 实用工具用于在 L2CAP 节点上执行各种操作。该示例展示了如何获取本地设备的逻辑连接（通道）列表和基带连接列表："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1135
#, no-wrap
msgid ""
"% l2control -a 00:02:72:00:d4:1a read_channel_list\n"
"L2CAP channels:\n"
"Remote BD_ADDR     SCID/ DCID   PSM  IMTU/ OMTU State\n"
"00:07:e0:00:0b:ca    66/   64     3   132/  672 OPEN\n"
"% l2control -a 00:02:72:00:d4:1a read_connection_list\n"
"L2CAP connections:\n"
"Remote BD_ADDR    Handle Flags Pending State\n"
"00:07:e0:00:0b:ca     41 O           0 OPEN\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1140
#, fuzzy
msgid ""
"Another diagnostic tool is man:btsockstat[1].  It is similar to "
"man:netstat[1], but for Bluetooth network-related data structures.  The "
"example below shows the same logical connection as man:l2control[8] above."
msgstr ""
"另一个诊断工具是 man:btsockstat[1]。它类似于 man:netstat[1]，但用于蓝牙网络相关的数据结构。下面的示例展示了与上面的 "
"man:l2control[8] 相同的逻辑连接。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1153
#, no-wrap
msgid ""
"% btsockstat\n"
"Active L2CAP sockets\n"
"PCB      Recv-Q Send-Q Local address/PSM       Foreign address   CID   State\n"
"c2afe900      0      0 00:02:72:00:d4:1a/3     00:07:e0:00:0b:ca 66    OPEN\n"
"Active RFCOMM sessions\n"
"L2PCB    PCB      Flag MTU   Out-Q DLCs State\n"
"c2afe900 c2b53380 1    127   0     Yes  OPEN\n"
"Active RFCOMM sockets\n"
"PCB      Recv-Q Send-Q Local address     Foreign address   Chan DLCI State\n"
"c2e8bc80      0    250 00:02:72:00:d4:1a 00:07:e0:00:0b:ca 3    6    OPEN\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1155
#, fuzzy, no-wrap
msgid "Radio Frequency Communication (RFCOMM)"
msgstr "无线电频率通信 (RFCOMM)"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1160
#, fuzzy
msgid ""
"The RFCOMM protocol provides emulation of serial ports over the L2CAP "
"protocol.  RFCOMM is a simple transport protocol, with additional provisions"
" for emulating the 9 circuits of RS-232 (EIATIA-232-E) serial ports.  It "
"supports up to 60 simultaneous connections (RFCOMM channels) between two "
"Bluetooth devices."
msgstr ""
"RFCOMM协议在L2CAP协议之上提供了串口的仿真。RFCOMM是一个简单的传输协议，此外还具备模拟RS-232（EIATIA-232-E）串口的9个电路的功能。它支持两个蓝牙设备之间的最多60个同时连接（RFCOMM通道）。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1164
#, fuzzy
msgid ""
"For the purposes of RFCOMM, a complete communication path involves two "
"applications running on the communication endpoints with a communication "
"segment between them.  RFCOMM is intended to cover applications that make "
"use of the serial ports of the devices in which they reside.  The "
"communication segment is a direct connect Bluetooth link from one device to "
"another."
msgstr ""
"为了实现RFCOMM功能，一个完整的通信路径需要两个应用程序在通信端点上运行，它们之间有一个通信段。RFCOMM旨在涵盖利用设备串口的应用程序。通信段是从一个设备直接连接到另一个设备的蓝牙链路。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1167
#, fuzzy
msgid ""
"RFCOMM is only concerned with the connection between the devices in the "
"direct connect case, or between the device and a modem in the network case."
"  RFCOMM can support other configurations, such as modules that communicate "
"via Bluetooth wireless technology on one side and provide a wired interface "
"on the other side."
msgstr ""
"RFCOMM仅关注直接连接时设备之间的连接，或网络情况下设备与调制解调器之间的连接。RFCOMM可以支持其他配置，例如一个方向通过蓝牙无线技术通信，另一方提供有线接口的模块。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1169
#, fuzzy
msgid "In FreeBSD, RFCOMM is implemented at the Bluetooth sockets layer."
msgstr "在FreeBSD中，RFCOMM是在蓝牙套接字层实现的。"

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1170
#, fuzzy, no-wrap
msgid "Service Discovery Protocol (SDP)"
msgstr "服务发现协议（SDP）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1174
#, fuzzy
msgid ""
"The Service Discovery Protocol (SDP) provides the means for client "
"applications to discover the existence of services provided by server "
"applications as well as the attributes of those services.  The attributes of"
" a service include the type or class of service offered and the mechanism or"
" protocol information needed to utilize the service."
msgstr ""
"服务发现协议（SDP）提供了客户端应用程序发现服务器应用程序提供的服务以及这些服务的属性的手段。服务的属性包括所提供服务的类型或类别，以及利用该服务所需的机制或协议信息。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1181
#, fuzzy
msgid ""
"SDP involves communication between a SDP server and a SDP client.  The "
"server maintains a list of service records that describe the characteristics"
" of services associated with the server.  Each service record contains "
"information about a single service.  A client may retrieve information from "
"a service record maintained by the SDP server by issuing a SDP request.  If "
"the client, or an application associated with the client, decides to use a "
"service, it must open a separate connection to the service provider in order"
" to utilize the service.  SDP provides a mechanism for discovering services "
"and their attributes, but it does not provide a mechanism for utilizing "
"those services."
msgstr ""
"SDP涉及SDP服务器和SDP客户端之间的通信。服务器维护描述与服务器关联的服务特性的服务记录列表。每个服务记录包含有关单个服务的信息。客户端可以通过发出SDP请求从SDP服务器维护的服务记录中检索信息。如果客户端或与客户端关联的应用程序决定使用服务，则必须打开与服务提供者的单独连接以利用该服务。SDP提供了一种发现服务及其属性的机制，但不提供利用这些服务的机制。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1185
#, fuzzy
msgid ""
"Normally, a SDP client searches for services based on some desired "
"characteristics of the services.  However, there are times when it is "
"desirable to discover which types of services are described by an SDP "
"server's service records without any prior information about the services.  "
"This process of looking for any offered services is called _browsing_."
msgstr ""
"通常，SDP客户端根据所需服务的某些特征搜索服务。然而，有时候希望在没有关于服务的任何先前信息的情况下，发现SDP服务器的服务记录描述了哪些类型的服务。这个查找任何可提供的服务的过程被称为__浏览__。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1188
#, fuzzy
msgid ""
"The Bluetooth SDP server, man:sdpd[8], and command line client, "
"man:sdpcontrol[8], are included in the standard FreeBSD installation.  The "
"following example shows how to perform a SDP browse query."
msgstr ""
"标准的FreeBSD安装中包含了Bluetooth "
"SDP服务器（man:sdpd[8]）和命令行客户端（man:sdpcontrol[8]）。下面的示例展示了如何执行SDP浏览查询。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1199
#, no-wrap
msgid ""
"% sdpcontrol -a 00:01:03:fc:6e:ec browse\n"
"Record Handle: 00000000\n"
"Service Class ID List:\n"
"        Service Discovery Server (0x1000)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"                Protocol specific parameter #1: u/int/uuid16 1\n"
"                Protocol specific parameter #2: u/int/uuid16 1\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1203
#, no-wrap
msgid ""
"Record Handle: 0x00000001\n"
"Service Class ID List:\n"
"        Browse Group Descriptor (0x1001)\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1213
#, no-wrap
msgid ""
"Record Handle: 0x00000002\n"
"Service Class ID List:\n"
"        LAN Access Using PPP (0x1102)\n"
"Protocol Descriptor List:\n"
"        L2CAP (0x0100)\n"
"        RFCOMM (0x0003)\n"
"                Protocol specific parameter #1: u/int8/bool 1\n"
"Bluetooth Profile Descriptor List:\n"
"        LAN Access Using PPP (0x1102) ver. 1.0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1220
#, fuzzy
msgid ""
"Note that each service has a list of attributes, such as the RFCOMM channel."
"  Depending on the service, the user might need to make note of some of the "
"attributes.  Some Bluetooth implementations do not support service browsing "
"and may return an empty list.  In this case, it is possible to search for "
"the specific service.  The example below shows how to search for the OBEX "
"Object Push (OPUSH) service:"
msgstr ""
"请注意，每个服务都有一系列的属性，例如RFCOMM通道。根据服务的不同，用户可能需要注意其中的一些属性。某些蓝牙实现不支持服务浏览，并可能返回一个空列表。在这种情况下，可以搜索特定的服务。下面的示例展示了如何搜索OBEX对象推送（OPUSH）服务："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1224
#, no-wrap
msgid "% sdpcontrol -a 00:01:03:fc:6e:ec search OPUSH\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1228
#, fuzzy
msgid ""
"Offering services on FreeBSD to Bluetooth clients is done with the "
"man:sdpd[8] server.  The following line can be added to "
"[.filename]#/etc/rc.conf#:"
msgstr ""
"通过man:sdpd[8]服务器提供对Bluetooth客户端的FreeBSD服务。可以将下面的行添加到[/etc/rc.conf]文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1232
#, no-wrap
msgid "sdpd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1235
#, fuzzy
msgid "Then the man:sdpd[8] daemon can be started with:"
msgstr "然后可以使用以下命令启动man:sdpd[8]守护进程："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1239
#, no-wrap
msgid "# service sdpd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1244
#, fuzzy
msgid ""
"The local server application that wants to provide a Bluetooth service to "
"remote clients will register the service with the local SDP daemon.  An "
"example of such an application is man:rfcomm_pppd[8].  Once started, it will"
" register the Bluetooth LAN service with the local SDP daemon."
msgstr ""
"本地服务器应用程序希望向远程客户端提供蓝牙服务，将会向本地SDP守护进程注册该服务。一个例子是`man:rfcomm_pppd[8]`这样的应用程序。一旦启动，它将会向本地SDP守护进程注册蓝牙局域网服务。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1246
#, fuzzy
msgid ""
"The list of services registered with the local SDP server can be obtained by"
" issuing a SDP browse query via the local control channel:"
msgstr "通过本地控制信道发出SDP浏览查询，可以获取已在本地SDP服务器注册的服务列表。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1250
#, no-wrap
msgid "# sdpcontrol -l browse\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1252
#, fuzzy, no-wrap
msgid "OBEX Object Push (OPUSH)"
msgstr ""
"OBEX Object Push（OPUSH）是一种在计算机系统中用于传输对象的协议。它基于OBEX（Object Exchange）协议，并专门用于推送对象（如文件、照片、音乐等）到远程设备。OPUSH通常被用于无线通信中，例如蓝牙传输。\n"
"\n"
"OBEX是一种面向连接的协议，它允许设备之间通过传输对象来进行通信。OPUSH协议提供了标准化的方法来处理对象的推送操作，包括连接建立、对象传输、连接关闭等。这种协议可以确保在设备之间高效、可靠地传输对象。\n"
"\n"
"OPUSH协议广泛应用于多种设备之间的通信，如手机、电脑、打印机等。通过使用OPUSH，用户可以轻松地将文件等对象推送到其他设备，方便实现设备之间的数据交换和共享。\n"
"\n"
"总而言之，OBEX Object Push（OPUSH）是一种用于在计算机系统中传输对象的协议，它通过OBEX协议提供了标准化的推送操作方法，使设备之间可以高效、可靠地传输对象。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1256
#, fuzzy
msgid ""
"Object Exchange (OBEX) is a widely used protocol for simple file transfers "
"between mobile devices.  Its main use is in infrared communication, where it"
" is used for generic file transfers between notebooks or PDAs, and for "
"sending business cards or calendar entries between cellular phones and other"
" devices with Personal Information Manager (PIM) applications."
msgstr ""
"Object Exchange (OBEX) "
"是一种广泛使用的协议，用于移动设备之间的简单文件传输。其主要用于红外通信，用于笔记本电脑或PDA之间的通用文件传输，以及在手机和其他具有个人信息管理(PIM)应用程序的设备之间发送名片或日历条目。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1258
#, fuzzy
msgid ""
"The OBEX server and client are implemented by obexapp, which can be "
"installed using the package:comms/obexapp[] package or port."
msgstr "OBEX服务器和客户端由obexapp实现，可以使用comms/obexapp包或端口进行安装。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1266
#, fuzzy
msgid ""
"The OBEX client is used to push and/or pull objects from the OBEX server.  "
"An example object is a business card or an appointment.  The OBEX client can"
" obtain the RFCOMM channel number from the remote device via SDP.  This can "
"be done by specifying the service name instead of the RFCOMM channel number."
"  Supported service names are: `IrMC`, `FTRN`, and `OPUSH`.  It is also "
"possible to specify the RFCOMM channel as a number.  Below is an example of "
"an OBEX session where the device information object is pulled from the "
"cellular phone, and a new object, the business card, is pushed into the "
"phone's directory."
msgstr ""
"OBEX客户端用于从OBEX服务器推送和/或拉取对象。一个示例对象可以是名片或约会。OBEX客户端可以通过SDP从远程设备获取RFCOMM通道号。这可以通过指定服务名称而不是RFCOMM通道号来完成。支持的服务名称有：`IrMC`，`FTRN`和`OPUSH`。也可以将RFCOMM通道指定为数字。下面是一个OBEX会话的示例，其中从手机中获取设备信息对象，并将一个新的对象，即名片，推送到电话的目录中。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1276
#, no-wrap
msgid ""
"% obexapp -a 00:80:37:29:19:a4 -C IrMC\n"
"obex> get telecom/devinfo.txt devinfo-t39.txt\n"
"Success, response: OK, Success (0x20)\n"
"obex> put new.vcf\n"
"Success, response: OK, Success (0x20)\n"
"obex> di\n"
"Success, response: OK, Success (0x20)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1283
#, fuzzy
msgid ""
"In order to provide the OPUSH service, man:sdpd[8] must be running and a "
"root folder, where all incoming objects will be stored, must be created.  "
"The default path to the root folder is [.filename]#/var/spool/obex#.  "
"Finally, start the OBEX server on a valid RFCOMM channel number.  The OBEX "
"server will automatically register the OPUSH service with the local SDP "
"daemon.  The example below shows how to start the OBEX server."
msgstr ""
"为了提供OPUSH服务，man:sdpd[8]必须在运行，并且必须创建一个根文件夹，用于存储所有传入的对象。根文件夹的默认路径是[/var/spool/obex]。最后，在有效的RFCOMM通道编号上启动OBEX服务器。OBEX服务器将自动向本地SDP守护程序注册OPUSH服务。下面的示例显示了如何启动OBEX服务器。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1287
#, no-wrap
msgid "# obexapp -s -C 10\n"
msgstr ""

#. type: Title ====
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1289
#, fuzzy, no-wrap
msgid "Serial Port Profile (SPP)"
msgstr "串口配置文件（SPP）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1293
#, fuzzy
msgid ""
"The Serial Port Profile (SPP) allows Bluetooth devices to perform serial "
"cable emulation.  This profile allows legacy applications to use Bluetooth "
"as a cable replacement, through a virtual serial port abstraction."
msgstr ""
"串口配置文件（Serial Port "
"Profile，简称SPP）允许蓝牙设备进行串行电缆仿真。该配置文件允许传统应用程序通过虚拟串口抽象将蓝牙用作电缆替代品。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1298
#, fuzzy
msgid ""
"In FreeBSD, man:rfcomm_sppd[1] implements SPP and a pseudo tty is used as a "
"virtual serial port abstraction.  The example below shows how to connect to "
"a remote device's serial port service.  A RFCOMM channel does not have to be"
" specified as man:rfcomm_sppd[1] can obtain it from the remote device via "
"SDP.  To override this, specify a RFCOMM channel on the command line."
msgstr ""
"在FreeBSD中，man:rfcomm_sppd[1]实现了SPP，并且使用伪输入输出终端作为虚拟串口抽象。下面的示例展示了如何连接到远程设备的串口服务。man:rfcomm_sppd[1]可以通过SDP从远程设备获取RFCOMM通道，因此不需要指定RFCOMM通道。如果要覆盖这个行为，在命令行上指定一个RFCOMM通道。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1304
#, no-wrap
msgid ""
"# rfcomm_sppd -a 00:07:E0:00:0B:CA -t\n"
"rfcomm_sppd[94692]: Starting on /dev/pts/6...\n"
"/dev/pts/6\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1307
#, fuzzy
msgid "Once connected, the pseudo tty can be used as serial port:"
msgstr "一旦连接成功，伪终端（pseudo tty）可以用作串口："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1311
#, no-wrap
msgid "# cu -l /dev/pts/6\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1314
#, fuzzy
msgid ""
"The pseudo tty is printed on stdout and can be read by wrapper scripts:"
msgstr "伪终端（pseudo tty）会被打印在标准输出（stdout）上，并且可以被包装脚本读取："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1319
#, no-wrap
msgid ""
"PTS=`rfcomm_sppd -a 00:07:E0:00:0B:CA -t`\n"
"cu -l $PTS\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1327
#, fuzzy
msgid ""
"By default, when FreeBSD is accepting a new connection, it tries to perform "
"a role switch and become master.  Some older Bluetooth devices which do not "
"support role switching will not be able to connect.  Since role switching is"
" performed when a new connection is being established, it is not possible to"
" ask the remote device if it supports role switching.  However, there is a "
"HCI option to disable role switching on the local side:"
msgstr ""
"默认情况下，当FreeBSD接受新连接时，它会尝试执行角色切换并成为主设备。一些不支持角色切换的较旧的蓝牙设备将无法连接。由于角色切换是在建立新连接时执行的，无法询问远程设备是否支持角色切换。但是，有一个HCI选项可以在本地禁用角色切换："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1331
#, no-wrap
msgid "# hccontrol -n ubt0hci write_node_role_switch 0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1335
#, fuzzy
msgid ""
"To display Bluetooth packets, use the third-party package hcidump, which can"
" be installed using the package:comms/hcidump[] package or port.  This "
"utility is similar to man:tcpdump[1] and can be used to display the contents"
" of Bluetooth packets on the terminal and to dump the Bluetooth packets to a"
" file."
msgstr ""
"要显示蓝牙数据包，请使用第三方软件包 hcidump，可使用 package:comms/hcidump[] 包或端口进行安装。该实用工具类似于 "
"man:tcpdump[1]，可用于在终端上显示蓝牙数据包的内容，并将蓝牙数据包转储到文件中。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1337
#, fuzzy, no-wrap
msgid "Bridging"
msgstr "桥接"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1341
#, fuzzy
msgid ""
"It is sometimes useful to divide a network, such as an Ethernet segment, "
"into network segments without having to create IP subnets and use a router "
"to connect the segments together.  A device that connects two networks "
"together in this fashion is called a \"bridge\"."
msgstr ""
"有时候，将一个网络（如以太网段）划分为网络分段，并且无需创建IP子网和使用路由器将这些分段连接起来是很有用的。以这种方式连接两个网络的设备被称为“桥接器”。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1346
#, fuzzy
msgid ""
"A bridge works by learning the MAC addresses of the devices on each of its "
"network interfaces.  It forwards traffic between networks only when the "
"source and destination MAC addresses are on different networks.  In many "
"respects, a bridge is like an Ethernet switch with very few ports.  A "
"FreeBSD system with multiple network interfaces can be configured to act as "
"a bridge."
msgstr ""
"桥接器通过学习每个网络接口上设备的MAC地址来工作。只有当源MAC地址和目标MAC地址位于不同的网络上时，它才会在网络之间转发流量。在许多方面，桥接器类似于只有很少端口的以太网交换机。具有多个网络接口的FreeBSD系统可以配置为充当桥接器。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1348
#, fuzzy
msgid "Bridging can be useful in the following situations:"
msgstr "桥接技术在以下情况下非常有用："

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1349
#, fuzzy, no-wrap
msgid "Connecting Networks"
msgstr "连接网络"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1353
#, fuzzy
msgid ""
"The basic operation of a bridge is to join two or more network segments.  "
"There are many reasons to use a host-based bridge instead of networking "
"equipment, such as cabling constraints or firewalling.  A bridge can also "
"connect a wireless interface running in hostap mode to a wired network and "
"act as an access point."
msgstr ""
"桥接的基本操作是连接两个或多个网络段。使用主机级别的桥接而不是网络设备有许多原因，如缆线约束或防火墙。桥接还可以连接以hostap模式运行的无线接口和有线网络，充当访问点。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1354
#, fuzzy, no-wrap
msgid "Filtering/Traffic Shaping Firewall"
msgstr "过滤/流量塑形防火墙"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1356
#, fuzzy
msgid ""
"A bridge can be used when firewall functionality is needed without routing "
"or Network Address Translation (NAT)."
msgstr "当需要防火墙功能但不需要路由或网络地址转换（NAT）时，可以使用桥接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1361
#, fuzzy
msgid ""
"An example is a small company that is connected via DSL or ISDN to an ISP.  "
"There are thirteen public IP addresses from the ISP and ten computers on the"
" network.  In this situation, using a router-based firewall is difficult "
"because of subnetting issues.  A bridge-based firewall can be configured "
"without any IP addressing issues."
msgstr ""
"一个例子是一个小公司，通过DSL或ISDN连接到一个ISP。ISP提供了13个公共IP地址，并且网络上有10台计算机。在这种情况下，使用基于路由器的防火墙可能会因为子网划分的问题而困难。而基于桥接的防火墙可以在没有任何IP地址问题的情况下配置。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1362
#, fuzzy, no-wrap
msgid "Network Tap"
msgstr "网络监控点"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1364
#, fuzzy
msgid ""
"A bridge can join two network segments in order to inspect all Ethernet "
"frames that pass between them using man:bpf[4] and man:tcpdump[1] on the "
"bridge interface, or by sending a copy of all frames out on an additional "
"interface known as a span port."
msgstr ""
"一座桥可以连接两个网络段，以便使用桥接接口上的 man:bpf[4] 和 man:tcpdump[1] "
"进行检查传递的所有以太网帧，或者通过将所有帧的副本发送到一个额外的接口，也就是一个称为\"span port\"的接口。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1365
#, fuzzy, no-wrap
msgid "Layer 2 VPN"
msgstr "第二层虚拟专用网络（Layer 2 VPN）"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1367
#, fuzzy
msgid ""
"Two Ethernet networks can be joined across an IP link by bridging the "
"networks to an EtherIP tunnel or a man:tap[4] based solution such as "
"OpenVPN."
msgstr "通过将网络桥接到EtherIP隧道或基于man:tap[4]的解决方案（如OpenVPN），可以通过IP链接连接两个以太网网络。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1368
#, fuzzy, no-wrap
msgid "Layer 2 Redundancy"
msgstr "第二层冗余"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1370
#, fuzzy
msgid ""
"A network can be connected together with multiple links and use the Spanning"
" Tree Protocol (STP) to block redundant paths."
msgstr "一个网络可以通过多个链路连接在一起，并使用生成树协议 (STP) 来阻塞冗余路径。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1373
#, fuzzy
msgid ""
"This section describes how to configure a FreeBSD system as a bridge using "
"man:if_bridge[4].  A netgraph bridging driver is also available, and is "
"described in man:ng_bridge[4]."
msgstr ""
"本节描述了如何使用 man:if_bridge[4] 将一个 FreeBSD 系统配置为桥接。同时，还提供了一个 netgraph "
"桥接驱动程序，详细信息可参考 man:ng_bridge[4]。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1378
#, fuzzy
msgid ""
"Packet filtering can be used with any firewall package that hooks into the "
"man:pfil[9] framework.  The bridge can be used as a traffic shaper with "
"man:altq[4] or man:dummynet[4]."
msgstr ""
"数据包过滤可以与连接到 man:pfil[9] 框架的任何防火墙包一起使用。桥接器可以与 man:altq[4] 或 man:dummynet[4] "
"一起用作流量整形器。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1380
#, fuzzy, no-wrap
msgid "Enabling the Bridge"
msgstr "启用桥接功能"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1384
#, fuzzy
msgid ""
"In FreeBSD, man:if_bridge[4] is a kernel module which is automatically "
"loaded by man:ifconfig[8] when creating a bridge interface.  It is also "
"possible to compile bridge support into a custom kernel by adding `device "
"if_bridge` to the custom kernel configuration file."
msgstr ""
"在FreeBSD中，man:if_bridge[4]是一个内核模块，当创建一个桥接接口时，man:ifconfig[8]会自动加载它。还可以通过在自定义内核配置文件中添加`device"
" if_bridge`来编译桥接支持进自定义内核。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1387
#, fuzzy
msgid ""
"The bridge is created using interface cloning.  To create the bridge "
"interface:"
msgstr "使用接口克隆来创建桥接。要创建桥接口："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1398
#, no-wrap
msgid ""
"# ifconfig bridge create\n"
"bridge0\n"
"# ifconfig bridge0\n"
"bridge0: flags=8802<BROADCAST,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:00:00:00:00:00 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:00:00:00:00:00 priority 0 ifcost 0 port 0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1403
#, fuzzy
msgid ""
"When a bridge interface is created, it is automatically assigned a randomly "
"generated Ethernet address.  The `maxaddr` and `timeout` parameters control "
"how many MAC addresses the bridge will keep in its forwarding table and how "
"many seconds before each entry is removed after it is last seen.  The other "
"parameters control how STP operates."
msgstr ""
"当创建桥接接口时，会自动分配一个随机生成的以太网地址。`maxaddr`和`timeout`参数控制桥接将在其转发表中保留多少个MAC地址以及每个条目在最后一次被看到后多少秒被删除。其他参数控制STP的操作方式。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1406
#, fuzzy
msgid ""
"Next, specify which network interfaces to add as members of the bridge.  For"
" the bridge to forward packets, all member interfaces and the bridge need to"
" be up:"
msgstr "接下来，指定要添加为桥接成员的网络接口。为了使桥接转发数据包，所有成员接口和桥接都需要处于启用状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1412
#, no-wrap
msgid ""
"# ifconfig bridge0 addm fxp0 addm fxp1 up\n"
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1416
#, fuzzy
msgid ""
"The bridge can now forward Ethernet frames between [.filename]#fxp0# and "
"[.filename]#fxp1#.  Add the following lines to [.filename]#/etc/rc.conf# so "
"the bridge is created at startup:"
msgstr ""
"桥接器现在可以在 [.filename]#fxp0# 和 [.filename]#fxp1# 之间转发以太网帧。请将下列行添加至 "
"[.filename]#/etc/rc.conf# 文件，以便在启动时创建该桥接器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1423
#, no-wrap
msgid ""
"cloned_interfaces=\"bridge0\"\n"
"ifconfig_bridge0=\"addm fxp0 addm fxp1 up\"\n"
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1428
#, fuzzy
msgid ""
"If the bridge host needs an IP address, set it on the bridge interface, not "
"on the member interfaces.  The address can be set statically or via DHCP.  "
"This example sets a static IP address:"
msgstr ""
"如果桥接主机需要一个IP地址，请在桥接接口上设置它，而不是在成员接口上设置。该地址可以通过静态设置或DHCP设置。此示例设置了一个静态IP地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1432
#, no-wrap
msgid "# ifconfig bridge0 inet 192.168.0.1/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1436
#, fuzzy
msgid ""
"It is also possible to assign an IPv6 address to a bridge interface.  To "
"make the changes permanent, add the addressing information to "
"[.filename]#/etc/rc.conf#."
msgstr "也可以将 IPv6 地址分配给桥接口。为了使更改永久生效，请将地址信息添加到 `/etc/rc.conf` 文件中。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1442
#, fuzzy
msgid ""
"When packet filtering is enabled, bridged packets will pass through the "
"filter inbound on the originating interface on the bridge interface, and "
"outbound on the appropriate interfaces.  Either stage can be disabled.  When"
" direction of the packet flow is important, it is best to firewall on the "
"member interfaces rather than the bridge itself."
msgstr ""
"当启用数据包过滤时，桥接的数据包将通过过滤器传入到桥接接口的原始接口上，并通过相应的接口传出。任一阶段均可以禁用。当数据包流向很重要时，最好在成员接口上进行防火墙设置，而不是在桥接本身上进行。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1445
#, fuzzy
msgid ""
"The bridge has several configurable settings for passing non-IP and IP "
"packets, and layer2 firewalling with man:ipfw[8].  See man:if_bridge[4] for "
"more information."
msgstr ""
"这个桥接器有几个可配置的选项，用于传递非IP和IP数据包，并使用man:ipfw[8]进行第二层防火墙配置。有关更多信息，请参阅man:if_bridge[4]。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1447
#, fuzzy, no-wrap
msgid "Enabling Spanning Tree"
msgstr "启用生成树"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1452
#, fuzzy
msgid ""
"For an Ethernet network to function properly, only one active path can exist"
" between two devices.  The STP protocol detects loops and puts redundant "
"links into a blocked state.  Should one of the active links fail, STP "
"calculates a different tree and enables one of the blocked paths to restore "
"connectivity to all points in the network."
msgstr ""
"为了使以太网网络正常运行，两个设备之间只能存在一条活跃路径。STP协议可以检测到环路并将冗余链路置于阻塞状态。如果其中一条活跃链路失败，STP会计算出不同的树，并启用一条被阻塞的路径，以恢复网络中所有节点的连通性。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1456
#, fuzzy
msgid ""
"The Rapid Spanning Tree Protocol (RSTP or 802.1w) provides backwards "
"compatibility with legacy STP.  RSTP provides faster convergence and "
"exchanges information with neighboring switches to quickly transition to "
"forwarding mode without creating loops.  FreeBSD supports RSTP and STP as "
"operating modes, with RSTP being the default mode."
msgstr ""
"快速生成树协议（RSTP或802.1w）与传统的生成树协议（STP）保持向后兼容。RSTP提供更快的收敛速度，并与相邻交换机交换信息，以便在不创建环路的情况下快速转换为转发模式。FreeBSD支持RSTP和STP作为操作模式，其中RSTP是默认模式。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1459
#, fuzzy
msgid ""
"STP can be enabled on member interfaces using man:ifconfig[8].  For a bridge"
" with [.filename]#fxp0# and [.filename]#fxp1# as the current interfaces, "
"enable STP with:"
msgstr "使用man:ifconfig[8]可以在成员接口上启用STP。对于以.fx0#和.fx1#作为当前接口的桥接，可以使用以下命令启用STP："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1474
#, no-wrap
msgid ""
"# ifconfig bridge0 stp fxp0 stp fxp1\n"
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether d6:cf:d5:a0:94:6d\n"
"        id 00:01:02:4b:d4:50 priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 0 port 0\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 3 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1478
#, fuzzy
msgid ""
"This bridge has a spanning tree ID of `00:01:02:4b:d4:50` and a priority of "
"`32768`.  As the `root id` is the same, it indicates that this is the root "
"bridge for the tree."
msgstr ""
"这座桥的跨度树标识为 `00:01:02:4b:d4:50`，优先级为 `32768`。由于 `root id` 是相同的，这表明这是整个树的根桥。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1480
#, fuzzy
msgid "Another bridge on the network also has STP enabled:"
msgstr "网络上的另一个桥接设备也启用了STP："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1494
#, no-wrap
msgid ""
"bridge0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        ether 96:3d:4b:f1:79:7a\n"
"        id 00:13:d4:9a:06:7a priority 32768 hellotime 2 fwddelay 15\n"
"        maxage 20 holdcnt 6 proto rstp maxaddr 100 timeout 1200\n"
"        root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4\n"
"        member: fxp0 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 4 priority 128 path cost 200000 proto rstp\n"
"                role root state forwarding\n"
"        member: fxp1 flags=1c7<LEARNING,DISCOVER,STP,AUTOEDGE,PTP,AUTOPTP>\n"
"                port 5 priority 128 path cost 200000 proto rstp\n"
"                role designated state forwarding\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1498
#, fuzzy
msgid ""
"The line `root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` "
"shows that the root bridge is `00:01:02:4b:d4:50` and has a path cost of "
"`400000` from this bridge.  The path to the root bridge is via `port 4` "
"which is [.filename]#fxp0#."
msgstr ""
"此行 `root id 00:01:02:4b:d4:50 priority 32768 ifcost 400000 port 4` 表明根桥的标识是 "
"`00:01:02:4b:d4:50`，从此桥到根桥的路径成本是 `400000`。到达根桥的路径是通过 [.filename]#fxp0# 的 "
"`port 4`。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1499
#, fuzzy, no-wrap
msgid "Bridge Interface Parameters"
msgstr "桥接接口参数"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1504
#, fuzzy
msgid ""
"Several `ifconfig` parameters are unique to bridge interfaces.  This section"
" summarizes some common uses for these parameters.  The complete list of "
"available parameters is described in man:ifconfig[8]."
msgstr ""
"一些 `ifconfig` 参数仅适用于桥接接口。本节概述了这些参数的一些常见用法。可用参数的完整列表在 man:ifconfig[8] 中进行了描述。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1505
#, fuzzy, no-wrap
msgid "private"
msgstr "私有的"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1509
#, fuzzy
msgid ""
"A private interface does not forward any traffic to any other port that is "
"also designated as a private interface.  The traffic is blocked "
"unconditionally so no Ethernet frames will be forwarded, including ARP "
"packets.  If traffic needs to be selectively blocked, a firewall should be "
"used instead."
msgstr ""
"私有接口不会将任何流量转发到任何其他被指定为私有接口的端口上。该流量被无条件地阻止，因此不会转发任何以太网帧，包括ARP数据包。如果需要有选择地阻止流量，应该使用防火墙。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1510
#, fuzzy, no-wrap
msgid "span"
msgstr "跨度"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1515
#, fuzzy
msgid ""
"A span port transmits a copy of every Ethernet frame received by the bridge."
"  The number of span ports configured on a bridge is unlimited, but if an "
"interface is designated as a span port, it cannot also be used as a regular "
"bridge port.  This is most useful for snooping a bridged network passively "
"on another host connected to one of the span ports of the bridge.  For "
"example, to send a copy of all frames out the interface named "
"[.filename]#fxp4#:"
msgstr ""
"一个`Span`端口会传输桥接器接收到的每个以太网帧的副本。在一个桥接器上配置的`Span`端口数量是无限的，但是如果一个接口被指定为`Span`端口，它就不能再用作普通的桥接器端口。这对于在连接到桥接器的一个`Span`端口的另一台主机上被动地窥视桥接网络非常有用。例如，要将所有帧的副本发送到名为[.filename]#fxp4#的接口上："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1519
#, no-wrap
msgid "# ifconfig bridge0 span fxp4\n"
msgstr ""

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1521
#, fuzzy, no-wrap
msgid "sticky"
msgstr ""
"sticky的意思是“粘性的”或“黏性的”。在计算机领域，它通常用来描述某些元素在页面上固定位置，随着页面滚动而保持在屏幕上方或下方不动。这种效果常用于导航栏或其他重要的页面元素，以便用户可以始终访问它们。在asciidoc格式中，无需特殊处理，可以直接使用\"sticky\"一词。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1526
#, fuzzy
msgid ""
"If a bridge member interface is marked as sticky, dynamically learned "
"address entries are treated as static entries in the forwarding cache.  "
"Sticky entries are never aged out of the cache or replaced, even if the "
"address is seen on a different interface.  This gives the benefit of static "
"address entries without the need to pre-populate the forwarding table.  "
"Clients learned on a particular segment of the bridge cannot roam to another"
" segment."
msgstr ""
"如果桥接成员接口被标记为粘性（sticky），动态学习的地址条目将被视为转发缓存中的静态条目。粘性条目永远不会在缓存中过期或被替换，即使地址在不同接口上被检测到也如此。这提供了静态地址条目的好处，而无需预先填充转发表。在桥接的特定段上学习的客户端不能漫游到另一个段上。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1529
#, fuzzy
msgid ""
"An example of using sticky addresses is to combine the bridge with VLANs in "
"order to isolate customer networks without wasting IP address space.  "
"Consider that `CustomerA` is on `vlan100`, `CustomerB` is on `vlan101`, and "
"the bridge has the address `192.168.0.1`:"
msgstr ""
"使用粘性地址的一个例子是将桥接与VLAN结合使用，以便在不浪费IP地址空间的情况下隔离客户网络。假设 `CustomerA` 在 "
"`vlan100`上，`CustomerB` 在 `vlan101`上，桥接设备的地址为 `192.168.0.1`："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1534
#, no-wrap
msgid ""
"# ifconfig bridge0 addm vlan100 sticky vlan100 addm vlan101 sticky vlan101\n"
"# ifconfig bridge0 inet 192.168.0.1/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1538
#, fuzzy
msgid ""
"In this example, both clients see `192.168.0.1` as their default gateway.  "
"Since the bridge cache is sticky, one host cannot spoof the MAC address of "
"the other customer in order to intercept their traffic."
msgstr ""
"在这个例子中，两个客户端都将`192.168.0.1`作为它们的默认网关。由于桥接缓存是黏性的，一个主机不能伪造另一个客户的MAC地址以截取它们的流量。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1540
#, fuzzy
msgid ""
"Any communication between the VLANs can be blocked using a firewall or, as "
"seen in this example, private interfaces:"
msgstr "任何位于不同VLAN之间的通信均可以通过防火墙或私有接口进行阻止，就像这个例子中一样："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1544
#, no-wrap
msgid "# ifconfig bridge0 private vlan100 private vlan101\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1547
#, fuzzy
msgid ""
"The customers are completely isolated from each other and the full `/24` "
"address range can be allocated without subnetting."
msgstr "客户之间完全隔离，可以分配整个 `/24` 地址范围而无需进行子网划分。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1550
#, fuzzy
msgid ""
"The number of unique source MAC addresses behind an interface can be "
"limited.  Once the limit is reached, packets with unknown source addresses "
"are dropped until an existing host cache entry expires or is removed."
msgstr "接口后面的唯一源MAC地址数量可以受限制。一旦达到限制，具有未知源地址的数据包将被丢弃，直到现有的主机缓存条目过期或被移除。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1552
#, fuzzy
msgid ""
"The following example sets the maximum number of Ethernet devices for "
"`CustomerA` on `vlan100` to 10:"
msgstr "以下示例将 `CustomerA` 在 `vlan100` 上的以太网设备的最大数量设置为 10："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1556
#, no-wrap
msgid "# ifconfig bridge0 ifmaxaddr vlan100 10\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1562
#, fuzzy
msgid ""
"Bridge interfaces also support monitor mode, where the packets are discarded"
" after man:bpf[4] processing and are not processed or forwarded further.  "
"This can be used to multiplex the input of two or more interfaces into a "
"single man:bpf[4] stream.  This is useful for reconstructing the traffic for"
" network taps that transmit the RX/TX signals out through two separate "
"interfaces.  For example, to read the input from four network interfaces as "
"one stream:"
msgstr ""
"桥接接口还支持监视模式，其中数据包在经过 man:bpf[4] 处理后被丢弃，不进一步处理或转发。这可以用于将两个或多个接口的输入多路复用到单个的 "
"man:bpf[4] 流中。这对于重构通过两个单独接口传输 RX/TX 信号的网络监听器的流量非常有用。例如，要将四个网络接口的输入作为一个流进行读取："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1567
#, no-wrap
msgid ""
"# ifconfig bridge0 addm fxp0 addm fxp1 addm fxp2 addm fxp3 monitor up\n"
"# tcpdump -i bridge0\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1569
#, fuzzy, no-wrap
msgid "SNMP Monitoring"
msgstr "SNMP 监控"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1573
#, fuzzy
msgid ""
"The bridge interface and STP parameters can be monitored via man:bsnmpd[1] "
"which is included in the FreeBSD base system.  The exported bridge MIBs "
"conform to IETF standards so any SNMP client or monitoring package can be "
"used to retrieve the data."
msgstr ""
"Bridge接口和STP参数可以通过man:bsnmpd[1]监控，该工具包含在FreeBSD基础系统中。导出的桥接管理信息库 (MIBs) "
"符合IETF标准，因此可以使用任何SNMP客户端或监控软件来检索数据。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1575
#, fuzzy
msgid ""
"To enable monitoring on the bridge, uncomment this line in "
"[.filename]#/etc/snmpd.config# by removing the beginning `+#+` symbol:"
msgstr "要在桥接上启用监控，请取消注释文件[.filename]#/etc/snmpd.config#中的此行，即删除开头的`+#+`符号："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1579
#, no-wrap
msgid "begemotSnmpdModulePath.\"bridge\" = \"/usr/lib/snmp_bridge.so\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1584
#, fuzzy
msgid ""
"Other configuration settings, such as community names and access lists, may "
"need to be modified in this file.  See man:bsnmpd[1] and man:snmp_bridge[3] "
"for more information.  Once these edits are saved, add this line to "
"[.filename]#/etc/rc.conf#:"
msgstr ""
"在这个文件中，可能需要修改其他配置设置，比如社区名称和访问列表。更多信息请参考man:bsnmpd[1]和man:snmp_bridge[3]。一旦这些编辑保存好了，将这行代码添加到[.filename]#/etc/rc.conf#文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1588
#, no-wrap
msgid "bsnmpd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1591
#, fuzzy
msgid "Then, start man:bsnmpd[1]:"
msgstr "然后，运行 man:bsnmpd[1] 命令："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1595
#, no-wrap
msgid "# service bsnmpd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1600
#, fuzzy
msgid ""
"The following examples use the Net-SNMP software (package:net-mgmt/net-"
"snmp[]) to query a bridge from a client system.  The package:net-"
"mgmt/bsnmptools[] port can also be used.  From the SNMP client which is "
"running Net-SNMP, add the following lines to "
"[.filename]#$HOME/.snmp/snmp.conf# in order to import the bridge MIB "
"definitions:"
msgstr ""
"以下示例使用Net-SNMP软件（包:net-mgmt/net-snmp[]）从客户端系统查询桥接器。还可以使用package:net-"
"mgmt/bsnmptools[]端口。请在运行Net-"
"SNMP的SNMP客户端中，将以下行添加到[.filename]#$HOME/.snmp/snmp.conf#以导入桥接器MIB定义："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1605
#, no-wrap
msgid ""
"mibdirs +/usr/share/snmp/mibs\n"
"mibs +BRIDGE-MIB:RSTP-MIB:BEGEMOT-MIB:BEGEMOT-BRIDGE-MIB\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1608
#, fuzzy
msgid "To monitor a single bridge using the IETF BRIDGE-MIB (RFC4188):"
msgstr "使用IETF BRIDGE-MIB (RFC4188) 监控单个桥接器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1627
#, no-wrap
msgid ""
"% snmpwalk -v 2c -c public bridge1.example.com mib-2.dot1dBridge\n"
"BRIDGE-MIB::dot1dBaseBridgeAddress.0 = STRING: 66:fb:9b:6e:5c:44\n"
"BRIDGE-MIB::dot1dBaseNumPorts.0 = INTEGER: 1 ports\n"
"BRIDGE-MIB::dot1dStpTimeSinceTopologyChange.0 = Timeticks: (189959) 0:31:39.59 centi-seconds\n"
"BRIDGE-MIB::dot1dStpTopChanges.0 = Counter32: 2\n"
"BRIDGE-MIB::dot1dStpDesignatedRoot.0 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"...\n"
"BRIDGE-MIB::dot1dStpPortState.3 = INTEGER: forwarding(5)\n"
"BRIDGE-MIB::dot1dStpPortEnable.3 = INTEGER: enabled(1)\n"
"BRIDGE-MIB::dot1dStpPortPathCost.3 = INTEGER: 200000\n"
"BRIDGE-MIB::dot1dStpPortDesignatedRoot.3 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedCost.3 = INTEGER: 0\n"
"BRIDGE-MIB::dot1dStpPortDesignatedBridge.3 = Hex-STRING: 80 00 00 01 02 4B D4 50\n"
"BRIDGE-MIB::dot1dStpPortDesignatedPort.3 = Hex-STRING: 03 80\n"
"BRIDGE-MIB::dot1dStpPortForwardTransitions.3 = Counter32: 1\n"
"RSTP-MIB::dot1dStpVersion.0 = INTEGER: rstp(2)\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1632
#, fuzzy
msgid ""
"The `dot1dStpTopChanges.0` value is two, indicating that the STP bridge "
"topology has changed twice.  A topology change means that one or more links "
"in the network have changed or failed and a new tree has been calculated.  "
"The `dot1dStpTimeSinceTopologyChange.0` value will show when this happened."
msgstr ""
"`dot1dStpTopChanges.0` 的值为 2，表示 STP "
"桥接的拓扑结构已经发生了两次变化。拓扑变化意味着网络中的一个或多个链路发生了改变或故障，并重新计算了新的树结构。`dot1dStpTimeSinceTopologyChange.0`"
" 的值将显示这个变化发生的时间。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1634
#, fuzzy
msgid ""
"To monitor multiple bridge interfaces, the private BEGEMOT-BRIDGE-MIB can be"
" used:"
msgstr "要监控多个桥接接口，可以使用私有的BEGEMOT-BRIDGE-MIB。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1652
#, no-wrap
msgid ""
"% snmpwalk -v 2c -c public bridge1.example.com\n"
"enterprises.fokus.begemot.begemotBridge\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge0\" = STRING: bridge0\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseName.\"bridge2\" = STRING: bridge2\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge0\" = STRING: e:ce:3b:5a:9e:13\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseAddress.\"bridge2\" = STRING: 12:5e:4d:74:d:fc\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge0\" = INTEGER: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeBaseNumPorts.\"bridge2\" = INTEGER: 1\n"
"...\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge0\" = Timeticks: (116927) 0:19:29.27 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTimeSinceTopologyChange.\"bridge2\" = Timeticks: (82773) 0:13:47.73 centi-seconds\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge0\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpTopChanges.\"bridge2\" = Counter32: 1\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge0\" = Hex-STRING: 80 00 00 40 95 30 5E 31\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeStpDesignatedRoot.\"bridge2\" = Hex-STRING: 80 00 00 50 8B B8 C6 A9\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1655
#, fuzzy
msgid ""
"To change the bridge interface being monitored via the `mib-2.dot1dBridge` "
"subtree:"
msgstr "要更改通过 `mib-2.dot1dBridge` 子树进行监控的桥接口："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1660
#, no-wrap
msgid ""
"% snmpset -v 2c -c private bridge1.example.com\n"
"BEGEMOT-BRIDGE-MIB::begemotBridgeDefaultBridgeIf.0 s bridge2\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1663
#, fuzzy, no-wrap
msgid "Link Aggregation and Failover"
msgstr "链路聚合和故障转移"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1668
#, fuzzy
msgid ""
"FreeBSD provides the man:lagg[4] interface which can be used to aggregate "
"multiple network interfaces into one virtual interface in order to provide "
"failover and link aggregation.  Failover allows traffic to continue to flow "
"as long as at least one aggregated network interface has an established "
"link.  Link aggregation works best on switches which support LACP, as this "
"protocol distributes traffic bi-directionally while responding to the "
"failure of individual links."
msgstr ""
"FreeBSD提供了man:lagg[4]接口，可以将多个网络接口聚合成一个虚拟接口，以提供故障转移和链路聚合功能。故障转移允许流量在至少有一个已建立链接的聚合网络接口的情况下继续传输。链路聚合在支持LACP协议的交换机上表现最佳，该协议可以双向分配流量并在单个链接故障时做出响应。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1671
#, fuzzy
msgid ""
"The aggregation protocols supported by the lagg interface determine which "
"ports are used for outgoing traffic and whether or not a specific port "
"accepts incoming traffic.  The following protocols are supported by "
"man:lagg[4]:"
msgstr "lagg接口支持的聚合协议决定了哪些端口用于出口流量，以及特定端口是否接收入口流量。man:lagg[4]支持以下协议："

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1672
#, fuzzy, no-wrap
msgid "failover"
msgstr "故障转移"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1677
#, fuzzy
msgid ""
"This mode sends and receives traffic only through the master port.  If the "
"master port becomes unavailable, the next active port is used.  The first "
"interface added to the virtual interface is the master port and all "
"subsequently added interfaces are used as failover devices.  If failover to "
"a non-master port occurs, the original port becomes master once it becomes "
"available again."
msgstr ""
"该模式仅通过主端口发送和接收流量。如果主端口不可用，则使用下一个活动端口。添加到虚拟接口的第一个接口是主端口，随后添加的接口将用作故障转移设备。如果故障转移到非主端口，则一旦原始端口再次可用，它将恢复为主端口。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1678
#, fuzzy, no-wrap
msgid "loadbalance"
msgstr "负载均衡"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1681
#, fuzzy
msgid ""
"This provides a static setup and does not negotiate aggregation with the "
"peer or exchange frames to monitor the link.  If the switch supports LACP, "
"that should be used instead."
msgstr "这提供了一个静态设置，不与对等方协商聚合或交换帧来监视链路。如果交换机支持链路聚合控制协议（LACP），应使用 LACP。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1682
#, fuzzy, no-wrap
msgid "lacp"
msgstr ""
"LACP 是链路聚合控制协议（Link Aggregation Control "
"Protocol）的缩写，用于在计算机网络中实现链路聚合。通过组合多个物理链路，LACP "
"允许它们作为一个逻辑链路来传输数据，以提供更高的带宽和冗余。LACP "
"是一个用于以太网的标准协议，在网络设备之间进行双向通信以协商和管理链路聚合。它提供了一种动态的方式来分配和管理链路负载，以提高网络性能和可靠性。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1687
#, fuzzy
msgid ""
"The IEEE(R) 802.3ad Link Aggregation Control Protocol (LACP) negotiates a "
"set of aggregable links with the peer into one or more Link Aggregated "
"Groups (LAGs).  Each LAG is composed of ports of the same speed, set to "
"full-duplex operation, and traffic is balanced across the ports in the LAG "
"with the greatest total speed.  Typically, there is only one LAG which "
"contains all the ports.  In the event of changes in physical connectivity, "
"LACP will quickly converge to a new configuration."
msgstr ""
"IEEE(R) "
"802.3ad链路聚合控制协议（LACP）与对等方协商一组可聚合的链路，形成一个或多个链接聚合组（LAG）。每个LAG由速度相同、设置为全双工操作的端口组成，流量在LAG中的端口之间平衡，选择总速度最高的LAG。通常情况下，只有一个包含所有端口的LAG。在物理连接发生变化时，LACP将迅速收敛到新的配置。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1690
#, fuzzy
msgid ""
"LACP balances outgoing traffic across the active ports based on hashed "
"protocol header information and accepts incoming traffic from any active "
"port.  The hash includes the Ethernet source and destination address and, if"
" available, the VLAN tag, and the IPv4 or IPv6 source and destination "
"address."
msgstr ""
"LACP根据哈希协议头信息平衡出站流量，并接受来自任何活动端口的入站流量。哈希包括以太网源地址和目的地址，如果可用，还包括VLAN标签以及IPv4或IPv6的源地址和目的地址。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1691
#, fuzzy, no-wrap
msgid "roundrobin"
msgstr ""
"Round "
"Robin（循环调度）是一种调度算法，用于在计算机系统中按照每个任务的轮流方式进行分配处理时间。它确保每个任务都能获得相对公平的处理时间，避免某些长时间运行的任务占用过多的处理资源。在循环调度中，每个任务按照先来先服务的原则排队，每个任务被分配一个固定的时间片，当时间片用完时，任务将被挂起并传递给下一个任务。循环调度算法广泛应用于操作系统中的进程调度和任务分配。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1694
#, fuzzy
msgid ""
"This mode distributes outgoing traffic using a round-robin scheduler through"
" all active ports and accepts incoming traffic from any active port.  Since "
"this mode violates Ethernet frame ordering, it should be used with caution."
msgstr "这种模式通过轮询调度算法将出站流量分发到所有活动端口，并接收来自任何活动端口的入站流量。由于这种模式违反了以太网帧的顺序，因此应谨慎使用。"

#. type: Labeled list
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1695
#, fuzzy, no-wrap
msgid "broadcast"
msgstr "广播"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1697
#, fuzzy
msgid ""
"This mode sends outgoing traffic to all ports configured on the lagg "
"interface, and receives frames on any port."
msgstr "该模式将输出流量发送到在lagg接口上配置的所有端口，并在任何端口上接收帧。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1698
#, fuzzy, no-wrap
msgid "Configuration Examples"
msgstr ""
"配置示例\n"
"\n"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1702
#, fuzzy
msgid ""
"This section demonstrates how to configure a Cisco(R) switch and a FreeBSD "
"system for LACP load balancing.  It then shows how to configure two Ethernet"
" interfaces in failover mode as well as how to configure failover mode "
"between an Ethernet and a wireless interface."
msgstr ""
"本节演示了如何配置 Cisco(R) 交换机和 FreeBSD 系统以实现 LACP "
"负载均衡。然后展示了如何配置两个以故障转移模式工作的以太网接口，以及如何在以太网接口和无线接口之间配置故障转移模式。"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1704
#, fuzzy, no-wrap
msgid "LACP Aggregation with a Cisco(R) Switch"
msgstr ""
"使用Cisco(R)交换机的LACP聚合\n"
"\n"
"LACP（Link Aggregation Control Protocol，链路聚合控制协议）是一种用于将多个物理链路组合成一个逻辑链路的协议。通过使用LACP聚合，可以提高网络的带宽和可靠性。\n"
"\n"
"要在Cisco交换机上配置LACP聚合，需要执行以下步骤：\n"
"\n"
"1. 使用适当的接口命令（如`interface GigabitEthernet1/0/1`）进入要配置的接口模式。\n"
"\n"
"2. 使用`channel-group`命令将接口添加到聚合组中，如下所示：\n"
"   ```\n"
"   channel-group <group-number> mode active\n"
"   ```\n"
"   这里的`<group-number>`是聚合组的数字标识符。`mode active`表示启用主动模式，该模式表示交换机将发送LACP请求。\n"
"\n"
"3. 重复步骤1和2，将其他要聚合的接口添加到同一聚合组中。\n"
"\n"
"4. 使用`switchport mode trunk`命令将聚合组端口设置为trunk模式，以支持多个VLAN的传输。\n"
"\n"
"5. 验证LACP聚合的状态和配置信息，可以使用`show etherchannel summary`和`show etherchannel detail`命令。\n"
"\n"
"请注意，LACP聚合需要在所有参与聚合的交换机上进行配置，并且接口设置和聚合组设置必须匹配。\n"
"\n"
"使用LACP聚合可以提供更高的容错性和可用性，并增加了网络的带宽。同时，使用Cisco交换机的LACP聚合提供了一种灵活和可靠的解决方案。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1710
#, fuzzy
msgid ""
"This example connects two man:fxp[4] Ethernet interfaces on a FreeBSD "
"machine to the first two Ethernet ports on a Cisco(R) switch as a single "
"load balanced and fault tolerant link.  More interfaces can be added to "
"increase throughput and fault tolerance.  Replace the names of the Cisco(R) "
"ports, Ethernet devices, channel group number, and IP address shown in the "
"example to match the local configuration."
msgstr ""
"这个示例将一个 FreeBSD 机器上的两个 man:fxp[4] 以单一的负载均衡和容错链路的形式连接到 Cisco(R) "
"交换机的前两个以太网端口。可以添加更多接口来增加吞吐量和容错能力。请根据本地配置，替换示例中所显示的 Cisco(R) 端口、以太网设备、通道组编号和 "
"IP 地址的名称。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1713
#, fuzzy
msgid ""
"Frame ordering is mandatory on Ethernet links and any traffic between two "
"stations always flows over the same physical link, limiting the maximum "
"speed to that of one interface.  The transmit algorithm attempts to use as "
"much information as it can to distinguish different traffic flows and "
"balance the flows across the available interfaces."
msgstr ""
"在以太网链路上，帧排序是强制的，两个站点之间的所有流量都始终通过同一物理链路传输，从而限制了最大速度为一个接口的速度。传输算法试图利用尽可能多的信息来区分不同的流量，并在可用接口之间平衡流量。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1715
#, fuzzy
msgid ""
"On the Cisco(R) switch, add the _FastEthernet0/1_ and _FastEthernet0/2_ "
"interfaces to channel group _1_:"
msgstr ""
"在 Cisco(R) 开关上，将 _FastEthernet0/1_ 和 _FastEthernet0/2_ 接口添加到通道组 _1_ 上："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1725
#, no-wrap
msgid ""
"interface FastEthernet0/1\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"
"!\n"
"interface FastEthernet0/2\n"
" channel-group 1 mode active\n"
" channel-protocol lacp\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1728
#, fuzzy
msgid ""
"On the FreeBSD system, create the man:lagg[4] interface using the physical "
"interfaces _fxp0_ and _fxp1_ and bring the interfaces up with an IP address "
"of _10.0.0.3/24_:"
msgstr ""
"在FreeBSD系统上，使用物理接口 _fxp0_ 和 _fxp1_ 创建 man:lagg[4] 接口，并使用 _10.0.0.3/24_ "
"的IP地址启用这些接口："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1735
#, no-wrap
msgid ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1738
#, fuzzy
msgid "Next, verify the status of the virtual interface:"
msgstr "接下来，验证虚拟接口的状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1751
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.3 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto lacp\n"
"        laggport: fxp1 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"
"        laggport: fxp0 flags=1c<ACTIVE,COLLECTING,DISTRIBUTING>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1756
#, fuzzy
msgid ""
"Ports marked as `ACTIVE` are part of the LAG that has been negotiated with "
"the remote switch.  Traffic will be transmitted and received through these "
"active ports.  Add `-v` to the above command to view the LAG identifiers."
msgstr ""
"标记为 `ACTIVE` 的端口是与远程交换机协商的 LAG 的一部分。通过这些活动端口传输和接收流量。在上述命令中添加 `-v` 以查看 LAG "
"标识符。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1758
#, fuzzy
msgid "To see the port status on the Cisco(R) switch:"
msgstr "要查看Cisco(R)交换机的端口状态："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1765
#, no-wrap
msgid ""
"switch# show lacp neighbor\n"
"Flags:  S - Device is requesting Slow LACPDUs\n"
"        F - Device is requesting Fast LACPDUs\n"
"        A - Device is in Active mode       P - Device is in Passive mode\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1767
#, no-wrap
msgid "Channel group 1 neighbors\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1769
#, no-wrap
msgid "Partner's information:\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1774
#, no-wrap
msgid ""
"                  LACP port                        Oper    Port     Port\n"
"Port      Flags   Priority  Dev ID         Age     Key     Number   State\n"
"Fa0/1     SA      32768     0005.5d71.8db8  29s    0x146   0x3      0x3D\n"
"Fa0/2     SA      32768     0005.5d71.8db8  29s    0x146   0x4      0x3D\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1777
#, fuzzy
msgid "For more detail, type `show lacp neighbor detail`."
msgstr "要获取更详细的信息，请键入 `show lacp neighbor detail`。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1779
#, fuzzy
msgid ""
"To retain this configuration across reboots, add the following entries to "
"[.filename]#/etc/rc.conf# on the FreeBSD system:"
msgstr "为了在重新启动后保留此配置，请将以下内容添加到 FreeBSD 系统上的 /etc/rc.conf 文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1786
#, no-wrap
msgid ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto lacp laggport fxp0 laggport fxp1 10.0.0.3/24\"\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1791
#, fuzzy, no-wrap
msgid "Failover Mode"
msgstr "故障转移模式"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1798
#, fuzzy
msgid ""
"Failover mode can be used to switch over to a secondary interface if the "
"link is lost on the master interface.  To configure failover, make sure that"
" the underlying physical interfaces are up, then create the man:lagg[4] "
"interface.  In this example, _fxp0_ is the master interface, _fxp1_ is the "
"secondary interface, and the virtual interface is assigned an IP address of "
"_10.0.0.15/24_:"
msgstr ""
"如果主接口的链路丢失，可以使用故障转移模式切换到备用接口。要配置故障转移，请确保底层物理接口正常运行，然后创建 man:lagg[4] "
"接口。在这个例子中，_fxp0_ 是主接口，_fxp1_ 是备用接口，并且虚拟接口被分配一个 IP 地址为 _10.0.0.15/24_。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1805
#, no-wrap
msgid ""
"# ifconfig fxp0 up\n"
"# ifconfig fxp1 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1808
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1909
#, fuzzy
msgid "The virtual interface should look something like this:"
msgstr "虚拟接口应该类似于这样："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1821
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether 00:05:5d:71:8d:b8\n"
"        inet 10.0.0.15 netmask 0xffffff00 broadcast 10.0.0.255\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
"        laggproto failover\n"
"        laggport: fxp1 flags=0<>\n"
"        laggport: fxp0 flags=5<MASTER,ACTIVE>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1826
#, fuzzy
msgid ""
"Traffic will be transmitted and received on _fxp0_.  If the link is lost on "
"_fxp0_, _fxp1_ will become the active link.  If the link is restored on the "
"master interface, it will once again become the active link."
msgstr ""
"数据流将在 _fxp0_ 上进行传输和接收。如果 _fxp0_ 上的连接丢失，_fxp1_ "
"将成为活动连接。如果主接口上的连接恢复，它将再次成为活动连接。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1828
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1932
#, fuzzy
msgid ""
"To retain this configuration across reboots, add the following entries to "
"[.filename]#/etc/rc.conf#:"
msgstr "为了在重启后保留该配置，请将以下内容添加到`/etc/rc.conf`文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1835
#, no-wrap
msgid ""
"ifconfig_fxp0=\"up\"\n"
"ifconfig_fxp1=\"up\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"laggproto failover laggport fxp0 laggport fxp1 10.0.0.15/24\"\n"
msgstr ""

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1840
#, fuzzy, no-wrap
msgid "Failover Mode Between Ethernet and Wireless Interfaces"
msgstr "以太网和无线接口之间的故障转移模式"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1846
#, fuzzy
msgid ""
"For laptop users, it is usually desirable to configure the wireless device "
"as a secondary which is only used when the Ethernet connection is not "
"available.  With man:lagg[4], it is possible to configure a failover which "
"prefers the Ethernet connection for both performance and security reasons, "
"while maintaining the ability to transfer data over the wireless connection."
msgstr ""
"对于笔记本电脑用户来说，通常希望将无线设备配置为次要设备，仅在以太网连接不可用时使用。通过使用 "
"man:lagg[4]，可以配置故障转移，以便出于性能和安全原因优先选择以太网连接，同时保持通过无线连接传输数据的能力。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1848
#, fuzzy
msgid ""
"This is achieved by overriding the Ethernet interface's MAC address with "
"that of the wireless interface."
msgstr "这是通过使用无线接口的MAC地址来覆盖以太网接口的MAC地址来实现的。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1854
#, fuzzy
msgid ""
"In theory, either the Ethernet or wireless MAC address can be changed to "
"match the other.  However, some popular wireless interfaces lack support for"
" overriding the MAC address.  We therefore recommend overriding the Ethernet"
" MAC address for this purpose."
msgstr ""
"理论上，Ethernet和无线MAC地址都可以更改以匹配另一个。然而，一些流行的无线接口缺乏支持覆盖MAC地址的功能。因此，我们建议为此目的覆盖Ethernet的MAC地址。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1861
#, fuzzy
msgid ""
"If the driver for the wireless interface is not loaded in the `GENERIC` or "
"custom kernel, and the computer is running FreeBSD {rel121-current}, load "
"the corresponding [.filename]#.ko# in [.filename]#/boot/loader.conf# by "
"adding `*driver_load=\"YES\"*` to that file and rebooting.  Another, better "
"way is to load the driver in [.filename]#/etc/rc.conf# by adding it to "
"`kld_list` (see man:rc.conf[5] for details) in that file and rebooting.  "
"This is needed because otherwise the driver is not loaded yet at the time "
"the man:lagg[4] interface is set up."
msgstr ""
"如果在`GENERIC`或自定义内核中没有加载无线接口的驱动程序，并且计算机正在运行FreeBSD "
"{rel121-current}，则通过在`.filename`中添加`*driver_load=\"YES\"*`到`.filename`目录下的`/boot/loader.conf`文件中来加载相应的`.ko`文件，并重新启动计算机。另一种更好的方法是通过将其添加到`/etc/rc.conf`文件的`kld_list`中（详细信息请参见man:rc.conf[5]）来在`.filename`目录下加载驱动程序，并重新启动计算机。这是必需的，因为否则在设置man:lagg[4]接口时驱动程序尚未加载。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1867
#, fuzzy
msgid ""
"In this example, the Ethernet interface, _re0_, is the master and the "
"wireless interface, _wlan0_, is the failover.  The _wlan0_ interface was "
"created from the _ath0_ physical wireless interface, and the Ethernet "
"interface will be configured with the MAC address of the wireless interface."
"  First, bring the wireless interface up (replacing _FR_ with your own "
"2-letter country code), but do not set an IP address.  Replace _wlan0_ to "
"match the system's wireless interface name:"
msgstr ""
"在这个示例中，以太网接口 `_re0_` 是主接口，无线接口 `_wlan0_` 是故障切换接口。无线接口 `_wlan0_` 是由物理无线接口 "
"`_ath0_` 创建的，并且以太网接口将使用无线接口的MAC地址进行配置。首先，启动无线接口（将 `_FR_` "
"替换为您自己的两个字母的国家代码），但不设置IP地址。将 `_wlan0_` 替换为与系统的无线接口名称匹配的名称："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1871
#, no-wrap
msgid "# ifconfig wlan0 create wlandev ath0 country FR ssid my_router up\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1874
#, fuzzy
msgid "Now you can determine the MAC address of the wireless interface:"
msgstr "现在，您可以确定无线接口的MAC地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1889
#, no-wrap
msgid ""
"# ifconfig wlan0\n"
"wlan0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"\tether b8:ee:65:5b:32:59\n"
"\tgroups: wlan\n"
"\tssid Bbox-A3BD2403 channel 6 (2437 MHz 11g ht/20) bssid 00:37:b7:56:4b:60\n"
"\tregdomain ETSI country FR indoor ecm authmode WPA2/802.11i privacy ON\n"
"\tdeftxkey UNDEF AES-CCM 2:128-bit txpower 30 bmiss 7 scanvalid 60\n"
"\tprotmode CTS ampdulimit 64k ampdudensity 8 shortgi -stbctx stbcrx\n"
"\t-ldpc wme burst roaming MANUAL\n"
"\tmedia: IEEE 802.11 Wireless Ethernet MCS mode 11ng\n"
"\tstatus: associated\n"
"\tnd6 options=29<PERFORMNUD,IFDISABLED,AUTO_LINKLOCAL>\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1893
#, fuzzy
msgid ""
"The `ether` line will contain the MAC address of the specified interface.  "
"Now, change the MAC address of the Ethernet interface to match:"
msgstr "`ether`行将包含指定接口的MAC地址。现在，将以太网接口的MAC地址更改为匹配："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1897
#, no-wrap
msgid "# ifconfig re0 ether b8:ee:65:5b:32:59\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1900
#, fuzzy
msgid ""
"Make sure the _re0_ interface is up, then create the man:lagg[4] interface "
"with _re0_ as master with failover to _wlan0_:"
msgstr "确保 _re0_ 接口已启用，然后使用 _re0_ 作为主接口和故障转移到 _wlan0_ 创建 man:lagg[4] 接口。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1906
#, no-wrap
msgid ""
"# ifconfig re0 up\n"
"# ifconfig lagg0 create\n"
"# ifconfig lagg0 up laggproto failover laggport re0 laggport wlan0\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1922
#, no-wrap
msgid ""
"# ifconfig lagg0\n"
"lagg0: flags=8843<UP,BROADCAST,RUNNING,SIMPLEX,MULTICAST> metric 0 mtu 1500\n"
"        options=8<VLAN_MTU>\n"
"        ether b8:ee:65:5b:32:59\n"
"        laggproto failover lagghash l2,l3,l4\n"
"        laggport: re0 flags=5<MASTER,ACTIVE>\n"
"        laggport: wlan0 flags=0<>\n"
"        groups: lagg\n"
"        media: Ethernet autoselect\n"
"        status: active\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1925
#, fuzzy
msgid "Then, start the DHCP client to obtain an IP address:"
msgstr "接下来，启动DHCP客户端以获取IP地址："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1929
#, no-wrap
msgid "# dhclient lagg0\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1941
#, no-wrap
msgid ""
"ifconfig_re0=\"ether b8:ee:65:5b:32:59\"\n"
"wlans_ath0=\"wlan0\"\n"
"ifconfig_wlan0=\"WPA\"\n"
"create_args_wlan0=\"country FR\"\n"
"cloned_interfaces=\"lagg0\"\n"
"ifconfig_lagg0=\"up laggproto failover laggport re0 laggport wlan0 DHCP\"\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1946
#, fuzzy, no-wrap
msgid "Diskless Operation with PXE"
msgstr "使用PXE进行无盘操作"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1952
#, fuzzy
msgid ""
"The Intel(R) Preboot eXecution Environment (PXE) allows an operating system "
"to boot over the network.  For example, a FreeBSD system can boot over the "
"network and operate without a local disk, using file systems mounted from an"
" NFS server.  PXE support is usually available in the BIOS.  To use PXE when"
" the machine starts, select the `Boot from network` option in the BIOS setup"
" or type a function key during system initialization."
msgstr ""
"Intel（R）Preboot eXecution "
"Environment（PXE）允许操作系统通过网络启动。例如，FreeBSD系统可以通过网络启动并运行，无需本地磁盘，而是使用从NFS服务器挂载的文件系统。PXE支持通常在BIOS中可用。要在计算机启动时使用PXE，请在BIOS设置中选择“从网络启动”选项或在系统初始化期间按下功能键。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1954
#, fuzzy
msgid ""
"In order to provide the files needed for an operating system to boot over "
"the network, a PXE setup also requires properly configured DHCP, TFTP, and "
"NFS servers, where:"
msgstr "为了提供操作系统通过网络引导所需的文件，PXE设置还需要正确配置的DHCP、TFTP和NFS服务器，其中："

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1956
#, fuzzy
msgid ""
"Initial parameters, such as an IP address, executable boot filename and "
"location, server name, and root path are obtained from the DHCP server."
msgstr "初始参数，如IP地址、可执行的引导文件名和位置、服务器名称和根路径，是从DHCP服务器获取的。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1957
#, fuzzy
msgid "The operating system loader file is booted using TFTP."
msgstr "使用TFTP引导操作系统加载程序文件。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1958
#, fuzzy
msgid "The file systems are loaded using NFS."
msgstr "文件系统是使用NFS加载的。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1963
#, fuzzy
msgid ""
"When a computer PXE boots, it receives information over DHCP about where to "
"obtain the initial boot loader file.  After the host computer receives this "
"information, it downloads the boot loader via TFTP and then executes the "
"boot loader.  In FreeBSD, the boot loader file is "
"[.filename]#/boot/pxeboot#.  After [.filename]#/boot/pxeboot# executes, the "
"FreeBSD kernel is loaded and the rest of the FreeBSD bootup sequence "
"proceeds, as described in crossref:boot[boot,The FreeBSD Booting Process]."
msgstr ""
"当计算机进行PXE引导时，它会通过DHCP接收关于从何处获取初始引导加载程序文件的信息。主机计算机接收到这些信息后，通过TFTP下载引导加载程序，然后执行引导加载程序。在FreeBSD中，引导加载程序文件是`/boot/pxeboot`。在`/boot/pxeboot`执行之后，FreeBSD内核被加载，随后执行FreeBSD的引导过程，详见《FreeBSD引导过程》。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1968
#, fuzzy
msgid ""
"For UEFI PXE based boot, the actual boot loader file to use is "
"[.filename]#/boot/loader.efi#.  See the below section crossref:advanced-"
"networking[_debugging_pxe_problems,Debugging PXE Problems] on how to use "
"[.filename]#/boot/loader.efi#."
msgstr ""
"对于基于UEFI PXE的引导，要使用的实际引导加载器文件是`/boot/loader.efi`。请参阅下面的章节`advanced-"
"networking`中的`Debugging PXE Problems`，了解如何使用`/boot/loader.efi`。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1972
#, fuzzy
msgid ""
"This section describes how to configure these services on a FreeBSD system "
"so that other systems can PXE boot into FreeBSD.  Refer to man:diskless[8] "
"for more information."
msgstr ""
"这一部分描述了如何在FreeBSD系统上配置这些服务，以便其他系统可以通过PXE启动到FreeBSD。详细信息请参考 man:diskless[8]。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1977
#, fuzzy
msgid ""
"As described, the system providing these services is insecure.  It should "
"live in a protected area of a network and be untrusted by other hosts."
msgstr "如描述的那样，提供这些服务的系统是不安全的。它应该生活在网络的受保护区域，并且被其他主机视为不可信任的。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1980
#, fuzzy, no-wrap
msgid "Setting Up the PXE Environment"
msgstr "配置 PXE 环境"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1986
#, fuzzy
msgid ""
"The steps shown in this section configure the built-in NFS and TFTP servers."
"  The next section demonstrates how to install and configure the DHCP "
"server.  In this example, the directory which will contain the files used by"
" PXE users is [.filename]#/b/tftpboot/FreeBSD/install#.  It is important "
"that this directory exists and that the same directory name is set in both "
"[.filename]#/etc/inetd.conf# and [.filename]#/usr/local/etc/dhcpd.conf#."
msgstr ""
"本节所示步骤配置了内置的NFS和TFTP服务器。下一节将演示如何安装和配置DHCP服务器。在这个示例中，将包含PXE用户使用的文件的目录是[/b/tftpboot/FreeBSD/install]。重要的是，这个目录存在，并且在[/etc/inetd.conf]和[/usr/local/etc/dhcpd.conf]中设置相同的目录名称。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1991
#, fuzzy
msgid ""
"The command examples below assume use of the man:sh[1] shell.  man:csh[1] "
"and man:tcsh[1] users will need to start a man:sh[1] shell or adapt the "
"commands to man:csh[1] syntax."
msgstr ""
"下面的命令示例假设使用man:sh[1] shell。man:csh[1]和man:tcsh[1]的用户需要启动一个man:sh[1] "
"shell，或者根据man:csh[1]语法调整命令。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:1995
#, fuzzy
msgid ""
"Create the root directory which will contain a FreeBSD installation to be "
"NFS mounted:"
msgstr "创建根目录，其中包含将要被NFS挂载的FreeBSD安装文件。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2000
#, no-wrap
msgid ""
"# export NFSROOTDIR=/b/tftpboot/FreeBSD/install\n"
"# mkdir -p ${NFSROOTDIR}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2003
#, fuzzy
msgid ""
"Enable the NFS server by adding this line to [.filename]#/etc/rc.conf#:"
msgstr "通过将以下行添加到[.filename]#/etc/rc.conf#文件中，启用NFS服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2007
#, no-wrap
msgid "nfs_server_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2010
#, fuzzy
msgid ""
"Export the diskless root directory via NFS by adding the following to "
"[.filename]#/etc/exports#:"
msgstr "通过将以下内容添加到[.filename]#/etc/exports#，将无磁盘根目录通过NFS导出："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2014
#, no-wrap
msgid "/b -ro -alldirs -maproot=root\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2017
#, fuzzy
msgid "Start the NFS server:"
msgstr "启动NFS服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2021
#, no-wrap
msgid "# service nfsd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2024
#, fuzzy
msgid ""
"Enable man:inetd[8] by adding the following line to "
"[.filename]#/etc/rc.conf#:"
msgstr "通过将以下行添加到 `/etc/rc.conf` 文件中，启用 man:inetd[8]："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2028
#, no-wrap
msgid "inetd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2031
#, fuzzy
msgid ""
"Uncomment the following line in [.filename]#/etc/inetd.conf# by making sure "
"it does not start with a `+#+` symbol:"
msgstr "取消对[.filename]#/etc/inetd.conf#中的以下行进行注释，确保它不以`+#+`符号开头："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2035
#, no-wrap
msgid ""
"tftp dgram udp wait root /usr/libexec/tftpd tftpd blocksize 1468 -l -s "
"/b/tftpboot\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2042
#, fuzzy
msgid ""
"The specified tftp blocksize, e.g. 1468 bytes, replaces the default size 512"
" bytes.  Some PXE versions require the TCP version of TFTP.  In this case, "
"uncomment the second `tftp` line which contains `stream tcp`."
msgstr ""
"指定的TFTP块大小，例如1468字节，替换了默认大小512字节。一些PXE版本需要TFTP的TCP版本。在这种情况下，取消注释包含`stream "
"tcp`的第二行 `tftp`。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2045
#, fuzzy
msgid "Start man:inetd[8]:"
msgstr "启动 man:inetd[8] 命令："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2049
#, no-wrap
msgid "# service inetd start\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2052
#, fuzzy
msgid ""
"Install the base system into [.filename]#${NFSROOTDIR}#, either by "
"decompressing the official archives or by rebuilding the FreeBSD kernel and "
"userland (refer to crossref:cutting-edge[makeworld,“Updating FreeBSD from "
"Source”] for more detailed instructions, but do not forget to add "
"`DESTDIR=_${NFSROOTDIR}_` when running the `make installkernel` and `make "
"installworld` commands."
msgstr ""
"将基础系统安装到[${NFSROOTDIR}]#${NFSROOTDIR}#中，可以通过解压官方档案或重新构建FreeBSD内核和用户空间来完成（有关更详细的说明，请参考crossref:cutting-"
"edge[makeworld，“从源码更新FreeBSD”]，但在运行`make installkernel`和`make "
"installworld`命令时不要忘记添加`DESTDIR=_${NFSROOTDIR}_`参数。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2053
#, fuzzy
msgid ""
"Test that the TFTP server works and can download the boot loader which will "
"be obtained via PXE:"
msgstr "测试TFTP服务器是否正常工作，并且可以通过PXE下载启动程序。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2059
#, no-wrap
msgid ""
"# tftp localhost\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2062
#, fuzzy
msgid ""
"Edit [.filename]#${NFSROOTDIR}/etc/fstab# and create an entry to mount the "
"root file system over NFS:"
msgstr "编辑 [.filename]#${NFSROOTDIR}/etc/fstab# 文件，并创建一个条目以通过NFS挂载根文件系统："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2067
#, no-wrap
msgid ""
"# Device                                         Mountpoint    FSType   Options  Dump Pass\n"
"myhost.example.com:/b/tftpboot/FreeBSD/install       /         nfs      ro        0    0\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2071
#, fuzzy
msgid ""
"Replace _myhost.example.com_ with the hostname or IP address of the NFS "
"server.  In this example, the root file system is mounted read-only in order"
" to prevent NFS clients from potentially deleting the contents of the root "
"file system."
msgstr ""
"将 _myhost.example.com_ 替换为 NFS 服务器的主机名或 IP 地址。在这个示例中，根文件系统以只读方式挂载，以防止 NFS "
"客户端潜在地删除根文件系统的内容。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2072
#, fuzzy
msgid ""
"Set the root password in the PXE environment for client machines which are "
"PXE booting :"
msgstr "在通过PXE启动的客户机上为根密码设置PXE环境："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2077
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# passwd\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2080
#, fuzzy
msgid ""
"If needed, enable man:ssh[1] root logins for client machines which are PXE "
"booting by editing [.filename]#${NFSROOTDIR}/etc/ssh/sshd_config# and "
"enabling `PermitRootLogin`. This option is documented in man:sshd_config[5]."
msgstr ""
"如有需要，通过编辑`${NFSROOTDIR}/etc/ssh/sshd_config`文件并启用`PermitRootLogin`，为使用PXE引导的客户端机器启用`man:ssh[1]`的根登录。该选项在`man:sshd_config[5]`中有文档记录。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2081
#, fuzzy
msgid ""
"Perform any other needed customizations of the PXE environment in "
"[.filename]#${NFSROOTDIR}#. These customizations could include things like "
"installing packages or editing the password file with man:vipw[8]."
msgstr "在[${NFSROOTDIR}]中进行任何其他所需的PXE环境定制。这些定制可能包括安装软件包或使用man:vipw[8]编辑密码文件。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2084
#, fuzzy
msgid ""
"When booting from an NFS root volume, [.filename]#/etc/rc# detects the NFS "
"boot and runs [.filename]#/etc/rc.initdiskless#.  In this case, "
"[.filename]#/etc# and [.filename]#/var# need to be memory backed file "
"systems so that these directories are writable but the NFS root directory is"
" read-only:"
msgstr ""
"当从NFS根卷引导时，[/etc/rc]检测到NFS引导并运行[/etc/rc.initdiskless]。在这种情况下，[/etc]和[/var]需要是内存支持的文件系统，以使这些目录可写，但NFS根目录只读："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2091
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# mkdir -p conf/base\n"
"# tar -c -v -f conf/base/etc.cpio.gz --format cpio --gzip etc\n"
"# tar -c -v -f conf/base/var.cpio.gz --format cpio --gzip var\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2096
#, fuzzy
msgid ""
"When the system boots, memory file systems for [.filename]#/etc# and "
"[.filename]#/var# will be created and mounted and the contents of the "
"[.filename]#cpio.gz# files will be copied into them.  By default, these file"
" systems have a maximum capacity of 5 megabytes.  If your archives do not "
"fit, which is usually the case for [.filename]#/var# when binary packages "
"have been installed, request a larger size by putting the number of 512 byte"
" sectors needed (e.g., 5 megabytes is 10240 sectors) in "
"[.filename]#${NFSROOTDIR}/conf/base/etc/md_size# and "
"[.filename]#${NFSROOTDIR}/conf/base/var/md_size# files for [.filename]#/etc#"
" and [.filename]#/var# file systems respectively."
msgstr ""
"当系统启动时，将创建并挂载 [.filename]#/etc# 和 [.filename]#/var# 的内存文件系统，并将 "
"[.filename]#cpio.gz# 文件的内容复制到它们中。默认情况下，这些文件系统的最大容量为5兆字节。如果你的档案不适应这个大小，通常情况下是"
" [.filename]#/var# 用于安装二进制软件包时，可以在 "
"[.filename]#${NFSROOTDIR}/conf/base/etc/md_size# 和 "
"[.filename]#${NFSROOTDIR}/conf/base/var/md_size# "
"文件中放置所需的512字节扇区数（例如，5兆字节是10240个扇区），以请求更大的大小，分别针对 [.filename]#/etc# 和 "
"[.filename]#/var# 文件系统。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2098
#, fuzzy, no-wrap
msgid "Configuring the DHCP Server"
msgstr "配置DHCP服务器"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2101
#, fuzzy
msgid ""
"The DHCP server does not need to be the same machine as the TFTP and NFS "
"server, but it needs to be accessible in the network."
msgstr "DHCP服务器不需要与TFTP和NFS服务器位于同一台机器上，但它需要在网络中可访问。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2103
#, fuzzy
msgid ""
"DHCP is not part of the FreeBSD base system but can be installed using the "
"package:net/isc-dhcp44-server[] port or package."
msgstr ""
"DHCP 不是 FreeBSD 基础系统的一部分，但可以使用 package:net/isc-dhcp44-server[] 端口或包来安装。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2106
#, fuzzy
msgid ""
"Once installed, edit the configuration file, "
"[.filename]#/usr/local/etc/dhcpd.conf#.  Configure the `next-server`, "
"`filename`, and `root-path` settings as seen in this example:"
msgstr ""
"安装完成后，编辑配置文件[.filename]#/usr/local/etc/dhcpd.conf#。按照下面的示例配置`next-"
"server`，`filename`和`root-path`这些设置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2116
#, no-wrap
msgid ""
"subnet 192.168.0.0 netmask 255.255.255.0 {\n"
"   range 192.168.0.2 192.168.0.3 ;\n"
"   option subnet-mask 255.255.255.0 ;\n"
"   option routers 192.168.0.1 ;\n"
"   option broadcast-address 192.168.0.255 ;\n"
"   option domain-name-servers 192.168.35.35, 192.168.35.36 ;\n"
"   option domain-name \"example.com\";\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2119
#, no-wrap
msgid ""
"   # IP address of TFTP server\n"
"   next-server 192.168.0.1 ;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2122
#, no-wrap
msgid ""
"   # path of boot loader obtained via tftp\n"
"   filename \"FreeBSD/install/boot/pxeboot\" ;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2125
#, no-wrap
msgid ""
"   # pxeboot boot loader will try to NFS mount this directory for root FS\n"
"   option root-path \"192.168.0.1:/b/tftpboot/FreeBSD/install/\" ;\n"
msgstr ""

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2127
#, no-wrap
msgid "}\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2130
#, fuzzy
msgid ""
"The `next-server` directive is used to specify the IP address of the TFTP "
"server."
msgstr "`next-server` 指令用于指定 TFTP 服务器的 IP 地址。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2133
#, fuzzy
msgid ""
"The `filename` directive defines the path to [.filename]#/boot/pxeboot#.  A "
"relative filename is used, meaning that [.filename]#/b/tftpboot# is not "
"included in the path."
msgstr ""
"`filename`指令定义了路径为[.filename]#/boot/pxeboot#的文件名。这是一个相对文件名，意味着路径中不包含[.filename]#/b/tftpboot#。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2135
#, fuzzy
msgid "The `root-path` option defines the path to the NFS root file system."
msgstr "`root-path`选项定义了NFS根文件系统的路径。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2137
#, fuzzy
msgid ""
"Once the edits are saved, enable DHCP at boot time by adding the following "
"line to [.filename]#/etc/rc.conf#:"
msgstr "编辑保存后，在[.filename]#/etc/rc.conf#中添加以下行以在启动时启用DHCP："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2141
#, no-wrap
msgid "dhcpd_enable=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2144
#, fuzzy
msgid "Then start the DHCP service:"
msgstr "然后启动DHCP服务："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2148
#, no-wrap
msgid "# service isc-dhcpd start\n"
msgstr ""

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2150
#, fuzzy, no-wrap
msgid "Debugging PXE Problems"
msgstr ""
"调试 PXE 问题\n"
"\n"
"===\n"
"\n"
"概述\n"
"\n"
"在计算机网络中，Preboot Execution Environment（PXE）被用于引导网络计算机。尽管它是一个强大且方便的工具，但在实践中可能会出现一些问题。本文将介绍如何调试 PXE 问题并解决它们。\n"
"\n"
"识别问题\n"
"\n"
"首先，我们需要确定 PXE 问题的根本原因。通常，这些问题可以归类为以下几个方面：\n"
"\n"
"1. 网络设置：确保网络配置正确，并且网络连接可靠。检查 DHCP 服务器设置、网络线缆连接以及防火墙设置。\n"
"\n"
"2. PXE 服务器配置：检查 PXE 服务器的设置，确保它已正确配置并能够响应请求。查看配置文件、TFTP 服务器设置和 DHCP 选项设置等。\n"
"\n"
"3. 客户端配置：检查客户端的 PXE 配置，确保它是正确的并能够与服务器通信。验证网络引导选项、启动顺序和 BIOS 设置。\n"
"\n"
"调试过程\n"
"\n"
"一旦确定了问题的根本原因，就可以开始调试过程了。这里有一些常用的调试技巧可以帮助我们找到解决方案：\n"
"\n"
"1. 使用日志：查看 PXE 服务器和客户端的日志，以获取详细的错误信息。这些日志通常包含有关引导过程中发生的问题的关键信息。\n"
"\n"
"2. 抓包分析：使用网络抓包工具（如 Wireshark）来监视网络流量。这可以帮助我们确定是否存在网络连接问题或传输错误。\n"
"\n"
"3. 验证网络连接：通过 ping 命令来验证 PXE 服务器和客户端之间的网络连接。确保双方都能够正常通信。\n"
"\n"
"4. 检查配置文件：仔细检查 PXE 服务器和客户端的配置文件，确保它们包含正确的设置。\n"
"\n"
"解决方案\n"
"\n"
"一旦发现了问题所在，我们就可以采取相应的解决方案。以下是常见的解决方案：\n"
"\n"
"1. 修复网络连接问题：检查网络线缆连接，修复 DHCP 配置问题或解决防火墙限制问题。\n"
"\n"
"2. 更新 PXE 服务器配置：调整 PXE 服务器的配置文件，确保它正确地响应客户端的请求。\n"
"\n"
"3. 更新客户端配置：检查客户端的 PXE 配置，更改网络引导选项或 BIOS 设置，以使其与服务器兼容。\n"
"\n"
"4. 更新操作系统或引导映像：如果问题是由于操作系统或引导映像损坏引起的，更新它们可能会解决问题。\n"
"\n"
"结论\n"
"\n"
"调试 PXE 问题可能需要一定的时间和努力，但一旦找到解决方案，就可以确保网络计算机可以正常引导。通过仔细检查网络设置、服务器配置和客户端配置，以及运用日志分析和抓包技巧，我们可以解决许多常见的 PXE 问题。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2154
#, fuzzy
msgid ""
"Once all of the services are configured and started, PXE clients should be "
"able to automatically load FreeBSD over the network.  If a particular client"
" is unable to connect, when that client machine boots up, enter the BIOS "
"configuration menu and confirm that it is set to boot from the network."
msgstr ""
"一旦所有服务被配置并启动，PXE客户端应该能够自动通过网络加载FreeBSD。如果某个特定的客户端无法连接，当该客户端机器启动时，进入BIOS配置菜单并确认是否设置为从网络启动。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2156
#, fuzzy
msgid ""
"This section describes some troubleshooting tips for isolating the source of"
" the configuration problem should no clients be able to PXE boot."
msgstr "本节介绍了一些故障排除技巧，用于确定配置问题的来源，以防止任何客户端能够进行 PXE 启动。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2160
#, fuzzy
msgid ""
"Use the package:net/wireshark[] package or port to debug the network traffic"
" involved during the PXE booting process, which is illustrated in the "
"diagram below."
msgstr "使用`package:net/wireshark[]`包或端口来调试在如下图所示的PXE引导过程中涉及的网络流量。"

#. type: Block title
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2161
#, fuzzy, no-wrap
msgid "PXE Booting Process with NFS Root Mount"
msgstr "使用NFS根挂载的PXE引导过程"

#. type: Target for macro image
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2162
#, fuzzy, no-wrap
msgid "pxe-nfs.png"
msgstr "pxe-nfs.png是一个图片文件的名称。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2165
#, fuzzy
msgid "Client broadcasts a DHCPDISCOVER message."
msgstr "客户端广播一个DHCPDISCOVER消息。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2167
#, fuzzy
msgid ""
"The DHCP server responds with the IP address, next-server, filename, and "
"root-path values."
msgstr "DHCP服务器响应包括IP地址、next-server、文件名和根目录路径等值。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2169
#, fuzzy
msgid ""
"The client sends a TFTP request to next-server, asking to retrieve filename."
msgstr "客户端向next-server发送TFTP请求，请求检索filename文件。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2171
#, fuzzy
msgid "The TFTP server responds and sends filename to client."
msgstr "TFTP服务器响应并将文件名发送给客户端。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2173
#, fuzzy
msgid ""
"The client executes filename, which is pxeboot(8), which then loads the "
"kernel. When the kernel executes, the root file system specified by root-"
"path is mounted over NFS."
msgstr ""
"客户端执行 filename，filename 是 pxeboot(8)，然后加载内核。当内核执行时，使用 root-path 指定的根文件系统通过 "
"NFS 挂载。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2175
#, fuzzy
msgid ""
"On the TFTP server, read [.filename]#/var/log/xferlog# to ensure that "
"[.filename]#pxeboot# is being retrieved from the correct location. To test "
"this example configuration:"
msgstr ""
"在TFTP服务器上，阅读`.filename`文件`/var/log/xferlog`，以确保正确地从指定位置获取`pxeboot`文件。要测试这个示例配置："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2181
#, no-wrap
msgid ""
"# tftp 192.168.0.1\n"
"tftp> get FreeBSD/install/boot/pxeboot\n"
"Received 264951 bytes in 0.1 seconds\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2184
#, fuzzy
msgid ""
"The `BUGS` sections in man:tftpd[8] and man:tftp[1] document some "
"limitations with TFTP."
msgstr "`man:tftpd[8]`和`man:tftp[1]`中的`BUGS`部分记录了TFTP协议的一些限制。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2185
#, fuzzy
msgid ""
"Make sure that the root file system can be mounted via NFS. To test this "
"example configuration:"
msgstr "确保可以通过NFS挂载根文件系统。要测试此示例配置，请按照以下步骤操作："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2189
#, no-wrap
msgid "# mount -t nfs 192.168.0.1:/b/tftpboot/FreeBSD/install /mnt\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2192
#, fuzzy
msgid ""
"For UEFI PXE based booting, replace the [.filename]#boot/pxeboot# file with "
"the [.filename]#boot/loader.efi# file:"
msgstr ""
"对于基于UEFI的PXE引导，请用[.filename]#boot/loader.efi#文件替换[.filename]#boot/pxeboot#文件："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2197
#, no-wrap
msgid ""
"# chroot ${NFSROOTDIR}\n"
"# mv boot/pxeboot boot/pxeboot.original\n"
"# cp boot/loader.efi boot/pxeboot\n"
msgstr ""

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2201
#, fuzzy, no-wrap
msgid "Common Address Redundancy Protocol (CARP)"
msgstr "常用地址冗余协议（CARP）"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2205
#, fuzzy
msgid ""
"The Common Address Redundancy Protocol (CARP) allows multiple hosts to share"
" the same IP address and Virtual Host ID (VHID) in order to provide _high "
"availability_ for one or more services.  This means that one or more hosts "
"can fail, and the other hosts will transparently take over so that users do "
"not see a service failure."
msgstr ""
"Common Address Redundancy Protocol (CARP) "
"允许多个主机共享相同的IP地址和虚拟主机标识（VHID），以提供一个或多个服务的高可用性。这意味着一个或多个主机可能出现故障，而其他主机将自动接管，以便用户不会看到服务中断。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2209
#, fuzzy
msgid ""
"In addition to the shared IP address, each host has its own IP address for "
"management and configuration.  All of the machines that share an IP address "
"have the same VHID.  The VHID for each virtual IP address must be unique "
"across the broadcast domain of the network interface."
msgstr ""
"除了共享的IP地址，每个主机还有自己的IP地址用于管理和配置。共享同一IP地址的所有机器具有相同的虚拟主机标识符（VHID）。每个虚拟IP地址的VHID必须在网络接口的广播域中是唯一的。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2212
#, fuzzy
msgid ""
"High availability using CARP is built into FreeBSD, though the steps to "
"configure it vary slightly depending upon the FreeBSD version.  This section"
" provides the same example configuration for versions before and equal to or"
" after FreeBSD 10."
msgstr ""
"在FreeBSD中，使用CARP实现高可用性是内置的，尽管根据FreeBSD版本的不同，配置步骤略有不同。本节将为FreeBSD "
"10版本之前和10版本之后提供相同的示例配置。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2215
#, fuzzy
msgid ""
"This example configures failover support with three hosts, all with unique "
"IP addresses, but providing the same web content.  It has two different "
"masters named `hosta.example.org` and `hostb.example.org`, with a shared "
"backup named `hostc.example.org`."
msgstr ""
"这个示例配置了具有三个主机的故障转移支持，所有主机都具有唯一的 IP 地址，但提供相同的网页内容。它有两个不同的主服务器，名为 "
"`hosta.example.org` 和 `hostb.example.org`，还有一个共享备份名为 `hostc.example.org`。"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2222
#, fuzzy
msgid ""
"These machines are load balanced with a Round Robin DNS configuration.  The "
"master and backup machines are configured identically except for their "
"hostnames and management IP addresses.  These servers must have the same "
"configuration and run the same services.  When the failover occurs, requests"
" to the service on the shared IP address can only be answered correctly if "
"the backup server has access to the same content.  The backup machine has "
"two additional CARP interfaces, one for each of the master content server's "
"IP addresses.  When a failure occurs, the backup server will pick up the "
"failed master machine's IP address."
msgstr ""
"这些机器采用了一个循环方式的DNS负载均衡配置。主服务器和备份服务器的配置完全相同，唯一的区别是它们的主机名和管理IP地址。这些服务器必须具有相同的配置和运行相同的服务。当故障切换发生时，只有当备份服务器能够访问相同的内容时，共享IP地址上的服务请求才能被正确地响应。备份服务器有两个额外的CARP接口，分别对应主内容服务器的每个IP地址。当发生故障时，备份服务器会接管失败的主服务器的IP地址。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2224
#, fuzzy, no-wrap
msgid "Using CARP on FreeBSD 10 and Later"
msgstr "在FreeBSD 10及更高版本上使用CARP"

#. type: delimited block * 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2227
#, fuzzy
msgid ""
"Enable boot-time support for CARP by adding an entry for the "
"[.filename]#carp.ko# kernel module in [.filename]#/boot/loader.conf#:"
msgstr ""
"在[.filename]#/boot/loader.conf#中添加一个[.filename]#carp.ko#内核模块的条目，以启用CARP的引导支持。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2231
#, no-wrap
msgid "carp_load=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2234
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2315
#, fuzzy
msgid "To load the module now without rebooting:"
msgstr "立即加载模块而不重新启动系统：\n"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2238
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2319
#, no-wrap
msgid "# kldload carp\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2241
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2322
#, fuzzy
msgid ""
"For users who prefer to use a custom kernel, include the following line in "
"the custom kernel configuration file and compile the kernel as described in "
"crossref:kernelconfig[kernelconfig,Configuring the FreeBSD Kernel]:"
msgstr ""
"对于喜欢使用自定义内核的用户，在自定义内核配置文件中添加以下行，并按照 crossref:kernelconfig[kernelconfig,配置 "
"FreeBSD 内核] 中描述的方式进行内核编译。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2245
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2326
#, no-wrap
msgid "device\tcarp\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2248
#, fuzzy
msgid ""
"The hostname, management IP address and subnet mask, shared IP address, and "
"VHID are all set by adding entries to [.filename]#/etc/rc.conf#. This "
"example is for `hosta.example.org`:"
msgstr ""
"设置主机名、管理IP地址、子网掩码、共享IP地址和VHID，只需在 `.filename` 文件的 `/etc/rc.conf` "
"中添加条目即可。以下示例是针对 `hosta.example.org` 的："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2254
#, no-wrap
msgid ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 pass testpass alias 192.168.1.50/32\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2259
#, fuzzy
msgid ""
"The next set of entries are for `hostb.example.org`.  Since it represents a "
"second master, it uses a different shared IP address and VHID.  However, the"
" passwords specified with `pass` must be identical as CARP will only listen "
"to and accept advertisements from machines with the correct password."
msgstr ""
"下一组条目是针对 `hostb.example.org` 设置的。由于它代表了第二个主服务器，因此使用了不同的共享 IP 地址和 VHID。然而，使用 "
"`pass` 指定的密码必须相同，因为 CARP 仅接受来自具有正确密码的机器的广告。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2265
#, no-wrap
msgid ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 2 pass testpass alias 192.168.1.51/32\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2270
#, fuzzy
msgid ""
"The third machine, `hostc.example.org`, is configured to handle failover "
"from either master.  This machine is configured with two CARPVHIDs, one to "
"handle the virtual IP address for each of the master hosts.  The CARP "
"advertising skew, `advskew`, is set to ensure that the backup host "
"advertises later than the master, since `advskew` controls the order of "
"precedence when there are multiple backup servers."
msgstr ""
"第三台机器 `hostc.example.org` 的配置可处理来自任一主机的故障切换。该机器配置有两个 CARPVHID，一个用于处理每个主机的虚拟 "
"IP 地址。CARP 广告的偏移量 `advskew` 被设置为确保备份主机晚于主机进行广告发布，因为 `advskew` "
"控制着多个备份服务器的优先级顺序。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2277
#, no-wrap
msgid ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_em0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"ifconfig_em0_alias0=\"inet vhid 1 advskew 100 pass testpass alias 192.168.1.50/32\"\n"
"ifconfig_em0_alias1=\"inet vhid 2 advskew 100 pass testpass alias 192.168.1.51/32\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2281
#, fuzzy
msgid ""
"Having two CARPVHIDs configured means that `hostc.example.org` will notice "
"if either of the master servers becomes unavailable.  If a master fails to "
"advertise before the backup server, the backup server will pick up the "
"shared IP address until the master becomes available again."
msgstr ""
"配置了两个CARPVHID意味着`hostc.example.org`会注意到主服务器中的任何一个不可用。如果主服务器在备份服务器之前未能发布广告，备份服务器将接管共享的IP地址，直到主服务器再次可用。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2288
#, fuzzy
msgid ""
"If the original master server becomes available again, `hostc.example.org` "
"will not release the virtual IP address back to it automatically.  For this "
"to happen, preemption has to be enabled.  The feature is disabled by "
"default, it is controlled via the man:sysctl[8] variable "
"`net.inet.carp.preempt`.  The administrator can force the backup server to "
"return the IP address to the master:"
msgstr ""
"如果原始主服务器再次可用，`hostc.example.org` 不会自动将虚拟 IP "
"地址释放给它。为了实现这一点，必须启用抢占。默认情况下，此功能被禁用，可以通过 `man:sysctl[8]` 变量 "
"`net.inet.carp.preempt` 进行控制。管理员可以强制备份服务器将 IP 地址返回给主服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2292
#, no-wrap
msgid "# ifconfig em0 vhid 1 state backup\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2298
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2384
#, fuzzy
msgid ""
"Once the configuration is complete, either restart networking or reboot each"
" system.  High availability is now enabled."
msgstr "配置完成后，要么重启网络，要么重新启动每个系统。高可用性现在已启用。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2301
#, fuzzy
msgid ""
"CARP functionality can be controlled via several man:sysctl[8] variables "
"documented in the man:carp[4] manual pages.  Other actions can be triggered "
"from CARP events by using man:devd[8]."
msgstr ""
"CARP功能可以通过man:carp[4]手册中记录的几个sysctl[8]变量来控制。使用man:devd[8]可以从CARP事件触发其他操作。"

#. type: Title ===
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2303
#, fuzzy, no-wrap
msgid "Using CARP on FreeBSD 9 and Earlier"
msgstr "在 FreeBSD 9 及之前版本中使用 CARP"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2306
#, fuzzy
msgid ""
"The configuration for these versions of FreeBSD is similar to the one "
"described in the previous section, except that a CARP device must first be "
"created and referred to in the configuration."
msgstr "这些版本的FreeBSD的配置与前一节中描述的类似，只是首先必须创建一个CARP设备并在配置中引用它。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2308
#, fuzzy
msgid ""
"Enable boot-time support for CARP by loading the [.filename]#if_carp.ko# "
"kernel module in [.filename]#/boot/loader.conf#:"
msgstr ""
"通过在 [.filename]#/boot/loader.conf# 中加载 [.filename]#if_carp.ko# 内核模块，启用 CARP "
"在启动时的支持。"

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2312
#, no-wrap
msgid "if_carp_load=\"YES\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2329
#, fuzzy
msgid "Next, on each host, create a CARP device:"
msgstr "接下来，在每台主机上创建一个CARP设备："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2333
#, no-wrap
msgid "# ifconfig carp0 create\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2338
#, fuzzy
msgid ""
"Set the hostname, management IP address, the shared IP address, and VHID by "
"adding the required lines to [.filename]#/etc/rc.conf#.  Since a virtual "
"CARP device is used instead of an alias, the actual subnet mask of `/24` is "
"used instead of `/32`.  Here are the entries for `hosta.example.org`:"
msgstr ""
"通过向 [.filename]#/etc/rc.conf# 添加所需的行，设置主机名、管理 IP 地址、共享 IP 地址和 VHID。由于使用虚拟 "
"CARP 设备而不是别名，所以实际的子网掩码是 `/24` 而不是 `/32`。以下是 `hosta.example.org` 的条目："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2345
#, no-wrap
msgid ""
"hostname=\"hosta.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.3 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 1 pass testpass 192.168.1.50/24\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2348
#, fuzzy
msgid "On `hostb.example.org`:"
msgstr "在 `hostb.example.org` 上："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2355
#, no-wrap
msgid ""
"hostname=\"hostb.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.4 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0\"\n"
"ifconfig_carp0=\"vhid 2 pass testpass 192.168.1.51/24\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2358
#, fuzzy
msgid ""
"The third machine, `hostc.example.org`, is configured to handle failover "
"from either of the master hosts:"
msgstr "第三台机器 `hostc.example.org` 配置成可以处理来自任一主机的故障切换："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2366
#, no-wrap
msgid ""
"hostname=\"hostc.example.org\"\n"
"ifconfig_fxp0=\"inet 192.168.1.5 netmask 255.255.255.0\"\n"
"cloned_interfaces=\"carp0 carp1\"\n"
"ifconfig_carp0=\"vhid 1 advskew 100 pass testpass 192.168.1.50/24\"\n"
"ifconfig_carp1=\"vhid 2 advskew 100 pass testpass 192.168.1.51/24\"\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2373
#, fuzzy
msgid ""
"Preemption is disabled in the [.filename]#GENERIC# FreeBSD kernel.  If "
"preemption has been enabled with a custom kernel, `hostc.example.org` may "
"not release the IP address back to the original content server.  The "
"administrator can force the backup server to return the IP address to the "
"master with the command:"
msgstr ""
"在 [.filename]#GENERIC# 版本的 FreeBSD "
"内核中，禁用了抢占（preemption）。如果使用自定义内核启用了抢占，`hostc.example.org` 可能无法将 IP "
"地址释放回原始内容服务器。管理员可以使用以下命令强制备份服务器将 IP 地址返回给主服务器："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2377
#, no-wrap
msgid "# ifconfig carp0 down && ifconfig carp0 up\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2380
#, fuzzy
msgid ""
"This should be done on the [.filename]#carp# interface which corresponds to "
"the correct host."
msgstr "这应该在与正确的主机对应的 [.filename]#carp# 接口上完成。"

#. type: Title ==
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2386
#, fuzzy, no-wrap
msgid "VLANs"
msgstr "虚拟局域网（VLANs）"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2390
#, fuzzy
msgid ""
"VLANs are a way of virtually dividing up a network into many different "
"subnetworks, also referred to as segmenting.  Each segment will have its own"
" broadcast domain and be isolated from other VLANs."
msgstr ""
"VLAN（Virtual Local Area Network） "
"是一种将一个网络虚拟分割为多个子网的方式，也被称为分割。每个子网都有自己的广播域，并与其他 VLAN 隔离。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2393
#, fuzzy
msgid ""
"On FreeBSD, VLANs must be supported by the network card driver.  To see "
"which drivers support vlans, refer to the man:vlan[4] manual page."
msgstr "在FreeBSD上，VLAN必须由网络卡驱动程序支持。要查看哪些驱动程序支持VLAN，可以参考man:vlan[4]手册页。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2396
#, fuzzy
msgid ""
"When configuring a VLAN, a couple pieces of information must be known.  "
"First, which network interface? Second, what is the VLAN tag?"
msgstr ""
"在配置VLAN时，必须了解几个信息。首先，要知道使用哪个网络接口（network interface）。其次，要知道VLAN标签（VLAN "
"tag）是什么。"

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2398
#, fuzzy
msgid ""
"To configure VLANs at run time, with a NIC of `em0` and a VLAN tag of `5` "
"the command would look like this:"
msgstr "要在运行时配置VLAN，使用 `em0` 网卡和 VLAN 标签为 `5`，命令如下："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2402
#, no-wrap
msgid "# ifconfig em0.5 create vlan 5 vlandev em0 inet 192.168.20.20/24\n"
msgstr ""

#. type: delimited block = 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2407
#, fuzzy
msgid ""
"See how the interface name includes the NIC driver name and the VLAN tag, "
"separated by a period? This is a best practice to make maintaining the VLAN "
"configuration easy when many VLANs are present on a machine."
msgstr "看到接口名称中包含了NIC驱动名称和VLAN标签，用句点分隔吗？这是一种最佳实践，当机器上存在许多VLAN时，可以方便地维护VLAN配置。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2411
#, fuzzy
msgid ""
"To configure VLANs at boot time, [.filename]#/etc/rc.conf# must be updated."
"  To duplicate the configuration above, the following will need to be added:"
msgstr "要在启动时配置VLAN，必须更新[.filename]#/etc/rc.conf#文件。要复制上面的配置，需要添加以下内容："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2416
#, no-wrap
msgid ""
"vlans_em0=\"5\"\n"
"ifconfig_em0_5=\"inet 192.168.20.20/24\"\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2419
#, fuzzy
msgid ""
"Additional VLANs may be added, by simply adding the tag to the `vlans_em0` "
"field and adding an additional line configuring the network on that VLAN "
"tag's interface."
msgstr "可以通过简单地将标签添加到`vlans_em0`字段，然后添加一行额外的配置网络的语句到该VLAN标签的接口上来添加额外的VLAN。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2423
#, fuzzy
msgid ""
"It is useful to assign a symbolic name to an interface so that when the "
"associated hardware is changed, only a few configuration variables need to "
"be updated.  For example, security cameras need to be run over VLAN 1 on "
"`em0`.  Later, if the `em0` card is replaced with a card that uses the "
"man:ixgb[4] driver, all references to `em0.1` will not have to change to "
"`ixgb0.1`."
msgstr ""
"将接口分配一个符号名称是很有用的，这样当相关硬件发生变化时，只需要更新少数配置变量。例如，安全摄像头需要在`em0`上的VLAN "
"1上运行。如果稍后用使用man:ixgb[4]驱动程序的卡替换了`em0`卡，所有对`em0.1`的引用都不需要改为`ixgb0.1`。"

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2425
#, fuzzy
msgid ""
"To configure VLAN `5`, on the NIC `em0`, assign the interface name "
"`cameras`, and assign the interface an IP address of `_192.168.20.20_` with "
"a `24`-bit prefix, use this command:"
msgstr ""
"要配置VLAN "
"`5`，在网卡`em0`上分配接口名称`cameras`，并分配接口一个IP地址`_192.168.20.20_`，使用`24`位前缀，使用以下命令："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2429
#, no-wrap
msgid ""
"# ifconfig em0.5 create vlan 5 vlandev em0 name cameras inet "
"192.168.20.20/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2432
#, fuzzy
msgid "For an interface named `video`, use the following:"
msgstr "对于名为 `video` 的接口，请使用以下内容："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2436
#, no-wrap
msgid ""
"# ifconfig video.5 create vlan 5 vlandev video name cameras inet "
"192.168.20.20/24\n"
msgstr ""

#. type: Plain text
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2439
#, fuzzy
msgid ""
"To apply the changes at boot time, add the following lines to "
"[.filename]#/etc/rc.conf#:"
msgstr "要在启动时应用更改，请将以下行添加到[/etc/rc.conf]文件中："

#. type: delimited block . 4
#: documentation/content/en/books/handbook/advanced-networking/_index.adoc:2445
#, no-wrap
msgid ""
"vlans_video=\"cameras\"\n"
"create_args_cameras=\"vlan 5\"\n"
"ifconfig_cameras=\"inet 192.168.20.20/24\"\n"
msgstr ""
